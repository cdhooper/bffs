œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#                    0   àˇˇˇˇ2[ì∫  @                         <ˇˇ‡ ˇˇ¯                       ˇˇ˛    	      @          à                  0            à   à           Ä   
   4  X      /mod                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 p                                                                                                                           p                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <     @ˇ      ˇ      ˇ                   T                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    0   àˇˇˇˇ2[ëµ  @                         <ˇˇ‡ ˇˇ¯                       ˇˇ˛    	      @          à                  0            à   à           Ä       ˝                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <     @ˇ      ˇ      ˇ                   T                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     	U2[ìµ        @   
   4  X     X  H   ß                                 ®   Ë    H  º  T  x                                                                                    "                                              "                ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ                                                                                                                                              ¿     Ä   ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ                                                                                                                                                                                                  ˇˇˇˇˇˇ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      AÌ            2[î'    2[ìú'ÔcÄ2[ìú'ÔcÄ   4                                                               2[ëº                A¿ 	           2[ì¬    .">¯    2[ì∂Ô    1                                                               2[öJ                ÅÄ           õw2[ìë    .¥Î    2[ìíƒ¥    8   <   @   D   H                                               P2[öL                ÅÄ           
ü2[ìë    ,∏C    2[ìí
∫ï    2                                                               2[öN                ÅÄ           Ÿ2[ìë    .‰Ê    2[ìí¶W    5                                                               2[öP                ÅÄ           Á2[ìë    .π—    2[ìí4ŒÄ   L                                                               2[öR                ÅÄ           √2[ìë    .ø˜    2[ìí(á˙    6                                                               2[öT                A¿            2[ìë    .">‚    2[ì∂ø§Ä   7                                                               2[öV                ÅÄ          4h2[ìë    -ÅÏ    2[ììÎ¬    P   T   X   \   `   d   h   l   p   t                           ú2[öX                Å           È=2[ìë    .">·    2[ìî]JÄ   x   |   Ä   Ñ   à   å   ê   î   ò   ú   †   §   ®              ê2[öZ                A¿            2[ìë    .">Œ    2[ì∂'    w                                                               2[ö\                ÅÄ           *2[ìë    .¡h    2[ìî4ŒÄ   ‹   ‡                                                           2[ö^                ÅÄ            ˜2[ìë    *á    2[ìî#√F    ‚                                                               2[ö`                ÅÄ            {2[ìë    *-    2[ìî/qÄ   „                                                               2[öb                ÅÄ           Û2[ìë    *    2[ìî5§È    ‰                                                               2[öd                A¿            2[ìë    .">œ    2[ì∂ òñÄ   Ê                                                               2[öf                Å¿            h2[ìë    +l.Â    2[ìï·£    Á                                                               2[öh                Å¿           Å2[ìë    -‘Ó¶    2[ìïÕe    Ë                                                               2[öj                Å¿            m2[ìë    +l.Â    2[ìï#√F    È                                                               2[öl                Å¿            a2[ìë    +l.Â    2[ìï/Ø    Í                                                               2[ön                Å¿            T2[ìë    +l.Â    2[ìï5§È    Î                                                               2[öp                Å¿           
L2[ìë    ,ãì)    2[ìñı·    Ï                                                               2[ör                Å¿            ¬2[ìë    +l.Â    2[ìñÎ¬    Ó                                                               2[öt                Å¿            P2[ìë    +l.Â    2[ìñ◊Ñ    Ô                                                               2[öv                Å¿           y2[ìë    .•,    2[ìñÕe                                                                   2[öx                Å¿            2[ìë    +l.Â    2[ìñ)π'    Ò                                                               2[öz                Å¿            #2[ìë    +l.Ê    2[ìñ/Ø    Ú                                                               2[ö|                Å¿           S2[ìë    +Ë«&    2[ìó       Û                                                               2[ö~                A¿            2[ìë    .">—    2[ì∂ òñÄ   Ù                                                               2[öÄ                ÅÄ           2[ìë    ,∂ùg    2[ìó◊Ñ    ı                                                               2[öÇ                ÅÄ           {2[ìë    ,∂ùü    2[ì¶IÄ   ˆ                                                               2[öÑ                ÅÄ           <2[ìë    ,∂ù∑    2[ìó)π'    ˜                                                               2[öÜ                ÅÄ            ô2[ìë    ,∂ùÃ    2[ìó/Ø    ¯                                                               2[öà                ÅÄ           n∫2[ìë    ,∂ûÄ    2[ìß/Ø    ¸        ˘                                                   82[öä                ÅÄ            ¡2[ìë    ,∂ûê    2[ìò—Ä   ˚                                                               2[öå                ÅÄ            _2[ìë    ,∂ûô    2[ìò‹ìÄ                                                                 2[öé                ÅÄ           T2[ìë    ,∂§c    2[ìö6÷   	                                                               2[öê                ÅÄ           «2[ìë    ,∂û±    2[ìò&æ6Ä  
                                                               2[öí                ÅÄ           Â2[ìë    ,∂û“    2[ìò-ÂDÄ                                                                 2[öî                ÅÄ            Y2[ìë    ,∂ûˇ    2[ìô˙Ä                                                                 2[öñ                ÅÄ           6R2[ìë    ,∂ü4    2[ìôS+Ä                                                               2[öò                ÅÄ           2[ìë    ,∂ü>    2[ìô·£                                                                  2[öö                ÅÄ           2[ìë    ,∂üK    2[ìôÕe                                                                  2[öú                ÅÄ           ä2[ìë    ,∂£    2[ì•3€%Ä                                                                 2[öû                ÅÄ           &2[ìë    ,∂üZ    2[ìô/Ø                                                                  2[ö†                ÅÄ           `2[ìë    ,∂üd    2[ìô5§È                                                                  2[ö¢                ÅÄ           2[ìë    ,∂üq    2[ìöı·                                                                  2[ö§                ÅÄ           )2[ìë    ,∂ü}    2[ìöÎ¬                                                                  2[ö¶                ÅÄ            ó2[ìë    ,∂üÜ    2[ìö◊Ñ                                                                  2[ö®                ÅÄ           Ÿ2[ìë    ,∂ü¨    2[ì†u*                                                                  2[ö™                ÅÄ           Ç2[ìë    ,∂ü«    2[ìö/Ø                                                                  2[ö¨                ÅÄ            ≥2[ìë    ,∂ü–    2[ìö5§È                                                                   2[öÆ                ÅÄ            º2[ìë    ,∂üË    2[ìõÎ¬   !                                                               2[ö∞                ÅÄ            o2[ìë    ,∂§™    2[ì•k   "                                                               2[ö≤                ÅÄ           	∞2[ìë    ,∂†    2[ì¢2©¯Ä  $                                                               2[ö¥                ÅÄ            ú2[ìë    ,∂†!    2[ìõ#√F   #                                                               2[ö∂                ÅÄ           J2[ìë    ,∂†5    2[ìõ0GûÄ  &                                                               2[ö∏                ÅÄ           È2[ìë    ,∂†v    2[ìúı·   '                                                               2[ö∫                ÅÄ            ˜2[ìë    ,∂†Ü    2[ìú·£   (                                                               2[öº                ÅÄ           2[ìë    ,∂†ò    2[ìúÕe   )                                                               2[öæ                ÅÄ           D2[ìë    ,∂†´    2[ì¶#√F   *                                                               2[ö¿                ÅÄ           Å2[ìë    ,∂†¡    2[ì°—Ä  +                                                               2[ö¬                ÅÄ           .2[ìë    ,∂†—    2[ì°´fÄ  ,                                                               2[öƒ                ÅÄ           42[ìë    ,∂†€    2[ì°9ﬁ   -                                                               2[ö∆                ÅÄ           Ì2[ìë    ,∂†Ò    2[ì°%ç	Ä  .                                                               2[ö»                ÅÄ            2[ìë    ,∂†˙    2[ì°2b   /                                                               2[ö                 ÅÄ            82[ìë    ,∂•N    2[ì¢…√Ä  0                                                               2[öÃ                ÅÄ            ™2[ìë    ,∂°    2[ì¢X;   1                                                               2[öŒ                ÅÄ           ó2[ìë    ,∂°    2[ì¢´fÄ  2                                                               2[ö–                ÅÄ            +2[ìë    ,∂°'    2[ì¢9ﬁ   3                                                               2[ö“                ÅÄ           É2[ìë    ,∂•t    2[ì¢-LÆ   4                                                               2[ö‘                ÅÄ           ©2[ìë    ,∂°Q    2[ì¢,Å   6                                                               2[ö÷                ÅÄ           †2[ìë    ,∂°j    2[ì£ø§Ä  8                                                               2[öÿ                ÅÄ            °2[ìë    ,∂°|    2[ì£N   7                                                               2[ö⁄                ÅÄ            ¯2[ìë    ,∂°É    2[ì£°GÄ  :                                                               2[ö‹                ÅÄ           K2[ìë    ,∂°ò    2[ì£ /ø   ;                                                               2[öﬁ                ÅÄ           '2[ìë    ,∂°™    2[ì£+ÇÍÄ  <                                                               2[ö‡                ÅÄ           |2[ìë    ,∂°∂    2[ì£2b   =                                                               2[ö‚                ÅÄ           :2[ìë    ,∂°œ    2[ì§…√Ä  >                                                               2[ö‰                ÅÄ           32[ìë    ,∂°Î    2[ì¶0GûÄ  ?                                                               2[öÊ                ÅÄ           Ht2[ìë    ,∂¢@    2[ì¶5§È   @  D  H                                                       (2[öË                ÅÄ           M2[ìë    ,∂¢K    2[ì§ /ø   J                                                               2[öÍ                ÅÄ           Ç2[ìë    ,∂¢c    2[ì§+ÇÍÄ  K                                                               2[öÏ                ÅÄ            Ÿ2[ìë    ,∂¢p    2[ì§2b   L                                                               2[öÓ                ÅÄ            •2[ìë    ,∂¢y    2[ì•…√Ä  M                                                               2[ö                ÅÄ           g2[ìë    ,∂¢Ñ    2[ì•X;   N                                                               2[öÚ                ÅÄ            |2[ìë    ,∂¢µ    2[ì•´fÄ  O                                                               2[öÙ                ÅÄ           Ô2[ìë    ,∂¢¡    2[ì•9ﬁ   P                                                               2[öˆ                ÅÄ           z2[ìë    ,∂¢     2[ì•,¥Ä  Q                                                               2[ö¯                ÅÄ           2[ìë    ,∂•¡    2[ìß#√F   R                                                               2[ö˙                ÅÄ           ^2[ìë    ,∂£)    2[ì¶
!˛Ä  S                                                               2[ö¸                ÅÄ            Û2[ìë    ,∂£2    2[ì¶∞v   T                                                               2[ö˛                ÅÄ           !2[ìë    ,∂£I    2[ì¶#*ØÄ  U                                                               2[õ                 ÅÄ           2[ìë    ,∂£\    2[ì¶/Ø   V                                                               2[õ                ÅÄ            •2[ìë    ,∂£}    2[ìßS+Ä  W                                                               2[õ                ÅÄ           Ö2[ìë    ,∂£â    2[ìßIÄ  X                                                               2[õ                ÅÄ           å2[ìë    ,∂£ë    2[ìß4ŒÄ  Y                                                               2[õ                ÅÄ           2[ìë    ,∂£–    2[ìß/qÄ  Z                                                               2[õ
                A¿            2[ìë    .">Á    2[ìµ6=Ä  [                                                               2[õ                Å           ^2[ìë    .">Á    2[ì®5§È   \  `  d  h  l  p  t  x  |  Ä  Ñ  à  å              @2[õ                A¿            2[ìë    .">“    2[ìµ6=Ä  ¨                                                               2[õ                Å¿           „2[ìë    (˛5ò    2[ì©–   ≠                                                               2[õ                Å¿           $"2[ìë    ,ñà    2[ì©°GÄ  ∞  Ø                                                           2[õ                A¿            2[ìë    .">ı    2[ìµ/Ø   ¥                                                               2[õ                A¿            2[ìë    .">¯    2[ìµ/Ø   µ                                                               2[õ                Å            G2[ìë    .">ˆ    2[ì™—Ä  ∏                                                               2[õ                Å            D2[ìë    .">ˆ    2[ì™–   ∂                                                               2[õ                Å            Ü2[ìë    .">ˆ    2[ì™°GÄ  º                                                               2[õ                Å            ,@2[ìë    .">ˆ    2[ì™%ç	Ä  ¿  æ                                                           2[õ                 Å            ƒ2[ìë    .">ˆ    2[ì™,¥Ä  ƒ                                                               2[õ"                Å            û2[ìë    .">ˆ    2[ì™8üŸÄ  ∑                                                               2[õ$                Å            ‡2[ìë    .">ˆ    2[ì´ìá   ∆                                                               2[õ&                Å            ˛2[ìë    .">ˆ    2[ì´ﬂÄ  «                                                               2[õ(                Å            ì2[ìë    .">ˆ    2[ì´◊Ñ   »                                                               2[õ*                Å            ®2[ìë    .">ˆ    2[ì´"í   Ã                                                               2[õ,                Å             /2[ìë    .">ˆ    2[ì´)π'   œ                                                               2[õ.                Å            
ß2[ìë    .">˜    2[ì´5§È   –                                                               2[õ0                Å             ÷2[ìë    .">˜    2[ì¨ òñÄ  “                                                               2[õ2                Å             [2[ìë    .">˜    2[ì¨Ô   ”                                                               2[õ4                Å            è2[ìë    .">˜    2[ì¨´fÄ  ‘                                                               2[õ6                Å            *q2[ìë    .">˜    2[ì¨ó(Ä  ÿ  ’                                                           2[õ8                Å            Ì2[ìë    .">˜    2[ì¨&æ6Ä  ◊                                                               2[õ:                Å            	e2[ìë    .">˜    2[ì¨2©¯Ä  ‹                                                               2[õ<                Å             Ï2[ìë    .">˜    2[ì≠      ﬁ                                                               2[õ>                Å            ó2[ìë    .">˜    2[ì≠ø§Ä  ‡                                                               2[õ@                Å            e2[ìë    .">˜    2[ì≠´fÄ  ﬂ                                                               2[õB                Å            ˇ2[ìë    .">˜    2[ì≠ó(Ä  ‰                                                               2[õD                Å            œ2[ìë    .">Á    2[ì≠&æ6Ä  ‚                                                               2[õF                Å            ;2[ìë    .">Á    2[ì≠3€%Ä  „                                                               2[õH                Å@           "2[ìë    .">Ë    2[ì≠:iù   Ë                                                               2[õJ                Å           †:2[ìë    .">Ï    2[ìÆó(Ä  Ï    Ù  ¯  ¸                                2[õL                Å            ’2[ìë    .">Ï    2[ìÆ&%†   È                                                               2[õN                Å            ˇ2[ìë    .">Ï    2[ìÆ/Ø   (                                                               2[õP                Å            ´æ2[ìë    .">Ï    2[ìØ
!˛Ä  ,  0  4  8  <  *                                           X2[õR                Å            º2[ìë    .">Ï    2[ìØIÄ  @                                                               2[õT                Å            â∏2[ìë    .">Ì    2[ìØ#*ØÄ  D  H  L  P  T                                               H2[õV                Å            iÂ2[ìë    .">Ì    2[ìØ3Bè   X  \  `  V                                                   82[õX                Å            >⁄2[ìë    .">Ì    2[ì∞      d  h                                                            2[õZ                Å            Të2[ìë    .">Ó    2[ì∞N   l  p  t                                                       ,2[õ\                Å            HÆ2[ìë    .">Ó    2[ì∞pÄ  x  |  Ä                                                       (2[õ^                Å            2[ìë    .">Ó    2[ì∞$Ùs   Ñ                                                               2[õ`                Å             ∑2[ìë    .">Ó    2[ì∞,Å   w                                                               2[õb                Å            ;2[ìë    .">Ô    2[ì∞5§È   à  å                                                            2[õd                Å            UÊ2[ìë    .">Ô    2[ì±'   ê  î  ò                                                       ,2[õf                Å            Ñe2[ìë    .">    2[ì±9ﬁ   ú  †  §  ®  á                                               D2[õh                Å            ]ü2[ìë    .">    2[ì±#√F   ¨  ∞  ¥                                                       02[õj                Å            ñ2[ìë    .">    2[ì±0‡5   õ                                                               2[õl                Å            v…2[ìë    .">Ò    2[ì≤ı·   ∏  º  ¿  ƒ                                                   <2[õn                Å            ^2[ìë    .">Ò    2[ì≤ÑXÄ  »                                                               2[õp                Å            "÷2[ìë    .">Ò    2[ì≤¿Ä  Ã  «                                                           2[õr                Å            €ö2[ìë    .">Ò    2[ì≤,Å   –  ‘  ÿ  ‹  ‡  ‰  Ë                                       p2[õt                Å             2[ìë    .">Ú    2[ì≤2©¯Ä  Ç                                                               2[õv                Å            "≠2[ìë    .">Ú    2[ì≥,Ä  Ï  É                                                           2[õx                Å            "ﬂ2[ìë    .">Ú    2[ì≥S+Ä    Ù                                                           2[õz                Å            P˚2[ìë    .">Ú    2[ì≥“tÄ  ¯  ¸  ı                                                       ,2[õ|                Å            9O2[ìë    .">Û    2[ì≥!`Ï                                                                  2[õ~                Å            Z?2[ìë    .">Û    2[ì≥-ÂDÄ                                                             02[õÄ                Å            M-2[ìë    .">Û    2[ì≥;3Ä                                                             (2[õÇ                Å            :2[ìë    .">Û    2[ì¥Î¬                                                                   2[õÑ                Å            B72[ìë    .">Û    2[ì¥°GÄ  $  (  #                                                       $2[õÜ                Å            Úö2[ìë    .">Ù    2[ì¥/Ø   ,  0  4  8  <  @  D  H                                   |2[õà                Å            I2[ìë    .">Ù    2[ì¥5§È   L                                                               2[õä                Å            2[ìë    .">Ù    2[ìµ,Ä  P                                                               2[õå                Å            ª2[ìë    .">Ù    2[ìµIÄ  T                                                               2[õé                Å            π“2[ìë    .">Ù    2[ìµ!˘ÇÄ  X  \  `  d  h  l                                           `2[õê                Å            «2[ìë    .">ı    2[ìµ) êÄ  K                                                               2[õí                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
   4  X                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       .       ..      FAQ     FEATURES £‹¸    NEWS ÖÄ    README Ä    BUGS ÖÄ   	 doc     dots       func       help      d man    f scripts    i@src                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     very close to ksh/sh grammar, with csh additions
most features of ksh, bash, and tcsh
75 builtins, 89 options, 154 key bindings
short for loops, ex: for i (*.c) echo $i
select
shell functions
conditional expressions (test builtin, [ ... ], and ksh-style [[ ... ]])
global aliases (may be expanded anywhere on the line)
directory stack access with =num
process substitution (vi =(cmd) edits the output of cmd)
generalized pipes (ls foo >>(cmd1) 2>>(cmd2) pipes stdout to cmd1
  and stderr to cmd2)
arithmetic expressions
advanced globbing:
  ls **/file  searches recursively for "file" in subdirectories
  ls file<20->  matches file20, file30, file100, etc.
  ls *.(c|pro)  matches *.c and *.pro
  ls *(R)  matches only world-readable files
  ls *.c~lex.c  matches all .c files except lex.c
null command shorthands:
  "< file" is same as "more <file"
  "> file" is same as "cat >file"
  ">> file" is same as "cat >>file"
ksh-style coprocesses
automatic file stream teeing (ls >foo >bar puts output in two places)
chpwd() function run every time you change directory (useful for
  updating the status line)
job control
csh-style history
full vi line editing, including "c2w" and "y$" and such things
full emacs line editing
incremental history search
magic-space history
spelling correction
array parameters
$HOSTTYPE, $LINENO, $RANDOM, $SECONDS, $cdpath, $COLUMNS, $fignore,
  $HISTCHARS, $mailpath
with autocd option, typing a directory name by itself is the same as
  typing "cd dirname"
menu completion: pressing TAB repeatedly cycles through the possible matches
incremental path hashing
automatic process time reporting for commands that run over a certain limit
full tcsh-style prompt substitution
utmp login/logout reporting
with histverify option, performing csh-style history expansions causes the
  input line to be brought up for editing instead of being executed
with sunkeyboardhack option, accidently typed trailing ` characters
  are removed from the input line (for those of you with Sun keyboards :-) )
autoloaded functions (loaded from a file when they are first referenced)
"cd old new" replaces "old" with "new" in directory string
generalized argument completion, including:
  - command name completion
  - filename and path completion
  - hostname completion
  - key binding completion
  - option completion
  - variable name completion
  - user-specified keyword completion
  - anything else you can think of
prompt on right side of screen
directory stacks
history datestamps and execution time records
command scheduling (like at(1), but in the shell's context)
tty mode freezing
up to 9 startup files (but you only need 1 or 2)
8-bit clean
which -a cmd lists all occurences of "cmd" in the path
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     .       ..     Ë	zsh-2.5.0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      New features in zsh version 2.5

Greatly expanded completion possibilities.  Programmable completion
allows detailed control over what arguments of what commands can be
completed to what.  See dots/zcomp in the distribution for examples.

Expand filenames with ~ and = on the right hand side of parameter
assignments.  New option MAGIC_EQUAL_SUBST to do it in all
identifier=expression arguments.

${+name} becomes 1 or 0 if name is set or unset.  ${~spec} toggles
GLOB_SUBST in substitution.  Parameter substitution takes lots
of flags in the format ${(flags)name}.

New glob qualifiers for block/character special files, times in glob
qualifiers can be in months, weeks, days, hours, minutes.  Qualifiers
can work on links or on what they point to.  Qualifiers separated by
commas are or-ed.

New parameter substitution modifiers (fFwW) to repeat actions.  New
option CSH_JUNKIE_HISTORY.

New line editor functions history-beginning-search-backward,
history-beginning-search-forward, expand-or-complete-prefix,
push-input, push-line-or-edit.

Assign to part of a string, use qualifiers on string subscription with
$foo[(qual)2,5]

New parameters: EGID, EUID, KEYTIMEOUT

New prompt escape sequence %_ to get constructs like for and while in
the secondary prompt.  %E in prompt clears to end of screen.

Conditional expressions in PROMPT and WATCHFMT.

New options ALWAYS_LAST_PROMPT, ALWAYS_TO_END, AUTO_PARAM_KEYS,
COMPLETE_ALIASES, COMPLETE_IN_WORD, CSH_JUNKIE_HISTORY,
GLOB_SUBST, LIST_AMBIGOUS, MAGIC_EQUAL_SUBST, NO_FLOW_CONTROL,
PROMPT_SUBST

New option -m to many builtins makes arguments subject to pattern
matching.

Bindkey can now bind both key sequences and prefixes of those.  You
can for example bind ESC and function keys sending ESC sequences.

Additional options to read builtin to use in functions called by
completion.

New options to print to sort arguments and print them in columns.

Some additional resource limits can be specified.

Some editor functions now work in the minibuffer.
                                       -*- text -*-
------------------------------------------------------------------------
% ( echo foo ; echo bar 1>& 2 ) 2>&1 1>/dev/null | cat
bar
foo
% ksh
$ ( echo foo ; echo bar 1>& 2 ) 2>&1 1>/dev/null | cat
bar

This is not exactly a bug, but an effect of the multiple IO
redirection.  It is a (k)sh incompatibility, though.
------------------------------------------------------------------------
If you do
% foo =(bar)
and hit ^Z before bar is finished, bar is suspended but nothing
happens, i.e. no prompt appears and zsh keeps waiting.
------------------------------------------------------------------------
Completion has a habit of doing the wrong thing after a
backslash/newline.
------------------------------------------------------------------------
~% (sleep 100 ; echo foo)
			# Hit ^Z here

zsh: suspended  ( sleep 100; echo foo )
~% fg
[1]  + continued  ( sleep 100; echo foo )
foo			# This is wrong!
~% ps
  PID TTY STAT  TIME COMMAND
 2092 v02 S     0:00 sleep 100
------------------------------------------------------------------------
If you suspend "man", zle seems to get into cooked mode.  It works ok
for plain "less".
------------------------------------------------------------------------
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                	 .       ..     
 intro.ms £‹¸   ‘zsh.texi £‹¸                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Archive-Name: unix-faq/shell/zsh
Last-Modified: 1994/6/27
Submitted-By: pws@s-a.amtp.liv.ac.uk (Peter Stephenson)
Version: $Id: zsh.FAQ,v 1.26 1994/06/27 13:42:21 pws Exp pws $
Frequency: Monthly

This document contains a list of frequently-asked (or otherwise
significant) questions concerning the Z-shell, a command interpreter for
many UNIX systems which is freely available to anyone with FTP access.
Zsh is more powerful than every other common shell (sh, ksh, csh, tcsh
and bash) put together.

Information on zsh is now available via the World Wide Web at
http://noaacdc.colorado.edu/~mdb/zsh/zsh_home.html including this FAQ and
much else (thanks to Mark Borges for this).

If you have never heard of `sh', `csh' or `ksh', then you are probably
better off to start by reading a general introduction to UNIX rather
than this document.

Another useful source of information is the collection of FAQ articles
posted frequently to the Usenet news groups comp.unix.questions,
comp.unix.shells and comp.answers with answers to general questions
about UNIX.  The fifth of the seven articles deals with shells,
including zsh, with a brief description of differences.  (This article
also talks about shell startup files which would otherwise rate a
mention here.)

If you just want to know how to get your hands on the latest version,
skip to question 4); if you want to know what to do with insoluble
problems, go to 22).

To encourage you to read on, if you don't know about zsh but are
familiar with other UNIX shells, here are some things that zsh is
particularly good at.  No claim of exclusivity is made, especially as
shells copy one another, though in the areas of command line editing and
globbing zsh is well ahead of the competition.  I am not aware of a
major feature in any other freely-available shell which zsh does not
also have.
  Command line editing:
    programmable completion: incorporates the ability to use
      the full power of zsh globbing (compctl -g),
    multi-line commands editable as a single buffer (even files!),
    variable editing (vared),
    command buffer stack,
    print text straight into the buffer for immediate editing (print -z),
    execution of unbound commands,
    menu completion,
    variable, editing function and option name completion,
    inline expansion of variables, history commands.
  Globbing --- extremely powerful, including:
    recursive globbing (cf. find),
    file attribute qualifiers (size, type, etc. also cf. find),
    full alternation and negation of patterns.
  Handling of multiple redirections (simpler than tee).
  Large number of options for tailoring.
  Path expansion (=foo -> /usr/bin/foo).
  Adaptable messages for spelling, watch, time as well as prompt
    (now including conditional expressions).
  Named directories.
  Comprehensive integer arithmetic.
  Manipulation of arrays (including reverse subscripting).
  Spelling correction.

Notation: Quotes `like this' are ordinary textual quotation
marks.  Other uses of quotation marks are input to the shell.

If you are reading this file with GNU Emacs 19 and have my
cross-referencing package xref.el (available from
suna.amtp.liv.ac.uk:/pub/pws), I can supply a suitable set of
cross-references to make reading the file easier.

Contents:
1) What is it?
2) On what machines will it run?
3) What's the latest version?
4) Where do I get it?
5) How does zsh differ from sh, ksh, csh, tcsh, bash?
6) Why do my csh aliases not work?  (Plus other alias pitfalls.)
7) How do I turn off spelling correction for an individual command?
8) How do I get the meta key to work on my xterm?
9) Why does my terminal act funny in way x?
10) Why does `$var' where var="foo bar" not do what I expect?
11) My PATH, (MANPATH, ...) sometimes doesn't handle tildes.  What gives?
12) How does base arithmetic work?
13) How do I get a newline in my prompt?
14) Why does `bindkey ^a command-name' or 'stty intr ^-' do something funny?
15) Why can't I bind \C-s and \C-q any more?
16) How do I execute command `foo' within function `foo'?
17) Why can't I get zsh to work with SGI's `userenv'?
18) Why do history substitutions with single bangs do something funny?
19) Why does zsh kill off all my background jobs when I logout?
20) I don't have root access: how do I make zsh my login shell?
21) Shouldn't zsh be more/less like ksh/(t)csh?
22) What bugs are currently known and unfixed?
23) Where do I report bugs, get more info / who's working on zsh?
24) What's on the wish-list?
--- End of Contents ---


1) What is it?

  Zsh is a UNIX command interpreter (shell) which of the standard shells
  most resembles the Korn shell (ksh), although it is not completely
  compatible.  It includes enhancements of many types, notably in the
  command-line editor, options for customising its behaviour, filename
  globbing, features to make C-shell (csh) users feel more at home and
  extra features drawn from tcsh (another `custom' shell).

  It was written by Paul Falstad <pf@z-code.com> when a student at
  Princeton; however, Paul doesn't maintain it any more and enquiries
  should be sent to the mailing list (see question 22).  It is freely
  available to anyone under unrestrictive conditions.

  For more information, the files doc/intro.txt or doc/intro.troff
  included with the source distribution are highly recommended.  A list
  of features is given in FEATURES, also with the source.


2) On what machines will it run?

  Zsh was written for machines of the Berkeley UNIX family; most such
  machines (and all the most popular) will run it without major surgery.
  Modifications have been made so that it should work under SYSVR4-based
  operating systems such as Solaris 2.x and OSF/1.  This best thing is
  to suck it and see.  You may not have to change too much: if you do
  change anything, arrange for the shell script `buildzsh' to set the
  necessary #define's, etc., without human intervention.  Recent
  additions include Convex, Unicos and Linux support; there is a project
  to allow POSIX.1 compilation (but note that that zsh is not itself
  particularly POSIX-compliant at the moment).  Success has been
  obtained on older SYSVR3 systems, but you may need to modify the code.
  
  If you add support for a new machine, it would be appreciated if you
  could alter buildzsh to configure zsh automatically and send the
  required context diffs to the list (see question 22).


3) What's the latest version?
  
  The latest production version is 2.3.1; at this time zsh was not
  ported to as many systems, so (for example) for Solaris 2 you are more
  or less constrained to use the beta version.

  The current beta version is 2.4.  New patches occur frequently and are
  added to the archive (next question).  At the time of writing the
  latest patch level was 333.  Note that this `open' development system
  does mean bugs are sometimes introduced into the most recent archived
  version.  These are usually fixed quickly.  Note also that as the
  shell changes, it may become incompatible with older versions; see the
  end of question 21 for a partial list.

  The next production version will be 2.5 (2.4 will not be released, so
  as to minimise confusion over version numbers).  It is expected that
  no new features will be added before the release.

  ** STOP PRESS ** Release of 2.5 is imminent.  The archive now contains
  a preliminary version 2.5.0a; apart from a few fixes, such as a known
  bug when completing using complicated compctl expressions and
  configuration changes for some machines, this will form the release.


4) Where do I get it?

  Bas de Bakker (bas@phys.uva.nl) is in charge of the archive and the
  latest version is available for users east of the Atlantic from:
	carlo.phys.uva.nl(145.18.218.21):/pub/bas/zsh/zsh-2.4beta.tar.gz
  The latest full release is in zsh-2.3.1.tar.gz in the same directory.
  Note that this is in gzip format: you will need GNU gzip from your
  nearest GNU archive to unpack it.  There is also a version under RCS
  control which may be more suitable for source hackers.

  Rick Ohnemus has a reflector site in the USA:
        ftp.sterling.com (192.124.9.3):/zsh

  The 2.3.1 distribution is also available from ftp.uu.net and mirrors
  in the directory pub/shells/zsh.


5) How does zsh differ from sh, ksh, csh, tcsh, bash?

  As has already been mentioned, zsh is most similar to ksh, while many
  of the additions are to please csh users.

  i) ksh:

  Most features of ksh (and hence also of sh) are implemented in zsh;
  problems can arise because the implementation is slightly different.
  Note also that not all ksh's are the same either.  I have based this
  on the 11/16/88f version of ksh.

  Various options can be turned on which will increase ksh
  compatibility, though decrease zsh's abilities: see the manual
  entries for GLOB_SUBST, IGNORE_BRACES (though brace expansion occurs
  in some versions of ksh), KSH_OPTION_PRINT, NO_BANG_HIST, NO_EQUALS,
  NO_HUP, NO_RCS, NO_SHORT_LOOPS, PROMPT_SUBST, RM_STAR_SILENT,
  SH_WORD_SPLIT (see question 10) and SINGLE_LINE_ZLE.  Note that you
  can also disable any built-in commands which get in your way.  If
  invoked as `ksh', the shell will try and set suitable options.

  Here are some differences from ksh which might prove significant for
  ksh programmers, some of which may be interpreted as bugs; there must
  be more.  Note that this list is deliberately rather full and that
  most of the items are fairly minor.  Those marked `*' perform in a
  ksh-like manner if the shell is invoked with the name `ksh'.
  
  Syntax:
  * Shell word splitting: see question 10).  (This is particularly
      frequently asked about.)
    Arrays are more csh-like than ksh-like:
      subscripts start at 1, not 0; array[0] refers to array[1];
      `$array' refers to the whole array, not $array[0];
      braces are unnecessary: $a[1] == ${a[1]}, etc.
    Coprocesses are established by `coproc'; `|&' behaves like csh.
    Opening for both input and output via <> is not yet supported.
  Command line substitutions, globbing etc.:
  * The results of parameter substitutions are treated as plain text:
      `foo="*"; print $foo' prints all files in ksh but * in zsh.
      (The GLOB_SUBST option has just been added to fix this.)
    The $((...)) version of numeric evaluation is not implemented; use $[...].
    Treatment of backslashes within backquotes is subtly different.
    $PSn do not do parameter substitution by default (use PROMPT_SUBST 
      option).
    Globbing does not allow ksh-style `pattern-lists'.  Equivalents:
      -------------------------------------------------------------------
             ksh             zsh          Meaning
            -----           -----        ---------
           !(foo)            ^foo        Anything but foo.
                      or   foo1~foo2     Anything matching foo1 but foo2.
      @(foo1|foo2|...)  (foo1|foo2|...)  One of foo1 or foo2 or ...
           ?(foo)           (foo|)       Zero or one occurrences of foo.
           *(foo)           (foo)#       Zero or more occurrences of foo.
           +(foo)         foo(foo)#      One or more occurrences of foo.
      -------------------------------------------------------------------
      The last two (with `#') require the EXTENDED_GLOB option.
    Unquoted assignments do file expansion after ':'s (intended for PATHs).
    `integer' does not allow -i; integers in bases other than 10 do not
      have "base#" prefixed to them when printed.
  Command execution:
  * There is no ENV variable (use /etc/zshrc, ~/.zshrc; note also ZDOTDIR).
    The PATH is not searched for commands specified at invocation without -c.
  Aliases and functions:
    The order in which aliases and functions are defined is significant
      (function definitions with () expand aliases -- see question 6).
    Aliases and functions cannot be exported.
    There are no tracked aliases: command hashing replaces these.
    The use of aliases for key bindings is replaced by `bindkey'.
  Traps and signals:
    By default, background jobs are killed when you log out:  see 18).
    Traps and options are not local to functions; traps are not reset
      automatically when called; traps are called as functions themselves
      (this is a bug for the `trap "..." NAL' form of trap setting).
    TRAPERR has become TRAPZERR (this was forced by UNICOS which has SIGERR).
  Editing:
    The options emacs, gmacs, trackall, viraw are not supported.
      Use bindkey to change the editing behaviour: `set -o {emacs,vi}' 
      become `bindkey -{e,v}'; for gmacs, go to emacs mode and use
      `bindkey \^t gosmacs-transpose-characters'.  `Trackall' is replaced
      by `hashcmds'.
    The `keyword' option does not exist and -k is instead interactivecomments.
      (`keyword' will not be in the next ksh release either.)
    Management of histories in multiple shells is different:
      the history list is not saved and restored after each command.
    \ does not escape editing chars (use ^V).
    Not all ksh bindings are set (e.g. `<ESC>#'; try <ESC>q).
  * # in an interactive shell is not treated as a comment by default.
  Built-in commands:
    Some built-ins (r, autoload, history, integer ...) were aliases in ksh.
    There is no built-in command newgrp: use a shell function, e.g.
      newgrp () { ((SHLVL--)) ; exec command newgrp $* }
      (in 2.4 you can get away with `alias newgrp="exec newgrp"'
    `jobs' has no `-n' flag.
    `read' has no `-s' flag.
    In `let "i = foo"', foo is evaluated as a number, not an expression
      (although in `let "i = $foo"' it is treated as an expression).
  Other idiosyncrasies:
    `select' always redisplays the list of selections on each loop.

  ii) csh:

  Although certain features aim to ease the withdrawal symptoms of csh
  (ab)users, the syntax is in general rather different and you should
  certainly not try to run scripts without modification.  The c2z script
  is provided with the source (in scripts/c2z) to help convert .cshrc
  and .login files; see also the next question concerning aliases,
  particularly those with arguments.

  Csh-compatibility additions include:
    Logout, rehash, source, (un)limit built-in commands.
    *rc file for interactive shells.
    Directory stacks.
    Cshjunkie*, ignoreeof options.
    The nonomatch option.
    >&, |& etc. redirection.
    foreach ... loops; alternative syntax for other loops.
    Alternative syntax `if ( ... ) ...' (also `for', `which'; this now
      requires the CSH_JUNKIE_PAREN option).
    $PROMPT as well as $PS1, $status as well as $?, $#argv as well as $#, ....
    Escape sequences via % for prompts.
    Special array variables $PATH etc. are colon-separated, $path are arrays.
    !-type history (which may be turned off via `setopt nobanghist').
    Arrays have csh-like features (see i)).

  iii) tcsh:

  (The previous section applies too, of course.)  Certain features have
  been borrowed from tcsh, including $watch, run-help, $savehist,
  $histlit, periodic commands etc., extended prompts, sched and
  which/where built-ins.  Programmable completion was inspired by, but
  is entirely different to, tcsh's `complete'. (There is a perl script
  called lete2ctl in the scripts directory of the source distribution to
  convert `complete' to `compctl' statements.)  This list is not
  definitive: some features have gone in the other direction.

  If you're missing the editor function run-fg-editor, try something
  with bindkey -s (which binds a string to a keystroke), e.g.
	bindkey -s '^z' '\eqfg %$EDITOR:t\n'
  which pushes the current line onto the stack and tries to bring a job
  with the basename of your editor into the foreground.  Bindkey -s
  allows limitless possibilities along these lines.

  iv) bash:
  
  Zsh has almost all the features that bash has (and much more); in
  addition it is about twice as fast, though this is less impressive
  than it sounds.  With the new malloc by Sven Wischnowsky (only used if
  you arranged for USE_ZSH_MALLOC to be defined in config.h when
  compiling zsh), zsh uses about the same amount of heap memory as bash,
  which was previously the biggest gripe.  The only feature I am aware
  of that zsh doesn't have is setting a numerical value for ignoreeof
  --- it's always 10 --- but of course I don't use bash :-).

  However, zsh has no claims towards Posix compliancy and will not use
  GNU readline (zle is more powerful).  In fact, bash is intended more
  as an enhanced sh than a ksh work-alike; it doesn't handle [[ ... ]],
  for example.


6) Why do my csh aliases not work?  (Plus other alias pitfalls.)

  First of all, check you are using the syntax
	alias newcmd='list of commands'
  and not
	alias newcmd 'list of commands'
  which won't work. (It tells you if `newcmd' and `list of commands' are
  already defined as aliases.)

  Otherwise, your aliases probably contain references to the command
  line of the form `\!*', etc.  Zsh does not handle this behaviour as it
  has shell functions which provide a way of solving this problem more
  consistent with other forms of argument handling.  For example, the
  csh alias
	alias cd 'cd \!*; echo $cwd'
  can be replaced by the zsh function,
	cd() { builtin cd $*; echo $PWD; }
  (the `builtin' tells zsh to use its own `cd', avoiding an infinite loop)
  or, perhaps better,
	cd() { builtin cd $*; print -D $PWD; }
  (which converts your home directory to a ~).  In fact, this problem is
  better solved by defining the special function chpwd() (see the manual).
  Note also that the `;' at the end of the function is optional in zsh,
  but not in ksh or sh (for sh's where it exists).

  Here is Bart Schaefer's guide to converting csh aliases for zsh.

    1.  If the csh alias references "parameters" (\!:1 \!* etc.),
        then in zsh you need a function (referencing $1 $* etc.).
        Otherwise, you can use a zsh alias.

    2.  If you use a zsh function, you need to refer _at_least_ to
        $* in the body (inside the { }).  Parameters don't magically
        appear inside the { } the way they get appended to an alias.
    
    3.  If the csh alias references its own name (alias rm "rm -i"),
        then in a zsh function you need the "command" keyword
        (function rm() { command rm -i $* }), but in a zsh alias
        you don't (alias rm="rm -i").

    4.  If you have aliases that refer to each other (alias ls "ls -C";
        alias lf "ls -F" ==> lf == ls -C -F) then you must either:
        a.  convert all of them to zsh functions; or
        b.  after converting, be sure your .zshrc defines all of your
            aliases before it defines any of your functions.

    Those first four are all you really need, but here are four more for
    heavy csh alias junkies:

    5.  Mapping from csh alias "parameter referencing" into zsh function
        (assuming shwordsplit is NOT set in zsh):
             csh                   zsh
            =====               ==========
            \!*                 $*              (or $argv)
            \!^                 $1              (or $argv[1])
            \!:1                $1
            \!:2                $2              (or $argv[2], etc.)
            \!$                 $*[$#]          (or $argv[$#], or $*[-1])
            \!:1-4              $*[1,4]
            \!:1-               $*[1,$#-1]      (or $*[1,-2])
            \!^-                $*[1,$#-1]
            \!*:q               "$@"            ($*:q doesn't work (yet))
            \!*:x               $=*             ($*:x doesn't work (yet))

    6.  Remember that it is NOT a syntax error in a zsh function to
        refer to a position ($1, $2, etc.) greater than the number of
        parameters. (E.g., in a csh alias, a reference to \!:5 will
        cause an error if 4 or fewer arguments are given; in a zsh
	function, $5 is the empty string if there are 4 or fewer
	parameters.)

    7.  To begin a zsh alias with a - (dash, hyphen) character, use
        "alias --":
                 csh                            zsh
            ===============             ==================
            alias - "fg %-"             alias -- -="fg %-"

    8.  Stay away from "alias -g" in zsh until you REALLY know what
        you're doing.

  There is one other serious problem with aliases: consider
        alias l='/bin/ls -F'
        l() { /bin/ls -la $* | more }
  `l' in the function definition is in command position and is expanded
  as an alias, defining `/bin/ls' and `-F' as functions which call
  `/bin/ls', which gets a bit recursive.  This can be avoided if you use
  `function' to define a function, which doesn't expand aliases.  It is
  possible to argue for extra warnings somewhere in this mess.  Luckily,
  it is not possible to define `function' as an alias.


7) How do I turn off spelling correction for an individual command?

  You presumably have `setopt correctall' in an initialisation file, so
  that zsh checks the spelling of each word in the command line.  You
  probably do not want this behaviour for commands which do not operate
  on existing files.
  
  The answer is to alias the offending command to itself with
  `nocorrect' stuck on the front, e.g.
       alias mkdir='nocorrect mkdir'


8) How do I get the meta key to work on my xterm?

  As stated in the manual, zsh needs to be told about the meta key by
  using `bindkey -me' or `bindkey -mv' in your .zshrc or on the command
  line.  You probably also need to tell the terminal driver to allow the
  `meta' bit of the character through; `stty pass8' is the usual
  incantation.  Sample .zshrc entry:
	[[ $TERM = "xterm" ]] && stty pass8 && bindkey -me
  or, on SYSVR4-ish systems without pass8,
	[[ $TERM = "xterm" ]] && stty -parenb -istrip cs8 && bindkey -me
  (disable parity detection, don't strip high bit, use 8-bit characters).
  Make sure this comes *before* any bindkey entries in your .zshrc which
  redefine keys normally defined in the emacs/vi keymap.


9) Why does my terminal act funny in way x?

  If you are using an OpenWindows cmdtool as your terminal, any
  escape sequences (such as those produced by cursor keys) will be
  swallowed up and never reach zsh.  Either use shelltool or avoid
  commands with escape sequences.  You can also disable scrolling from
  the cmdtool pane menu (which effectively turns it into a shelltool).
  If you still want scrolling, try using an xterm with the scrollbar
  activated.

  If that's not the problem, and you are using stty to change some tty
  settings, make sure you haven't asked zsh to freeze the tty settings:
  type
	ttyctl -u
  before any stty commands you use.

  On the other hand, if you aren't using stty and have problems you may
  need the opposite:  `ttyctl -f' freezes the terminal to protect it
  from hiccups introduced by other programmes (kermit has been known to
  do this).

  If _that's_ not the problem, and you are having difficulties with
  external commands (not part of zsh), and you think some terminal
  setting is wrong (e.g. ^V is getting interpreted as `literal next
  character' when you don't want it to be), try
	ttyctl -u
	STTY='lnext "^-"' commandname
  (in this example), or just export STTY for all commands to see.  Note
  that zsh doesn't reset the terminal completely afterwards: just the
  modes it uses itself and a number of special processing characters
  (see the stty(1) manual page).

  After the release of version 2.5, there is likely to be an overhaul
  which allows the terminal modes used by the shell to be modified
  separately from those seen by external programmes.  This is partially
  implemented already:  in 2.5, the shell will be less susceptible to
  mode changes inherited from programmes.


10) Why does `$var' where var="foo bar" not do what I expect?

  In most Bourne-shell derivatives, multi-word variables such as
	var="foo bar"
  are split into words when passed to a command or used in a `for foo in
  $var' loop.  By default, zsh does not have that behaviour: the
  variable remains intact.  (This is not a bug!  See below.)  An option
  (shwordsplit) exists to provide compatibility.
  
  For example, defining the function args to show the number of its
  arguments:
	args() { echo $#; }
  and with our definition of vble,
	args $vble
  produces the output `1'.  After
	setopt shwordsplit
  the same function produces the output `2', as with sh and ksh.
  
  Unless you need strict sh/ksh compatibility, you should ask yourself
  whether you really want this behaviour, as it can produce unexpected
  effects for variables with entirely innocuous embedded spaces.  The
  natural way to produce word-splitting behaviour in zsh is via arrays.
  For example,
	set -A array one two three twenty
  (or
        array=(one two three twenty)
  if you prefer), followed by
	args $array
  produces the output `4', regardless of the setting of shwordsplit.
  Arrays are also much more versatile than single strings.

  Note also the "$@" method of word splitting is always available in zsh
  functions and scripts (though strictly this does array splitting, not
  word splitting), also the substitution ${=foo} to toggle word
  splitting on variable `foo'.

  Shwordsplit is set when zsh is invoked with the name `ksh'.


11) My PATH, (MANPATH, ...) sometimes doesn't handle tildes.  What gives?

  The code has recently been overhauled, so take a look at the latest
  version of 2.4beta.  This guarantees that no ~user expansion (or
  =command expansion, which takes place at the same time) will happen if
  the tilde is quoted, and also rationalises PATH-type variables by
  expanding all unquoted assignments as if they are colon-separated
  lists (so you may need to add or subtract a few extra quotes, but the
  results are more predictable).  In addition typeset, etc., now should
  behave like ordinary assignments in this respect; previously tildes in
  typeset assignments were unquotable.


12) How does base arithmetic work?

  The ksh syntax is now understood, i.e.
        let 'foo = 16#ff'
  or equivalently
        (( foo = 16#ff ))
  or even
        foo=$[16#ff]
  (note that `foo=$((16#ff))' is not yet supported).
  The original syntax was
	(( foo = [16]ff ))
  --- this was based on a misunderstanding of the ksh manual page.  It
  still works but its use is deprecated.
  Then
	echo $foo
  gives the answer `255'.  It is possible to declare variables explicitly
  to be integers, via
	typeset -i foo
  which has a different effect: namely the base used in the first
  assignment (hexadecimal in the example) is subsequently used whenever
  `foo' is displayed (although the internal representation is unchanged).
  To ensure foo is always displayed in decimal, declare it as
	typeset -i 10 foo
  which requests base 10 for output.  You can change the output base of an
  existing variable in this fashion.  Using the `$[ ... ]' method will
  always display in decimal.


13) How do I get a newline in my prompt?

  You can place a literal newline in quotes, i.e.
	PROMPT="Hi Joe,
	what now?%# "
  If you have the bad taste to set the option cshjunkiequotes, which
  inhibits such behaviour, you will have to bracket this with 
  `unsetopt cshjunkiequotes' and `setopt cshjunkiequotes', or put it in
  your .zshrc before the option is set.
  
  Arguably the prompt code should handle `print'-like escapes.  Feel
  free to write this :-).


14) Why does `bindkey ^a command-name' or 'stty intr ^-' do something funny?

  You probably have the extendedglob option set in which case ^ and #
  are metacharacters.  ^a matches any file except one called a, so the
  line is interpreted as bindkey followed by a list of files.  Quote the
  ^ with a backslash or put quotation marks around ^a.


15) Why can't I bind \C-s and \C-q any more?

  The control-s and control-q keys now do flow control by default,
  unless you have turned this off with `stty -ixon' or redefined the
  keys which control it with `stty start' or `stty stop'.  (This is
  done by the system, not zsh; the shell simply respects these
  settings.)  In other words, \C-s stops all output to the terminal,
  while \C-q resumes it.

  There is an option NO_FLOW_CONTROL to stop zsh from allowing flow
  control and hence restoring the use of the keys: put `setopt
  noflowcontrol' in .zshrc.


16) How do I execute command `foo' within function `foo'?

  The command `command foo' does just that.  You don't need this with
  aliases, but you do with functions.  Note that error messages like
        zsh: job table full or recursion limit exceeded
  are a good sign that you tried calling `foo' in function `foo' without
  using `command'.


17) Why can't I get zsh to work with SGI's `userenv'?

  It seems the Silicon Graphics `userenv' command interacts weirdly with
  the line editor (zsh is not unique in this respect).  Add this line to
  the top of your .zshenv file:
        if [[ "${ENVONLY:-0}" -eq 1 ]]; then unsetopt zle; fi
  --- which will turn the line editor off if it sees a `userenv' coming.
  Don't turn zle back on with setopt until [[ $ENVONLY -ne 1 ]].


18) Why do history substitutions with single bangs do something funny?

  If you have a command like "echo !-2:$ !$", the first history
  substitution then sets a default to which later history substitutions
  with single unqualified bangs refer, so that !$ becomes equivalent to
  !-2:$.  The option CSH_JUNKIE_HISTORY makes all single bangs refer
  to the last command.


19) Why does zsh kill off all my background jobs when I logout?

  Simple answer: you haven't asked it not to.  Zsh (unlike [t]csh) gives
  you the option of having background jobs killed or not: the `nohup'
  option exists if you don't want them killed.  Note that you can always
  run programs with `nohup' in front of the pipeline whether or not the
  option is set, which will prevent that job from being killed on
  logout.  (Nohup is actually an external command.)

  The `disown' builtin is very useful in this respect: if zsh informs
  you that you have background jobs when you try to logout, you can
  `disown' all the ones you don't want killed when you exit.  This is
  also a good way of making jobs you don't need the shell to know about
  (such as commands which create new windows) invisible to the shell.


20) I don't have root access: how do I make zsh my login shell?

  Unfortunately, on many machines you can't use `chsh' to change your
  shell unless the name of the shell is contained in /etc/shells, so if
  you have your own copy of zsh you need some sleight-of-hand to use it
  when you log on.  (Simply typing `zsh' is not really a solution since
  you still have your original login shell waiting for when you exit.)
  
  The basic idea is to use `exec <zsh-path>' to replace the current
  shell with zsh.  Often you can do this in a login file such as
  .profile (if your shell is sh or ksh) or .login (if it's csh).  Make
  sure you have some way of altering the file (e.g. via FTP) before you
  try this as `exec' is often rather unforgiving.

  If you have zsh in a subdirectory `bin' of your home directory,
  put this in .profile:
	[ -f $HOME/bin/zsh ] && exec $HOME/bin/zsh -l
  or if your login shell is csh or tcsh, put this in .login:
	if ( -f ~/bin/zsh ) exec ~/bin/zsh -l
  (in each case the -l tells zsh it is a login shell).  

  It's not a good idea to put this (even without the -l) into .cshrc, at
  least without some tests on what the csh is supposed to be doing, as
  that will cause _every_ instance of csh to turn into a zsh and will
  cause csh scripts (yes, unfortunately some people write these) which
  do not call `csh -f' to fail.  If you want to tell xterm to run zsh,
  change the SHELL environment variable to the full path of zsh at the
  same time as you exec zsh.  If you have to exec zsh from your .cshrc,
  a minimum safety check is `if ($?prompt) exec zsh'.

  If you like your login shell to appear in the process list as '-zsh',
  you can link zsh to -zsh (e.g. by `ln -s ~/bin/zsh ~/bin/-zsh') and
  change the exec to `exec -zsh'.  (Make sure -zsh is in your path.)
  This has the same effect as the `-l' option.

  Footnote: if you DO have root access, make sure zsh goes in
  /etc/shells on all appropriate machines, including NIS clients, or you
  may have problems with FTP to that machine.


21) Shouldn't zsh be more/less like ksh/(t)csh?

  People often ask why zsh has all these `unnecessary' csh-like features,
  or alternatively why zsh doesn't understand more csh syntax.  This is
  far from a definitive answer and the debate will no doubt continue.

  Paul's object in writing zsh was to produce a ksh-like shell which
  would have features familiar to csh users.  For a long time, csh was
  the preferred interactive shell and there is a strong resistance to
  changing to something unfamiliar, hence the additional syntax and
  CSH_JUNKIE options.  This argument still holds.  On the other hand,
  the arguments for having what is close to a plug-in replacement for ksh
  are, if anything, even more powerful:  the deficiencies of csh as a
  programming language are well known (look in any Usenet FAQ archive, e.g.
    rtfm.mit.edu:pub/usenet-by-group/news.answers/unix-faq/shell/csh-whynot
  if you are in any doubt) and zsh is able to run many standard scripts
  such as /etc/rc.
  
  Of course, this makes zsh rather large and quite messy so that it
  seems to appeal mainly to hackers.  The only answer, perhaps not
  entirely satisfactory, is that you have to ignore the bits you don't
  want.


22) What bugs are currently known and unfixed?

  Here are some of the more well-known ones, very roughly in decreasing
  order of significance.  Many of these can also be counted against
  differences from ksh in question 5); note that this applies to the
  latest beta version and that simple bugs are often fixed quite
  quickly.  There is a file BUGS in the source distribution with more
  detail.

  Pipelines ending in a while/until/for loop are uninterruptible.
  Certain built-ins won't allow the `VAR=value command ...' assignment;
    the ones that do don't unset VAR after use (may not really be a bug).
    (N.B.: `exec foo=bar command' is a workaround for exec.)
  The `histlit' option adds newlines to lines in the history
    (and is broken in several other ways, e.g. !:x word selection;
    it may be removed).
  `time' is ignored with builtins and can't be used with {...} or (...);
    in shells with no job control the command name is blank.
  `set -x' (`setopt xtrace') doesn't show as much as it should.
  The line number of errors inside control structures is always given
    as the end of the structure (i.e. at `fi', `done', etc.).
  $_ returns the last unexpanded word from the previous line (not command).
  The :q modifier doesn't split words and -q and -x don't work for variables.
  In vi mode, `u' can go past the original modification point.
  Autocd won't use globbed filenames.
  The singlelinezle option has problems with prompts containing escapes.
  `wait' on its own is not interruptible;  interrupting `wait %...'
    kills the job; wait does not set the correct status.
  Builtins at the end of a pipeline lose their status to previous commands.

  Note that a few recent changes introduce incompatibilities (these
  are not bugs):
  An option CSH_JUNKIE_PAREN has proved necessary for the syntax `if (
    <condition> ) <code>' and for similar for and while (but not
    foreach) commands.  This is because it is valid Bourne/Korn shell
    syntax to have a subshell command immediately after if, and the
    default syntax should be compliant with that.
  Assignment of `...` and $(...) to variables in the form `foo=$(...)'
    is now always scalar; previously the command output was split and
    array assignment performed if more than one word resulted.  You
    can still generate an array vie `foo=($(...))', which was always
    the safe way of doing it.  Again, this is for Bourne/Korn compliance.
  The -h option to compctl has been removed (use `-k hosts' for the
    same effect); automatic handling of hosts after '@' has been removed
    (use e.g. `compctl -u -x "n[-1,@]" -k hosts -- finger').
  Handling of backslashes in `echo' and `print' has changed.
  umask's behaviour with respect to symbolic operators has reversed
    (and is now ksh-compatible).
  The option CSH_JUNKIE_TILDE has been upgraded to GLOB_SUBST: instead
    of just ~'s and ='s, all characters become eligible for file
    expansion and globbing when the option is set.  (The option was
    not present in 2.3 at all.)

  There is at least one common bug which is not due to zsh.  If you have
  abnormal behaviour with file descriptor 4, it's because your password
  database is being read from the Network Information System and
  getpwent() left this fd open.


23) Where do I report bugs, get more info / who's working on zsh?

  The shell is being maintained by various (entirely self-appointed)
  subscribers to the mailing list,
	zsh-list@sterling.com so any suggestions, complaints,
  questions and matters for discussion should be sent there.  If you
  want someone to mail you directly, say so.  Most patches to zsh appear
  there first.
  
  A lower-volume list,
	zsh-announce@sterling.com
  exists for announcements of new features and proposed changes
  requiring some decisions.

  Both lists are handled by an automated server.  The instructions for
  zsh-announce are the same as for zsh-list: just change zsh-list to
  zsh-announce everywhere in the following.

  To join zsh-list, send email to
	Majordomo@sterling.com
  containing
	subscribe zsh-list <optional-address>
  where <optional-address> can be blank if you want to subscribe from
  your current email address.  Send the message `help' to the same
  address for help on the list server; `unsubscribe zsh-list' also
  works. (Don't send this to the list!) The list manager, Rick Ohnemus,
  can be reached at
	owner-zsh-list@sterling.com
  (or `rick' at the same adress).

  The list (everything since May 1992) is archived in
	ftp.sterling.com:zsh/zsh-list/YY-MM
  where YY-MM are the year and month in digits.

  Of course, you can also post zsh queries to the Usenet group
  comp.unix.shell; if all else fails, you could even e-mail me.


24) What's on the wish-list?

  (The following will not be done before the release of 2.5.)
  Ksh/sh compatibility could be improved if required.  This would
    be a useful long term goal.
  Option for glob qualifiers to follow perl syntax.
  Option to quote !-history lexically via '' but not "".
  Binding of shell functions (or commands?) to key strokes --
    requires some way of accessing the editing buffer from functions
    and probably of executing zle functions as a command.
  trap '...' FOO should be eval'd rather than called as a function.
  `PATH=' should clear the PATH:  it inserts `.'; use `unset PATH' or
    `path=()' for the time being.  This is not really a bug as the .
    would be used internally in any case (cf. ksh).
  Users should be able to create their own foopath/FOOPATH array/path
    combinations.
  The introduction to zsh (intro.*) could do with an update to reflect
    extended completion (in particular) and other recent additions.


Acknowledgments:

Thanks to zsh-list, in particular Bart Schaefer, for suggestions
regarding this document; thanks to Jim Mattson and more recently Bas de
Bakker for their hard work as archivists, and to Peter Gray for
maintaining the mailing list, without which zsh might easily have died,
and to the latest list maintainer, Rick Ohnemus.  The world is eternally
in the debt of Paul Falstad for inventing zsh in the first place.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         This is zsh version 2.5.0.  Zsh is a shell with lots of features.  For
a list of these, see the FEATURES file.  For more details, see the
documentation.


Installing zsh
--------------
To compile zsh, cd into the src directory and type "./buildzsh".  The
buildzsh script takes various options that are useful if you want to
use a nonstandard compiler, build on several architectures, etc.  Do a
"./buildzsh help" for details.  If no errors occur, you can install
zsh by typing "make install".  This will install the executable and
the manpage.

The compilation procedure has recently been tested and found to work
on the machines listed below.  It might work on others, too,
particularly if they're small variations of these.  If so, please tell
us about it.

SunOS 4.1.1 and 4.1.3
SunOS 5.1 and 5.2
Solaris 2.3
Linux (various versions), but can't use USE_ZSH_MALLOC
AIX 3.2
HP9000/700, after manually telling buildzsh to use setpgid
HP9000/827, but only with GCC
HP9000/847
HPUX 9.04
NeXT with NS3.0 and NS3.1
IRIX 5.1.1.1 and 5.2
Alpha with OSF/1 1.2, 1.3 and 2.0
Alpha with Ultrix (unspecified)
DECstation with Ultrix (unspecified)
DECstation 5000/240 with Ultrix 4.2A
DECstation 5000/25 with Mach 3.0
NetBSD 0.9b
DYNIX/ptx 1.4 and 2.0.4 with X11
Sony NWS with NEWS-OS 3.3
Mac with MiNT after redefining the zgetwd() function as getwd()

If you have used zsh before, please be sure to read the section
"Important changes" below.

Included in this release are alternative malloc and associated
functions which reduce memory usage on some systems.  You can use
these by defining USE_ZSH_MALLOC in config.h.


Documentation
-------------
There are a number of documents about zsh in this distribution:

man/zsh.1	A manpage in nroff format.  This will be installed in
		/usr/man/man1 by "make install".

doc/intro.ms	An introduction to zsh in troff format using the ms
		macros.  This document explains many of the features
		that make zsh more equal than other shells.

doc/zsh.texi	Everything the manpage has, but in texinfo format.

If you do not have the necessary tools to process these documents,
postscript, ascii and info versions are available in a separate file
at the distribution sites:

carlo.phys.uva.nl:/pub/bas/zsh/zsh-2.5.0doc.tar.gz
ftp.sterling.com:/zsh/zsh-2.5.0doc.tar.gz

The distribution also contains a help directory with descriptions of
builtin commands taken from the manpage.  The example function
func/run-help will view the appropriate file from the help directory,
set in the HELPDIR variable, or run 'man' if such a file is not
available.


Important changes
-----------------
This is a list of changes in zsh compared to version 2.3.1 which might
force you to change your old initialization files.

The -h option to compctl for host completion no longer exists.  Define
a hosts variable and use compctl -k hosts instead.  Example: change
compctl -h ping
to
compctl -k hosts ping

The hostcmds, bindcmds, optcmds and varcmds special arrays no longer
exist.  Use compctl -k hosts, -b, -o and -v respectively.

The NO_UNSET option applies to the positional parameters (usually the
arguments to a script) as well as to all other parameters.

There is a new option CSH_JUNKIE_PAREN which has to be set to allow
the csh-syntax "if (test) { foo }" to work.  This has been done to
enhance sh compatibility, where "if (test)" might be used to run
"test" in a subshell.


Feedback
--------
Zsh is currently maintained by the members of the zsh mailing list:

	zsh-list@sterling.com

If you wish to subscribe to the mailing list, send an email message to
	Majordomo@sterling.com
(this is an automated server) containing
	subscribe zsh-list <optional-address>
where <optional-address> can be blank if you want to subscribe from
your current email address.  Send the message `help' to the same
address for help on the list server; `unsubscribe zsh-list' also
works. (Don't send this to the list!). The list manager, Rick Ohnemus,
can be reached at
	owner-zsh-list@sterling.com

You can send bug reports, compliments and the like to the mailing
list.  If are not a subscriber and would like to receive an answer,
please mention so in your message.


Authors
-------
Zsh was originally written by Paul Falstad, people who have supplied
patches for this release are (in lexical order):

Chris.Moore@src.bae.co.uk (Chris Moore)
Harald.Eikrem@delab.sintef.no
Irving_Wolfe@happy-man.com (Irving Wolfe)
Jarkko.Hietaniemi@hut.fi (Jarkko Hietanimi)
P.Stephenson@swansea.ac.uk (Peter Stephenson)
Richard.Sharman@software.mitel.com (Richard Sharman)
Tero_Kivinen@hut.FI (Tero Kivinen)
arf@maths.nott.ac.uk (Anthony Iano-Fletcher)
bas@phys.uva.nl (Bas de Bakker)
benson@odi.com (Benson Margulies)
billb@bedford.progress.com (Bill Burton)
brown@wi.extrel.com (M. Brown)
carlos@snfep1.if.usp.br (Carlos Carvalho)
cedman@capitalist.princeton.edu (Carl Edman)
chip%fin@myrddin.sybus.com (Chip Salzenberg)
chs@apu.fi (Hannu Strang)
cross@eng.umd.edu (Chris Ross)
dm@cs.brown.edu (Dimitris Michailidis)
dmm0t@rincewind.mech.virginia.edu (David M. Meyer)
esky@CS.UCLA.EDU (Eskandar Ensafi)
franl@centerline.com (Fran Litterio)
gansevle@cs.utwente.nl (Fred Gansevles)
gnohmon@ssiny.com (Ralph Betza)
guillaum@clipper.ens.fr (Florent Guillaume)
guthrie@math.upenn.edu (John Guthrie)
hegedus@celeste.eng.yale.edu (Peter Hegedus)
hoh@approve.se (Goran Larsson)
hooft@chem.ruu.nl (Rob Hooft)
hsw1@papa.attmail.com (Stephen Harris)
irving@happy-man.com (Irving Wolfe)
jch@cs.cmu.edu (Jonathan Hardwick)
jhi@dol-guldur.hut.fi (Jarkko Hietaniemi)
jos@oce.nl (Jos Backus)
liblit@cs.psu.edu (Benjamin Liblit)
marc@cam.org (Marc Boucher)
mason@werple.apana.org.au (Geoff Wing)
mycroft@gnu.ai.mit.edu (Charles Hannum)
mystic@axposf.pa.dec.com (D. Hall)
norbert@i3.informatik.rwth-aachen.de (Norbert Kiesel)
oberon@cs.tu-berlin.de (Sven Wischnowsky)
pclink@qld.tne.oz.au (Rick)
pem@aaii.oz.au (Paul Maisano)
per@efd.lth.se (Per Foreby)
pf@z-code.com (Paul Falstad)
roderick@ibcinc.com (Roderick Schertler)
schaefer@z-code.com (Bart Schaefer)
schlangm@informatik.uni-muenchen.de (Harald Schlangmann)
seniorr@teleport.com (Russell Senior)
sinclair@dcs.gla.ac.uk (Duncan Sinclair)
sterling@oldcolo.com (Bruce Sterling Woodcock)
suzuki@otsl.oki.co.jp (Hisao Suzuki)
tsm@cs.brown.edu (Timothy Miller)
wacker@physik.uni-dortmund.de (Klaus Wacker)
wacren@cis10.ens-cachan.fr (Laurent Wacrenier)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         .nr PI 0
.de Ds
.LD
.ft C
..
.de De
.DE
.ft R
..
.de Sh
.SH
\\$1
.XS
\\$1
.XE
..
.TL
An Introduction to the Z Shell
.AU
Paul Falstad
pf@z-code.com
.AU
Bas de Bakker
bas@phys.uva.nl
.PP
.Sh "Introduction"
.PP
\fBzsh\fP is a shell designed for interactive use, although it is also
a powerful scripting language.  Many of the useful features of bash,
ksh, and tcsh were incorporated into \fBzsh\fP; many original features were
added.  This document details some of the unique features of \fBzsh\fP.  It
assumes basic knowledge of the standard UNIX shells; the intent is to
show a reader already familiar with one of the other major shells what
makes \fBzsh\fP more useful or more powerful.  This document is not at all
comprehensive; read the manual entry for a description of the shell
that is complete and concise, although somewhat overwhelming and
devoid of examples.
.PP
The text will frequently mention options that you can set to change
the behaviour of \fBzsh\fP.  You can set these options with the
command
.Ds
% setopt \fIoptionname\fC
.De
and unset them again with
.Ds
% unsetopt \fIoptionname\fC
.De
Case is ignored in option names, as are embedded underscores.
.Sh "Filename Generation"
.PP
Otherwise known as \fIglobbing\fP, filename generation
is quite extensive in \fBzsh\fP.  Of course, it has all the
basics:
.Ds
% ls
Makefile   file.pro   foo.o      main.o     q.c        run234     stuff
bar.o      foo        link       morestuff  run123     run240     sub
file.h     foo.c      main.h     pipe       run2       run303
% ls *.c
foo.c  q.c
% ls *.[co]
bar.o   foo.c   foo.o   main.o  q.c
% ls foo.?
foo.c  foo.o
% ls *.[^c]
bar.o   file.h  foo.o   main.h  main.o
% ls *.[^oh]
foo.c  q.c
.De
Also, if the \fIEXTENDEDGLOB\fP option is set,
some new features are activated.
For example, the \fC^\fP character negates the pattern following it:
.Ds
% setopt extendedglob
% ls -d ^*.c
Makefile   file.pro   link       morestuff  run2       run303
bar.o      foo        main.h     pipe       run234     stuff
file.h     foo.o      main.o     run123     run240     sub
% ls -d ^*.*
Makefile   link       pipe       run2       run240     stuff
foo        morestuff  run123     run234     run303     sub
% ls -d ^Makefile
bar.o      foo        link       morestuff  run123     run240     sub
file.h     foo.c      main.h     pipe       run2       run303
file.pro   foo.o      main.o     q.c        run234     stuff
% ls -d *.^c
\&.rhosts   bar.o     file.h    file.pro  foo.o     main.h    main.o
.De
An expression of the form
\fC<\fIx\fR\-\fIy\fC>\fR
matches a range of integers:
.Ds
% ls run<200-300>
run234  run240
% ls run<300-400>
run303
% ls run<-200>
run123  run2
% ls run<300->
run303
% ls run<>
run123  run2    run234  run240  run303
.De
The \fINUMERICGLOBSORT\fP option will sort files with numbers
according to the number.  This will not work with \fCls\fP as it
resorts its arguments:
.Ds
% setopt numericglobsort
% echo run<>
run2 run123 run234 run240 run303
.De
Grouping is possible:
.Ds
% ls (foo|bar).*
bar.o  foo.c  foo.o
% ls *.(c|o|pro)
bar.o     file.pro  foo.c     foo.o     main.o    q.c
.De
Also, the string \fC**/\fP forces a recursive search of
subdirectories:
.Ds
% ls -R
Makefile   file.pro   foo.o      main.o     q.c        run234     stuff
bar.o      foo        link       morestuff  run123     run240     sub
file.h     foo.c      main.h     pipe       run2       run303

morestuff:

stuff:
file  xxx   yyy

stuff/xxx:
foobar

stuff/yyy:
frobar
% ls **/*bar
stuff/xxx/foobar  stuff/yyy/frobar
% ls **/f*
file.h            foo               foo.o             stuff/xxx/foobar
file.pro          foo.c             stuff/file        stuff/yyy/frobar
% ls *bar*
bar.o
% ls **/*bar*
bar.o             stuff/xxx/foobar  stuff/yyy/frobar
% ls stuff/**/*bar*
stuff/xxx/foobar  stuff/yyy/frobar
.De
.PP
It is possible to exclude certain files from the patterns using
the ~ character.  A pattern of the form \fC*.c~bar.c\fP lists all
files matching \fC*.c\fP, except for the file \fCbar.c\fP.
.Ds
% ls *.c
foo.c    foob.c    bar.c
% ls *.c~bar.c
foo.c    foob.c
% ls *.c~f*
bar.c
.De
.PP
One can add a number of \fIqualifiers\fP to the end of
any of these patterns, to restrict matches to certain
file types.  A qualified pattern is of the form
.DS
\fIpattern\fC(\fR...\fC)\fR
.De
with single-character qualifiers inside the parentheses.
.Ds
% alias l='ls -dF'
% l *
Makefile    foo*        main.h      q.c         run240
bar.o       foo.c       main.o      run123      run303
file.h      foo.o       morestuff/  run2        stuff/
file.pro    link@       pipe        run234      sub
% l *(/)
morestuff/  stuff/
% l *(@)
link@
% l *(*)
foo*        link@       morestuff/  stuff/
% l *(x)
foo*        link@       morestuff/  stuff/
% l *(X)
foo*        link@       morestuff/  stuff/
% l *(R)
bar.o       foo*        link@       morestuff/  run123      run240
file.h      foo.c       main.h      pipe        run2        run303
file.pro    foo.o       main.o      q.c         run234      stuff/
.De
Note that \fC*(x)\fP and \fC*(*)\fP both match executables.
\fC*(X)\fP matches files executable by others, as opposed to
\fC*(x)\fP, which matches files executable by the owner.
\fC*(R)\fP and \fC*(r)\fP match readable files;
\fC*(W)\fP and \fC*(w)\fP, which checks for writable files.
\fC*(W)\fP is especially important, since it checks for world-writable
files:
.Ds
% l *(w)
bar.o       foo*        link@       morestuff/  run123      run240
file.h      foo.c       main.h      pipe        run2        run303
file.pro    foo.o       main.o      q.c         run234      stuff/
% l *(W)
link@   run240
% l -l link run240
lrwxrwxrwx  1 pfalstad       10 May 23 18:12 link -> /usr/bin/
-rw-rw-rw-  1 pfalstad        0 May 23 18:12 run240
.De
If you want to have all the files of a certain type as well as all
symbolic links pointing to files of that type, prefix the qualifier
with a \fC-\fP:
.Ds
% l *(-/)
link@       morestuff/  stuff/
.De
You can filter out the symbolic links with the \fC^\fP character:
.Ds
% l *(W^@)
run240
% l *(x)
foo*        link@       morestuff/  stuff/
% l *(x^@/)
foo*
.De
To find all plain files, you can use \fC.\fP:
.Ds
% l *(.)
Makefile  file.h    foo*      foo.o     main.o    run123    run234    run303
bar.o     file.pro  foo.c     main.h    q.c       run2      run240    sub
% l *(^.)
link@       morestuff/  pipe        stuff/
% l s*(.)
stuff/   sub
% l *(p)
pipe
% l -l *(p)
prw-r--r--  1 pfalstad        0 May 23 18:12 pipe
.De
\fC*(U)\fP matches all files owned by you.
To search for all files not owned by you, use \fC*(^U)\fP:
.Ds
% l -l *(^U)
-rw-------  1 subbarao       29 May 23 18:13 sub
.De
This searches for setuid files:
.Ds
% l -l *(s)
-rwsr-xr-x  1 pfalstad       16 May 23 18:12 foo*
.De
This checks for a certain user's files:
.Ds
% l -l *(u[subbarao])
-rw-------  1 subbarao       29 May 23 18:13 sub
.De
.Sh "Startup Files"
.PP
There are five startup files that \fBzsh\fP will read commands from:
.Ds
$ZDOTDIR/.zshenv
$ZDOTDIR/.zprofile
$ZDOTDIR/.zshrc
$ZDOTDIR/.zlogin
$ZDOTDIR/.zlogout
.De
If \fBZDOTDIR\fP is not set, then the value of \fBHOME\fP is used;
this is the usual case.
.\".KE    <--- missing .KS or .KF above
.PP
\&\fC.zshenv\fP is sourced on all invocations of the shell,
unless the \fC-f\fP option is set.  It should contain commands to set
the command search path, plus other important environment
variables.
\&\fC.zshenv\fP should not contain commands that produce output
or assume the shell is attached to a tty.
.PP
\&\fC.zshrc\fP is sourced in interactive shells.  It should contain
commands to set up aliases, functions, options, key bindings, etc.
.PP
\&\fC.zlogin\fP is sourced in login shells.  It should contain
commands that should be executed only in login shells.
\&\fC.zlogout\fP is sourced when login shells exit.
\&\fC.zprofile\fP is similar to \fC.zlogin\fP, except that it is sourced before
\&\fC.zshrc\fP.
\&\fC.zprofile\fP is meant as an alternative to \fC.zlogin\fP for
ksh fans;
the two are not intended to be used together, although this
could certainly be done if desired.
\&\fC.zlogin\fP is not the place for alias definitions, options, environment
variable settings, etc.;
as a general rule, it should not change the shell environment
at all.  Rather, it should be used to set the terminal type
and run a series of external commands (\fCfortune\fP, \fCmsgs\fP, etc).
.Sh "Shell Functions"
.PP
\fBzsh\fP also allows you to create your own commands by defining shell
functions.  For example:
.Ds
% yp () {
>       ypmatch $1 passwd.byname
> }
% yp pfalstad
pfalstad:*:3564:35:Paul John Falstad:/u/pfalstad:/usr/princeton/bin/zsh
.De
This function looks up a user in the NIS password map.
The \fC$1\fP expands to the first argument to \fCyp\fP.
The function could have been equivalently defined in one of the following
ways:
.Ds
% function yp {
>       ypmatch $1 passwd.byname
> }
% function yp () {
>       ypmatch $1 passwd.byname
> }
% function yp () ypmatch $1 passwd.byname
.De
Note that aliases are expanded when the function definition is
parsed, not when the function is executed.  For example:
.Ds
% alias ypmatch=echo
% yp pfalstad
pfalstad:*:3564:35:Paul John Falstad:/u/pfalstad:/usr/princeton/bin/zsh
.De
Since the alias was defined after the function was parsed, it has
no effect on the function's execution.
However, if we define the function again with the alias in place:
.Ds
% function yp () { ypmatch $1 passwd.byname }
% yp pfalstad
pfalstad passwd.byname
.De
it is parsed with the new alias definition in place.
Therefore, in general you must define aliases before functions.
.\".KE    <--- missing .KS or .KF above
.PP
We can make the function take multiple arguments:
.Ds
% unalias ypmatch
% yp () {
>       for i
>       do ypmatch $i passwd.byname
>       done
> }
% yp pfalstad subbarao sukthnkr
pfalstad:*:3564:35:Paul John Falstad:/u/pfalstad:/usr/princeton/bin/zsh
subbarao:*:3338:35:Kartik Subbarao:/u/subbarao:/usr/princeton/bin/zsh
sukthnkr:*:1267:35:Rahul Sukthankar:/u/sukthnkr:/usr/princeton/bin/tcsh
.De
The \fCfor i\fP loops through each of the function's arguments,
setting \fCi\fP equal to each of them in turn.
We can also make the function do something sensible
if no arguments are given:
.Ds
% yp () {
>       if (( $# == 0 ))
>       then echo usage: yp name ...; fi
>       for i; do ypmatch $i passwd.byname; done
> }
% yp
usage: yp name ...
% yp pfalstad sukthnkr
pfalstad:*:3564:35:Paul John Falstad:/u/pfalstad:/usr/princeton/bin/zsh
sukthnkr:*:1267:35:Rahul Sukthankar:/u/sukthnkr:/usr/princeton/bin/tcsh
.De
\fC$#\fP is the number of arguments supplied to the function.
If it is equal to zero, we print a usage message; otherwise,
we loop through the arguments, and \fCypmatch\fP all of them.
.\".KE    <--- missing .KS or .KF above
.PP
Here's a function that selects a random line from a file:
.Ds
% randline () {
>       integer z=$(wc -l <$1)
>       sed -n $[RANDOM % z + 1]p $1
> }
% randline /etc/motd
PHOENIX WILL BE DOWN briefly Friday morning, 5/24/91 from 8 AM to
% randline /etc/motd
SunOS Release 4.1.1 (PHOENIX) #19: Tue May 14 19:03:15 EDT 1991
% randline /etc/motd
| Please use the "msgs" command to read announcements.  Refer to the   |
% echo $z

%
.De
\fCrandline\fP has a local variable, \fCz\fP, that holds the number of
lines in the file.  \fC$[RANDOM % z + 1]\fP expands to a random number
between 1 and \fCz\fP.  An expression of the form \fC$[\fR...\fC]\fR
expands to the value of the arithmetic expression within the brackets,
and the \fBRANDOM\fP variable returns a random number each time it
is referenced.  \fC%\fP is the modulus operator, as in C.
Therefore, \fCsed -n $[RANDOM%z+1]p\fP picks a random line from its
input, from 1 to \fCz\fP.
.PP
Function definitions can be viewed with the \fCfunctions\fP builtin:
.Ds
% functions randline
randline () {
        integer z=$(wc -l <$1)
        sed -n $[RANDOM % z + 1]p $1

}
% functions
yp () {
        if let $# == 0 
        
        then
                echo usage: yp name ...
        
        fi
        for i
        do
                ypmatch $i passwd.byname
        
                done

}
randline () {
        integer z=$(wc -l <$1)
        sed -n $[RANDOM % z + 1]p $1

}
.De
Here's another one:
.Ds
% cx () { chmod +x $* }
% ls -l foo bar
-rw-r--r--  1 pfalstad       29 May 24 04:38 bar
-rw-r--r--  1 pfalstad       29 May 24 04:38 foo
% cx foo bar
% ls -l foo bar
-rwxr-xr-x  1 pfalstad       29 May 24 04:38 bar
-rwxr-xr-x  1 pfalstad       29 May 24 04:38 foo
.De
Note that this could also have been implemented as an alias:
.Ds
% chmod 644 foo bar
% alias cx='chmod +x'
% cx foo bar
% ls -l foo bar
-rwxr-xr-x  1 pfalstad       29 May 24 04:38 bar
-rwxr-xr-x  1 pfalstad       29 May 24 04:38 foo
.De
.PP
Instead of defining a lot of functions in your \fC.zshrc\fP,
all of which you may not use,
it is often better to use the \fCautoload\fP builtin.
The idea is, you create a directory where function
definitions are stored, declare the names in
your \fC.zshrc\fP, and tell the shell where to look for them.
Whenever you reference a function, the shell
will automatically load it into memory.
.Ds
% mkdir /tmp/funs
% cat >/tmp/funs/yp
ypmatch $1 passwd.byname
^D
% cat >/tmp/funs/cx
chmod +x $*
^D
% FPATH=/tmp/funs
% autoload cx yp
% functions cx yp
undefined cx ()
undefined yp ()
% chmod 755 /tmp/funs/{cx,yp}
% yp egsirer
egsirer:*:3214:35:Emin Gun Sirer:/u/egsirer:/bin/sh
% functions yp
yp () {
        ypmatch $1 passwd.byname
}
.De
This idea has other benefits.  By adding a \fC#!\fP header
to the files, you can make them double as shell scripts.
(Although it is faster to use them as functions, since a
separate process is not created.)
.Ds
% ed /tmp/funs/yp
25
i
#! /usr/local/bin/zsh
.
w
42
q
% </tmp/funs/yp
#! /usr/local/bin/zsh
ypmatch $1 passwd.byname
% /tmp/funs/yp sukthnkr
sukthnkr:*:1267:35:Rahul Sukthankar:/u/sukthnkr:/usr/princeton/bin/tcsh
.De
Now other people, who may not use \fBzsh\fP, or who don't want to
copy all of your \fC.zshrc\fP, may use these functions as shell
scripts.
.Sh "Directories"
.PP
One nice feature of \fBzsh\fP is the way it prints directories.
For example, if we set the prompt like this:
.Ds
phoenix% PROMPT='%~> '
~> cd src
~/src>
.De
the shell will print the current directory in the prompt,
using the \fC~\fP character.
However, \fBzsh\fP is smarter than most other shells in this respect:
.Ds
~/src> cd ~subbarao
~subbarao> cd ~maruchck
~maruchck> cd lib
~maruchck/lib> cd fun
~maruchck/lib/fun> foo=/usr/princeton/common/src
~maruchck/lib/fun> cd ~foo
~foo> cd ..
/usr/princeton/common> cd src
~foo> cd news/nntp
~foo/news/nntp> cd inews
~foo/news/nntp/inews>
.De
Note that \fBzsh\fP prints \fIother\fP users' directories 
in the form \fC~user\fP.  Also note that you can
set a parameter and use it as a directory name;
\fBzsh\fP will act as if \fCfoo\fP is a user
with the login directory \fC/usr/princeton/common/src\fP.
This is convenient, especially if you're sick of seeing
prompts like this:
.Ds
phoenix:/usr/princeton/common/src/X.V11R4/contrib/clients/xv/docs>
.De
If you get stuck in this position, you can give the current
directory a short name, like this:
.Ds
/usr/princeton/common/src/news/nntp/inews> inews=$PWD
/usr/princeton/common/src/news/nntp/inews> echo ~inews
/usr/princeton/common/src/news/nntp/inews
~inews>
.De
When you reference a directory in the form \fC~inews\fP,
the shell assumes that you want the directory displayed
in this form; thus simply typing \fCecho ~inews\fP or
\fCcd ~inews\fP causes the prompt to be shortened.
You can define a shell function for this purpose:
.Ds
~inews> namedir () { $1=$PWD ;  : ~$1 }
~inews> cd /usr/princeton/bin
/usr/princeton/bin> namedir pbin
~pbin> cd /var/spool/mail
/var/spool/mail> namedir spool
~spool> cd .msgs
~spool/.msgs>
.De
You may want to add this one-line function to your \fC.zshrc\fP.

\fBzsh\fP can also put the current directory in your title bar,
if you are using a windowing system.
One way to do this is with the \fCchpwd\fP function, which is
automatically executed by the shell whenever you change
directory.  If you are using xterm, this will work:
.Ds
chpwd () { print -Pn '^[]2;%~^G' }
.De
The \fC-P\fP option tells \fCprint\fP to treat its arguments like a prompt
string; otherwise the \fC%~\fP would not be expanded.
The \fC-n\fP option suppresses the terminating newline, as with \fCecho\fP.
.PP
If you are using an IRIS \fCwsh\fP, do this:
.Ds
chpwd () { print -Pn '\e2201.y%~\e234' }
.De
The \fCprint -D\fP command has other uses.  For example, to
print the current directory to standard output in short form,
you can do this:
.Ds
% print -D $PWD
~subbarao/src
.De
and to print each component of the path in short form:
.Ds
% print -D $path
/bin /usr/bin ~locbin ~locbin/X11 ~/bin
.De
.Sh "Directory Stacks"
.PP
If you use csh, you may know about directory stacks.
The \fCpushd\fP command puts the current directory on the
stack, and changes to a new directory; the \fCpopd\fP command
pops a directory off the stack and changes to it.
.Ds
phoenix% cd 
phoenix% PROMPT='Z %~> '
Z ~> pushd /tmp
/tmp ~
Z /tmp> pushd /usr/etc
/usr/etc /tmp ~
Z /usr/etc> pushd /usr/bin
/usr/bin /usr/etc /tmp ~
Z /usr/bin> popd
/usr/etc /tmp ~
Z /usr/etc> popd
/tmp ~
Z /tmp> pushd /etc
/etc /tmp ~
Z /etc> popd 
/tmp ~
.De
\fBzsh\fP's directory stack commands work similarly.  One
difference is the way \fCpushd\fP is handled if no arguments
are given.  As in csh, this exchanges the top two elements
of the directory stack:
.Ds
Z /tmp> dirs
/tmp ~
Z /tmp> pushd
~ /tmp
.De
unless the stack only has one entry:
.Ds
Z ~> popd
/tmp
Z /tmp> dirs
/tmp
Z /tmp> pushd
~ /tmp
Z ~>
.De
or unless the \fIPUSHDTOHOME\fP option is set:
.Ds
Z ~> setopt pushdtohome
Z ~> pushd
~ ~ /tmp
.De
.PP
As an alternative to using directory stacks in this manner,
we can get something like a \fIdirectory history\fP
by setting a few more options and parameters:
.Ds
~> DIRSTACKSIZE=8
~> setopt autopushd pushdminus pushdsilent pushdtohome
~> alias dh='dirs -v'
~> cd /tmp
/tmp> cd /usr
/usr> cd bin
/usr/bin> cd ../pub
/usr/pub> dh
0       /usr/pub
1       /usr/bin
2       /usr
3       /tmp
4       ~
/usr/pub> cd -3
/tmp> dh
0       /tmp
1       /usr/pub
2       /usr/bin
3       /usr
4       ~
/tmp> ls =2/df
/usr/bin/df
/tmp> cd -4
~>
.De
Note that \fC=2\fP expanded to the second directory in the
history list, and that \fCcd -3\fP recalled the third
directory in the list.
.PP
You may be wondering what all those options do.
\fIAUTOPUSHD\fP made \fCcd\fP act like \fCpushd\fP.
(\fCalias cd=pushd\fP is not sufficient, for various reasons.)
\fIPUSHDMINUS\fP swapped the meaning of \fCcd +1\fP and
\fCcd -1\fP; we want them to mean the opposite of what they mean in csh,
because it makes more sense in this scheme, and it's easier to type:
.Ds
~> dh
0       ~
1       /tmp
2       /usr/pub
3       /usr/bin
4       /usr
~> unsetopt pushdminus
~> cd +1
/tmp> dh
0       /tmp
1       ~
2       /usr/pub
3       /usr/bin
4       /usr
/tmp> cd +2
/usr/pub>
.De
\fIPUSHDSILENT\fP keeps the shell from printing
the directory stack each time we do a \fCcd\fP,
and \fIPUSHDTOHOME\fP we mentioned earlier:
.Ds
/usr/pub> unsetopt pushdsilent
/usr/pub> cd /etc
/etc /usr/pub /tmp ~ /usr/bin /usr
/etc> cd
~ /etc /usr/pub /tmp ~ /usr/bin /usr
~> unsetopt pushdtohome
~> cd
/etc ~ /usr/pub /tmp ~ /usr/bin /usr
/etc>
.De
\fBDIRSTACKSIZE\fP keeps the directory stack
from getting too large, much like \fIHISTSIZE\fP:
.Ds
/etc> setopt pushdsilent
/etc> cd /
/> cd /
/> cd /
/> cd /
/> cd /
/> cd /
/> cd /
/> cd /
/> dh
0       /
1       /
2       /
3       /
4       /
5       /
6       /
7       /
.De
.Sh "Command/Process Substitution"
.PP
Command substitution in \fBzsh\fP can take two forms.
In the traditional form, a command enclosed in
backquotes (\fC`\fP...\fC`\fP) is replaced on the command line with its output.
This is the form used by the older shells.
Newer shells (like \fBzsh\fP) also provide another form,
\fC$(\fR...\fC)\fR.  This form is much easier to nest.
.Ds
% ls -l `echo /vmunix`
-rwxr-xr-x  1 root      1209702 May 14 19:04 /vmunix
% ls -l $(echo /vmunix)
-rwxr-xr-x  1 root      1209702 May 14 19:04 /vmunix
% who | grep mad
subbarao ttyt7   May 23 15:02   (mad55sx15.Prince)
pfalstad ttyu1   May 23 16:25   (mad55sx14.Prince)
subbarao ttyu6   May 23 15:04   (mad55sx15.Prince)
pfalstad ttyv3   May 23 16:25   (mad55sx14.Prince)
% who | grep mad | awk '{print $2}'
ttyt7
ttyu1
ttyu6
ttyv3
% cd /dev; ls -l $(who |
> grep $(echo mad) |
> awk '{ print $2 }')
crwx-w----  1 subbarao  20,  71 May 23 18:35 ttyt7
crw--w----  1 pfalstad  20,  81 May 23 18:42 ttyu1
crwx-w----  1 subbarao  20,  86 May 23 18:38 ttyu6
crw--w----  1 pfalstad  20,  99 May 23 18:41 ttyv3
.De
Many common uses of command substitution, however, are
superseded by other mechanisms of \fBzsh\fP:
.Ds
% ls -l `tty`
crw-rw-rw-  1 root      20,  28 May 23 18:35 /dev/ttyqc
% ls -l $TTY
crw-rw-rw-  1 root      20,  28 May 23 18:35 /dev/ttyqc
% ls -l `which rn`
-rwxr-xr-x  1 root       172032 Mar  6 18:40 /usr/princeton/bin/rn
% ls -l =rn
-rwxr-xr-x  1 root       172032 Mar  6 18:40 /usr/princeton/bin/rn
.De
A command name with a \fC=\fP prepended is replaced with its full
pathname.  This can be very convenient.  If it's not convenient
for you, you can turn it off:
.Ds
% ls
=foo    =bar
% ls =foo =bar
zsh: foo not found
% setopt noequals
% ls =foo =bar
=foo    =bar
.De
.PP
Another nice feature is process substitution:
.Ds
% who | fgrep -f =(print -l root lemke shgchan subbarao)
root     console May 19 10:41
lemke    ttyq0   May 22 10:05   (narnia:0.0)
lemke    ttyr7   May 22 10:05   (narnia:0.0)
lemke    ttyrd   May 22 10:05   (narnia:0.0)
shgchan  ttys1   May 23 16:52   (gaudi.Princeton.)
subbarao ttyt7   May 23 15:02   (mad55sx15.Prince)
subbarao ttyu6   May 23 15:04   (mad55sx15.Prince)
shgchan  ttyvb   May 23 16:51   (gaudi.Princeton.)
.De
A command of the form \fC=(\fR...\fC)\fR is replaced with the name of a \fIfile\fP
containing its output.  (A command substitution, on the other
hand, is replaced with the output itself.)
\fCprint -l\fP is like \fCecho\fP, excepts that it prints its arguments
one per line, the way \fCfgrep\fP expects them:
.Ds
% print -l foo bar
foo
bar
.De
We could also have written:
.Ds
% who | fgrep -f =(echo 'root
> lemke
> shgchan
> subbarao')
.De
Using process substitution,
you can edit the output of a command:
.Ds
% ed =(who | fgrep -f ~/.friends)
355
g/lemke/d
w /tmp/filbar
226
q
% cat /tmp/filbar
root     console May 19 10:41
shgchan  ttys1   May 23 16:52   (gaudi.Princeton.)
subbarao ttyt7   May 23 15:02   (mad55sx15.Prince)
subbarao ttyu6   May 23 15:04   (mad55sx15.Prince)
shgchan  ttyvb   May 23 16:51   (gaudi.Princeton.)
.De
or easily read archived mail:
.Ds
% mail -f =(zcat ~/mail/oldzshmail.Z)
"/tmp/zsha06024": 84 messages, 0 new, 43 unread
>  1  U  TO: pfalstad, zsh (10)
   2  U  nytim!tim@uunet.uu.net, Re: Zsh on Sparc1 /SunOS 4.0.3
   3  U  JAM%TPN@utrcgw.utc.com, zsh fix (15)
   4  U  djm@eng.umd.edu, way to find out if running zsh? (25)
   5  U  djm@eng.umd.edu, Re: way to find out if running zsh? (17)
   6   r djm@eng.umd.edu, Meta . (18)
   7  U  jack@cs.glasgow.ac.uk, Re: problem building zsh (147)
   8  U  nytim!tim@uunet.uu.net, Re: Zsh on Sparc1 /SunOS 4.0.3
   9     ursa!jmd, Another fix... (61)
  10  U  pplacewa@bbn.com, Re: v18i084: Zsh 2.00 - A small complaint (36)
  11  U  lubkin@cs.rochester.edu, POSIX job control (34)
  12  U  yale!bronson!tan@uunet.UU.NET
  13  U  brett@rpi.edu, zsh (36)
  14  S  subbarao, zsh sucks!!!! (286)
  15  U  snibru!d241s008!d241s013!ala@relay.EU.net, zsh (165)
  16  U  nytim!tim@uunet.UU.NET, Re: Zsh on Sparc1 /SunOS 4.0.3
  17  U  subbarao, zsh is a junk shell (43)
  18  U  amaranth@vela.acs.oakland.edu, zsh (33)
43u/84 1: x
% ls -l /tmp/zsha06024
/tmp/zsha06024 not found
.De
Note that the shell creates a temporary file, and deletes it
when the command is finished.
.Ds
% diff =(ls) =(ls -F)
3c3
< fortune
---
> fortune*
10c10
< strfile
---
> strfile*
.De
If you read \fBzsh\fP's man page, you may notice that \fC<(\fR...\fC)\fR
is another form of process substitution which is similar to
\fC=(\fR...\fC)\fR.
There is an important difference between the two.
In the \fC<(\fR...\fC)\fR case, the shell creates a named pipe (FIFO)
instead of a file.  This is better, since it does not
fill up the file system; but it does not work in all cases.
In fact, if we had replaced \fC=(\fR...\fC)\fR with \fC<(\fR...\fC)\fR in 
the examples above, all of them would have stopped working
except for \fCfgrep -f <(\fR...\fC)\fR.
You can not edit a pipe, or open it as a mail folder;
\fCfgrep\fP, however, has no problem with reading
a list of words from a pipe.
You may wonder why \fCdiff <(foo) bar\fP doesn't work, since
\fCfoo | diff - bar\fP works; this is because \fCdiff\fP creates
a temporary file if it notices that one of its arguments
is \fC-\fP, and then copies its standard input to the temporary
file.
.PP
\fC>(\fR...\fC)\fR is just like \fC<(\fR...\fC)\fR except that the
command between the parentheses will get its input from the named
pipe.
.Ds
% dvips -o >(lpr) zsh.dvi
.De
.Sh "Redirection"
.PP
Apart from all the regular redirections like the Bourne shell has,
\fBzsh\fP can do more.  You can send the output of a command to more
than one file, by specifying more redirections like
.Ds
% echo Hello World >file1 >file2
.De
and the text will end up in both files.  Similarly, you can send the
output to a file and into a pipe:
.Ds
% make > make.log | grep Error
.De
The same goes for input.  You can make the input of a command come
from more than one file.
.Ds
% sort <file1 <file2 <file3
.De
The command will first get the contents of file1 as its standard
input, then those of file2 and finally the contents of file3.  This,
too, works with pipes.
.Ds
% cut -d: -f1 /etc/passwd | sort <newnames
.De
The sort will get as its standard input first the output of \fCcut\fP
and then the contents of \fCnewnames\fP.
.PP
Suppose you would like to watch the standard output of a command on
your terminal, but want to pipe the standard error to another command.
An easy way to do this in \fBzsh\fP is by redirecting the standard
error using \fC2> >(\fR...\fC)\fR.
.Ds
% find / -name games 2> >(grep -v 'Permission' > realerrors)
.De
The above redirection will actually be implemented with a regular
pipe, not a temporary named pipe.
.Sh "Aliasing"
.PP
Often-used commands can be abbreviated with an alias:
.Ds
% alias uc=uncompress
% ls
hanoi.Z
% uc hanoi
% ls
hanoi
.De
or commands with certain desired options:
.Ds
% alias fm='finger -m'
% fm root
Login name: root                        In real life: Operator
Directory: /                            Shell: /bin/csh
On since May 19 10:41:15 on console     3 days 5 hours Idle Time
No unread mail
No Plan.

% alias lock='lock -p -60000'
% lock
lock: /dev/ttyr4 on phoenix. timeout in 60000 minutes
time now is Fri May 24 04:23:18 EDT 1991
Key: 

% alias l='ls -AF'
% l /
\&.bash_history              kadb*
\&.bashrc                    lib@
\&.cshrc                     licensed/
\&.exrc                      lost+found/
\&.login                     macsyma
\&\fR...
.De
Aliases can also be used to replace old commands:
.Ds
% alias grep=egrep ps=sps make=gmake
% alias whoami='echo root'
% whoami
root
.De
or to define new ones:
.Ds
% cd /
% alias sz='ls -l | sort -n +3 | tail -10'
% sz
drwxr-sr-x  7 bin          3072 May 23 11:59 etc
drwxrwxrwx 26 root         5120 May 24 04:20 tmp
drwxr-xr-x  2 root         8192 Dec 26 19:34 lost+found
drwxr-sr-x  2 bin         14848 May 23 18:48 dev
-r--r--r--  1 root       140520 Dec 26 20:08 boot
-rwxr-xr-x  1 root       311172 Dec 26 20:08 kadb
-rwxr-xr-x  1 root      1209695 Apr 16 15:33 vmunix.old
-rwxr-xr-x  1 root      1209702 May 14 19:04 vmunix
-rwxr-xr-x  1 root      1209758 May 21 12:23 vmunix.new.kernelmap.old
-rwxr-xr-x  1 root      1711848 Dec 26 20:08 vmunix.org
% cd
% alias rable='ls -AFtrd *(R)' nrable='ls -AFtrd *(^R)'
% rable
README      func/       bin/        pub/        News/       src/
nicecolors  etc/        scr/        tmp/        iris/       zsh*
% nrable
Mailboxes/  mail/       notes
.De
(The pattern \fC*(R)\fP matches all readable files in the current
directory, and \fC*(^R)\fP matches all unreadable files.)
.PP
Most other shells have aliases of this kind (\fIcommand\fP aliases).
However, \fBzsh\fP also has \fIglobal\fP aliases, which are substituted
anywhere on a line.
Global aliases can be used to abbreviate frequently-typed
usernames, hostnames, etc.
.Ds
% alias -g me=pfalstad gun=egsirer mjm=maruchck
% who | grep me
pfalstad ttyp0   May 24 03:39   (mickey.Princeton)
pfalstad ttyp5   May 24 03:42   (mickey.Princeton)
% fm gun
Login name: egsirer                     In real life: Emin Gun Sirer
Directory: /u/egsirer                   Shell: /bin/sh
Last login Thu May 23 19:05 on ttyq3 from bow.Princeton.ED
New mail received Fri May 24 02:30:28 1991;
  unread since Fri May 24 02:30:27 1991
% alias -g phx=phoenix.princeton.edu warc=wuarchive.wustl.edu
% ftp warc
Connected to wuarchive.wustl.edu.
.De
Here are some more interesting uses.
.Ds
% alias -g M='| more' GF='| fgrep -f ~/.friends'
% who M   # \fIpipes the output of \fCwho\fI through \fCmore
% who GF  # \fIsee if your friends are on\fC
% w GF    # \fIsee what your friends are doing
.De
Another example makes use of \fBzsh\fP's process substitution.
If you run NIS, and you miss being able to do this:
.Ds
% grep pfalstad /etc/passwd
.De
you can define an alias that will seem more natural
than \fCypmatch pfalstad passwd\fP:
.Ds
% alias -g PASS='<(ypcat passwd)'
% grep pfalstad PASS
pfalstad:*:3564:35:Paul John Falstad:/u/pfalstad:/usr/princeton/bin/zsh
.De
If you're really crazy, you can even call it \fC/etc/passwd\fP:
.Ds
% alias -g /etc/passwd='<(ypcat passwd)'
% grep pfalstad /etc/passwd
pfalstad:*:3564:35:Paul John Falstad:/u/pfalstad:/usr/princeton/bin/zsh
.De
The last example shows one of the perils of global aliases;
they have a lot of potential to cause confusion.
For example, if you defined a global alias called \fC|\fP (which is
possible), \fBzsh\fP would begin to act very strangely; every pipe
symbol would be replaced with the text of your alias.
To some extent, global aliases are like macros in C;
discretion is advised in using them and in choosing names for them.
Using names in all caps is not a bad idea, especially
for aliases which introduce shell metasyntax (like \fCM\fP and \fCGF\fP
above).
.PP
Note that \fBzsh\fP aliases are not like csh aliases.  The syntax for
defining them is different, and they do not have arguments.
All your favorite csh aliases will probably not work under \fBzsh\fP.
For example, if you try:
.Ds
alias rm mv '\e!* /tmp/wastebasket'
.De
no aliases will be defined, but \fBzsh\fP will not report an error.
In csh, this line defines an alias that makes \fCrm\fP safe---files
that are \fCrm\fP'd will be moved to a temporary directory instead of
instantly destroyed.  In \fBzsh\fP's syntax, however, this line asks
the shell to print any existing alias definitions for \fCrm\fP,
\fCmv\fP, or \fC!*\ /tmp/wastebasket\fP.  Since there are none, most
likely, the shell will not print anything, although \fCalias\fP will
return a nonzero exit code.  The proper syntax is this:
.Ds
alias rm='mv \e!* /tmp/wastebasket'
.De
However, this won't work either:
.Ds
% rm foo.dvi
zsh: no matches found: !*
.De
While this makes \fCrm\fP safe, it is certainly not what the user
intended.  In \fBzsh\fP, you must use a shell function for this:
.Ds
% unalias rm
% rm () { mv $* /tmp/wastebasket }
% rm foo.dvi
% ls /tmp/wastebasket
foo.dvi
.De
While this is much cleaner and easier to read (I hope you will
agree), it is not csh-compatible.  Therefore, a script to convert
csh aliases and variables has been provided.  You should only need to use it
once, to convert all your csh aliases and parameters to \fBzsh\fP format:
.Ds
% csh
csh> alias
l       ls -AF
more    less
on      last -2 !:1 ; who | grep !:1
csh> exit
% c2z >neat_zsh_aliases
% cat neat_zsh_aliases
alias l='ls -AF'
alias more='less'
on () { last -2 $1 ; who | grep $1 }
\&...
.De
The first two aliases were converted to regular \fBzsh\fP aliases, while
the third, since it needed to handle arguments, was converted to
a function.  \fCc2z\fP can convert most aliases to \fBzsh\fP format without
any problems.  However, if you're using some really arcane csh tricks,
or if you have an alias with a name like \fCdo\fP (which is reserved
in \fBzsh\fP), you may have to fix some of the aliases by hand.
.PP
The \fCc2z\fP script checks your csh setup, and produces a list
of \fBzsh\fP commands which replicate your aliases and parameter settings
as closely as possible.  You could include its output in your
startup file, \fC.zshrc\fP.
.Sh "History"
.PP
There are several ways to manipulate history in \fBzsh\fP.
One way is to use csh-style \fC!\fP history:
.Ds
% /usr/local/bin/!:0 !-2*:s/foo/bar/ >>!$
.De
If you don't want to use this, you can turn it off
by typing \fCsetopt nobanghist\fP.  If you are afraid of accidentally
executing the wrong command you can set the \fIHISTVERIFY\fP option.
If this option is set, commands that result from history expansion
will not be executed immediately, but will be put back into the editor
buffer for further consideration.
.PP
If you're not familiar with \fC!\fP history, here follows some
explanation.  History substitutions always start with a \fC!\fP,
commonly called \*Qbang\*U.  After the \fC!\fP comes an (optional)
designation of which \*Qevent\*U (command) to use, then a colon, and
then a designation of what word of that command to use.  For example,
\fC!-\fIn\fR refers to the command \fIn\fP commands ago.
.Ds
% ls
foo  bar
% cd foo
% !-2
ls
baz  bam
.De
No word designator was used, which means that the whole command
referred to was repeated.  Note that the shell will echo the result of
the history substitution.  The word designator can, among other
things, be a number indicating the argument to use, where \fC0\fP is
the command.
.Ds
% /usr/bin/ls foo
foo
% !:0 bar
/usr/bin/ls bar
bar
.De
In this example, no event designator was used, which tells \fBzsh\fP
to use the previous command.  A \fC$\fP specifies the last argument
.Ds
% mkdir /usr/local/lib/emacs/site-lisp/calc
% cd !:$
cd /usr/local/lib/emacs/site-lisp/calc
.De
If you use more words of the same command, only the first \fC!\fP
needs an event designator.
.Ds
% make prig >> make.log
make: *** No rule to make target `prig'.  Stop.
% cd src
% !-2:0 prog >> !:$
make prog >> make.log
.De
This is different from csh, where a bang with no event designator
always refers to the previous command.  If you actually like this
behaviour, set the \fICSHJUNKIEHISTORY\fP option.
.Ds
% setopt cshjunkiehistory
% !-2:0 prog2 >> !:$
make prog2 >> cshjunkiehistory
.De
Another way to use history is to use the \fCfc\fP command.  For
example, if you type an erroneous command:
.Ds
% for i in `cat /etc/clients` 
 do 
 rpu $i 
 done
zsh: command not found: rpu
zsh: command not found: rpu
zsh: command not found: rpu
\&\fR...
.De
typing \fCfc\fP will execute an editor on this command, allowing
you to fix it.  (The default editor is \fCvi\fP, by the way,
not \fCed\fP).
.Ds
% fc
49
/rpu/s//rup/p
 rup $i 
w
49
q
for i in `cat /etc/clients` 
 do 
 rup $i 
 done
        beam    up  2 days, 10:17,    load average: 0.86, 0.80, 0.50
         bow    up  4 days,  8:41,    load average: 0.91, 0.80, 0.50
        burn    up          17:18,    load average: 0.91, 0.80, 0.50
       burst    up  9 days,  1:49,    load average: 0.95, 0.80, 0.50
         tan    up          11:14,    load average: 0.91, 0.80, 0.50
       bathe    up  3 days, 17:49,    load average: 1.84, 1.79, 1.50
        bird    up  1 day,   9:13,    load average: 1.95, 1.82, 1.51
      bonnet    up  2 days, 21:18,    load average: 0.93, 0.80, 0.50
\&\fR...
.De
A variant of the \fCfc\fP command is \fCr\fP, which redoes the last
command, with optional changes:
.Ds
% echo foo
foo
% r
echo foo
foo

% echo foo
foo
% r foo=bar
echo bar
bar
.De
.Sh "Command Line Editing"
.PP
\fBzsh\fP's command line editor, \fBZLE\fP, is quite powerful.
It is designed to emulate either emacs or vi; the default
is emacs.  To set the bindings for vi mode, type \fCbindkey -v\fP.  If
your \fBEDITOR\fP or \fBVISUAL\fP environment variable is vi,
\fBzsh\fP will use vi emulation by default.  You can then switch to
emacs mode with \fCbindkey -e\fP.
.PP
In addition to basic editing, the shell allows you to 
recall previous lines in the history.  In emacs mode,
this is done with \fI^P\fP (control-P) or (on many terminals) with the
cursor-up key:
.Ds
% ls ~
-           README      file        mail        pub         tmp
Mailboxes   bin         func        nicecolors  scr         zsh
News        etc         iris        notes       src
% echo foobar
foobar
% \fI^P\fC
% echo foobar\fI^P\fC
% ls ~_
.De
Pressing \fI^P\fP once brings up the previous line (\fCecho foobar\fP);
pressing it again brings up the line before that (\fCls ~\fP).
The cursor is left at the end of the line, allowing you to
edit the line if desired before executing it.
In many cases, \fBZLE\fP eliminates the need for the \fCfc\fP command,
since it is powerful enough to handle even multiline commands:
.Ds
% for i in a b c d e
> do
> echo $i
> done
a
b
c
d
e
% \fI^P\fC
% for i in a b c d e 
 do 
 echo $i 
 done_
.De
Now you can just move up to the part you want to change...
.Ds
% for i in \kxa\l'|\nxu\(ul' b c d e
 do 
 echo $i 
 done
.De
change it, and execute the new command.
.Ds
% for i in f g h i j
 do 
 echo $i 
 done
f
g
h
i
j
.De
Also, you can search the history for a certain command using
\fIESC-P\fP, this will look for the last command that started with the
(part of the) word at the beginning of the current line.  Hitting
\fIESC-P\fP another time gets you the command before that, etc.
.Ds
% set \fIESC-P\fC
% setopt autolist \fIESC-P\fC
% setopt nocorrect_
.De
Another way is to do an incremental search, emacs-style:
.Ds
% \fI^R\fC
% _
i-search:

% l\kxs\l'|\nxu\(ul' /usr/bin
i-search: l

% date > foofile\kx.\l'|\nxu\(ul'c
i-search: le
.De
Suppose you have retrieved an old history event in one of these ways
and would like to execute several consecutive old commands starting
with this one.  \fC^O\fP will execute the current command and then put
the next command from the history into the editor buffer.  Typing
\fC^O\fP several times will therefore reexecute several consecutive
commands from the history.  Of course, you can edit some of those
commands in between.
.PP
In addition to completion (see below), \fITAB\fP performs expansion if
possible.
.Ds
% ls *.c\fITAB\fC
% ls foofile.c fortune.c rnd.c strfile.c unstr.c_
.De
For example, suppose you have a bunch of weird files in an important
directory:
.Ds
% ls
  * * *       ; & % $??foo  dspfok        foo.c
  !"foo"!       ` \e `         foo           rrr
.De
You want to remove them, but you don't want to damage \fCfoo.c\fP.
Here is one way to do this:
.Ds
% rm *\fITAB\fC
% rm \e \e \e*\e \e*\e \e*\e \e \e  \e!\e"foo\e"\e! \e;\e \e&\e %\e \e$'
''
'foo \e`\e \e\e\e \e` dspfok foo foo.c rrr_
.De
When you expand \fC*\fP, \fBzsh\fP inserts the names of all the files
into the editing buffer, with proper shell quoting.
Now, just move back and remove \fCfoo.c\fP from the buffer:
.Ds
% rm \e \e \e*\e \e*\e \e*\e \e \e  \e!\e"foo\e"\e! \e;\e \e&\e %\e \e$'
''
'foo \e`\e \e\e\e \e` dspfok foo \kxr\l'|\nxu\(ul'rr
.De
and press return.
Everything except \fCfoo.c\fP will be deleted from the directory.  If
you do not want to actually expand the current word, but would like to
see what the matches are, type \fC^Xg\fP.
.Ds
% rm f*\fI^Xg\fP
foo    foo.c
% rm f*_
.De
Here's another trick; let's say you have typed this command in:
.Ds
% gcc -o x.out foob.c -g -Wpointer-arith -Wtrigraphs_
.De
and you forget which library you want.  You need to escape
out for a minute and check by typing
\fCls /usr/lib\fP, or some other such command;
but you don't want to retype the whole command again,
and you can't press return now because the current command
is incomplete.
In \fBzsh\fP, you can put the line on the \fIbuffer stack\fP, using
\fIESC-Q\fP, and type some other commands.  The next time a prompt is printed,
the \fCgcc\fP line will be popped off the stack and put
in the editing buffer automatically; you can then enter the
proper library name and press return (or, \fIESC-Q\fP again and look
for some other libraries whose names you forgot).
.PP
A similar situation: what if you forget the option to gcc that
finds bugs using AI techniques?  You could either use \fIESC-Q\fP
again, and type \fCman gcc\fP, or you could press \fIESC-H\fP, which
essentially does the same thing; it puts the current line on
the buffer stack, and executes the command \fCrun-help gcc\fP,
where \fCrun-help\fP is an alias for \fCman\fP.
.PP
Another interesting command is \fIESC-A\fP.  This executes the
current line, but retains it in the buffer, so that it appears
again when the next prompt is printed.
Also, the cursor stays in the same place.
This is useful for executing a series of similar commands:
.Ds
% cc grok.c -g -lc -lgl -lsun -lmalloc -Bstatic -o b.out
% cc fubar.c -g -lc -lgl -lsun -lmalloc -Bstatic -o b.out
% cc fooble.c -g -lc -lgl -lsun -lmalloc -Bstatic -o b.out
.De
.PP
The \fIESC-'\fP command is useful for managing the shell's quoting
conventions.  Let's say you want to print this string:
.Ds
don't do that; type 'rm -rf \e*', with a \e before the *.
.De
All that is necessary is to type it into the editing buffer:
.Ds
% don't do that; type 'rm -rf \e*', with a \e before the *.
.De
press \fIESC-'\fP (escape-quote):
.Ds
% 'don'\e''t do that; type '\e''rm -rf \e*'\e'', with a \e before the *.'
.De
then move to the beginning and add the \fCecho\fP command.
.Ds
% echo 'don'\e''t do that; type '\e''rm -rf \e*'\e'', with a \e before the *.'
don't do that; type 'rm -rf \e*', with a \e before the *.
.De
Let's say you want to create an alias to do this \fCecho\fP command.
This can be done by recalling the line with \fI^P\fP and pressing
\fIESC-'\fP again:
.Ds
% 'echo '\e''don'\e''\e'\e'''\e''t do that; type '\e''\e'\e'''\e''rm -rf
\e*'\e''\e'\e'''\e'', with a \e before the *.'\e'''
.De
and then move to the beginning and add the command to create
an alias.
.Ds
% alias zoof='echo '\e''don'\e''\e'\e'''\e''t do that; type '\e''\e'\e'''\e''rm
-rf \e*'\e''\e'\e'''\e'', with a \e before the *.'\e'''
% zoof
don't do that; type 'rm -rf \e*', with a \e before the *.
.De
If one of these fancy editor commands changes your command line in a
way you did not intend, you can undo changes with \fC^_\fP, if you can
get it out of your keyboard, or \fC^X^U\fP, otherwise.
.PP
Another use of the editor is to edit the value of variables.
For example, an easy way to change your path is to use
the \fCvared\fP command:
.Ds
% vared PATH
> /u/pfalstad/scr:/u/pfalstad/bin/sun4:/u/maruchck/scr:/u/subbarao/bin:/u/maruc
hck/bin:/u/subbarao/scripts:/usr/princeton/bin:/usr/ucb:/usr/bin:/bin:/usr/host
s:/usr/princeton/bin/X11:/./usr/lang:/./usr/etc:/./etc
.De
You can now edit the path.  When you press return, the contents
of the edit buffer will be assigned to \fBPATH\fP.
.Sh "Completion"
.PP
Another great \fBzsh\fP feature is completion.  If you hit \fITAB\fP, \fBzsh\fP
will complete all kinds of stuff.  Like commands or filenames:
.Ds
% comp\fITAB\fC
% compress _

% ls nic\fITAB\fC
% ls nicecolors _

% ls /usr/pr\fITAB\fC
% ls /usr/princeton/_

% ls -l =com\fITAB\fC
% ls -l =compress _
.De
If the completion is ambiguous, the editor will beep.  If you find
this annoying, you can set the \fINOLISTBEEP\fP option.  Completion
can even be done in the middle of words.  To use this, you will have
to set the \fICOMPLETEINWORD\fP option:
.Ds
% setopt completeinword
% ls /usr/p\kxt\l'|\nxu\(ul'on\fITAB\fC
% ls /usr/prince\kxt\l'|\nxu\(ul'on/
% setopt alwaystoend
% ls /usr/p\kxt\l'|\nxu\(ul'on\fITAB\fC
% ls /usr/princeton/_
.De
You can list possible completions by pressing \fI^D\fP:
.Ds
% ls /vmu\fITAB \(embeep\(em\fC
% ls /vmunix_
% ls /vmunix\fI^D\fC
vmunix                    vmunix.old                
vmunix.new.kernelmap.old  vmunix.org
.De
Or, you could just set the \fIAUTOLIST\fP option:
.Ds
% setopt autolist
% ls /vmu\fITAB \(embeep\(em\fC
vmunix                    vmunix.old                
vmunix.new.kernelmap.old  vmunix.org
% ls /vmunix_
.De
If you like to see the types of the files in these lists, like in
\fCls\ -F\fP, you can set the \fILISTTYPES\fP option.  Together with
\fIAUTOLIST\fP you can use \fILISTAMBIGUOUS\fP.  This will only list
the possibilities if there is no unambiguous part to add:
.Ds
% setopt listambiguous
% ls /vmu\fITAB \(embeep\(em\fC
% ls /vmunix_\fITAB \(embeep\(em\fC
vmunix                    vmunix.old                
vmunix.new.kernelmap.old  vmunix.org
.De
If you don't want several of these listings to scroll the screen so
much, the \fIALWAYSLASTPROMPT\fP option is useful.  If set, you can
continue to edit the line you were editing, with the completion
listing appearing beneath it.
.PP
Another interesting option is \fIMENUCOMPLETE\fP.  This affects the
way \fITAB\fP works.  Let's look at the \fC/vmunix\fP example again:
.Ds
% setopt menucomplete
% ls /vmu\fITAB\fC
% ls /vmunix\fITAB\fC
% ls /vmunix.new.kernelmap.old\fITAB\fC
% ls /vmunix.old_
.De
Each time you press \fITAB\fP, it displays the next possible completion.
In this way, you can cycle through the possible completions until
you find the one you want.
.PP
The \fIAUTOMENU\fP option makes a nice compromise between this method
of completion and the regular method.  If you set this option,
pressing \fITAB\fP once completes the unambiguous part normally,
pressing the \fITAB\fP key repeatedly after an ambiguous completion
will cycle through the possible completions.
.PP
Another option you could set is \fIRECEXACT\fP, which causes
exact matches to be accepted, even if there are other possible
completions:
.Ds
% setopt recexact
% ls /vmu\fITAB \(embeep\(em\fC
vmunix                    vmunix.old                
vmunix.new.kernelmap.old  vmunix.org
% ls /vmunix_\fITAB\fC
% ls /vmunix _
.De
To facilitate the typing of pathnames, a slash will be added whenever
a directory is completed.  Some computers don't like the spurious
slashes at the end of directory names.  In that case, the
\fIAUTOREMOVESLASH\fP option comes to rescue.  It will remove these
slashes when you type a space or return after them.
.PP
The \fIfignore\fP variable lists suffixes of files to ignore
during completion.
.Ds
% ls foo\fITAB \(embeep\(em\fC
foofile.c  foofile.o
% fignore=( .o \e~ .bak .junk )
% ls foo\fITAB\fP
% ls foofile.c _
.De
Since \fCfoofile.o\fP has a suffix that is in the \fCfignore\fP list,
it was not considered a possible completion of \fCfoo\fP.
.PP
Username completion is also supported:
.Ds
% ls ~pfal\fITAB\fC
% ls ~pfalstad/_
.De
and parameter name completion:
.Ds
% echo $ORG\fITAB\fC
% echo $ORGANIZATION _
% echo ${ORG\fITAB\fC
% echo ${ORGANIZATION _
.De
Note that in the last example a space is added after the completion as
usual.  But if you want to add a colon or closing brace, you probably
don't want this extra space.  Setting the \fIAUTOPARAMKEYS\fP option
will automatically remove this space if you type a colon or closing
brace after such a completion.
.PP
There is also option completion:
.Ds
% setopt nocl\fITAB\fC
% setopt noclobber _
.De
and binding completion:
.Ds
% bindkey '^X^X' pu\fITAB\fC
% bindkey '^X^X' push-line _
.De
The \fCcompctl\fP command is used to control completion of the
arguments of specific commands.  For example, to specify that certain
commands take other commands as arguments, you use \fCcompctl -c\fP:
.Ds
% compctl -c man nohup
% man upt\fITAB\fC
% man uptime _
.De
To specify that a command should complete filenames, you should use
\fCcompctl -f\fP.  This is the default.  It can be combined with \fC-c\fP,
as well.
.Ds
% compctl -cf echo
% echo upt\fITAB\fC
% echo uptime _

% echo fo\fITAB\fC
% echo foo.c
.De
Similarly, use \fC-o\fP to specify options, \fC-v\fP to specify
variables, and \fC-b\fP to specify bindings.
.Ds
% compctl -o setopt unsetopt
% compctl -v typeset vared unset export
% compctl -b bindkey
.De
You can also use \fC-k\fP to specify a custom list of keywords to use
in completion.  After the \fC-k\fP comes either the name of an array
or a literal array to take completions from.
.Ds
% ftphosts=(ftp.uu.net wuarchive.wustl.edu)
% compctl -k ftphosts ftp
% ftp wu\fITAB\fC
% ftp wuarchive.wustl.edu _

% compctl -k '(cpirazzi subbarao sukthnkr)' mail finger
% finger cp\fITAB\fC
% finger cpirazzi _
.De
To better specify the files to complete for a command, use the
\fC-g\fP option which takes any glob pattern as an argument.  Be sure
to quote the glob patterns as otherwise they will be expanded when the
\fCcompctl\fP command is run.
.Ds
% ls
letter.tex  letter.dvi  letter.aux  letter.log  letter.toc
% compctl -g '*.tex' latex
% compctl -g '*.dvi' xdvi dvips
% latex l\fITAB\fC
% latex letter.tex _
% xdvi l\fITAB\fC
% xdvi letter.dvi _
.De
Glob patterns can include qualifiers within parentheses.  To rmdir
only directories and cd to directories and symbolic links pointing to
them:
.Ds
% compctl -g '*(-/)' cd
% compctl -g '*(/)' rmdir
.De
RCS users like to run commands on files which are not in the current
directory, but in the RCS subdirectory where they all get \fC,v\fP
suffixes.  They might like to use
.Ds
% compctl -g 'RCS/*(:t:s/\e,v//)' co rlog rcs
% ls RCS
builtin.c,v  lex.c,v      zle_main.c,v
% rlog bu\fITAB\fC
% rlog builtin.c _
.De
The \fC:t\fP modifier keeps only the last part of the pathname and the
\fC:s/\e,v//\fP will replace any \fC,v\fP by nothing.
.PP
The \fC-s\fP flag is similar to \fC-g\fP, but it uses all expansions,
instead of just globbing, like brace expansion, parameter substitution
and command substitution.
.Ds
% compctl -s '$(setopt)' unsetopt
.De
will only complete options which are actually set to be arguments to
\fCunsetopt\fP.
.PP
Sometimes a command takes another command as its argument.  You can
tell \fBzsh\fP to complete commands as the first argument to such a
command and then use the completion method of the second command.  The
\fC-l\fP flag with a null-string argument is used for this.
.Ds
% compctl -l '' nohup exec
% nohup comp\fITAB\fC
% nohup compress _
% nohup compress fil\fITAB\fC
% nohup compress filename _
.De
Sometimes you would like to run really complicated commands to find
out what the possible completions are.  To do this, you can specify a
shell function to be called that will assign the possible completions
to a variable called reply.  Note that this variable must be an array.
Here's another (much slower) way to get the completions for \fCco\fP
and friends:
.Ds
% function getrcs {
> reply=()
> for i in RCS/*
>   do
>   reply=($reply[*] $(basename $i ,v))
>   done
> }
% compctl -K getrcs co rlog rcs
.De
Some command arguments use a prefix that is not a part of the things
to complete.  The kill builtin command takes a signal name after a
\fC-\fP.  To make such a prefix be ignored in the completion process,
you can use the \fC-P\fP flag.
.Ds
% compctl -P - -k signals kill
% kill -H\fITAB\fP
% kill -HUP _
.De
TeX is usually run on files ending in \fC.tex\fP, but also sometimes
on other files.  It is somewhat annoying to specify that the arguments
of TeX should end in \fC.tex\fP and then not be able to complete these
other files.  Therefore you can specify things like \*QComplete to
files ending in \fC.tex\fP if available, otherwise complete to any
filename.\*U.  This is done with \fIxor\fPed completion:
.Ds
% compctl -g '*.tex' + -f tex
.De
The \fC+\fP tells the editor to only take the next thing into account
if the current one doesn't generate any matches.  If you have not
changed the default completion, the above example is in fact
equivalent to
.Ds
% compctl -g '*.tex' + tex
.De
as a lone \fC+\fP at the end is equivalent to specifying the default
completion after the \fC+\fP.  This form of completion is also
frequently used if you want to run some command only on a certain type
of files, but not necessarily in the current directory.  In this case
you will want to complete both files of this type and directories.
Depending on your preferences you can use either of
.Ds
% compctl -g '*.ps' + -g '*(-/)' ghostview
% compctl -g '*.ps *(-/)' ghostview
.De
where the first one will only complete directories (and symbolic links
pointing to directories) if no postscript file matches the already
typed part of the argument.
.Sh "Extended completion"
.PP
If you play with completion, you will soon notice that you would like
to specify what to complete, depending on what flags you give to the
command and where you are on the command line.  For example, a command
could take any filename argument after a \fC-f\fP flag, a username
after a \fC-u\fP flag and an executable after a \fC-x\fP flag.  This
section will introduce you to the ways to specify these things.  To
many people it seems rather difficult at first, but taking the trouble
to understand it can save you lots of typing in the end.  Even I keep
being surprised when \fBzsh\fP manages to complete a small or even
empty prefix to the right file in a large directory.
.PP
To tell \fBzsh\fP about these kinds of completion, you use \*Qextended
completion\*U by specifying the \fC-x\fP flag to compctl.  The
\fC-x\fP flag takes a list of patterns/flags pairs.  The patterns
specify when to complete and the flags specify what.  The flags are
simply those mentioned above, like \fC-f\fP or \fC-g \fIglob
pattern\fR.
.PP
As an example, the \fCr[\fIstring1\fC,\fIstring2\fC]\fR pattern
matches if the cursor is after something that starts with
\fIstring1\fP and before something that starts with \fIstring2\fP.
The \fIstring2\fP is often something that you do not want to match
anything at all.
.Ds
% ls
foo1   bar1   foo.Z  bar.Z
% compctl -g '^*.Z' -x 'r[-d,---]' -g '*.Z' -- compress
% compress f\fITAB\fP
% compress foo1 _
% compress -d f\fITAB\fP
% compress -d foo.Z _
.De
In the above example, if the cursor is after the \fC-d\fP the pattern
will match and therefore \fBzsh\fP uses the \fC-g *.Z\fP flag that will only
complete files ending in \fC.Z\fP.  Otherwise, if no pattern matches,
it will use the flags before the \fC-x\fP and in this case complete
every file that does not end in \fC.Z\fP.
.PP
The \fCs[\fIstring\fC]\fR pattern matches if the current word starts
with \fIstring\fP.  The \fIstring\fP itself is not considered to be
part of the completion.
.Ds
% compctl -x 's[-]' -k signals -- kill
% kill -H\fITAB\fP
% kill -HUP _
.De
The \fCtar\fP command takes a tar file as an argument after the
\fC-f\fP option.  The \fCc[\fIoffset\fC,\fIstring\fC]\fR pattern
matches if the word in position \fIoffset\fP relative to the current
word is \fIstring\fP.  More in particular, if \fIoffset\fP is -1, it
matches if the previous word is \fIstring\fP.  This suggests
.Ds
% compctl -f -x 'c[-1,-f]' -g '*.tar' -- tar
.De
But this is not enough.  The \fC-f\fP option could be the last of a
longer string of options.  \fCC[\fR...\fC,\fR...\fC]\fR is just like
\fCc[\fR...\fC,\fR...\fC]\fR, except that it uses glob-like pattern
matching for \fIstring\fP.  So
.Ds
% compctl -f -x 'C[-1,-*f]' -g '*.tar' -- tar
.De
will complete tar files after any option string ending in an \fCf\fP.
But we'd like even more.  Old versions of tar used all options as the
first argument, but without the minus sign.  This might be
inconsistent with option usage in all other commands, but it is still
supported by newer versions of \fCtar\fP.  So we would also like to
complete tar files if the first argument ends in an \fCf\fP and we're
right behind it.
.PP
We can `and' patterns by putting them next to each other with a space
between them.  We can `or' these sets by putting comma's between them.
We will also need some new patterns.  \fCp[\fInum\fC]\fR will match if
the current argument (the one to be completed) is the \fInum\fPth
argument.  \fCW[\fIindex\fC,\fIpattern\fC]\fR will match if the
argument in place \fIindex\fP matches the \fIpattern\fP.  This gives
us
.Ds
% compctl -f -x 'C[-1,-*f] , W[1,*f] p[2]' -g '*.tar' -- tar
.De
In words: If the previous argument is an option string that ends in an
\fCf\fP, or the first argument ended in an \fCf\fP and it is now the
second argument, then complete only filenames ending in \fC.tar\fP.
.PP
All the above examples used only one set of patterns with one
completion flag.  You can use several of these pattern/flag pairs
separated by a \fC-\fP.  The first matching pattern will be used.
Suppose you have a version of \fCtar\fP that supports compressed files
by using a \fC-Z\fP option.  Leaving the old tar syntax aside for a
moment, we would like to complete files ending in \fC.tar.Z\fP if a
\fC-Z\fP option has been used and files ending in \fC.tar\fP
otherwise, all this only after a \fC-f\fP flag.  Again, the \fC-Z\fP
can be alone or it can be part of a longer option string, perhaps the
same as that of the \fC-f\fP flag.  Here's how to do it; note the
backslash and the secondary prompt which are not part of the
\fCcompctl\fP command.
.Ds
% compctl -f -x 'C[-1,-*Z*f] , R[-*Z*,---] C[-1,-*f]' -g '*.tar.Z' - \e
> 'C[-1,-*f]' -g '*.tar' -- tar
.De
The first pattern set tells us to match if either the previous
argument was an option string including a \fCZ\fP and ending in an
\fCf\fP or there was an option string with a \fCZ\fP somewhere and the
previous word was any option string ending in an \fCf\fP.  If this is
the case, we need a compressed tar file.  Only if this is not the case
the second pattern set will be considered.  By the way,
\fCR[\fIpattern1\fC,\fIpattern2\fC]\fR is just like
\fCr[\fR...\fC,\fR...\fC]\fR except that it uses pattern matching with
shell metacharacters instead of just strings.
.PP
You will have noticed the \fC--\fP before the command name.  This ends
the list of pattern/flag pairs of \fC-x\fP.  It is usually used just
before the command name, but you can also use an extended completion
as one part of a list of xored completions, in which case the \fC--\fP
appears just before one of the \fC+\fP signs.
.PP
Note the difference between using extended completion as part of a
list of xored completions as in
.Ds
% ls
foo  bar
% compctl -x 'r[-d,---]' -g '*.Z' -- + -g '^*.Z' compress
% compress -d f\fITAB\fP
% compress -d foo _
.De
and specifying something before the \fC-x\fP as in
.Ds
% compctl -g '^*.Z' -x 'r[-d,---]' -g '*.Z' -- compress
% compress -d f\fITAB\fP
% compress -d f_
.De
In the first case, the alternative glob pattern (\fC^*.Z\fP) will be
used if the first part does not generate any possible completions,
while in the second case the alternative glob pattern will only be
used if the \fCr[\fR...\fC]\fR pattern doesn't match.
.Sh "Bindings"
.PP
Each of the editor commands we have seen was actually a function bound
by default to a certain key.  The real names of the commands are:
.Ds
\fCexpand-or-complete   \fITAB\fR
\fCpush-line            \fIESC-Q\fR
\fCrun-help             \fIESC-H\fR
\fCaccept-and-hold      \fIESC-A\fR
\fCquote-line           \fIESC-'\fR
.De
These bindings are arbitrary; you could change them if you want.
For example, to bind \fCaccept-line\fP to \fI^Z\fP:
.Ds
% bindkey '^Z' accept-line
.De
Another idea would be to bind the delete key to \fCdelete-char\fP;
this might be convenient if you use \fI^H\fP for backspace.
.Ds
% bindkey '^?' delete-char
.De
Or, you could bind \fI^X\fP\fI^H\fP to \fCrun-help\fP:
.Ds
% bindkey '^X^H' run-help
.De
Other examples:
.Ds
% bindkey '^X^Z' universal-argument
% bindkey ' ' magic-space
% bindkey -s '^T' 'uptime
> '
% bindkey '^Q' push-line-or-edit
.De
\fCuniversal-argument\fP multiplies the next command by 4.
Thus \fI^X\fP\fI^Z\fP\fI^W\fP might delete the last four words on the line.
If you bind space to \fCmagic-space\fP, then csh-style history
expansion is done on the line whenever you press the space bar.
.PP
Something that often happens is that I am typing a multiline command
and discover an error in one of the previous lines.  In this case,
\fCpush-line-or-edit\fP will put the entire multiline construct into
the editor buffer.  If there is only a single line, it is equivalent
to \fCpush-line\fP.
.PP
The \fC-s\fP flag to \fCbindkey\fP specifies that you are binding the key
to a string, not a command.  Thus \fCbindkey -s '^T' 'uptime\en'\fP
lets you VMS lovers get the load average whenever you press \fI^T\fP.
.PP
If you have a NeXT keyboard, the one with the \fC|\fP and \fC\e\fP keys
very inconveniently placed, the following
bindings may come in handy:
.Ds
% bindkey -s '\ee/' '\e\e'
% bindkey -s '\ee=' '|'
.De
Now you can type \fIALT-/\fP to get a backslash, and \fIALT-=\fP to
get a vertical bar.  This only works inside \fBzsh\fP, of course;
\fCbindkey\fP has no effect on the key mappings inside \fCtalk\fP
or \fCmail\fP, etc.
.PP
Some people like to bind \fC^S\fP and \fC^Q\fP to editor commands.
Just binding these has no effect, as the terminal will catch them and
use them for flow control.  You could unset them as stop and start
characters, but most people like to use these for external commands.
The solution is to set the \fINOFLOWCONTROL\fP option.  This will
allow you to bind the start and stop characters to editor commands,
while retaining their normal use for external commands.
.Sh "Parameter Substitution"
.PP
In \fBzsh\fP, parameters are set like this:
.Ds
% foo=bar
% echo $foo
bar
.De
Spaces before or after the \fC=\fP are frowned upon:
.Ds
% foo = bar
zsh: command not found: foo
.De
Also, \fCset\fP doesn't work for setting parameters:
.Ds
% set foo=bar
% set foo = bar
% echo $foo

%
.De
Note that no error message was printed.  This is because both
of these commands were perfectly valid; the \fCset\fP builtin
assigns its arguments to the \fIpositional parameters\fP
(\fC$1\fP, \fC$2\fP, etc.).
.Ds
% set foo=bar
% echo $1
foo=bar
% set foo = bar
% echo $3 $2
bar =
.De
If you're really intent on using the csh syntax, define a
function like this:
.Ds
% set () {
>    eval "$1$2$3"
> }
% set foo = bar
% set fuu=brrr
% echo $foo $fuu
bar brrr
.De
But then, of course you can't use the form of \fCset\fP with
options, like \fCset -F\fP (which turns off filename generation).
Also, the \fCset\fP command by itself won't list all the parameters
like it should.
To get around that you need a \fCcase\fP statement:
.Ds
% set () {
>    case $1 in
>    -*|+*|'') builtin set $* ;;
>    *) eval "$1$2$3" ;;
>    esac
> }
.De
For the most part, this should make csh users happy.
.PP
The following sh-style operators are supported in \fBzsh\fP:
.Ds
% unset null
% echo ${foo-xxx}
bar
% echo ${null-xxx}
xxx
% unset null
% echo ${null=xxx}
xxx
% echo $null
xxx
% echo ${foo=xxx}
bar
% echo $foo
bar
% unset null
% echo ${null+set}

% echo ${foo+set}
set
.De
Also, csh-style \fC:\fP modifiers may be appended to a parameter
substitution.
.Ds
% echo $PWD
/home/learning/pf/zsh/zsh2.00/src
% echo $PWD:h
/home/learning/pf/zsh/zsh2.00
% echo $PWD:h:h
/home/learning/pf/zsh
% echo $PWD:t
src
% name=foo.c
% echo $name
foo.c
% echo $name:r
foo
% echo $name:e
c
.De
The equivalent constructs in ksh (which are also supported in \fBzsh\fP)
are a bit more general and easier to remember.
When the shell expands \fC${foo#\fR\fIpat\fR\fC}\fR,
it checks to see if \fIpat\fP matches a substring at the beginning
of the value
of \fCfoo\fP.  If so, it removes that portion of \fCfoo\fP, using the shortest
possible match.
With \fC${foo##\fR\fIpat\fR\fC}\fR, the longest possible match is removed.
\fC${foo%\fR\fIpat\fR\fC}\fR and \fC${foo%%\fR\fIpat\fR\fC}\fR remove the match
from the end.
Here are the ksh equivalents of the \fC:\fP modifiers:
.Ds
% echo ${PWD%/*}
/home/learning/pf/zsh/zsh2.00
% echo ${PWD%/*/*}
/home/learning/pf/zsh
% echo ${PWD##*/}
src
% echo ${name%.*}
foo
% echo ${name#*.}
c
.De
\fBzsh\fP also has upper/lowercase modifiers:
.Ds
% xx=Test
% echo $xx:u
TEST
% echo $xx:l
test
.De
and a substitution modifier:
.Ds
% echo $name:s/foo/bar/
bar.c
% ls
foo.c    foo.h    foo.o    foo.pro
% for i in foo.*; mv $i $i:s/foo/bar/
% ls
bar.c    bar.h    bar.o    bar.pro
.De
There is yet another syntax to modify substituted parameters.  You can
add certain modifiers in parentheses after the opening brace like:
.Ds
${(\fImodifiers\fC)\fIparameter\fC}
.De
For example, \fCo\fP sorts the words resulting from the expansion:
.Ds
% echo ${path}
/usr/bin /usr/bin/X11 /etc
% echo ${(o)path}
/etc /usr/bin /usr/bin/X11
.De
One possible source of confusion is the fact that in \fBzsh\fP,
the result of parameter substitution is \fInot\fP split into
words.  Thus, this will not work:
.Ds
% srcs='glob.c exec.c init.c'
% ls $srcs
glob.c exec.c init.c not found
.De
This is considered a feature, not a bug.
If splitting were done by default, as it is in most other shells,
functions like this would not work properly:
.Ds
$ ll () { ls -F $* }
$ ll 'fuu bar'
fuu not found
bar not found

% ll 'fuu bar'
fuu bar not found
.De
Of course, a hackish workaround is available in sh (and \fBzsh\fP):
.Ds
% setopt shwordsplit
% ll () { ls -F "$@" }
% ll 'fuu bar'
fuu bar not found
.De
If you like the sh behaviour, \fBzsh\fP can accomodate you:
.Ds
% ls ${=srcs}
exec.c  glob.c  init.c
% setopt shwordsplit
% ls $srcs
exec.c  glob.c  init.c
.De
Another way to get the \fC$srcs\fP trick to work is to use an array:
.Ds
% unset srcs
% srcs=( glob.c exec.c init.c )  
% ls $srcs
exec.c  glob.c  init.c
.De
or an alias:
.Ds
% alias -g SRCS='exec.c glob.c init.c'
% ls SRCS
exec.c  glob.c  init.c
.De
Another option that modifies parameter expansion is
\fIRCEXPANDPARAM\fP:
.Ds
% echo foo/$srcs
foo/glob.c exec.c init.c
% setopt rcexpandparam
% echo foo/$srcs
foo/glob.c foo/exec.c foo/init.c
% echo foo/${^srcs}
foo/glob.c foo/exec.c foo/init.c
% echo foo/$^srcs
foo/glob.c foo/exec.c foo/init.c
.De
.Sh "Shell Parameters"
.PP
The shell has many predefined parameters that may be
accessed.  Here are some examples:
.Ds
% sleep 10 &
[1] 3820
% echo $!
3820
% set a b c
% echo $#
3
% echo $ARGC
3
% ( exit 20 ) ; echo $?
20
% false; echo $status
1
.De
(\fC$?\fP and \fC$status\fP are equivalent.)
.Ds
% echo $HOST $HOSTTYPE
dendrite sun4
% echo $UID $GID
701 60
% cd /tmp
% cd /home
% echo $PWD $OLDPWD
/home /tmp
% ls $OLDPWD/.getwd 
/tmp/.getwd
.De
\fC~+\fP and \fC~-\fP are short for \fC$PWD\fP and \fC$OLDPWD\fP, respectively.
.Ds
% ls ~-/.getwd
/tmp/.getwd
% ls -d ~+/learning
/home/learning
% echo $RANDOM
4880
% echo $RANDOM
11785
% echo $RANDOM
2062
% echo $TTY
/dev/ttyp4
% echo $VERSION
zsh v2.00.03
% echo $USERNAME
pf
.De
.PP
The \fCcdpath\fP variable sets the search path for the \fCcd\fP command.
If you do not specify \fC.\fP somewhere in the path, it is assumed to
be the first component.
.Ds
% cdpath=( /usr ~ ~/zsh )
% ls /usr
5bin         dict         lang         net          sccs         sys
5include     etc          lector       nserve       services     tmp
5lib         export       lib          oed          share        ucb
adm          games        local        old          skel         ucbinclude
bin          geac         lost+found   openwin      spool        ucblib
boot         hosts        macsyma_417  pat          src          xpg2bin
demo         include      man          princeton    stand        xpg2include
diag         kvm          mdec         pub          swap         xpg2lib
% cd spool
/usr/spool
% cd bin
/usr/bin
% cd func
~/func
% cd 
% cd pub
% pwd
/u/pfalstad/pub
% ls -d /usr/pub
/usr/pub
.De
\fBPATH\fP and \fBpath\fP both set the search path for commands.
These two variables are equivalent, except that one is a string
and one is an array.  If the user modifies \fBPATH\fP, the shell
changes \fBpath\fP as well, and vice versa.
.Ds
% PATH=/bin:/usr/bin:/tmp:.
% echo $path
/bin /usr/bin /tmp .
% path=( /usr/bin . /usr/local/bin /usr/ucb )
% echo $PATH
/usr/bin:.:/usr/local/bin:/usr/ucb
.De
The same is true of \fBCDPATH\fP and \fBcdpath\fP:
.Ds
% echo $CDPATH
/usr:/u/pfalstad:/u/pfalstad/zsh
% CDPATH=/u/subbarao:/usr/src:/tmp
% echo $cdpath
/u/subbarao /usr/src /tmp
.De
In general, predefined parameters with names in all lowercase are
arrays; assignments to them take the form:
.Ds
\fIname\fR\fC=(\fR \fIelem\fR ...\ \fC)\fR
.De
Predefined parameters with names in all uppercase are strings.  If
there is both an array and a string version of the same parameter, the
string version is a colon-separated list, like \fBPATH\fP.
.PP
\fBHISTFILE\fP is the name of the history file, where the history
is saved when a shell exits.
.Ds
% zsh
phoenix% HISTFILE=/tmp/history
phoenix% SAVEHIST=20
phoenix% echo foo
foo
phoenix% date
Fri May 24 05:39:35 EDT 1991
phoenix% uptime
  5:39am  up 4 days, 20:02,  40 users,  load average: 2.30, 2.20, 2.00
phoenix% exit
% cat /tmp/history
HISTFILE=/tmp/history
SAVEHIST=20
echo foo
date
uptime
exit
% HISTSIZE=3
% history
   28  rm /tmp/history
   29  HISTSIZE=3
   30  history
.De
If you have several incantations of \fBzsh\fP running at the same
time, like when using the X window system, it might be preferable to
append the history of each shell to a file when a shell exits instead
of overwriting the old contents of the file.  You can get this
behaviour by setting the \fIAPPENDHISTORY\fP option.
.PP
In \fBzsh\fP, if you say
.Ds
% >file
.De
the command \fCcat\fP is normally assumed:
.Ds
% >file
foo!    
^D
% cat file
foo!
.De
Thus, you can view a file simply by typing:
.Ds
% <file
foo!
.De
However, this is not csh or sh compatible.  To correct this,
change the value of the parameter \fBNULLCMD\fP,
which is \fCcat\fP by default.
.Ds
% NULLCMD=:
% >file
% ls -l file
-rw-r--r--  1 pfalstad        0 May 24 05:41 file
.De
If \fCNULLCMD\fP is unset, the shell reports an error if no
command is specified (like csh).
.Ds
% unset NULLCMD
% >file
zsh: redirection with no command
.De
Actually, \fBREADNULLCMD\fP is used whenever you have a null command
reading input from a single file.  Thus, you can set \fBREADNULLCMD\fP
to \fCmore\fP or \fCless\fP rather than \fCcat\fP.  Also, if you
set \fBNULLCMD\fP to \fC:\fP for sh compatibility, you can still read
files with \fC< file\fP if you leave \fBREADNULLCMD\fP set to \fCmore\fP.
.Sh "Prompting"
.PP
The default prompt for \fBzsh\fP is:
.Ds
phoenix% echo $PROMPT
%m%# 
.De
The \fC%m\fP stands for the short form of the current hostname,
and the \fC%#\fP stands for a \fC%\fP or a \fC#\fP, depending on whether
the shell is running as root or not.
\fBzsh\fP supports many other control sequences
in the \fBPROMPT\fP variable.
.Ds
% PROMPT='%/> '
/u/pfalstad/etc/TeX/zsh>

% PROMPT='%~> '   
~/etc/TeX/zsh> 

% PROMPT='%h %~> '
6 ~/etc/TeX/zsh> 
.De
\fC%h\fP represents the number of current history event.
.Ds
% PROMPT='%h %~ %M> '
10 ~/etc/TeX/zsh apple-gunkies.gnu.ai.mit.edu> 

% PROMPT='%h %~ %m> '
11 ~/etc/TeX/zsh apple-gunkies> 

% PROMPT='%h %t> '
12 6:11am> 

% PROMPT='%n %w tty%l>'
pfalstad Fri 24 ttyp0>
.De
\fBPROMPT2\fP is used in multiline commands, like for-loops.  The
\fC%_\fP escape sequence was made especially for this prompt.  It is
replaced by the kind of command that is being entered.
.Ds
% PROMPT2='%_> '
% for i in foo bar
for>

% echo 'hi
quote>
.De
Also available is the \fBRPROMPT\fP parameter.
If this is set, the shell puts a prompt on the \fIright\fP side
of the screen.
.Ds
% RPROMPT='%t'
%                                                      6:14am

% RPROMPT='%~'
%                                               ~/etc/TeX/zsh

% PROMPT='%l %T %m[%h] ' RPROMPT=' %~'
p0 6:15 phoenix[5]                              ~/etc/TeX/zsh
.De
These special escape sequences can also be used with the
\fC-P\fP option to \fCprint\fP:
.Ds
% print -P %h tty%l
15 ttyp1
.De
.PP
The \fBPOSTEDIT\fP parameter is printed whenever the editor exits.
This can be useful for termcap tricks.  To highlight the prompt
and command line while leaving command output unhighlighted, try this:
.Ds
% POSTEDIT=`echotc se`
% PROMPT='%S%% '
.De
.Sh "Login/logout watching"
.PP
You can specify login or logout events to monitor
by setting the \fBwatch\fP variable.
Normally, this is done by specifying a list of usernames.
.Ds
% watch=( pfalstad subbarao sukthnkr egsirer )
.De
The \fClog\fP command reports all people logged in
that you are watching for.
.Ds
% log
pfalstad has logged on p0 from mickey.
pfalstad has logged on p5 from mickey.
% \fR...\fC
subbarao has logged on p8 from phoenix.
% \fR...\fC
subbarao has logged off p8 from phoenix.
% \fR...\fC
sukthnkr has logged on p8 from dew.
% \fR...\fC
sukthnkr has logged off p8 from dew.
.De
If you specify hostnames with an \fC@\fP prepended,
the shell will watch for all users logging in from
the specified host.
.Ds
% watch=( @mickey @phoenix )
% log
djthongs has logged on q2 from phoenix.
pfalstad has logged on p0 from mickey.
pfalstad has logged on p5 from mickey.
.De
If you give a tty name with a \fC%\fP prepended, the shell
will watch for all users logging in on that tty.
.Ds
% watch=( %ttyp0 %console )
% log
root has logged on console from .
pfalstad has logged on p0 from mickey.
.De
The format of the reports may also be changed.
.Ds
% watch=( pfalstad gettes eps djthongs jcorr bdavis )
% log
jcorr has logged on tf from 128.112.176.3:0.
jcorr has logged on r0 from 128.112.176.3:0.
gettes has logged on p4 from yo:0.0.
djthongs has logged on pe from grumpy:0.0.
djthongs has logged on q2 from phoenix.
bdavis has logged on qd from BRUNO.
eps has logged on p3 from csx30:0.0.
pfalstad has logged on p0 from mickey.
pfalstad has logged on p5 from mickey.
% WATCHFMT='%n on tty%l from %M'
% log
jcorr on ttytf from 128.112.176.3:0.
jcorr on ttyr0 from 128.112.176.3:0.
gettes on ttyp4 from yo:0.0
djthongs on ttype from grumpy:0.0
djthongs on ttyq2 from phoenix.Princeto
bdavis on ttyqd from BRUNO.pppl.gov
eps on ttyp3 from csx30:0.0
pfalstad on ttyp0 from mickey.Princeton
pfalstad on ttyp5 from mickey.Princeton
% WATCHFMT='%n fm %m'
% log
jcorr fm 128.112.176.3:0
jcorr fm 128.112.176.3:0
gettes fm yo:0.0
djthongs fm grumpy:0.0
djthongs fm phoenix
bdavis fm BRUNO
eps fm csx30:0.0
pfalstad fm mickey
pfalstad fm mickey
% WATCHFMT='%n %a at %t %w.'
% log
jcorr logged on at 3:15pm Mon 20.
jcorr logged on at 3:16pm Wed 22.
gettes logged on at 6:54pm Wed 22.
djthongs logged on at 7:19am Thu 23.
djthongs logged on at 7:20am Thu 23.
bdavis logged on at 12:40pm Thu 23.
eps logged on at 4:19pm Thu 23.
pfalstad logged on at 3:39am Fri 24.
pfalstad logged on at 3:42am Fri 24.
.De
If you have a \fC.friends\fP file in your home directory,
a convenient way to make \fBzsh\fP watch for all your friends
is to do this:
.Ds
% watch=( $(< ~/.friends) )
% echo $watch
subbarao maruchck root sukthnkr \fR...
.De
If watch is set to \fCall\fP, then all users logging in or out
will be reported.
.Sh "Options"
.PP
Some options have already been mentioned; here are a few more:
.PP
Using the \fIAUTOCD\fP option, you can simply type the name
of a directory, and it will become the current directory.
.Ds
% cd /
% setopt autocd
% bin
% pwd
/bin
% ../etc
% pwd
/etc
.De
With \fICDABLEVARS\fP, if the argument to \fCcd\fP is the name of a
parameter whose value is a valid directory, it will become
the current directory.
.Ds
% setopt cdablevars
% foo=/tmp
% cd foo
/tmp
.De
\fICORRECT\fP turns on spelling correction for commands,
and the \fICORRECTALL\fP option turns on spelling correction
for all arguments.
.Ds
% setopt correct
% sl
zsh: correct `sl' to `ls' [nyae]? y
% setopt correctall
% ls x.v11r4
zsh: correct `x.v11r4' to `X.V11R4' [nyae]? n
/usr/princton/src/x.v11r4 not found
% ls /etc/paswd
zsh: correct to `/etc/paswd' to `/etc/passwd' [nyae]? y
/etc/passwd
.De
If you press \fCy\fP
when the shell asks you if you want to correct a word, it will
be corrected.  If you press \fCn\fP, it will be left alone.
Pressing \fCa\fP aborts the command, and pressing \fCe\fP brings the line
up for editing again, in case you agree the word is spelled wrong
but you don't like the correction.
.PP
Normally, a quoted expression may contain a newline:
.Ds
% echo '
> foo
> '

foo

%
.De
With \fICSHJUNKIEQUOTES\fP set, this is illegal, as it is
in csh.
.Ds
% setopt cshjunkiequotes
% ls 'foo
zsh: unmatched '
.De
\fIGLOBDOTS\fP lets files beginning with a \fC.\fP be matched without
explicitly specifying the dot.
.Ds
% ls -d *x*
Mailboxes
% setopt globdots
% ls -d *x*
\&.exrc         .pnewsexpert  .xserverrc
\&.mushexpert   .xinitrc      Mailboxes
.De
\fIHISTIGNOREDUPS\fP prevents the current line from being
saved in the history if it is the same as the previous one;
\fIHISTIGNORESPACE\fP prevents the current line from being
saved if it begins with a space.
.Ds
% PROMPT='%h> '
39> setopt histignoredups
40> echo foo
foo
41> echo foo
foo
41> echo foo
foo
41> echo bar
bar
42> setopt histignorespace
43>  echo foo
foo
43>  echo fubar
fubar
43>  echo fubar
fubar
.De
\fIIGNOREBRACES\fP turns off csh-style brace expansion.
.Ds
% echo x{y{z,a},{b,c}d}e
xyze xyae xbde xcde
% setopt ignorebraces
% echo x{y{z,a},{b,c}d}e
x{y{z,a},{b,c}d}e
.De
\fIIGNOREEOF\fP forces the user to type \fCexit\fP or \fClogout\fP,
instead of just pressing \fI^D\fP.
.Ds
% setopt ignoreeof
% ^D
zsh: use 'exit' to exit.
.De
\fIINTERACTIVECOMMENTS\fP turns on interactive comments;
comments begin with a \fC#\fP.
.Ds
% setopt interactivecomments
% date # this is a comment
Fri May 24 06:54:14 EDT 1991
.De
\fINOBEEP\fP makes sure the shell never beeps.
.PP
\fINOCLOBBER\fP prevents you from accidentally
overwriting an existing file.
.Ds
% setopt noclobber
% cat /dev/null >~/.zshrc
zsh: file exists: /u/pfalstad/.zshrc
.De
If you really do want to clobber a file, you can use the
\fC>!\fP operator.
To make things easier in this case, the \fC>\fP is stored in
the history list as a \fC>!\fP:
.Ds
% cat /dev/null >! ~/.zshrc
% cat /etc/motd > ~/.zshrc
zsh: file exists: /u/pfalstad/.zshrc
% !!
cat /etc/motd >! ~/.zshrc
% \fR...
.De
\fIRCQUOTES\fP lets you use a more elegant method for including
single quotes in a singly quoted string:
.Ds
% echo '"don'\e''t do that."'
"don't do that."
% echo '"don''t do that."'
"dont do that."
% setopt rcquotes
% echo '"don''t do that."'
"don't do that."
.De
Finally,
\fISUNKEYBOARDHACK\fP wins the award for the strangest option.
If a line ends with \fC`\fP, and there are an odd number of them
on the line, the shell will ignore the trailing \fC`\fP.  This
is provided for keyboards whose RETURN key is too small,
and too close to the \fC`\fP key.
.Ds
% setopt sunkeyboardhack
% date`
Fri May 24 06:55:38 EDT 1991
.De
.Sh "Closing Comments"
.PP
I (Bas de Bakker) would be happy to receive mail if anyone has any
tricks or ideas to add to this document, or if there are some points
that could be made clearer or covered more thoroughly.  Please notify
me of any errors in this document.
.bp
.PX
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            .       ..      zcomp Ê     zlogin      zshenv     ∏zshrc Ê                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \input texinfo.tex @c -*- texinfo -*-
@c %**start of header
@setfilename zsh.info
@settitle    zsh
@c %**end of header

@setchapternewpage on
@iftex
@finalout
@end iftex

@ifinfo
This is a texinfo version of the man page for the Z Shell, originally by Paul
Falstad.  It was converted from the @code{zsh.1} file
distributed with zsh v2.5.0.  The conversion was done by Jonathan
Hardwick, @code{jch@@cs.cmu.edu}, who would love to hear of any errors
he introduced or texinfo rules he broke.  The text remains the work of
Paul Falstad.@refill
@end ifinfo

@titlepage
@sp 4
@center @titlefont{The Z Shell}
@sp 2
@center Originally by Paul Falstad
@center pf@@z-code.com
@sp 2
@center 30 December 1993
@page
@vskip 0pt plus 1filll
This is a texinfo version of the man page for the Z Shell, by Paul
Falstad.  It was converted from the original @code{zsh.1} file
distributed with zsh v2.5.0.  The conversion was done by Jonathan
Hardwick, @code{jch@@cs.cmu.edu}, who would love to hear of any errors
he introduced or texinfo rules he broke.  The text remains the work of
Paul Falstad.
@end titlepage

@node Top, Shell Grammar, (dir), (dir)
@c @top zsh

@menu
* Shell Grammar::		
* Expansion::			
* Redirection::			
* Command Execution::		
* Functions::			
* Jobs & Signals::		
* History::			
* Arithmetic Evaluation::	
* Conditional Expressions::	
* Zsh Line Editor::		
* Parameters::			
* Options::			
* Shell Builtin Commands::	
* Invocation::			
* Wrapping Up::			

 --- Indices ---

* Concept Index::		
* Variables Index::             
* Options Index::               
* Functions Index::             
* Editor Functions Index::      
* Keystroke Index::             

 --- The Detailed Node Listing ---

Shell Grammar

* Simple Commands & Pipelines:: 
* Complex Commands::            
* Reserved Words::              
* Comments::                    
* Aliasing::                    
* Quoting::                     

Expansion

* Filename Expansion::          
* Process Substitution::        
* Parameter Expansion::         
* Command Substitution::        
* Arithmetic Expansion::        
* Brace Expansion::             
* Filename Generation::         

History

* Event Designators::           
* Word Designators::            
* Modifiers::                   

Zsh Line Editor

* Movement::                    
* History Control::             
* Modifying Text::              
* Arguments::                   
* Completion::                  
* Miscellaneous::               

Parameters

* Array Parameters::            
* Positional Parameters::       
* Parameters Set By The Shell::  
* Parameters Used By The Shell::  

Wrapping Up
@end menu

@node Shell Grammar, Expansion, Top, Top
@chapter Shell Grammar
@cindex shell grammar
@cindex grammar, shell

@menu
* Simple Commands & Pipelines::	 
* Complex Commands::		
* Reserved Words::		
* Comments::			
* Aliasing::			
* Quoting::			
@end menu

@node Simple Commands & Pipelines, Complex Commands,  , Shell Grammar
@section Simple Commands
@cindex simple commands
@cindex commands, simple

@noindent
A @dfn{simple command} is a sequence of optional parameter assignments
followed by blank-separated words, with optional redirections
interspersed.  The first word is the command to be executed, and the
remaining words, if any, are arguments to the command.  If a command
name is given, the parameter assignments modify the environment of the
command when it is executed.  The value of a simple command is its exit
status, or 128 plus the signal number if terminated by a signal.@refill

@findex exec
@findex command
@findex noglob
@findex nocorrect
@noindent
If a simple command is preceded by the word @code{exec}, it is executed
in the parent shell without forking.  If preceded by @code{command}, the
command word is taken to be the name of an external command, rather than
a shell function or builtin.  If preceded by @code{noglob}, filename
generation is not performed on any of the words.  If preceded by a
@code{-}, the command is executed with a @code{-} prepended to its
@code{argv[0]} string.  If preceded by @code{nocorrect}, spelling
correction is not done on any of the words.@refill

@cindex pipeline
@noindent
A @dfn{pipeline} is a sequence of one or more commands separated by
@code{|} or @code{|&}.  @code{|&} is shorthand for @code{2>&1 |}.  The
standard output of each command is connected to the standard input of
the next command in the pipeline.@refill

@cindex pipeline, value of
@noindent
The value of a pipeline is the value of the last command.  If a pipeline
is preceded by a @code{!}, the value of that pipeline is the logical NOT
of the value of the last command.@refill

@findex coproc
@cindex coprocesses
@noindent
If a pipeline is preceded by @code{coproc}, it is executed as a
coprocess; a two-way pipe is established between it and the parent
shell.  The shell can read from or write to the coprocess by means of
the @code{>&p} and @code{<&p} redirection operators.@refill

@cindex sublist
@noindent
A @dfn{sublist} is a sequence of one or more pipelines separated by
@code{&&} or @code{||}.  If two pipelines are separated by @code{&&},
the second pipeline is executed only if the first is successful (returns
a zero value).  If two pipelines are separated by @code{||}, the second
is executed only if the first is unsuccessful (returns a nonzero
value).  Both operators have equal precedence and are left 
associative.@refill

@cindex list
@noindent
A @dfn{list} is a sequence of one or more sublists separated by, and
optionally terminated by, @code{;}, @code{&}, or a newline.  Normally
the shell waits for each list to finish before executing the next one.
If a list is terminated by a @code{&}, the shell executes it in the
background, and does not wait for it to finish.@refill

@node Complex Commands, Reserved Words, Simple Commands & Pipelines, Shell Grammar
@section Complex Commands
@cindex complex commands
@cindex commands, complex

@noindent
A @dfn{complex command} is one of the following:

@table @code
@cindex for loops
@cindex loops, for
@findex for
@item for @var{name} [ in @var{word} @dots{} ]
@itemx do @var{list}
@itemx done
Expand the list of @var{word}s, and set the parameter @var{name} to each
of them in turn, executing @var{list} each time.  If the @code{in
@var{word}} is omitted, use the positional parameters instead of the
@var{word}s.@refill

@item for @var{name} [ in @var{word} @dots{} ] ; @var{sublist}
This is a shorthand for @code{for}.  Though it may cause confusion, it
is included for convenience; its use in scripts is discouraged, unless
@var{sublist} is a command of the form @{ @var{list} @}.@refill

@findex foreach
@item foreach @var{name} ( @var{word} @dots{} )
@itemx @var{list}
@itemx end
Another form of @code{for}.

@item for @var{name} in @var{word} @dots{}
@itemx @{
@itemx @var{list}
@itemx @}
Another form of @code{for}.

@item for @var{name} ( @var{word} @dots{} ) @{
@itemx @var{list}
@itemx @}
Another form of @code{for}; this requires the option
@code{CSH_JUNKIE_PAREN}.@refill

@item for @var{name} ( @var{word} @dots{} ) @var{sublist}
Another form of @code{for}; this also requires
@code{CSH_JUNKIE_PAREN}.@refill

@cindex selection, user
@cindex user selection
@findex select
@item select @var{name} [ in @var{word} @dots{} ]
@itemx do @var{list}
@itemx done
Print the set of @var{word}s, each preceded by a number.  If the
@code{in @var{word}} is omitted, use the positional parameters.  The
@code{PROMPT3} prompt is printed and a line is read from standard input.
If this line consists of the number of one of the listed @var{word}s,
then the parameter @var{name} is set to the @var{word} corresponding to
this number.  If this line is empty, the selection list is printed
again.  Otherwise, the value of the parameter @var{name} is set to null.
The contents of the line read from standard input is saved in the
parameter @code{REPLY}.  @var{list} is executed for each selection until
a break or end-of-file is encountered.@refill

@item select @var{name} [ in @var{word} ] ; @var{sublist}
A short form of @code{select}.

@findex case
@cindex case selection
@cindex selection, case
@item case @var{word} in [ @var{pattern} ) @var{list} ;; ] @dots{} esac
Execute the @var{list} associated with the first @var{pattern} that
matches @var{word}, if any.  The form of the patterns is the same as
that used for filename generation.  @xref{Filename Generation}.@refill

@item case @var{word} @{ [ @var{pattern} ) @var{list} ;; ] @dots{} @}
Another form of @code{case}.

@findex if
@cindex if construct
@item if @var{list}
@itemx then @var{list}
@itemx [ elif @var{list} ; then @var{list} ] @dots{}
@itemx [ else @var{list} ]
@itemx fi
The @code{if @var{list}} is executed, and, if it returns a zero exit
status, the @code{then @var{list}} is executed.  Otherwise, the
@code{elif @var{list}} is executed and, if its value is zero, the
@code{then @var{list}} is executed.  If each @code{elif @var{list}}
returns nonzero, the @code{else @var{list}} is executed.@refill

@item if ( @var{list} ) @var{sublist}
A short form of @code{if}; this requires the option
@code{CSH_JUNKIE_PAREN}.@refill

@item if ( @var{list} ) @{
@itemx @var{list}
@itemx @} elif ( @var{list} ) @{
@itemx @var{list}
@itemx @} @dots{} else @{
@itemx @var{list}
@itemx @}
An alternate form of @code{if}.  The parentheses surrounding @var{list}
can be omitted if the only command in the list is a conditional
expression of the form @code{[[ @var{exp} ]]}.  @xref{Conditional
Expressions}.  This form also requires @code{CSH_JUNKIE_PAREN}.@refill

@findex while
@cindex while loops
@cindex loops, while
@item while @var{list}
@itemx do @var{list}
@itemx done
Execute the @code{do @var{list}} as long as the @code{while @var{list}}
returns a zero exit status.@refill

@item while ( @var{list} ) @{
@itemx @var{list}
@itemx @}
An alternate form of @code{while}; this requires the option
@code{CSH_JUNKIE_PAREN}.@refill

@findex until
@cindex until loops
@cindex loops, until
@item until @var{list}
@itemx do @var{list}
@itemx done
Execute the @code{do @var{list}} as long as the @code{until @var{list}}
returns a nonzero exit status.@refill

@findex repeat
@cindex repeat loops
@cindex loops, repeat
@item repeat @var{word}
@itemx do @var{list}
@itemx done
@var{word} is expanded and treated as an arithmetic expression, which
must evaluate to a number @var{n}.  @var{list} is then executed @var{n}
times.@refill

@item repeat @var{word} @var{sublist}
This is a short form of @code{repeat}.

@cindex subshells
@item ( @var{list} )
Execute @var{list} in a subshell.

@item @{ @var{list} @}
Execute @var{list}.

@item function @var{word} [ () ] @dots{} @{ @var{list} @}
@itemx @var{word} @dots{} () @{ @var{list} @}
@itemx @var{word} @dots{} () @var{sublist}
Define a function which is referenced by any one of @var{word}.
Normally, only one @var{word} is provided; multiple @var{word}s are
usually only useful for setting traps.  The body of the function is the
@var{list} between the @code{@{} and @code{@}}.
@xref{Functions}.@refill

@cindex timing
@item time [ @var{pipeline} ]
The @var{pipeline} is executed, and timing statistics are reported on
the standard error in the form specified by the @code{TIMEFMT}
parameter.  If @var{pipeline} is omitted, print statistics about the
shell process and its children.@refill

@cindex testing conditional expression
@item [[ @var{exp} ]]
Evaluates the conditional expression @var{exp} and return a zero exit
status if it is true.  @xref{Conditional Expressions}, for a description
of @var{exp}.@refill
@end table

@node Reserved Words, Comments, Complex Commands, Shell Grammar
@section Reserved Words
@cindex reserved words

@findex unalias, use of
@noindent
The following words are recognized as @dfn{reserved words} when used as
the first word of a command unless quoted or removed using the
@code{unalias} builtin:@refill

@noindent
@code{do} @code{done} @code{esac} @code{then} @code{elif} @code{else}
@code{fi} @code{for} @code{case} @code{if} @code{while} @code{function}
@code{repeat} @code{time} @code{until} @code{exec} @code{command}
@code{select} @code{coproc} @code{noglob} @code{-} @code{nocorrect}
@code{foreach} @code{end} @refill

@node Comments, Aliasing, Reserved Words, Shell Grammar
@section Comments
@cindex comments

@vindex HISTCHARS, use of
@pindex INTERACTIVE_COMMENTS, use of
@noindent
In noninteractive shells, or in interactive shells with the
@code{INTERACTIVE_COMMENTS} option set, a word beginning with the third
character of the @code{HISTCHARS} parameter (@code{#} by default) causes
that word and all the following characters up to a newline to be
ignored.@refill

@node Aliasing, Quoting, Comments, Shell Grammar
@section Aliasing
@cindex aliasing

@findex alias, use of
@cindex aliases, global
@noindent
Every token in the shell input is checked to see if there is an alias
defined for it.  If so, it is replaced by the text of the alias if it is
in command position (if it could be the first word of a simple command),
or if the alias is global.  If the text ends with a space, the next word
in the shell input is treated as though it were in command position for
purposes of alias expansion.  An alias is defined using the @code{alias}
builtin; global aliases may be defined using the @code{-g} option to
that builtin.@refill

@noindent
Alias substitution is done on the shell input before any other
substitution except history substitution.  Therefore, if an alias is
defined for the word @samp{foo}, alias substitution may be avoided by
quoting part of the word, e.g.@: @samp{\foo}.  But there is nothing to
prevent an alias being defined for @samp{\foo} as well.@refill

@node Quoting,  , Aliasing, Shell Grammar
@section Quoting
@cindex quoting

@noindent
A character may be @dfn{quoted} (that is, made to stand for itself) by
preceding it with a @code{\}.  @code{\} followed by a newline is
ignored.  All characters enclosed between a pair of single quotes
@ifinfo
(@code{@'@'}) are quoted, except the first character of @code{HISTCHARS}
@end ifinfo
@iftex
(@code{''}) are quoted, except the first character of @code{HISTCHARS}
@end iftex
(@code{!} by default).  A single quote cannot appear within single
quotes.  Inside double quotes (@code{""}), parameter and command
substitution occurs, and @code{\} quotes the characters @code{\},
@code{`}, @code{"}, and @code{$}. @refill

@node Expansion, Redirection, Shell Grammar, Top
@chapter Expansion
@cindex expansion

@noindent
Expansion is performed on the command line after it has been parsed.
The types of expansions performed are @dfn{filename expansion},
@dfn{process substitution}, @dfn{parameter expansion}, @dfn{command
substitution}, @dfn{arithmetic expansion}, @dfn{brace expansion}, and
@dfn{filename generation}.@refill

@menu
* Filename Expansion::		
* Process Substitution::	
* Parameter Expansion::		
* Command Substitution::	
* Arithmetic Expansion::	
* Brace Expansion::		
* Filename Generation::		
@end menu

@node Filename Expansion, Process Substitution,  , Expansion
@section Filename Expansion
@cindex filename expansion
@cindex expansion, filename

@noindent
Each word is checked to see if it begins with an unquoted @code{~}.  If
it does, then the word up to a @code{/} is checked to see if it matches
the name of a named directory.  If so, then the @code{~} and the matched
portion are replaced with the value of the named directory.  A @code{~}
by itself or followed by a @code{/} is replaced by the value of the
@code{HOME} parameter.  A @code{~} followed by a @code{+} or a @code{-}
is replaced by the value of @code{PWD} or @code{OLDPWD},
respectively.@refill

@cindex directories, named
@cindex named directories
@noindent
Named directories are typically login directories for users on the
system.  They may also be defined if the text after the @code{~} is the
name of a string shell parameter whose value begins with a @code{/}.  In
certain circumstances (in prompts, for instance), when the shell prints
a path, the path is checked to see if it has a named directory as its
prefix.  If so, then the prefix portion is replaced with a @code{~}
followed by the name of the directory.  The longest match is
preferred.@refill

@noindent
If a word begins with an unquoted @code{=} and the @code{NO_EQUALS}
option is not set, the remainder of the word is taken as the name of a
command or alias.  If a command exists by that name, the word is
replaced by the full pathname of the command.  If an alias exists by
that name, the word is replaced with the text of the alias.  Otherwise
the word is checked up to a @code{/} to see if it is a number or a
@code{-}.  If so, the matched portion is replaced with the @var{n}'th
directory in the directory stack, where @var{n} is the number matched,
or the last directory in the directory stack if a @code{-} is
matched.@refill

@noindent
Filename expansion is performed on the right hand side of a parameter
assignment, including those appearing after commands of the
@code{typeset} family.  In this case, the right hand side will be
treated as a colon-separated list in the manner of @code{PATH}, so that
a @code{~} or @code{=} following a @code{:} is eligible for expansion.
All such behaviour can be disabled by quoting the @code{~}, @code{=}, or
the whole expression (but not simply the colon); the @code{NO_EQUALS}
option is also respected.@refill

@noindent
If the option @code{MAGIC_EQUAL_SUBST} is set, any unquoted shell
argument of the form @code{@var{identifier}=@var{expression}} becomes
eligible for file expansion as described in the previous paragraph.
Quoting the first @code{=} also inhibits this.@refill

@node Process Substitution, Parameter Expansion, Filename Expansion, Expansion
@section Process Substitution
@cindex process substitution
@cindex substitution, process

@noindent
Each command argument of the form @code{<(@var{list})},
@code{>(@var{list})} or @code{=(@var{list})} is subject to process
substitution.  In the case of the @code{<} and @code{>} forms, the shell
will run process @var{list} asynchronously, connected to a named pipe
(FIFO).  The name of this pipe will become the argument to the command.
If the form with @code{>} is selected then writing to this file will
provide input for @var{list}.  If @code{<} is used, then the file passed
as an argument will be a named pipe connected to the output of the
@var{list} process.  For example,@refill

@code{paste <(cut -f1 @var{file1}) <(cut -f3 @var{file2}) | tee >(@var{process1}) >(@var{process2}) >/dev/null}

@noindent
@code{cut}s fields 1 and 3 from the files @var{file1} and @var{file2}
respectively, @code{paste}s the results together, and sends it to the
processes @var{process1} and @var{process2}.  Note that the file, which
is passed as an argument to the command, is a system pipe so programs
that expect to @code{lseek(2)} on the file will not work.  Also note
that the previous example can be more compactly and efficiently written
as:@refill

@code{paste <(cut -f1 @var{file1}) <(cut -f3 @var{file2}) >>(@var{process1}) >>(@var{process2})}

@noindent
The shell uses pipes instead of FIFOs to implement the latter two
process substitutions in the above example.

@cindex temporary files
@cindex files, temporary
@noindent
If @code{=} is used, then the file passed as an argument will be the name
of a temporary file containing the output of the @var{list} process.
This may be used instead of the @code{<} form for a program that expects
to @code{lseek(2)} on the input file.@refill

@node Parameter Expansion, Command Substitution, Process Substitution, Expansion
@section Parameter Expansion
@cindex parameter expansion
@cindex expansion, parameter

@noindent
The character @code{$} is used to introduce parameter expansions.
@xref{Parameters}, for a description of parameters.@refill

@table @code
@item $@{@var{name}@}
The value, if any, of the parameter @var{name} is substituted.  The
braces are required if @var{name} is followed by a letter, digit, or
underscore that is not to be interpreted as part of its name.  If
@var{name} is an array parameter, then the values of each element of
@var{name} is substituted, one element per word.  Otherwise, the
expansion results in one word only; no word splitting is done on the
result.@refill

@item $@{+@var{name}@}
If @var{name} is the name of a set parameter, then substitute 1,
otherwise substitute 0.@refill

@item $@{@var{name}:-@var{word}@}
If @var{name} is set and is non-null then substitute its value;
otherwise substitute @var{word}.@refill

@item $@{@var{name}:=@var{word}@}
If @var{name} is unset or is null then set it to @var{word}; the value
of the parameter is then substituted.@refill

@item $@{@var{name}:?@var{word}@}
If @var{name} is set and is non-null, then substitute its value;
otherwise, print @var{word} and exit from the shell.  If @var{word} is
omitted, then a standard message is printed.@refill

@item $@{@var{name}:+@var{word}@}
If @var{name} is set and is non-null then substitute @var{word};
otherwise substitute nothing.@refill

@item $@{@var{name}#@var{pattern}@}
@itemx $@{@var{name}##@var{pattern}@}
If the @var{pattern} matches the beginning of the value of @var{name},
then substitute the value of @var{name} with the matched portion
deleted; otherwise, just substitute the value of @var{name}.  In the
first form, the smallest matching pattern is preferred; in the second
form, the largest matching pattern is preferred.@refill

@item $@{@var{name}%@var{pattern}@}
@itemx $@{@var{name}%%@var{pattern}@}
If the @var{pattern} matches the end of the value of @var{name}, then
substitute the value of @var{name} with the matched portion deleted;
otherwise, just substitute the value of @var{name}.  In the first form,
the smallest matching pattern is preferred; in the second form, the
largest matching pattern is preferred.@refill

@item $@{#@var{spec}@}
If @var{spec} is one of the above substitutions, substitute the length
in characters of the result instead of the result itself.  If @var{spec}
is an array expression, substitute the number of elements of the
result.@refill

@cindex rc, array expansion style
@cindex array expansion, rc style
@pindex RC_EXPAND_PARAM, use of
@item $@{^@var{spec}@}
Toggle the value of the @code{RC_EXPAND_PARAM} option for the evaluation
of @var{spec}.  When this option is set, array expansions of the form
@samp{foo$@{xx@}bar}, where the parameter @samp{xx} is set to @samp{(a b
c)}, are substituted with @samp{fooabar foobbar foocbar} instead of the
default @samp{fooa b cbar}.@refill

@cindex word splitting, sh style
@cindex sh, word splitting style
@pindex SH_WORD_SPLIT, use of
@vindex IFS, use of
@item $@{=@var{spec}@}
Toggle the value of the @code{SH_WORD_SPLIT} option for the evaluation
of @var{spec}.  When this option is set, parameter values are split into
separate words using @code{IFS} as a delimiter before substitution.
This is done by default in most other shells.@refill

@cindex csh, tilde expansion
@cindex tilde expansion, csh
@pindex CSH_JUNKIE_LOOPS
@item $@{~@var{spec}@}
Toggle the value of the @code{GLOB_SUBST} option for the evaluation of
@var{spec}.  When this option is set, any pattern characters resulting
from the substitution become eligible for file expansion and filename
generation.@refill
@end table

@noindent
If the colon is omitted from one of the above expressions containing a
colon, then the shell only checks whether @var{name} is set or not, not
whether it is null.@refill

@noindent
If the opening brace is directly followed by an opening parenthesis
the string up to the matching closing parenthesis will be taken as a
list of flags.  Where arguments are valid, any character, or the
matching pairs @code{(@dots{})}, @code{@{@dots{}@}}, @code{[@dots{}]},
or @code{<@dots{}>}, may be used in place of the colon as delimiters.
The following flags are supported:

@table @code
@item o
Sort the resulting words in ascending order.

@item O
Sort the resulting words in descending order.

@item i
With @code{o} or @code{O}, makes the sort case-insensitive.

@item L
Converts all letters in the result to lowercase.

@item U
Converts all letters in the result to uppercase.

@item C
Capitalizes the resulting words

@item c
With @code{$@{#@var{name}@}}, count the total number of characters in an
array, as if the elements were concatenated with spaces between
them.@refill

@item w
With @code{$@{#@var{name}@}}, count words in arrays or strings; the
@code{s} flag may be used to set a word delimiter.@refill

@item l:@var{expr}::@var{string1}::@var{string2}:
Pad the resulting words on the left.  Each word will be truncated if
required and placed in a field @var{expr} characters wide.  The space to
the left will be filled with @var{string1} (concatenated as often as
needed), or spaces if @var{string1} is not given.  If both @var{string1}
and @var{string2} are given, this string will be placed exactly once
directly to the left of the resulting word.@refill

@item r:@var{expr}::@var{string1}::@var{string2}:
As @code{l}, but pad the words on the right.

@item j:@var{string}:
Join the words or arrays together using @var{string} as a separator.
Note that this occurs before word splitting by the @code{SH_WORD_SPLIT}
option.@refill

@item s:@var{string}:
Force word splitting (see the option @code{SH_WORD_SPLIT}) at the
separator @var{string}.  Splitting only occurs in places where an array
value is valid.

@item S
(This and all remaining flags are used with the
@code{$@{@dots{}#@dots{}@}} and @code{$@{@dots{}%@dots{}@}} forms).
Search substrings as well as beginnings or ends of strings.@refill

@item I:@var{expr}:
Search the @var{expr}'th match (where @var{expr} evaluates to a number).

@item M
Include the matched portion in the result.

@item R
Include the unmatched portion in the result (the @var{r}est).

@item B
Include the index of the beginning of the match in the result.

@item E
Include the index of the end of the match in the result.

@item N
Include the length of the match in the result.
@end table

@node Command Substitution, Arithmetic Expansion, Parameter Expansion, Expansion
@section Command Substitution
@cindex command substitution
@cindex substitution, command

@vindex IFS, use of
@noindent
A command enclosed in parentheses preceded by a dollar sign, like so:
@code{$(@dots{})} or quoted with grave accents: @code{`@dots{}`} is
replaced with its standard output.  If the substitution is not enclosed
in double quotes, the output is broken into words using the @code{IFS}
parameter.  The substitution @code{$(cat foo)} may be replaced by the
equivalent but faster @code{$(<foo)}.  In either case, if the option
@code{GLOB_SUBST} is set the output is eligible for filename
generation.@refill

@node Arithmetic Expansion, Brace Expansion, Command Substitution, Expansion
@section Arithmetic Expansion
@cindex arithmetic expansion
@cindex expansion, arithmetic

@noindent
A string of the form @code{$[@var{exp}]} is substituted with the value
of the arithmetic expression @var{exp}.  @var{exp} is treated as if it
were within single quotes.  @xref{Arithmetic Evaluation}.@refill

@node Brace Expansion, Filename Generation, Arithmetic Expansion, Expansion
@section Brace Expansion
@cindex brace expansion
@cindex expansion, brace

@noindent
A string of the form @samp{foo@{xx,yy,zz@}bar} is expanded to the
individual words @samp{fooxxbar}, @*@samp{fooyybar}, and @samp{foozzbar}.
Left-to-right order is preserved.  This construct may be nested.
Malformed brace expansion expressions, including expressions without a
comma, are left unchanged by the shell.@refill

@noindent
An expression of the form @code{@{x-y@}}, where @code{x} and @code{y}
are single characters, is expanded to every character between @code{x}
and @code{y}, inclusive.@refill

@node Filename Generation,  , Brace Expansion, Expansion
@section Filename Generation
@cindex filename generation

@cindex globbing
@pindex NO_GLOB, use of
@pindex EXTENDED_GLOB, use of
@pindex NULL_GLOB, use of
@pindex NO_NOMATCH, use of
@pindex GLOB_DOTS, use of
@noindent
If a word contains an unquoted instance of one of the characters
@code{*}, @code{|}, @code{<}, @code{[}, or @code{?}, it is regarded as a
pattern for filename generation, unless the @code{NO_GLOB} option is
set.  If the @code{EXTENDED_GLOB} option is set, the @code{^} and
@code{#} characters also denote a pattern; otherwise (except for an
initial @code{~}, @xref{Filename Expansion}) they are not
treated specially by the shell.  The word is replaced with a list of
sorted filenames that match the pattern.  If no matching pattern is
found, the shell gives an error message, unless the @code{NULL_GLOB}
option is set, in which case the word is deleted; or unless the
@code{NO_NOMATCH} option is set, in which case the word is left
unchanged.  In filename generation, the character @code{/} must be
matched explicitly; also, a @code{.} must be matched explicitly at the
beginning of a pattern or after a @code{/}, unless the @code{GLOB_DOTS}
option is set.  No filename generation pattern matches the files
@file{.} or @file{..}.  In other instances of pattern matching, the
@code{/} and @code{.} are not treated specially.@refill

@table @code
@item *
Matches any string, including the null string.

@item ?
Matches any character.

@item [@dots{}]
Matches any of the enclosed characters.

@item [^@dots{}]
Matches any character except the enclosed characters.  @code{!@dots{}}
is the same.

@item <x-y>
Matches any number in the range @code{x} to @code{y}, inclusive.  If
@code{x} is omitted, the number must be less than or equal to @code{y}.
If @code{y} is omitted, the number must be greater than or equal to
@code{x}.  A pattern of the form @code{<->} or simply @code{<>} matches
any number.@refill

@item ^x
Matches anything except the pattern @code{x}.

@item x|y
Matches either @code{x} or @code{y}.

@item x#
Matches zero or more occurrences of the pattern @code{x}.

@item x##
Matches one or more occurrences of the pattern @code{x}.
@end table

@noindent
Parentheses may be used for grouping.  Note that the @code{|} character
must be within parentheses, so that the lexical analyzer does not think
it is a pipe character.  Also note that @code{/} has a higher precedence
than @code{^}; that is:@refill

@code{ls ^foo/bar}

@noindent
will search directories in @file{.} except @file{./foo} for a file named
@file{bar}.@refill

@noindent
A pathname component of the form @code{(@var{foo}/)#} matches a path
consisting of zero or more directories matching the pattern @var{foo}.
As a shorthand, @code{**/} is equivalent to @code{(*/)#}.  Thus:@refill

@code{ls (*/)#bar}

@noindent
or

@code{ls **/bar}

@noindent
does a recursive directory search for files named @file{bar}.

@cindex exclusion, globbing
@cindex globbing, excluding patterns
@noindent
If used for filename generation, a pattern may contain an exclusion
specifier.  Such patterns are of the form @code{@var{pat1}~@var{pat2}}.
This pattern will generate all files matching @var{pat1}, but which do
not match @var{pat2}.  For example, @samp{*.c~lex.c} will match all
files ending in @file{.c}, except the file @file{lex.c}.  This may
appear inside parentheses.  Note that @code{~} has higher precedence
than @code{|}, so that @samp{pat1|pat2~pat3} matches any time that
@var{pat1} matches, or if @var{pat2} matches while @var{pat3} does not.
Note also that any @code{/} characters are not treated specially in the
exclusion specifier, so that a @code{*} will match multiple path
segments if they appear in the pattern to the left of the
@code{~}.@refill 

@cindex qualifiers, globbing
@cindex globbing, qualifiers
@noindent
Patterns used for filename generation may also end in a list of
qualifiers enclosed in parentheses.  The qualifiers specify which
filenames that otherwise match the given pattern will be inserted in the
argument list.  A qualifier may be any one of the following:

@table @code
@item /
Directories

@item .
Plain files

@item @@
Symbolic links

@item =
Sockets

@item p
Named pipes (FIFOs)

@item *
Executable plain files (0100)

@item %
Device files (character or block special)

@item %b
Block special files

@item %c
Character special files

@item r
Readable files (0400)

@item w
Writable files (0200)

@item x
Executable files (0100)

@item R
World-readable files (0004)

@item W
World-writable files (0002)

@item X
World-executable files (0001)

@item s
Setuid files (04000)

@item S
Setgid files (02000)

@item d@var{dev}
Files on the device @var{dev}

@item l[+-]@var{ct}
Files having a link count less than (@code{-}), more than (@code{+}), or
equal to @var{ct}.@refill

@item U
Files owned by the effective user id.

@item G
Files owned by the effective group id.

@item u@var{id}
Files owned by user @var{id} if @var{id} is a number.  If not, the
character after the @code{u} will be used as a separator and the string
between it and the next matching separator (@code{(}, @code{[},
@code{@{}, and @code{<} match @code{)}, @code{]}, @code{@}}, and
@code{>} respectively; any other character matches itself) will be taken
as a user name and translated into the corresponding user id (e.g.@:
@code{u:foo:} or @code{u[foo]} for user @code{foo}).@refill

@item g@var{id}
Like @code{u@var{id}} but with group ids or names.

@item a[+-]@var{n}
Files accessed within last @var{n} days (@code{-}), more than @var{n}
days ago (@code{+}), or exactly @var{n} days ago.@refill

@item m[+-]@var{n}
Files modified within last @var{n} days (@code{-}), more than @var{n}
days ago (@code{+}), or exactly @var{n} days ago.@refill

@item c[+-]@var{n}
Files whose inode changed within last @var{n} days (@code{-}), more than
@var{n} days ago (@code{+}), or exactly @var{n} days ago.  If any of
the flags @code{a}, @code{m}, or @code{c} is directly followed by a @code{M},
@code{w}, @code{h}, or @code{m} (e.g.@: @code{mh+5}) the check is
performed in units of months (of 30 days), weeks, hours, or minutes
respectively.@refill

@item L[+-]@var{n}
Files less than @var{n} bytes (@code{-}), more than @var{n} bytes
(@code{+}), or exactly @var{n} bytes in length.@refill

@item ^
Negates all qualifiers following it.

@item -
Toggles between making the qualifiers work on symbolic links (the
default), and the files they point to.

@item M
@pindex MARK_DIRS, setting in pattern
Sets the @code{MARK_DIRS} option for the current pattern.

@item T
Appends a trailing qualifier mark to the file names, analogous to the
@code{LIST_TYPES}, for the current pattern (overrides @code{M}).@refill

@item N
@pindex NULL_GLOB, setting in pattern
Sets the @code{NULL_GLOB} option for the current pattern.

@item D
@pindex GLOB_DOTS, setting in pattern
Sets the @code{GLOB_DOTS} option for the current pattern.
@end table

@noindent
More than one of these lists can be combined, separated by commas; the
whole list matches if at least one of the sublists matches (they are
or'ed, the qualifiers in the sublists are and'ed).  A @code{/} at the
end of a pattern is equivalent to @code{(/)}.@refill

@noindent
If a @code{:} appears in a qualifier list, the remainder of the
expression in parentheses is interpreted as a modifier
(@xref{Modifiers}).  Note that each modifier must be introduced by a
separate @code{:}.  Note also that the result after modification does
not have to be an existing file.  The name of any existing file can be
followed by a modifier of the form @code{(:@dots{})} even if no filename
generation is performed.@refill

@noindent
Thus:

@code{ls *(-/)}

@noindent
lists all directories and symbolic links that point to directories, and

@code{ls *(%W)}

@noindent
lists all world-writable device files in the current directory, and

@code{ls *(W,X)}

@noindent
lists all files in the current directory that are world-writable or
world-executable, and

@code{echo /tmp/foo*(u0^@@:t)}

@noindent
outputs the basename of all root-owned files beginning with the string
@samp{foo} in @file{/tmp}, ignoring symlinks, and@refill

@code{ls *.*~(lex|parse).[ch](^D^l1)}

@noindent
lists all files having a link count of one whose names contain a dot
(but not those starting with a dot, since @code{GLOB_DOTS} is explicitly
switched off) except for @file{lex.c}, @file{lex.h}, @file{parse.c}, and
@file{parse.h}.@refill

@node Redirection, Command Execution, Expansion, Top
@chapter Redirection
@cindex redirection

@cindex file descriptors
@cindex descriptors, file
@noindent
Before a command is executed, its input and output may be redirected.
The following may appear anywhere in a simple command or may precede or
follow a complex command.  Substitution occurs before @var{word} is used
except as noted below.  If the result of substitution on @var{word}
produces more than one filename, redirection occurs for each separate
filename in turn.@refill

@table @code
@item <@var{word}
Open file @var{word} as standard input.

@item >@var{word}
@pindex NO_CLOBBER, use of
Open file @var{word} as standard output.  If the file does not exist
then it is created.  If the file exists, and the @code{NO_CLOBBER}
option is set, this causes an error; otherwise, it is truncated to zero
length.@refill

@item >!@var{word}
Same as @code{>}, except that the file is truncated to zero length if it
exists, even if @code{NO_CLOBBER} is set.@refill

@item >>@var{word}
Open file @var{word} as standard output.  If the file exists then output
is appended to it.  If the file does not exist, and the
@code{NO_CLOBBER} option is set, this causes an error; otherwise, the
file is created.@refill

@item >>!@var{word}
Same as @code{>>}, except that the file is created if it does not exist,
even if @code{NO_CLOBBER} is set.@refill

@item <<[-]@var{word}
The shell input is read up to a line that is the same as @var{word}, or
to an end-of-file.  No parameter substitution, command substitution or
filename generation is performed on @var{word}.  The resulting document,
called a @dfn{here-document}, becomes the standard input.  If any
character of @var{word} is quoted with single or double quotes or a
@code{\}, no interpretation is placed upon the characters of the
document.  Otherwise, parameter and command substitution occurs,
@code{\} followed by a newline is removed, and @code{\} must be used to
quote the characters @code{\}, @code{$}, @code{`}, and the first
character of @var{word}.  If @code{<<-} is used, then all leading tabs
are stripped from @var{word} and from the document.@refill

@item <<<@var{word}
Open a file containing @var{word}, after expansion, as standard input.

@item <&@var{digit}
The standard input is duplicated from file descriptor @var{digit} (see
@code{dup(2)}).  Similarly for standard output using
@code{>&@var{digit}}.@refill

@item >&@var{word}
Same as @code{>@var{word} 2>&1}.

@item >>&@var{word}
Same as @code{>>@var{word} 2>&1}.

@item <&-
Close the standard input.

@item >&-
Close the standard output.

@item <&p
The input from the coprocess is moved to the standard input.

@item >&p
The output to the coprocess is moved to the standard output.
@end table

@noindent
If one of the above is preceded by a digit, then the file descriptor
referred to is that specified by the digit (instead of the default 0 or
1).  The order in which redirections are specified is significant.  The
shell evaluates each redirection in terms of the (@var{file descriptor},
@var{file}) association at the time of evaluation.  For example:@refill

@code{@dots{} 1>@var{fname} 2>&1}

@noindent
first associates file descriptor 1 with file @var{fname}.  It then
associates file descriptor 2 with the file associated with file
descriptor 1 (that is, @var{fname}).  If the order of redirections were
reversed, file descriptor 2 would be associated with the terminal
(assuming file descriptor 1 had been) and then file descriptor 1 would
be associated with file @var{fname}.@refill

@noindent
If the user tries to open a file descriptor for writing more than once,
the shell opens the file descriptor as a pipe to a process that copies
its input to all the specified outputs, similar to @code{tee(1)}.  Thus:

@code{date >foo >bar}

@noindent
writes the date to two files, named @file{foo} and @file{bar}.  Note
that a pipe is an implicit indirection; thus@refill

@code{date >foo | cat}

@noindent
writes the date to the file @file{foo}, and also pipes it to @code{cat}.

@noindent
If the user tries to open a file descriptor for reading more than once,
the shell opens the file descriptor as a pipe to a process that copies
all the specified inputs to its output in the order specified, similar
to @code{cat(1)}.  Thus

@code{sort <foo <fubar}

@noindent
or even

@code{sort <f@{oo,ubar@}}

@noindent
is equivalent to @samp{cat foo fubar | sort}.  Similarly, you can do

@code{echo exit 0 >> *.sh}

Note that a pipe is an implicit indirection; thus

@code{cat bar | sort <foo}

@noindent
is equivalent to @samp{cat bar foo | sort} (note the order of the inputs).

@noindent
If a simple command consists of one or more redirection operators and
zero or more parameter assignments, but no command name, the command
@code{cat} is assumed.  Thus

@code{< file}

@noindent
prints the contents of @code{file}.

@noindent
If a command is followed by @code{&} and job control is not active, then
the default standard input for the command is the empty file
@file{/dev/null}.  Otherwise, the environment for the execution of a
command contains the file descriptors of the invoking shell as modified
by input/output specifications.@refill

@node Command Execution, Functions, Redirection, Top
@chapter Command Execution
@cindex command execution
@cindex execution, of commands

@noindent
If a command name contains no slashes, the shell attempts to locate it.
If there exists a shell function by that name, the function is invoked
as described below (@pxref{Functions}).  If there exists a shell builtin
by that name, the builtin is invoked.

@vindex path, use of
@noindent
Otherwise, the shell searches each element of @code{path} for a directory
containing an executable file by that name.  If the search is
unsuccessful, the shell prints an error message and returns a nonzero
exit status.

@noindent
If execution fails because the file is not in executable format, and the
file is not a directory, it is assumed to be a shell script.
@code{/bin/sh} is spawned to execute it.  If the program is a file
beginning with @code{#!}, the remainder of the first line specifies an
interpreter for the program.  The shell will execute the specified
interpreter on operating systems that do not handle this executable
format in the kernel.@refill

@node Functions, Jobs & Signals, Command Execution, Top
@chapter Functions
@cindex functions

@findex function
@noindent
The @code{function} reserved word is used to define shell functions.
Shell functions are read in and stored internally.  Alias names are
resolved when the function is read.  Functions are executed like
commands with the arguments passed as positional parameters.@refill

@noindent
Functions execute in the same process as the caller and share all files
and the present working directory with the caller.  A trap on
@code{EXIT} set inside a function is executed after the function
completes in the environment of the caller.@refill

@findex return, use of
@noindent
The @code{return} builtin is used to return from function calls.

@findex functions, use of
@findex unfunction, use of
@noindent
Function identifiers can be listed with the @code{functions} builtin.
Functions can be undefined with the @code{unfunction} builtin.@refill

@noindent
The following functions, if defined, have special meaning to the shell:

@table @code
@findex chpwd
@item chpwd
Executed whenever the current working directory is changed.

@findex precmd
@item precmd
Executed before each prompt.

@vindex PERIOD
@findex periodic
@item periodic
If the parameter @code{PERIOD} is set, this function is executed every
@code{PERIOD} seconds, just before a prompt.@refill

@findex TRAPERR
@findex TRAPDEBUG
@findex TRAPEXIT
@cindex signals, trapping
@cindex trapping signals
@item TRAP@var{xxx}
If defined and non-null, this function will be executed whenever the
shell catches a signal @code{SIG@var{xxx}}, where @var{xxx} is a signal
name as specified for the @code{kill} builtin (@pxref{Shell Builtin
Commands}).  In addition, @code{TRAPZERR} is executed whenever a command
has a non-zero exit status, @code{TRAPDEBUG} is executed after each
command, and @code{TRAPEXIT} is executed when the shell exits, or when
the current function exits if defined inside a function.  If a function
of this form is defined and null, the shell and processes spawned by it
will ignore @code{SIG@var{xxx}}.@refill
@end table

@node Jobs & Signals, History, Functions, Top
@chapter Jobs & Signals
@cindex jobs

@findex jobs, use of
@pindex MONITOR, use of
@noindent
If the @code{MONITOR} option is set, an interactive shell associates a
@dfn{job} with each pipeline.  It keeps a table of current jobs,
printed by the @code{jobs} command, and assigns them small integer
numbers.  When a job is started asynchronously with @code{&}, the shell
prints a line which looks like:@refill

@code{[1] 1234}

@noindent
indicating that the job which was started asynchronously was job number
1 and had one (top-level) process, whose process id was 1234.

@kindex CTRL-Z
@cindex jobs, suspending
@cindex suspending jobs
@findex fg, use of
@findex bg, use of
@noindent
If you are running a job and wish to do something else you may hit the
key @code{^Z} (control-Z) which sends a @code{TSTP} signal to the current
job.  The shell will then normally indicate that the job has been
@dfn{suspended}, and print another prompt.  You can then manipulate the
state of this job, putting it into the background with the @code{bg}
command, or run some other commands and then eventually bring the job
back into the foreground with the foreground command @code{fg}.  A
@code{^Z} takes effect immediately and is like an interrupt in that
pending output and unread input are discarded when it is typed.@refill

@cindex jobs, background, IO
@cindex background jobs, IO
@noindent
A job being run in the background will suspend if it tries to read from
the terminal.  Background jobs are normally allowed to produce output,
but this can be disabled by giving the command @code{stty tostop}.  If
you set this tty option, then background jobs will suspend when they try
to produce output, just as they do when they try to read input.@refill

@cindex jobs, referring to
@cindex referring to jobs
@noindent
There are several ways to refer to jobs in the shell.  A job can be
referred to by the process id of any process of the job or by one of the
following:

@table @code
@item %@var{number}
The job with the given number.

@item %@var{string}
Any job whose command line begins with @var{string}.

@item %?@var{string}
Any job whose command line contains @var{string}.

@item %%
Current job.

@item %+
Equivalent to @code{%%}.

@item %-
Previous job.
@end table

@findex notify, use of
@noindent
The shell learns immediately whenever a process changes state.  It
normally informs you whenever a job becomes blocked so that no further
progress is possible.  If @code{notify} is not set, it waits until just
before it prints a prompt before it informs you.@refill

@noindent
When the monitor mode is on, each background job that completes triggers
any trap set for @code{CHLD}.

@findex disown, use of
@cindex jobs, disowning
@cindex disowning jobs
@noindent
When you try to leave the shell while jobs are running or suspended, you
will be warned that @samp{You have suspended (running) jobs}.  You may
use the @code{jobs} command to see what they are.  If you do this or
immediately try to exit again, the shell will not warn you a second
time; the suspended jobs will be terminated, and the running jobs will
be sent a @code{SIGHUP} signal.  To avoid having the shell terminate the
running jobs, either use the @code{nohup(1)} command or the
@code{disown} builtin (@pxref{Shell Builtin Commands}).@refill

@cindex signals
@noindent
The @code{INT} and @code{QUIT} signals for an invoked command are
ignored if the command is followed by @code{&} and the job @code{monitor}
option is not active.  Otherwise, signals have the values inherited by
the shell from its parent (but @xref{Functions}, for the
@code{TRAP@var{xxx}} special functions).@refill

@node History, Arithmetic Evaluation, Jobs & Signals, Top
@chapter History
@cindex history

@vindex HISTSIZE, use of
@noindent
History substitution allows you to use words from previous command lines
in the command line you are typing.  This simplifies spelling
corrections and the repetition of complicated commands or arguments.
Command lines are saved in the history list, the size of which is
controlled by the @code{HISTSIZE} variable.  The most recent command is
retained in any case.  A history substitution begins with a @code{!} and
may occur anywhere on the command line; history substitutions do not
nest.  The @code{!} can be escaped with @code{\} to suppress its special
meaning.  Single or double quotes will @emph{not} work for this.@refill

@noindent
Input lines containing history substitutions are echoed on the terminal
after being expanded, but before any other substitutions take place or
the command gets executed.

@menu
* Event Designators::		
* Word Designators::		
* Modifiers::			
@end menu

@node Event Designators, Word Designators,  , History
@section Event Designators
@cindex history event designators
@cindex event designators, history

@noindent
An event designator is a reference to a command-line entry in the
history list.

@table @code
@item !
Start a history substitution, except when followed by a blank, newline,
@code{=}, or @code{(}.

@item !!
Refer to the previous command.  By itself, this substitution repeats the
previous command.

@item !n
Refer to command line @var{n}.

@item !-n
Refer to the current command line minus @var{n}.

@item !str
Refer to the most recent command starting with @var{str}.

@item !?@var{str}[?]
Refer to the most recent command containing @var{str}.

@item !#
Refer to the current command line typed in so far.

@item !@{@dots{}@}
Insulate a history reference from adjacent characters (if necessary).
@end table

@node Word Designators, Modifiers, Event Designators, History
@section Word Designators
@cindex history word designators
@cindex word designators, history

@noindent
A word designator indicates which word or words of a given command line
will be included in a history reference.  A @code{:} separates the event
specification from the word designator.  It can be omitted if the word
designator begins with a @code{,}, @code{$}, @code{*}, @code{-} or
@code{%}.  Word designators include:@refill

@table @code
@item 0
The first input word (command).

@item @var{n}
The @var{n}'th argument.

@item ^
The first argument, that is, @code{1}.

@item $
The last argument.

@item %
The word matched by (the most recent) @code{?@var{str}} search.

@item @var{x}-@var{y}
A range of words;  @code{-@var{y}} abbreviates @code{0-@var{y}}.

@item *
All the arguments, or a null value if there is just one word in the
event.

@item @var{x}*
Abbreviates @code{@var{x}-$}.

@item @var{x}
Like @code{@var{x}*} but omitting word @code{$}.
@end table

@noindent
Note that a @code{%} word designator will only work when used as
@code{!%}, @code{!:%}, or @code{!?@var{str}?:%}, and only when used
after a @code{?!} substitution.  Anything else will result in an error,
although the error may not be the most obvious one.@refill

@node Modifiers,  , Word Designators, History
@section Modifiers
@cindex modifiers, history
@cindex history modifiers

@noindent
After the optional word designator, you can add a sequence of one or
more of the following modifiers, each preceded by a @code{:}.  These
modifiers also work on the result of filename and parameter
expansion.@refill

@table @code
@item h
Remove a trailing pathname component, leaving the head.

@item r
Remove a trailing suffix of the form @code{.@var{xxx}}, leaving the
basename.@refill

@item e
Remove all but the suffix.

@item t
Remove all leading pathname components, leaving the tail.

@item &
Repeat the previous substitution.

@item g
Apply the change to the first occurrence of a match in each word, by
prefixing the above (for example, @code{g&}).

@item p
Print the new command but do not execute it.

@item q
Quote the substituted words, escaping further substitutions.

@item x
Like @code{q}, but break into words at each blank.

@item l
Convert the words to all lowercase.

@item u
Convert the words to all uppercase.

@item f
Repeats the immediately-following (without a colon) modifier until the
resulting word doesn't change any more.  This modifier and the following
four only work with parameter and filename expansion.

@item F:@var{expr}:
Like @code{f}, but repeats only @var{n} times if the expression
@var{expr} evaluates to @var{n}.  Any character can be used instead of
the @code{:}, with the exception that if @code{(}, @code{[}, or
@code{@{} is used as the opening delimiter, the closing delimiter must
be @code{)}, @code{]}, or @code{@}} respectively.@refill

@item w
Makes the immediately-following modifier work on each word in the
string.

@item W:@var{sep}:
Like @code{w}, but words are considered to be the parts of the string
that are separated by @var{sep}.  Delimiters are handled as in @code{F}
above.@refill

@item s/@var{l}/@var{r}[/]
Substitute @var{r} for @var{l}.

@noindent
Unless preceded by a @code{g}, the substitution is done only for the
first string that matches @var{l}.@refill

@noindent
The left-hand side of substitutions are not regular expressions, but
character strings.  Any character can be used as the delimiter in place
of @code{/}.  A backslash quotes the delimiter character.  The character
@code{&}, in the right-hand side, is replaced by the text from the
left-hand side.  The @code{&} can be quoted with a backslash.  A null
@var{l} uses the previous string either from a @var{l} or from a
contextual scan string @var{s} from @code{!?@var{s}}.  You can omit the
rightmost delimiter if a newline immediately follows @var{r}; the
rightmost @code{?} in a context scan can similarly be omitted.@refill
@end table

@cindex csh, history style
@cindex history, csh style
@noindent
By default, a history reference with no event specification refers to
the same line as the last history reference on that command line, unless
it is the first history reference in a command.  In that case, a history
reference with no event specification always refers to the previous
command.  However, if the option @code{CSH_JUNKIE_HISTORY} is set, then
a history reference with no event specification will @var{always} refer
to the previous command.  For example, @code{!!:1} will always refer to
the first word of the previous command and @code{!!$} will always refer
to the last word of the previous command.  If @code{CSH_JUNKIE_HISTORY}
is set, then @code{!:1} and @code{!$} will function in the same manner
as @code{!!:1} and @code{!!$}, respectively.
However, if @code{CSH_JUNKIE_HISTORY} is unset, then @code{!:1} and
@code{!$} will refer to the first and last words respectively of the
last command referenced on the current command line.  However, if they
are the first history reference on the command line, then they refer to
the previous command.@refill

@noindent
The character sequence @samp{^foo^bar} repeats the last command,
replacing the string @samp{foo} with the string @samp{bar}.@refill

@cindex history, disabling
@cindex disabling history
@noindent
If the shell encounters the character sequence @code{!"} in the input,
the history mechanism is temporarily disabled until the current list is
fully parsed.  The @code{!"} is removed from the input, and any
subsequent @code{!} characters have no special significance.@refill

@findex fc, use of
@noindent
A less convenient but more comprehensible form of command history
support is provided by the @code{fc} builtin 
(@pxref{Shell Builtin Commands}).

@node Arithmetic Evaluation, Conditional Expressions, History, Top
@chapter Arithmetic Evaluation
@cindex arithmetic evaluation
@cindex evaluation, arithmetic

@noindent
An ability to perform integer arithmetic is provided with the builtin
@code{let}.  Evaluations are performed using @emph{long} arithmetic.
Constants are of the form @code{[@var{base}#]@var{n}} where @var{base}
is a decimal number between two and thirty-six representing the
arithmetic base and @var{n} is a number in that base (for example,
@code{16#ff} is 255 in hexadecimal).  If @var{base} is omitted then base
10 is used.  For backwards compatibility the form @code{[16]ff} is also
accepted.@refill

@cindex arithmetic operators
@cindex operators, arithmetic
@noindent
An arithmetic expression uses nearly the same syntax, precedence, and
associativity of expressions in C.  The following operators are
supported (listed in decreasing order of precedence):

@table @code
@item + - ! ~ ++ --
Unary plus/minus, logical NOT, complement, @{pre,post@}@{in,de@}crement

@item &
Logical AND

@item ^
Logical XOR

@item |
Logical OR

@item * / % **
Multiplication, division, remainder, exponentiation

@item + -
Addition, subtraction

@item << >>
Logical shift left, shift right

@item < > <= >=
Comparison

@item == !=
Equality and inequality

@item &&
Boolean AND

@item || ^^
Boolean OR, XOR

@item ? :
Ternary operator

@item = += -= *= /= %= &= ^= |= <<= >>= &&= ||= ^^= **=
Assignment

@item ,
Comma operator
@end table

@noindent
The operators @code{&&}, @code{||}, @code{&&=}, and @code{||=} are
short-circuiting, and only one of the latter two expressions in a
ternary operator is evaluated.  Note the precedence of the logical AND,
OR, and XOR operators.@refill

@noindent
An expression of the form @code{#\x} where @code{x} is any character
gives the ASCII value of this character.  An expression of the form
@code{#foo} gives the ASCII value of the first character of the value of
the parameter @code{foo}.@refill

@noindent
Named parameters can be referenced by name within an arithmetic
expression without using the parameter substitution syntax, but if it is
an array with a subscript the leading @code{$} is needed.

@cindex parameters, integer
@cindex integer parameters
@findex integer, use of
@noindent
An internal integer representation of a named parameter can be specified
with the @code{integer} builtin.  Arithmetic evaluation is performed on
the value of each assignment to a named parameter declared integer in
this manner.@refill

@findex let, use of
@noindent
Since many of the arithmetic operators require quoting, an alternative
form of the @code{let} command is provided.  For any command which
begins with a @code{((}, all the characters until a matching @code{))}
are treated as a quoted expression.  More precisely, @code{(( @dots{} ))} is
equivalent to @code{let "@dots{}"}.@refill

@node Conditional Expressions, Zsh Line Editor, Arithmetic Evaluation, Top
@chapter Conditional Expressions
@cindex conditional expressions
@cindex expressions, conditional

@noindent
A @dfn{conditional expression} is used with the @code{[[} compound
command to test attributes of files and to compare strings.  Each
expression can be constructed from one or more of the following unary or
binary expressions:@refill

@table @code
@item -a @var{file}
True if @var{file} exists.

@item -b @var{file}
True if @var{file} exists and is a block special file.

@item -c @var{file}
True if @var{file} exists and is a character special file.

@item -d @var{file}
True if @var{file} exists and is a directory.

@item -e @var{file}
True if @var{file} exists.

@item -f @var{file}
True if @var{file} exists and is an ordinary file.

@item -g @var{file}
True if @var{file} exists and has its setgid bit set.

@item -h @var{file}
True if @var{file} exists and is a symbolic link.

@item -k @var{file}
True if @var{file} exists and has its sticky bit set.

@item -n @var{string}
True if length of @var{string} is non-zero.

@item -o @var{option}
True if option named @var{option} is on.

@item -p @var{file}
True if @var{file} exists and is a FIFO special file or a pipe.

@item -r @var{file}
True if @var{file} exists and is readable by the current process.

@item -s @var{file}
True if @var{file} exists and has size greater than zero.

@item -t @var{fd}
True if file descriptor number @var{fd} is open and associated with a
terminal device (note: @var{fd} is not optional).@refill

@item -u @var{file}
True if @var{file} exists and has its setuid bit set.

@item -w @var{file}
True if @var{file} exists and is writable by current process.

@item -x @var{file}
True if @var{file} exists and is executable by current process.  If
@var{file} exists and is a directory, then the current process has
permission to search in the directory.@refill

@item -z @var{string}
True if length of @var{string} is zero.

@item -L @var{file}
True if @var{file} exists and is a symbolic link.

@item -O @var{file}
True if @var{file} exists and is owned by the effective user id of this
process.

@item -G @var{file}
True if @var{file} exists and its group matches the effective group id
of this process.

@item -S @var{file}
True if @var{file} exists and is a socket.

@item @var{file1} -nt @var{file2}
True if @var{file1} exists and is newer than @var{file2}.

@item @var{file1} -ot @var{file2}
True if @var{file1} exists and is older than @var{file2}.

@item @var{file1} -ef @var{file2}
True if @var{file1} and @var{file2} exist and refer to the same file.

@item @var{string} = @var{pattern}
True if @var{string} matches @var{pattern}.

@item @var{string} != @var{pattern}
True if @var{string} does not match @var{pattern}.

@item @var{string1} < @var{string2}
True if @var{string1} comes before @var{string2} based on ASCII value of
their characters.@refill

@item @var{string1} > @var{string2}
True if @var{string1} comes after @var{string2} based on ASCII value of
their characters.@refill

@item @var{exp1} -eq @var{exp2}
True if @var{exp1} is equal to @var{exp2}.

@item @var{exp1} -ne @var{exp2}
True if @var{exp1} is not equal to @var{exp2}.

@item @var{exp1} -lt @var{exp2}
True if @var{exp1} is less than @var{exp2}.

@item @var{exp1} -gt @var{exp2}
True if @var{exp1} is greater than @var{exp2}.

@item @var{exp1} -le @var{exp2}
True if @var{exp1} is less than or equal to @var{exp2}.

@item @var{exp1} -ge @var{exp2}
True if @var{exp1} is greater than or equal to @var{exp2}.

@item ( @var{exp} )
True if @var{exp} is true.

@item ! @var{exp}
True if @var{exp} is false.

@item @var{exp1} && @var{exp2}
True if @var{exp1} and @var{exp2} are both true.

@item @var{exp1} || @var{exp2}
True if either @var{exp1} or @var{exp2} is true.
@end table

@noindent
In each of the above expressions, if @var{file} is of the form
@samp{/dev/fd/@var{n}}, where @var{n} is an integer, then the test is
applied to the open file whose descriptor number is @var{n}, even if
the underlying system does not support the @file{/dev/fd}
directory.@refill

@node Zsh Line Editor, Parameters, Conditional Expressions, Top
@chapter Zsh Line Editor
@cindex line editor
@cindex editor, line

@pindex ZLE, use of
@noindent
If the @code{ZLE} option is set (it is by default) and the shell input is
attached to the terminal, the user is allowed to edit command lines.@refill

@vindex TERM
@pindex SINGLE_LINE_ZLE, use of
@cindex ksh, editor mode
@cindex editor, modes
@noindent
There are two display modes.  The first, multiline mode, is the default.
It only works if the @code{TERM} parameter is set to a valid terminal
type that can move the cursor up.  The second, single line mode, is used
if @code{TERM} is invalid or incapable of moving the cursor up, or if
the @code{SINGLE_LINE_ZLE} option is set.  This mode is similar to ksh,
and uses no termcap sequences.  If @code{TERM} is @samp{emacs}, the
@code{ZLE} option will be unset by the shell.@refill

@cindex bindings, key
@cindex key bindings
@findex bindkey, use of
@vindex VISUAL
@vindex EDITOR
@noindent
Command bindings may be set using the @code{bindkey} builtin.  There are
two keymaps---the main keymap and the alternate keymap.  The alternate
keymap is bound to vi command mode.  The main keymap is bound to emacs
mode by default.  To bind the main keymap to vi insert mode, use
@code{bindkey -v}.  However, if either of
the @code{VISUAL} or @code{EDITOR} environment variables contains the
string @samp{vi} when the shell starts up the main keymap will be bound
to vi insert mode by default.@refill

@noindent
The following is a list of all the key commands and their default
bindings in emacs and vi command mode.

@menu
* Movement::			
* History Control::		
* Modifying Text::		
* Arguments::			
* Completion::			
* Miscellaneous::		
@end menu

@node Movement, History Control,  , Zsh Line Editor
@section Movement

@table @code
@tindex vi-backward-blank-word
@kindex B
@item vi-backward-blank-word (unbound) (@kbd{B})
Move backward one word, where a word is defined as a series of non-blank
characters.

@tindex backward-char
@kindex CTRL-B
@kindex ESC-[D
@item backward-char (@kbd{^B} @kbd{ESC-[D})
Move backward one character.

@tindex vi-backward-char
@kindex ESC-B
@kindex ESC-b
@item vi-backward-char (unbound) (@kbd{h})
Move backward one character, without changing lines.

@tindex backward-word
@item backward-word (@kbd{ESC-B} @kbd{ESC-b})
Move to the beginning of the previous word.

@tindex emacs-backward-word
@item emacs-backward-word
Move to the beginning of the previous word.

@tindex vi-backward-word
@kindex b
@item vi-backward-word (unbound) (@kbd{b})
Move to the beginning of the previous word, vi-style.

@tindex beginning-of-line
@kindex CTRL-A
@kindex 0
@item beginning-of-line (@kbd{^A}) (@kbd{0})
Move to the beginning of the line.  If already at the beginning of the
line, move to the beginning of the previous line, if any.

@tindex vi-beginning-of-line
@item vi-beginning-of-line
Move to the beginning of the line, without changing lines.

@tindex end-of-line
@kindex CTRL-E
@item end-of-line (@kbd{^E})
Move to the end of the line.  If already at the end of the line, move to
the end of the next line, if any.

@tindex vi-end-of-line
@kindex $
@item vi-end-of-line (unbound) (@kbd{$})
Move to the end of the line.

@tindex vi-forward-blank-word
@kindex W
@item vi-forward-blank-word (unbound) (@kbd{W})
Move forward one word, where a word is defined as a series of non-blank
characters.

@tindex vi-forward-blank-word-end
@kindex E
@item vi-forward-blank-word-end (unbound) (@kbd{E})
Move to the end of the current word, or, if at the end of the current
word, to the end of the next word, where a word is defined as a series
of non-blank characters.

@tindex forward-char
@kindex CTRL-F
@kindex ESC-[C
@item forward-char (@kbd{^F} @kbd{ESC-[C})
Move forward one character.

@tindex vi-forward-char
@kindex l
@kindex SPACE
@item vi-forward-char (unbound) (@key{SPACE} @kbd{l})
Move forward one character.

@tindex vi-find-next-char
@kindex CTRL-X CTRL-F
@kindex f
@item vi-find-next-char (@kbd{^X^F}) (@kbd{f})
Read a character from the keyboard, and move to the next occurrence of
it in the line.

@tindex vi-find-next-char-skip
@kindex t
@item vi-find-next-char-skip (unbound) (@kbd{t})
Read a character from the keyboard, and move to the position just before
the next occurrence of it in the line.

@tindex vi-find-prev-char
@kindex F
@item vi-find-prev-char (unbound) (@kbd{F})
Read a character from the keyboard, and move to the previous occurrence
of it in the line.

@tindex vi-find-prev-char-skip
@kindex T
@item vi-find-prev-char-skip (unbound) (@kbd{T})
Read a character from the keyboard, and move to the position just after
the previous occurrence of it in the line.

@tindex vi-first-non-blank
@kindex ^
@item vi-first-non-blank (unbound) (@kbd{^})
Move to the first non-blank character in the line.

@tindex vi-forward-word
@kindex w
@item vi-forward-word (unbound) (@kbd{w})
Move forward one word, vi-style.

@tindex forward-word
@kindex ESC-F
@kindex ESC-f
@item forward-word (@kbd{ESC-F} @kbd{ESC-f})
Move to the beginning of the next word.  The editor's idea of a word is
specified with the @code{WORDCHARS} parameter.@refill

@tindex emacs-forward-word
@item emacs-forward-word
Move to the end of the next word.

@tindex vi-forward-word-end
@kindex e
@item vi-forward-word-end (unbound) (@kbd{e})
Move to the end of the next word.

@tindex vi-goto-column
@kindex ESC-|
@kindex |
@item vi-goto-column (@kbd{ESC-|}) (@kbd{|})
Move to the column specified by the numeric argument.

@tindex vi-goto-mark
@kindex `
@item vi-goto-mark (unbound) (@kbd{`})
Move to the specified mark.

@tindex vi-goto-mark-line
@kindex '
@item vi-goto-mark-line (unbound) (@kbd{'})
Move to the beginning of the line containing the specified mark.

@tindex vi-repeat-find
@kindex ;
@item vi-repeat-find (unbound) (@kbd{;})
Repeat the last @code{vi-find} command.

@tindex vi-rev-repeat-find
@kindex ,
@item vi-rev-repeat-find (unbound) (@kbd{,})
Repeat the last @code{vi-find} command in the opposite direction.
@end table

@node History Control, Modifying Text, Movement, Zsh Line Editor
@section History Control

@table @code
@tindex beginning-of-buffer-or-history
@kindex ESC-<
@item beginning-of-buffer-or-history (@kbd{ESC-<})
Move to the beginning of the buffer, or if already there, move to the
first event in the history list.

@tindex beginning-of-line-hist
@item beginning-of-line-hist
Move to the beginning of the line.  If already at the beginning of the
buffer, move to the previous history line.

@tindex beginning-of-history
@item beginning-of-history
Move to the first event in the history list.

@tindex down-line-or-history
@kindex CTRL-N
@kindex ESC-[B
@kindex +
@kindex j
@item down-line-or-history (@kbd{^N} @kbd{ESC-[B}) (@kbd{+} @kbd{j})
Move down a line in the buffer, or if already at the bottom line, move
to the next event in the history list.

@tindex down-line-or-search
@item down-line-or-search
Move down a line in the buffer, or if already at the bottom line,
search forward in the history for a line beginning with the first
word in the buffer.

@tindex down-history
@kindex CTRL-N
@item down-history (unbound) (@kbd{^N})
Move to the next event in the history list.

@tindex history-beginning-search-backward
@item history-beginning-search-backward
Search backward in the history for a line beginning with the current
line up to the cursor.  This leaves the cursor in its original position.

@tindex end-of-buffer-or-history
@kindex ESC->
@item end-of-buffer-or-history (@kbd{ESC->})
Move to the end of the buffer, or if already there, move to the last
event in the history list.

@tindex end-of-line-hist
@item end-of-line-hist
Move to the end of the line.  If already at the end of the buffer, move
to the next history line.

@tindex end-of-history
@item end-of-history
Move to the last event in the history list.

@tindex vi-fetch-history
@kindex G
@item vi-fetch-history (unbound) (@kbd{G})
Fetch the history line specified by the numeric argument.

@tindex history-incremental-search-backward
@kindex CTRL-R
@kindex CTRL-X r
@item history-incremental-search-backward (@kbd{^R} @kbd{^Xr})
Search backward incrementally for a specified string.  The string may
begin with @code{^} to anchor the search to the beginning of the line.
A restricted set of editing functions is available in the mini-buffer.
An interrupt signal, as defined by the stty setting, will stop the
search and go back to the original line.  An undefined key will have the
same effect.  The supported functions are: @code{backward-delete-char},
@code{quoted-insert}, @code{accept-and-hold},
@code{accept-and-infer-next-history}, @code{accept-line} and
@code{accept-line-and-down-history}; @code{magic-space} just inserts a
space.  Any string that is bound to an out-string (via @code{bindkey
-s}) will behave as if out-string were typed directly.  Typing the
binding of @code{history-incremental-search-backward} will get the next
occurrence of the contents of the mini-buffer.  Typing the binding of
@code{history-incremental-search-forward} inverts the sense of the
search.  The direction of the search is indicated in the mini-buffer.
Any multi-character string that is not bound to one of the above
functions will beep and interrupt the search, leaving the last found
line in the buffer.  Any single character that is not bound to one of
the above functions, or @code{self-insert} or @code{self-insert-unmeta},
will have the same effect but the function will be executed.@refill

@tindex history-incremental-search-forward
@kindex CTRL-X s
@item history-incremental-search-forward (@kbd{^Xs})
Search forward incrementally for a specified string.  The string may
begin with @code{^} to anchor the search to the beginning of the line.
The functions available in the mini-buffer are the same as for
@code{history-incremental-search-backward}.@refill

@tindex history-search-backward
@kindex ESC-P
@kindex ESC-p
@kindex K
@item history-search-backward (@kbd{ESC-P} @kbd{ESC-p}) (@kbd{K})
Search backward in the history for a line beginning with the first word
in the buffer.  

@tindex vi-history-search-backward
@kindex /
@item vi-history-search-backward (unbound) (@kbd{/})
Search backward in the history for a specified string.  The string may
begin with @code{^} to anchor the search to the beginning of the line.
A restricted set of editing functions is available in the mini-buffer.
An interrupt signal, as defined by the stty setting, will stop the
search, as will a character bound to @code{vi-cmd-mode}.  The functions
available in the mini-buffer are: @code{accept-line},
@code{backward-delete-char}, @code{vi-backward-delete-char} and
@code{quoted-insert}.  Any string that is bound to an out-string (via
@code{bindkey -s}) will behave as if out-string were typed directly.  Any other
character that is not bound to @code{self-insert} or
@code{self-insert-unmeta} will beep and be ignored.  If the function is
called from vi command mode, the bindings of vi insert mode will be
used.@refill

@tindex history-search-forward
@kindex ESC-N
@kindex ESC-n
@kindex J
@item history-search-forward (@kbd{ESC-N} @kbd{ESC-n}) (@kbd{J})
Search forward in the history for a line beginning with the first word
in the buffer.

@tindex vi-history-search-forward
@kindex ?
@item vi-history-search-forward (unbound) (@kbd{?})
Search forward in the history for a specified string.  The string may
begin with @code{^} to anchor the search to the beginning of the line.
The functions available in the mini-buffer are the same as for
@code{vi-history-search-backward}.@refill

@tindex infer-next-history
@kindex CTRL-X CTRL-N
@item infer-next-history (@kbd{^X^N})
Search in the history for a line matching the current one and fetch the
event following it.

@tindex insert-last-word
@kindex ESC-_
@kindex ESC-.
@item insert-last-word (@kbd{ESC-_} @kbd{ESC-.})
Insert the last word from the previous history event at the cursor
position.

@tindex vi-repeat-search
@kindex n
@item vi-repeat-search (unbound) (@kbd{n})
Repeat the last vi history search.

@tindex vi-rev-repeat-search
@kindex N
@item vi-rev-repeat-search (unbound) (@kbd{N})
Repeat the last vi history search, but in reverse.

@tindex toggle-literal-history
@pindex HIST_LIT, use of
@kindex ESC-R
@kindex ESC-r
@item toggle-literal-history (@kbd{ESC-R} @kbd{ESC-r})
Toggle between literal and lexical history.  The default is lexical
history unless the @code{HIST_LIT} option is set.

@tindex up-line-or-history
@kindex CTRL-P
@kindex ESC-[A
@kindex -
@kindex k
@item up-line-or-history (@kbd{^P} @kbd{ESC-[A}) (@kbd{-} @kbd{k})
Move up a line in the buffer, or if already at the top line, move to the
previous event in the history list.

@tindex up-line-or-search
@item up-line-or-search
Move up a line in the buffer, or if already at the top line, search
backward in the history for a line beginning with the first word in the
buffer.

@tindex up-history
@kindex CTRL-P
@item up-history (unbound) (@kbd{^P})
Move to the previous event in the history list.

@tindex history-beginning-search-forward
@item history-beginning-search-forward
Search forward in the history for a line beginning with the current line
up to the cursor.  This leaves the cursor at its original position.
@end table

@node Modifying Text, Arguments, History Control, Zsh Line Editor
@section Modifying Text

@table @code
@tindex vi-add-eol
@kindex A
@item vi-add-eol (unbound) (@kbd{A})
Move to the end of the line and enter insert mode.

@tindex vi-add-next
@kindex a
@item vi-add-next (unbound) (@kbd{a})
Move forward one character and enter insert mode.

@tindex backward-delete-char
@kindex CTRL-H
@kindex CTRL-?
@item backward-delete-char (@kbd{^H} @kbd{^?}) (@kbd{^?})
Delete the character behind the cursor.

@tindex vi-backward-delete-char
@kindex X
@item vi-backward-delete-char (unbound) (@kbd{X})
Delete the character behind the cursor, without changing lines.

@tindex backward-delete-word
@item backward-delete-word
Delete the word behind the cursor.

@tindex backward-kill-line
@item backward-kill-line
Kill from the beginning of the line to the cursor position.

@tindex backward-kill-word
@kindex CTRL-W
@kindex ESC-CTRL-H
@kindex ESC-CTRL-?
@item backward-kill-word (@kbd{^W} @kbd{ESC-^H} @kbd{ESC-^?})
Kill the word behind the cursor.

@tindex vi-backward-kill-word
@kindex CTRL-W
@item vi-backward-kill-word (unbound) (@kbd{^W})
Kill the word behind the cursor.

@tindex capitalize-word
@kindex ESC-C
@kindex ESC-c
@item capitalize-word (@kbd{ESC-C} @kbd{ESC-c})
Capitalize the current word and move past it.

@tindex vi-change
@kindex c
@item vi-change (unbound) (@kbd{c})
Read a movement command from the keyboard, and kill from the cursor
position to the endpoint of the movement.  Then enter insert mode.  If
the command is @code{vi-change}, kill the current line.@refill

@tindex vi-change-eol
@kindex C
@item vi-change-eol (unbound) (@kbd{C})
Kill to the end of the line and enter insert mode.

@tindex vi-change-whole-line
@kindex S
@kindex s
@item vi-change-whole-line (unbound) (@kbd{S} @kbd{s})
Kill the current line and enter insert mode.

@tindex copy-region-as-kill
@kindex ESC-W
@kindex ESC-w
@item copy-region-as-kill (@kbd{ESC-W} @kbd{ESC-w})
Copy the area from the cursor to the mark to the kill buffer.

@tindex copy-prev-word
@kindex ESC-CTRL-_
@item copy-prev-word (@kbd{ESC-^_})
Duplicate the word behind the cursor.

@tindex vi-delete
@kindex d
@item vi-delete (unbound) (@kbd{d})
Read a movement command from the keyboard, and kill from the cursor
position to the endpoint of the movement.  If the command is
@code{vi-delete}, kill the current line.@refill

@tindex delete-char
@kindex x
@item delete-char (unbound) (@kbd{x})
Delete the character under the cursor.

@tindex vi-delete-char
@item vi-delete-char (unbound) (@kbd{x})
Delete the character under the cursor.

@tindex delete-word
@kindex ESC-D
@kindex ESC-d
@item delete-word (@kbd{ESC-D} @kbd{ESC-d})
Delete the current word.

@tindex down-case-word
@kindex ESC-L
@kindex ESC-l
@item down-case-word (@kbd{ESC-L} @kbd{ESC-l})
Convert the current word to all lowercase and move past it.

@tindex kill-word
@item kill-word
Kill the current word.

@tindex gosmacs-transpose-chars
@item gosmacs-transpose-chars
Exchange the two characters behind the cursor.

@tindex vi-indent
@kindex >
@item vi-indent (unbound) (@kbd{>})
Indent a number of lines.

@tindex vi-insert
@kindex i
@item vi-insert (unbound) (@kbd{i})
Enter insert mode.

@tindex vi-insert-bol
@kindex I
@item vi-insert-bol (unbound) (@kbd{I})
Move to the beginning of the line and enter insert mode.

@tindex vi-join
@kindex CTRL-X CTRL-J
@item vi-join (@kbd{^X^J})
Join the current line with the next one.

@tindex kill-line
@kindex CTRL-K
@kindex D
@item kill-line (@kbd{^K}) (@kbd{D})
Kill from the cursor to the end of the line.

@tindex vi-kill-line
@item vi-kill-line
Kill from the cursor to the beginning of the line.

@tindex kill-region
@item kill-region
Kill from the cursor to the mark.

@tindex kill-buffer
@kindex CTRL-X CTRL-K
@kindex CTRL-U
@item kill-buffer (@kbd{^X^K}) (@kbd{^U})
Kill the entire buffer.

@tindex kill-whole-line
@kindex CTRL-U
@item kill-whole-line (@kbd{^U})
Kill the current line.

@tindex vi-match-bracket
@kindex CTRL-X CTRL-B
@kindex %
@item vi-match-bracket (@kbd{^X^B}) (@kbd{%})
Move to the bracket character (one of @code{@{@}}, @code{()}, or
@code{[]}) that matches the one under the cursor.@refill

@tindex vi-open-line-above
@kindex O
@item vi-open-line-above (unbound) (@kbd{O})
Open a line above the cursor and enter insert mode.

@tindex vi-open-line-below
@kindex o
@item vi-open-line-below (unbound) (@kbd{o})
Open a line below the cursor and enter insert mode.

@tindex vi-oper-swap-case
@item vi-oper-swap-case
Read a movement command from the keyboard, and swap the case of all
characters from the cursor position to the endpoint of the movement.  If
the movement command is @code{vi-oper-swap-case}, swap the case of all
characters on the current line.@refill

@tindex overwrite-mode
@kindex CTRL-X CTRL-O
@item overwrite-mode (@kbd{^X^O})
Toggle between overwrite mode and insert mode.

@tindex vi-put-after
@kindex p
@item vi-put-after (unbound) (@kbd{p})
Insert the contents of the kill buffer after the cursor.

@tindex quoted-insert
@kindex CTRL-V
@item quoted-insert (@kbd{^V})
Insert the next character typed into the buffer literally.

@tindex quote-line
@kindex ESC-'
@item quote-line (@kbd{ESC-'})
Quote the current line; that is, put a @code{'} character at the
beginning and the end, and convert all @code{'} characters to
@code{\'}.@refill

@tindex quote-region
@kindex ESC-"
@item quote-region (@kbd{ESC-"})
Quote the region from the cursor to the mark.

@tindex vi-replace
@kindex R
@item vi-replace (unbound) (@kbd{R})
Enter overwrite mode.

@tindex vi-repeat-change
@kindex .
@item vi-repeat-change (unbound) (@kbd{.})
Repeat the last vi mode text modification.

@tindex vi-replace-chars
@kindex r
@item vi-replace-chars (unbound) (@kbd{r})
Replace the character under the cursor with a character read from the
keyboard.

@tindex self-insert
@item self-insert (printable characters)
Put a character in the buffer at the cursor position.

@tindex self-insert-unmeta
@kindex ESC-CTRL-I
@kindex ESC-CTRL-J
@kindex ESC-CTRL-M
@item self-insert-unmeta (@kbd{ESC-^I} @kbd{ESC-^J} @kbd{ESC-^M})
Put a character in the buffer after stripping the meta bit and
converting @code{^M} to @code{^J}.@refill

@tindex vi-substitute
@kindex s
@item vi-substitute (unbound) (@kbd{s})
Substitute the next character(s).

@tindex vi-swap-case
@kindex ~
@item vi-swap-case (unbound) (@kbd{~})
Swap the case of the character under the cursor and move past it.

@tindex transpose-chars
@kindex CTRL-T
@item transpose-chars (@kbd{^T})
Exchange the two characters to the left of the cursor if at end of line,
else exchange the character under the cursor with the character to the
left.

@tindex transpose-words
@kindex ESC-T
@kindex ESC-t
@item transpose-words (@kbd{ESC-T} @kbd{ESC-t})
Exchange the current word with the one before it.

@tindex vi-unindent
@kindex <
@item vi-unindent (unbound) (@kbd{<})
Unindent a number of lines.

@tindex up-case-word
@kindex ESC-U
@kindex ESC-u
@item up-case-word (@kbd{ESC-U} @kbd{ESC-u})
Convert the current word to all caps and move past it.

@tindex yank
@kindex CTRL-Y
@kindex P
@item yank (@kbd{^Y}) (@kbd{P})
Insert the contents of the kill buffer at the cursor position.

@tindex yank-pop
@kindex ESC-y
@item yank-pop (@kbd{ESC-y})
Remove the text just yanked, rotate the kill-ring, and yank the new top.
Only works following @code{yank} or @code{yank-pop}.

@tindex vi-yank
@kindex y
@item vi-yank (unbound) (@kbd{y})
Read a movement command from the keyboard, and copy the region from the
cursor position to the endpoint of the movement into the kill buffer.
If the command is @code{vi-yank}, copy the current line.

@tindex vi-yank-eol
@kindex Y
@item vi-yank-eol (unbound) (@kbd{Y})
Copy the region from the cursor position to the end of the line into the
kill buffer.
@end table

@node Arguments, Completion, Modifying Text, Zsh Line Editor
@section Arguments

@table @code
@tindex digit-argument
@kindex ESC-0
@kindex ESC-9
@kindex 0
@kindex 9
@item digit-argument (@kbd{ESC-0}@dots{}@kbd{ESC-9}) (0-9)
Start a new numeric argument, or add to the current one.

@tindex neg-argument
@kindex ESC--
@item neg-argument (@kbd{ESC--})
Changes the sign of the following argument.

@tindex universal-argument
@item universal-argument
Multiply the argument of the next command by 4.
@end table

@node Completion, Miscellaneous, Arguments, Zsh Line Editor
@section Completion

@table @code
@tindex accept-and-menu-complete
@item accept-and-menu-complete
In a menu completion, insert the current completion into the buffer, and
advance to the next possible completion.

@tindex complete-word
@kindex \
@item complete-word (unbound) (@kbd{\})
Attempt completion on the current word.

@tindex delete-char-or-list
@kindex CTRL-D
@item delete-char-or-list (@kbd{^D})
Delete the character under the cursor.  If the cursor is at the end of
the line, list possible completions for the current word.

@tindex execute-named-cmd
@kindex ESC-x
@item execute-named-cmd (@kbd{ESC-x})
Read the name of a editor command and execute it.  A restricted set of
editing functions is available in the mini-buffer.  An interrupt signal,
as defined by the stty setting, will abort the function.  The allowed
functions are: @code{backward-delete-char},
@code{vi-backward-delete-char}, @code{kill-region} (kills the last
word), @code{backward-kill-word}, @code{vi-backward-kill-word},
@code{kill-whole-line}, @code{vi-kill-line}, @code{backward-kill-line}
and @code{accept-line}.  The @key{SPACE} and @key{TAB} keys, if not
bound to one of these functions, will complete the name and then list
the possibilities if the @code{AUTO_LIST} option is set.@refill

@tindex execute-last-named-cmd
@kindex ESC-z
@item execute-last-named-cmd (@kbd{ESC-z})
Redo the last function executed with @code{execute-named-cmd}.@refill

@tindex expand-cmd-path
@item expand-cmd-path
Expand the current command to its full pathname.

@tindex expand-or-complete
@kindex TAB
@kindex CTRL-X
@item expand-or-complete (@key{TAB}) (@key{TAB} @kbd{^X})
Attempt shell expansion on the current word.  If that fails, attempt
completion.

@tindex expand-or-complete-prefix
@item expand-or-complete-prefix
Attempt shell expansion on the current word up to the cursor.

@tindex expand-history
@kindex ESC-SPACE
@kindex ESC-!
@item expand-history (@kbd{ESC-SPACE} @kbd{ESC-!})
Perform history expansion on the edit buffer.

@tindex expand-word
@kindex CTRL-X *
@item expand-word (@kbd{^X*})
Attempt shell expansion on the current word.

@tindex list-choices
@kindex ESC-CTRL-D
@kindex CTRL-D
@kindex =
@item list-choices (@kbd{ESC-^D}) (@kbd{^D=})
List possible completions for the current word.

@tindex list-expand
@kindex CTRL-X g
@kindex CTRL-X G
@kindex CTRL-G
@item list-expand (@kbd{^Xg} @kbd{^XG}) (@kbd{^G})
List the expansion of the current word.

@tindex magic-space
@item magic-space
Perform history expansion and insert a space into the buffer.  This is
intended to be bound to @key{SPACE}.

@tindex menu-complete
@pindex MENU_COMPLETE, use of
@item menu-complete
Like @code{complete-word}, except that menu completion is used.
@xref{Options}, for the @code{MENU_COMPLETE} option.@refill

@tindex menu-expand-or-complete
@item menu-expand-or-complete
Like @code{expand-or-complete}, except that menu completion is used.

@tindex reverse-menu-complete
@item reverse-menu-complete
@xref{Options}, for the @code{MENU_COMPLETE} option.
@end table

@node Miscellaneous,  , Completion, Zsh Line Editor
@section Miscellaneous

@table @code
@tindex accept-and-hold
@kindex ESC-A
@kindex ESC-a
@item accept-and-hold (@kbd{ESC-A} @kbd{ESC-a})
Push the contents of the buffer on the buffer stack and execute it.

@tindex accept-and-infer-next-history
@item accept-and-infer-next-history
Execute the contents of the buffer.  Then search the history list for a
line matching the current one and push the event following onto the
buffer stack.

@tindex accept-line
@kindex CTRL-J
@kindex CTRL-M
@item accept-line (@kbd{^J} @kbd{^M})
Execute the contents of the buffer.

@tindex accept-line-and-down-history
@kindex CTRL-O
@item accept-line-and-down-history (@kbd{^O})
Execute the current line, and push the next history event on the the
buffer stack.

@tindex vi-cmd-mode
@kindex CTRL-X CTRL-V
@kindex CTRL-[
@item vi-cmd-mode (@kbd{^X^V}) (@kbd{^[})
Enter command mode; that is, use the alternate keymap.  Yes, this is
bound by default in emacs mode.

@tindex vi-caps-lock-panic
@kindex H
@kindex K
@item vi-caps-lock-panic (unbound) (@kbd{H} @kbd{K})
Hang until any lowercase key is pressed.  This is for vi users without
the mental capacity to keep track of their caps lock key (like the
author).

@tindex clear-screen
@kindex CTRL-L
@kindex ESC-CTRL-L
@item clear-screen (@kbd{^L} @kbd{ESC-^L})
Clear the screen and redraw the prompt.

@tindex exchange-point-and-mark
@kindex CTRL-X CTRL-X
@item exchange-point-and-mark (@kbd{^X^X})
Exchange the cursor position with the position of the mark.

@tindex get-line
@kindex ESC-G
@kindex ESC-g
@item get-line (@kbd{ESC-G} @kbd{ESC-g})
Pop the top line off the buffer stack and insert it at the cursor
position.

@tindex pound-insert
@kindex #
@pindex INTERACTIVE_COMMENTS, use of
@item pound-insert (unbound) (@kbd{#})
If there is no @code{#} character at the beginning of the current line,
add one.  If there is one, remove it.  In either case, accept the
current line.  The @code{INTERACTIVE_COMMENTS} option must be set for
this to have any usefulness.@refill

@tindex push-input
@item push-input
Push the entire current multiline construct onto the buffer stack and
return to the top-level (@code{PS1}) prompt.  If the current parser
construct is only a single line, this is exactly like @code{push-line}.
Next time the editor starts up or is popped with @code{get-line}, the
construct will be popped off the top of the buffer stack and loaded into
the editing buffer.@refill

@tindex push-line
@kindex CTRL-Q
@kindex ESC-Q
@kindex ESC-q
@item push-line (@kbd{^Q} @kbd{ESC-Q} @kbd{ESC-q})
Push the current buffer onto the buffer stack and clear the buffer.
Next time the editor starts up, the buffer will be popped off the top of
the buffer stack and loaded into the editing buffer.

@tindex push-line-or-edit
@item push-line-or-edit
At the top-level (@code{PS1}) prompt, equivalent to @code{push-line}.
At a secondary (@code{PS2}) prompt, move the entire current multiline
construct into the editor buffer.  The latter is equivalent to
@code{push-line} followed by @code{get-line}.@refill

@tindex redisplay
@kindex CTRL-R
@item redisplay (unbound) (@kbd{^R})
Redisplays the edit buffer.

@tindex run-help
@kindex ESC-H
@kindex ESC-h
@item run-help (@kbd{ESC-H} @kbd{ESC-h})
Push the buffer onto the buffer stack, and execute the command
@code{run-help @var{cmd}}, where @var{cmd} is the current command.
@code{run-help} is normally aliased to @code{man}.@refill

@tindex send-break
@kindex CTRL-C
@item send-break (@kbd{^C})
Abort the current editor function, e.g.@: @code{execute-named-command}, or
the editor itself, e.g.@: if you are in @code{vared}.  Otherwise abort the
parsing of the current line.@refill

@tindex vi-set-buffer
@kindex "
@item vi-set-buffer (unbound) (@kbd{"})
Specify a buffer to be used in the following command.

@tindex vi-set-mark
@kindex m
@item vi-set-mark (unbound) (@kbd{m})
Set the specified mark at the cursor position.

@tindex set-mark-command
@kindex CTRL-@@
@item set-mark-command (@kbd{^@@})
Set the mark at the cursor position.

@tindex spell-word
@kindex ESC-$
@kindex ESC-S
@kindex ESC-s
@item spell-word (@kbd{ESC-$} @kbd{ESC-S} @kbd{ESC-s})
Attempt spelling correction on the current word.

@tindex undefined-key
@item undefined-key
Beep.

@tindex undo
@kindex CTRL-_
@kindex CTRL-X CTRL-U
@kindex CTRL-X u
@kindex u
@item undo (@kbd{^_} @kbd{^X^U} @kbd{^Xu} (@kbd{u})
Incrementally undo the last text modification.

@tindex which-command
@kindex ESC-?
@item which-command (@kbd{ESC-?})
Push the buffer onto the buffer stack, and execute the command
@code{which-command @var{cmd}}, where @var{cmd} is the current command.
@code{which-command} is normally aliased to @code{whence}.@refill
@end table

@node Parameters, Options, Zsh Line Editor, Top
@chapter Parameters
@cindex parameters

@findex typeset, use of
@findex set, use of
@noindent
A parameter has a name, a value, and a number of attributes.  A name may
be any sequence of alphanumeric characters and @code{_}'s, or the single
characters @code{*}, @code{@@}, @code{#}, @code{?}, @code{-}, @code{$},
or @code{!}.  The value may be either a scalar (a string), an
integer, or an array.  To assign a scalar or integer value to a
parameter, use the @code{typeset} builtin.  To assign an array value,
use @samp{set -A @var{name} @var{value} @dots{}}.  The value of a
parameter may also be assigned by writing:@refill

@code{@var{name}=@var{value} @dots{}}

@noindent
If the integer attribute, @code{-i}, is set for @var{name}, the
@var{value} is subject to arithmetic evaluation.@refill

@menu
* Array Parameters::		
* Positional Parameters::	
* Parameters Set By The Shell::	 
* Parameters Used By The Shell::  
@end menu

@node Array Parameters, Positional Parameters,  , Parameters
@section Array Parameters

@noindent
The value of an array parameter may be assigned by writing:

@var{name}=(@var{value} @dots{}) @dots{}

@cindex array elements
@noindent
Individual elements of an array may be selected using a subscript.  A
subscript of the form @code{[@var{exp}]} selects the single element
@var{exp}, where @var{exp} is an arithmetic expression.  The elements
are numbered beginning with 1.  A subscript of the form @code{[*]} or
@code{[@@]} evaluates to all elements of an array; there is no
difference between the two except when they appear within double quotes.
@code{"$foo[*]"} evaluates to @code{"$foo[1] $foo[2] @dots{}"}, while
@code{"$foo[@@]"} evaluates to @code{"$foo[1]"} @code{"$foo[2]"}, etc.
A subscript of the form @code{[@var{exp1},@var{exp2}]} selects all
elements in the range @var{exp1} to @var{exp2}, inclusive.  If one of
the subscripts evaluates to a negative number, say @code{-@var{n}}, then
the @var{n}'th element from the end of the array is used.  Thus
@code{$foo[-3]} is the third element from the end of the array
@code{foo}, and @code{$foo[1,-1]} is the same as @code{$foo[*]}.@refill

@cindex substrings
@noindent
Subscripting may also be performed on non-array values, in which case
the subscripts specify a substring to be extracted.  For example, if
@code{FOO} is set to @code{foobar}, then @code{echo $FOO[2,5]} prints
@code{ooba}.@refill

@noindent
If a subscript is used on the left side of an assignment the selected
range is replaced by the expression on the right side.

@noindent
If the opening bracket or the comma is directly followed by an opening
parenthesis the string up to the matching closing parenthesis is
considered to be a list of flags.  The possible flags are:

@table @code
@item e
The argument is expanded using full shell expansion first.

@item w
If the parameter subscripted is a scalar, then this flag makes
subscription work on a per-word basis instead of on a per-character
basis.

@item s:@var{string}:
Defines the @var{string} that separates words (for use with the @code{w}
flag).@refill

@item r
The subscript is taken as a pattern, and the result is the first
matching array element, substring, or word (if the parameter is an
array, scalar, or a scalar and the @code{w} flag is given,
respectively).  Note that this is like giving a number;
@code{$foo[(r)??,3]} and @code{$foo[(r)??,(r)f*]} work.@refill

@item R
Like @code{r}, but returns the last match.

@item i
Like @code{r}, but returns the index of the match.  This may not be
combined with a second argument.@refill

@item I
Like @code{i}, but returns the index of the last match.

@item n:@var{expr}:
If combined with @code{r}, @code{R}, @code{i}, or @code{I}, makes them
return the @var{n}'th or @var{n}'th last match (assuming @var{expr}
evaluates to @var{n}).@refill
@end table

@node Positional Parameters, Parameters Set By The Shell, Array Parameters, Parameters
@section Positional Parameters

@noindent
Positional parameters are set by the shell on invocation, by the
@code{set} builtin, or by direct assignment.  The parameter @var{n},
where @var{n} is a number, is the @var{n}'th positional parameter.  The
parameters @code{*}, @code{@@}, and @code{argv} are arrays containing
all the positional parameters; thus @code{argv[@var{n}]}, is equivalent
to simply @var{n}.@refill

@node Parameters Set By The Shell, Parameters Used By The Shell, Positional Parameters, Parameters
@section Parameters Set By The Shell

@noindent
The following parameters are automatically set by the shell:

@table @code
@vindex !
@item !
The process id of the last background command invoked.

@vindex #
@item #
The number of positional parameters in decimal.

@vindex ARGC
@item ARGC
Same as @code{#}.

@vindex $
@item $
The process id of this shell.

@vindex -
@item -
Flags supplied to the shell on invocation or by the @code{set} or
@code{setopt} commands.@refill

@vindex *
@item *
An array containing the positional parameters.

@vindex argv
@item argv
Same as @code{*}.

@vindex @@
@item @@
Same as @code{argv[@@]}.

@vindex ?
@item ?
The exit value returned by the last command.

@vindex status
@item status
Same as @code{?}.

@vindex _
@item _
The last argument of the previous command.  Also, this parameter is set
in the environment of every command executed to the full pathname of the
command.

@vindex EGID
@item EGID
The effective group id of the shell process.

@vindex EUID
@item EUID
The effective user id of the shell process.

@vindex ERRNO
@item ERRNO
The value of @code{errno} as set by the most recently failed system
call.  This value is system dependent and is intended for debugging
purposes.@refill

@vindex GID
@item GID
The group id of the shell process.

@vindex HOST
@   ¨   ∞   ¥   ∏   º   ¿   ƒ   »   Ã   –   ‘   ÿ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                item HOST
The current hostname.

@vindex HOSTTYPE
@item HOSTTYPE
A string corresponding to the type of the host the shell is running on.

@vindex LINENO
@item LINENO
The line number of the current line within the current script being
executed.

@vindex OLDPWD
@item OLDPWD
The previous working directory.

@vindex OPTARG
@item OPTARG
The value of the last option argument processed by the @code{getopts}
command.@refill

@vindex OPTIND
@item OPTIND
The index of the last option argument processed by the @code{getopts}
command.@refill

@vindex PPID
@item PPID
The process id of the parent of the shell.

@vindex PWD
@item PWD
The present working directory.

@vindex RANDOM
@item RANDOM
A random integer from 0 to 32767, newly generated each time this
parameter is referenced.  The random number generator can be seeded by
assigning a numeric value to @code{RANDOM}.@refill

@vindex SECONDS
@item SECONDS
The number of seconds since shell invocation.  If this parameter is
assigned a value, then the value returned upon reference will be the
value that was assigned plus the number of seconds since the assignment.

@vindex SHLVL
@item SHLVL
Incremented by one each time a new shell is started.

@vindex signals
@item signals
An array containing the names of the signals.

@vindex TTY
@item TTY
The name of the tty associated with the shell, if any.

@vindex UID
@item UID
The user id of the shell process.

@vindex USERNAME
@item USERNAME
@vindex LOGNAME
@itemx LOGNAME
The username corresponding to the user id of the shell process.

@vindex VERSION
@item VERSION
The version number of this @code{zsh}.
@end table

@node Parameters Used By The Shell,  , Parameters Set By The Shell, Parameters
@section Parameters Used By The Shell

@noindent
The following parameters are used by the shell:

@table @code
@vindex ARGV0
@item ARGV
If exported, its value is used as argv[0] of external commands.  Usually
used in constructs like @samp{ARGV0=emacs nethack}.@refill

@vindex BAUD
@item BAUD
The baud rate of the current connection.  Used by the line editor update
mechanism to compensate for a slow terminal by delaying updates until
necessary.  This may be profitably set to a lower value in some
circumstances, e.g.@: for slow modems dialing into a communications server
which is connected to a host via a fast link; in this case, this
variable would be set by default to the speed of the fast link, and not
the modem.  This parameter should be set to the baud rate of the slowest
part of the link for best performance.  The compensation mechanism can
be turned off by setting the variable to zero.

@vindex cdpath
@vindex CDPATH
@item cdpath (CDPATH)
An array (colon-separated list) of directories specifying the search
path for the @code{cd} command.@refill

@vindex COLUMNS
@item COLUMNS
The number of columns for this terminal session.  Used for printing
select lists and for the line editor.

@vindex DIRSTACKSIZE
@pindex AUTO_PUSHD, use of
@item DIRSTACKSIZE
The maximum size of the directory stack.  If the stack gets larger than
this, it will be truncated automatically.  This is useful with the
@code{AUTO_PUSHD} option.@refill

@vindex FCEDIT
@item FCEDIT
The default editor for the @code{fc} builtin.

@vindex fignore
@vindex FIGNORE
@item fignore (FIGNORE)
An array (colon-separated list) containing the suffixes of files to be
ignored during filename completion.

@vindex fpath
@vindex FPATH
@item fpath (FPATH)
An array (colon-separated list) of directories specifying the search
path for function definitions.  This path is searched when a function
with the @code{-u} attribute is referenced.  If an executable file is
found, then it is read and executed in the current environment.@refill

@vindex HISTCHARS
@item HISTCHARS
Three characters used by the shell's history and lexical analysis
mechanism.  The first character signals the start of a history
substitution (default @code{!}).  The second character signals the start
of a quick history substitution (default @code{^}).  The third character
is the comment character (default @code{#}).@refill

@vindex HISTFILE
@item HISTFILE
The file to save the history in when an interactive shell exits.  If
unset, the history is not saved.

@vindex HISTSIZE
@item HISTSIZE
The maximum size of the history list.

@vindex HOME
@item HOME
The default argument for the @code{cd} command.

@vindex IFS
@item IFS
Internal field separators, normally space, tab, and newline, that are
used to separate words which result from command or parameter
substitution and words read by the @code{read} builtin.@refill

@vindex KEYTIMEOUT
@item KEYTIMEOUT
The time the shell waits, in hundredths of seconds, for another key to
be pressed when reading bound multi-character sequences.

@vindex LINES
@item LINES
The number of lines for this terminal session.  Used for printing select
lists and for the line editor.

@vindex LISTMAX
@item LISTMAX
In the line editor, the number of filenames to list without asking
first.  If set to zero, the shell asks only if the listing would scroll
off the screen.

@vindex LITHISTSIZE
@item LITHISTSIZE
The maximum size of the literal history list (before history expansion).

@vindex LOGCHECK
@item LOGCHECK
The interval in seconds between checks for login/logout activity using
the @code{watch} parameter.@refill

@vindex MAIL
@item MAIL
If this parameter is set and @code{mailpath} is not set, the shell looks
for mail in the specified file.  By default it is set to the user's
system mailbox.@refill

@vindex MAILCHECK
@item MAILCHECK
The interval in seconds between checks for new mail.

@vindex mailpath
@vindex MAILPATH
@item mailpath (MAILPATH)
An array (colon-separated list) of filenames to check for new mail.
Each filename can be followed by a @code{?} and a message that will be
printed.  The sequence @code{$_} in the message will be replaced by the
name of the mail file.  The default message is @samp{You have new
mail}.  If an element is a directory instead of a file the shell will
recursively check every file in every subdirectory of the
element.@refill

@vindex manpath
@vindex MANPATH
@item manpath (MANPATH)
An array (colon-separated list) whose value is not used by the shell.
The @code{manpath} array can be useful, however, since setting it also
sets @code{MANPATH}, and vice versa.@refill

@vindex NULLCMD
@cindex null command, setting
@cindex csh, null command style
@cindex ksh, null command style
@item NULLCMD
The command name to assume if a redirection is specified with no
command.  Defaults to @code{cat}.  For sh/ksh-like behavior, change this
to @code{:}.  For csh-like behavior, unset this parameter; the shell will
print an error message if null commands are entered.@refill

@vindex path
@vindex PATH
@item path (PATH)
An array (colon-separated list) of directories to search for commands.
When this parameter is set, each directory is scanned and all files
found are put in a hash table.

@vindex POSTEDIT
@item POSTEDIT
This string is output whenever the line editor exits.  It usually
contains termcap strings to reset the terminal.

@vindex PROMPT
@item PROMPT
The primary prompt string, printed before a command is read; the default
is @samp{%m%# }.  If the escape sequence takes an optional integer, it
should appear between the @code{%} and the next character of the
sequence.  The following escape sequences are recognized:@refill

@table @code
@item %d
@itemx %/
Present working directory (@code{$PWD}).

@item %~
@code{$PWD}.  If it has a named directory as its prefix, that part is
replaced by a @code{~} followed by the name of the directory.  If it
starts with @code{$HOME}, that part is replaced by a @code{~}.@refill

@item %c
@itemx %.
@itemx %C
Trailing component of @code{$PWD}.  An integer may follow the @code{%}
to get more than one component.  Unless @code{%C} is used, tilde
expansion is performed first.@refill

@item !
@itemx %h
@itemx %!
Current history event number

@item %M
The full machine hostname.

@item %m
The hostname up to the first @samp{.}.  An integer may follow the @code{%} to
specify how many components of the hostname are desired.@refill

@item %S (%s)
Start (stop) standout mode.

@item %U (%u)
Start (stop) underline mode.

@item %B (%b)
Start (stop) boldface mode.

@item %t
@itemx %@@
Current time of day, in 12-hour, am/pm format.

@item %T
Current time of day, in 24-hour format.

@item %*
Current time of day in 24-hour format, with seconds.

@item %n
@code{$USERNAME}.

@item %w
The date in day-dd format.

@item %W
The date in mm/dd/yy format.

@item %D
The date in yy-mm-dd format.

@item %D@{@var{string}@}
@var{string} is formatted using the @code{strftime} function.  See
@code{strftime(3)} for more details, if your system has it.@refill

@item %l
The line (tty) the user is logged in on.

@item %?
The return code of the last command executed just before the
prompt.@refill 

@item %_
The status of the parser, i.e. the shell constructs (like @code{if} and
@code{for}) that have been started on the command line.  If given an
integer number, that many strings will be printed.@refill

@item %E
Clears to end of screen.  Useful with @code{ALWAYS_LAST_PROMPT}
set.@refill

@item %#
A @code{#} if the shell is running as root, a @code{%} if not.
Equivalent to @code{%(#.#.%%)}@refill

@item %v
The value of the first element of the @code{psvar} array parameter.
Following the @code{%} with an integer gives that element of the
array.@refill

@item %@{@dots{}%@}
Include a string as a literal escape sequence.  The string within the
braces should not change the cursor position.@refill

@item %(x.@var{true-text}.@var{false-text})
Specifies a ternary expression.  The character following the @code{x} is
arbitrary; the same character is used to separate the text for the true
result from that for the false result.  Both the separator and the right
parenthesis may be escaped with a backslash.  @var{true-text} and
@var{false-text} may both contain arbitrarily-nested escape sequences,
including further ternary expressions.  The left parenthesis may be
preceded or followed by a positive integer @var{n}, which defaults to
zero.  The text character @code{x} may be any of the following:@refill

@table @code
@item c
@itemx .
@itemx ~
True if the current path, with prefix replacement, has at least @var{n}
elements.@refill
@item /
@itemx C
True if the current absolute path has at least @var{n} elements.
@item t
True if the time in minutes is equal to @var{n}.
@item T
True if the time in hours is equal to @var{n}.
@item d
True if the day of the month is equal to @var{n}.
@item D
True if the month is equal to @var{n} (January = 0).
@item w
True if the day of the week is equal to @var{n} (Sunday = 0).
@item ?
True if the exit status of the last command was @var{n}.
@item # 
True if the effective uid of the current process is @var{n}.
@item g
True if the effective gid of the current process is @var{n}.
@item L
True if the @code{SHLVL} parameter is at least @var{n}.
@item S
True if the @code{SECONDS} parameter is at least @var{n}.
@item v
True if the array @code{psvar} has at least @var{n} elements.
@item _
True if at least @var{n} shell constructs were started.
@end table
@end table

@vindex PROMPT2
@item PROMPT2
The secondary prompt, printed when the shell needs more information to
complete a command.  Recognizes the same escape sequences as
@code{PROMPT}.  The default is @samp{> }.@refill

@vindex PROMPT3
@item PROMPT3
Selection prompt used within a @code{select} loop.  Recognizes the same
escape sequences as @code{PROMPT}.  The default is @samp{?# }.@refill

@vindex PROMPT4
@item PROMPT4
The execution trace prompt.  Default is @samp{+ }.

@vindex PS1
@vindex PS2
@vindex PS3
@vindex PS4
@item PS1
@itemx PS2
@itemx PS3
@itemx PS4
Same as @code{PROMPT}, @code{PROMPT2}, @code{PROMPT3}, and @code{PROMPT4},
respectively.@refill

@vindex psvar
@vindex PSVAR
@item psvar (PSVAR)
An array (colon-separated list) whose first nine values can be used in
@code{PROMPT} strings.  Setting @code{psvar} also sets @code{PSVAR}, and
vice versa.@refill

@vindex prompt
@item prompt
Same as @code{PROMPT}.

@vindex READNULLCMD
@item READNULLCMD
The command name to assume if a single input redirection is specified
with no command.  Defaults to @code{more}.@refill

@vindex REPORTTIME
@item REPORTTIME
If nonzero, commands whose combined user and system execution times
(measured in seconds) are greater than this value have timing statistics
printed for them.@refill

@vindex RPROMPT
@vindex RPS1
@item RPROMPT
@itemx RPS1
This prompt is displayed on the right-hand side of the screen when the
primary prompt is being displayed on the left.  This does not work if
the @code{SINGLE_LINE_ZLE} option is set.  Recognizes the same escape
sequences as @code{PROMPT}.@refill

@vindex SAVEHIST
@item SAVEHIST
The maximum number of history events to save in the history file.

@vindex SPROMPT
@item SPROMPT
The prompt used for spelling correction.  The sequence @code{%R} expands
to the string which presumably needs spelling correction, and @code{%r}
expands to the proposed correction.  All other @code{PROMPT} escapes are
also allowed.@refill

@vindex STTY
@item STTY
If this parameter is set in a command's environment, the shell runs the
@code{stty} command with the value of this parameter as arguments in
order to set up the terminal before executing the command.  The modes
apply only to the command, and are reset when it finishes or is
suspended.  If the command is suspended and continued later with the
@code{fg} or @code{wait} builtins it will see the modes specified by
STTY, as if it were not suspended.  This (intentionally) does not apply
if the command is continued via @code{kill -CONT}.  @code{STTY} is
ignored if the command is run in the background, or if it is in the
environment of the shell but not explicitly assigned to in the input
line.  This avoids running @code{stty} at every external command by
accidentally exporting it.  Also note that @code{STTY} should not be
used for window size specifications; these will not be local to the
command.@refill
  
@vindex TIMEFMT
@item TIMEFMT
The format of process time reports with the @code{time} keyword.  The
default is @samp{%E real  %U user  %S system  %P %J}.  Recognizes the
following escape sequences:@refill

@table @code
@item %U
CPU seconds spent in user mode.
@item %S
CPU seconds spent in kernel mode.
@item %E
Elapsed time in seconds.
@item %P
The CPU percentage, computed as (%U+%S)/%E.
@item %W
Number of times the process was swapped.
@item %X
The average amount of (shared) text space used in Kbytes.
@item %D
The average amount of (unshared) data/stack space used in Kbytes.
@item %K
The total space used (%X+%D) in Kbytes.
@item %M
The maximum memory the process had in use at any time in Kbytes.
@item %F
The number of major page faults (page needed to be brought from
disk).@refill
@item %R
The number of minor page faults.
@item %I
The number of input operations.
@item %O
The number of output operations.
@item %r
The number of socket messages received.
@item %s
The number of socket messages sent.
@item %k
The number of signals received.
@item %w
Number of voluntary context switches (waits).
@item %c
Number of involuntary context switches.
@item %J
The name of this job.
@end table

@vindex TMOUT
@item TMOUT
If this parameter is nonzero, the shell will terminate if a command is
not entered within the specified number of seconds after issuing a
prompt.

@vindex TMPPREFIX
@item TMPPREFIX
A pathname prefix which the shell will use for all temporary files.
Note that this should include an initial part for the file name as well
as any directory names.  The default is /tmp/zsh.

@vindex watch
@vindex WATCH
@item watch (WATCH)
An array (colon-separated list) of login/logout events to report.  If it
contains the single word @samp{all}, then all login/logout events are
reported.  If it contains the single word @samp{notme}, then all
login/logout events are reported except for those originating from
@code{$USERNAME}.  An entry in this list may consist of a username, an
@code{@@} followed by a remote hostname, and a @code{%} followed by a
line (tty).  Any or all of these components may be present in an entry;
if a login/logout event matches all of them, it is reported.@refill

@vindex WATCHFMT
@item WATCHFMT
The format of login/logout reports if the @code{watch} parameter is set.
Default is @samp{%n has %a %l from %m}.  Recognizes the following escape
sequences:@refill

@table @code
@item %n
The name of the user that logged in/out.

@item %a
The observed action, i.e. @samp{logged on} or @samp{logged off}.

@item %l
The line (tty) the user is logged in on.

@item %M
The full hostname of the remote host.

@item %m
The hostname up to the first @samp{.}.  If only the IP address is
available or the utmp field contains the name of an X-windows display,
the whole name is printed.@refill

@noindent
NOTE: The @code{%m} and @code{%M} escapes will work only if there is a
host name field in the @code{utmp} on your machine.  Otherwise they are
treated as ordinary strings.@refill

@item %S (%s)
Start (stop) standout mode.

@item %U (%u)
Start (stop) underline mode.

@item %B (%b)
Start (stop) boldface mode.

@item %t
@itemx %@@
The time, in 12-hour, am/pm format.

@item %T
The time, in 24-hour format.

@item %w
The date in day-dd format.

@item %W
The date in mm/dd/yy format.

@item %D
The date in yy-mm-dd format.

@item %(x:@var{true-text}:@var{false-text})
Specifies a ternary expression.  The character following the @code{x} is
arbitrary; the same character is used to separate the text for the true
result from that for the false result.  Both the separator and the right
parenthesis may be escaped with a backslash.  Ternary expressions may be
nested.@refill

@noindent
The test character @code{x} may be any one of @code{l}, @code{n},
@code{m}, or @code{M}, which indicate a true result if the corresponding
escape sequence would return a non-empty value; or it may be @code{a},
which indicates a true result if the watched user has logged in, or
false if he has logged out.  Other characters evaluate to neither true
nor false; the entire expression is omitted in this case.@refill

@noindent
If the result is true, then the @var{true-text} is formatted according
to the result above and printed, and the @var{false-text} is skipped.
If false, the @var{true-text} is skipped, and the @var{false-text} is
formatted and printed.  Either or both of the branches may be empty, but
both separators must always be present.@refill
@end table

@vindex WORDCHARS
@item WORDCHARS
A list of nonalphanumeric characters considered part of a word by the
line editor.

@vindex ZDOTDIR
@item ZDOTDIR
The directory to search for shell startup files (@file{.zshrc}, etc), if
not @code{$HOME}.@refill
@end table

@node Options, Shell Builtin Commands, Parameters, Top
@chapter Options
@cindex options

@noindent
The following options may be set upon invocation of the shell, or with
the @code{set} or @code{setopt} builtins.  The names are
case-insensitive and underscores are ignored, that is, @samp{allexport}
is equivalent to @samp{A_lleXP_ort}.@refill

@table @code
@cindex export, automatic
@pindex ALL_EXPORT
@item ALL_EXPORT (-a)
All parameters subsequently defined are automatically exported.

@cindex history, appending to file
@pindex ALWAYS_LAST_PROMPT
@item ALWAYS_LAST_PROMPT
If unset, key functions that list completions try to return to the last
prompt if given a numeric argument.  If set, these functions try to
return to the last prompt if given no numeric argument.@refill

@pindex ALWAYS_TO_END
@item ALWAYS_TO_END
If a completion with the cursor in the word was started and it results
in only one match, the cursor is placed at the end of the word.

@pindex APPEND_HISTORY
@item APPEND_HISTORY
If this is set, zsh sessions will append their history list to the
history file, rather than overwrite it.  Thus, multiple parallel zsh
sessions will all have their history lists added to the history file, in
the order they are killed.  @xref{Shell Builtin Commands}, for the
@code{fc} command.@refill

@cindex cd, automatic
@pindex AUTO_CD
@item AUTO_CD (-J)
If a command is not in the hash table, and there exists an executable
directory by that name, perform the @code{cd} command to that directory.

@cindex completion, listing choices
@pindex AUTO_LIST
@item AUTO_LIST (-9)
Automatically list choices on an ambiguous completion.

@cindex completion, menu, on TAB
@pindex AUTO_MENU
@item AUTO_MENU
Automatically use menu completion after the second consecutive request
for completion, for example by pressing the @key{TAB} key repeatedly.
This option is overriden by @code{MENU_COMPLETE}.@refill

@cindex directories, named
@pindex AUTO_NAME_DIRS
@item AUTO_NAME_DIRS
Any parameter that is set to the absolute name of a directory
immediately becomes a name for that directory in the usual form
@code{~param}.  If this option is not set, the parameter must be used in
that form for it to become a name (a command-line completion is
sufficient for this).@refill

@pindex AUTO_PARAM_KEYS
@item AUTO_PARAM_KEYS
If a parameter name was completed and the next character typed is one of
those that have to come directly after the name (like @code{@}},
@code{:}, etc.), they are placed there automatically.@refill

@cindex cd, behaving like pushd
@cindex pushd, making cd behave like
@pindex AUTO_PUSHD
@item AUTO_PUSHD (-N)
Make @code{cd} act like @code{pushd}.

@cindex slash, removing trailing
@pindex AUTO_REMOVE_SLASH
@item AUTO_REMOVE_SLASH
When the last character resulting from a completion is a slash and the next
character typed is a word delimiter, remove the slash.@refill

@cindex jobs, resuming automatically
@cindex resuming jobs automatically
@pindex AUTO_RESUME
@item AUTO_RESUME (-W)
Treat single word simple commands without redirection as candidates for
resumption of an existing job.

@cindex jobs, background priority
@cindex background jobs, priority of
@pindex BGNICE
@item BGNICE (-6)
Run all background jobs at a lower priority.  This option is set by
default.

@cindex brace expansion, extending
@cindex expansion, brace, extended
@pindex BRACE_CCL
@item BRACE_CCL
Allow brace expansions of the form @code{@{a-zA-Z@}}, etc.

@cindex cd, to parameter
@pindex CDABLE_VARS
@item CDABLE_VARS (-T)
If the argument to a @code{cd} command (or an implied cd with the
@code{AUTO_CD} option set) is not a directory, and does not begin with a
slash, try to expand the expression as if it were preceded by a
@code{~} (@pxref{Filename Expansion}).@refill 

@cindex links, symbolic
@cindex symbolic links
@pindex CHASE_LINKS
@item CHASE_LINKS (-w)
Resolve symbolic links to their true values.

@cindex aliases, completion of
@pindex COMPLETE_ALIASES
@item COMPLETE_ALIASES
If set, aliases on the command line are not internally substituted
before completion is attempted.

@pindex COMPLETE_IN_WORD
@item COMPLETE_IN_WORD
If unset, the cursor is moved to the end of the word if completion is
started.  Otherwise it stays where it is and completion is done from
both ends.

@cindex correction, spelling
@cindex spelling correction
@pindex CORRECT
@item CORRECT (-0)
Try to correct the spelling of commands.

@pindex CORRECT_ALL
@item CORRECT_ALL (-O)
Try to correct the spelling of all arguments in a line.

@cindex csh, history style
@pindex CSH_JUNKIE_HISTORY
@item CSH_JUNKIE_HISTORY
A history reference without an event specifier will always refer to the
previous command.

@cindex csh, loop style
@cindex loop style, csh
@pindex CSH_JUNKIE_LOOPS
@item CSH_JUNKIE_LOOPS
Allow loop bodies to take the form @samp{@var{list}; end} instead of
@samp{do @var{list}; done}.@refill

@pindex CSH_JUNKIE_PAREN
@item CSH_JUNKIE_PAREN
Allow @code{for}, @code{if} and @code{while} loops where the argument
list is given in parentheses.  Otherwise, the parentheses will be
treated as specifying a subshell.@refill

@cindex csh, quoting style
@cindex quoting style, csh
@pindex CSH_JUNKIE_QUOTES
@item CSH_JUNKIE_QUOTES
Complain if a quoted expression runs off the end of a line; prevent
quoted expressions from containing unescaped newlines.

@pindex GLOB_SUBST
@item GLOB_SUBST
Treat any characters resulting from parameter substitution as being
eligible for file expansion and filename generation, and any characters
resulting from command substitution as being eligible for filename
generation.@refill

@cindex csh, null globbing style
@cindex null globbing, csh style
@cindex globbing, null, csh style
@pindex CSH_NULL_GLOB
@item CSH_NULL_GLOB
If a pattern for filename generation has no matches, delete the pattern
from the argument list; do not report an error unless all the patterns
in a command have no matches.  Overrides @code{NULL_GLOB}.@refill

@cindex exit status, trapping
@pindex ERR_EXIT
@item ERR_EXIT (-e)
If a command has a non-zero exit status, execute the @code{ZERR} trap, if
set, and exit.@refill

@cindex globbing, extended
@pindex EXTENDED_GLOB
@item EXTENDED_GLOB
Treat the @code{#} and @code{^} characters as part of patterns for
filename generation, etc.  An initial unquoted @code{~} always produces
named directory expansion (@pxref{Filename Expansion}).@refill

@cindex history, timestamping
@pindex EXTENDED_HISTORY
@item EXTENDED_HISTORY
Save beginning and ending timestamps to the history file.  The format of
these timestamps is @code{:@var{<beginning time>}:@var{<ending
time>}:@var{<command>}}.@refill

@pindex GLOB_COMPLETE
@item GLOB_COMPLETE
When the current word has a glob pattern, do not insert all the words
resulting from the expansion but cycle through them like
@code{MENU_COMPLETE}.  If no matches are found, a @code{*} is added to
the end of the word, or inserted at the cursor if
@code{COMPLETE_IN_WORD} is set, and completion is attempted again.
Using patterns works not only for files but for all completions, such as
options, user names, etc.@refill

@cindex globbing, of . files
@pindex GLOB_DOTS
@item GLOB_DOTS (-4)
Do not require a leading @code{.} in a filename to be matched
explicitly.@refill

@cindex hashing, of commands
@cindex command hashing
@pindex HASH_CMDS
@item HASH_CMDS
Place the location of each command in the hash table the first time it
is executed.  If this option is unset, no path hashing will be done at
all.@refill

@cindex hashing, of directories
@cindex directories, hashing
@pindex HASH_DIRS
@item HASH_DIRS
Whenever a command is executed, hash the directory containing it, as
well as all directories that occur earlier in the path.  Has no effect
if @code{HASH_CMDS} is unset.@refill

@pindex HASH_LIST_ALL
@item HASH_LIST_ALL
Whenever a command completion is attempted, make sure the entire command
path is hashed first.  This makes the first completion slower.

@cindex history, ignoring duplicates
@pindex HIST_IGNORE_DUPS
@item HIST_IGNORE_DUPS (-h)
Do not enter command lines into the history list if they are duplicates
of the previous event.

@cindex history, ignoring spaces
@pindex HIST_IGNORE_SPACE
@item HIST_IGNORE_SPACE (-g)
Do not enter command lines into the history list if they begin with a
blank.

@cindex history, storing as literal
@pindex HIST_LIT
@item HIST_LIT (-j)
Use literal (unparsed) versions of the history lines in the editor.

@pindex HIST_NO_STORE
@item HIST_NO_STORE
Remove the @code{history} (@code{fc -l}) command from the history
when invoked.@refill

@cindex history, verifying substitution
@pindex HIST_VERIFY
@item HIST_VERIFY
Whenever the user enters a line with history substitution, don't execute
the line directly; instead, perform history substitution and reload the
line into the editing buffer.

@cindex brace expansion, disabling
@cindex expansion, brace, disabling
@cindex disabling brace expansion
@pindex IGNORE_BRACES
@item IGNORE_BRACES (-I)
Do not perform brace expansion.

@cindex EOF, ignoring
@pindex IGNORE_EOF
@item IGNORE_EOF (-7)
Do not exit on end-of-file.  Require the use of @code{exit} or
@code{logout} instead.@refill

@pindex INTERACTIVE
@item INTERACTIVE (-i)
This is an interactive shell.

@cindex comments, in interactive shells
@pindex INTERACTIVE_COMMENTS
@item INTERACTIVE_COMMENTS (-k)
Allow comments even in interactive shells.

@cindex ksh, option printing style
@cindex option printing, ksh style
@pindex KSH_OPTION_PRINT
@item KSH_OPTION_PRINT
Alters the way options settings are printed.

@cindex completions, ambiguous
@cindex ambiguous completions
@pindex LIST_AMBIGUOUS
@item LIST_AMBIGUOUS
If this option is set completions are shown only if the completions
don't have an unambiguous prefix or suffix that could be inserted in the
command line.

@cindex files, marking type of
@cindex marking file types
@pindex LIST_TYPES
@item LIST_TYPES (-X)
When listing files that are possible completions, show the type of each
file with a trailing identifying mark.

@pindex LOGIN
@item LOGIN (-l)
This is a login shell.

@cindex jobs, list format
@cindex list format, of jobs
@pindex LONG_LIST_JOBS
@item LONG_LIST_JOBS (-R)
List jobs in the long format by default.

@pindex MAGIC_EQUAL_SUBST
@item MAGIC_EQUAL_SUBST
All unquoted arguments of the form
@code{@var{identifier}=@var{expression}} have file expansion performed
on @var{expression} as if it were a parameter assignment, although the
argument is not otherwise treated specially.@refill

@cindex mail, warning of arrival
@pindex MAIL_WARNING
@item MAIL_WARNING (-U)
Print a warning message if a mail file has been accessed since the shell
last checked.

@cindex directories, marking
@cindex marking directories
@pindex MARK_DIRS
@item MARK_DIRS (-8)
Append a trailing @code{/} to all directory names resulting from filename
generation (globbing).@refill

@cindex completion, menu
@pindex MENU_COMPLETE
@item MENU_COMPLETE (-Y)
On an ambiguous completion, instead of listing possibilities or beeping,
insert the first match immediately.  Then when completion is requested
again, remove the first match and insert the second match, etc.  When
there are no more matches, go back to the first one again.
@code{reverse-menu-complete} may be used to loop through the list in the
other direction.  This option overrides @code{AUTO_MENU}.@refill

@cindex job control, allowing
@pindex MONITOR
@item MONITOR (-m)
Allow job control.  Set by default in interactive shells.

@cindex globbing, malformed pattern
@pindex NO_BAD_PATTERN
@item NO_BAD_PATTERN (-2)
If a pattern for filename generation is badly formed, leave it unchanged
in the argument list instead of printing an error.

@cindex history, disabling substitution
@cindex disabling history substitution
@pindex NO_BANG_HIST
@item NO_BANG_HIST (-K)
Do not perform textual history substitution.  Do not treat the @code{!}
character specially.@refill

@cindex beep, disabling
@cindex disabling the beep
@pindex NO_BEEP
@item NO_BEEP (-B)
Do not beep.

@cindex file clobbering, preventing
@cindex clobbering, of files
@pindex NO_CLOBBER
@item NO_CLOBBER (-1)
Prevents @code{>} redirection from truncating existing files.  @code{>!}
may be used to truncate a file instead.  Also prevents @code{>>} from
creating files.  @code{>>!} may be used instead.@refill

@cindex filename substitution, =
@pindex NO_EQUALS
@item NO_EQUALS
Don't perform @code{=} filename substitution.

@cindex command execution, preventing
@pindex NO_EXEC
@item NO_EXEC (-n)
Read commands and check them for syntax errors, but do not execute them.

@cindex flow control
@pindex NO_FLOW_CONTROL
@item NO_FLOW_CONTROL
Disable output flow control via start/stop characters (usually assigned
to @kbd{^S}/@kbd{^Q}) in the shell's editor.@refill

@cindex globbing, disabling
@cindex disabling globbing
@pindex NO_GLOB
@item NO_GLOB (-F)
Disable filename generation.

@cindex history, beeping
@cindex beep, history
@pindex NO_HIST_BEEP
@item NO_HIST_BEEP
Don't beep when an attempt is made to access a history entry which isn't
there.

@cindex jobs, nohup
@pindex NO_HUP
@item NO_HUP
Don't send the @code{HUP} signal to running jobs when the shell exits.

@cindex completion, beep on ambiguous
@cindex beep, ambiguous completion
@pindex NO_LIST_BEEP
@item NO_LIST_BEEP
Don't beep on an ambiguous completion.

@cindex globbing, no matches
@pindex NO_NOMATCH
@item NO_NOMATCH (-3)
If a pattern for filename generation has no matches, leave it unchanged
in the argument list instead of printing an error.  This also applies
to file expansion of an initial @code{~} or @code{=}.@refill

@cindex prompt, without CR
@pindex NO_PROMPT_CR
@item NO_PROMPT_CR (-V)
Don't print a carriage return just before printing a prompt in the line
editor.

@cindex startup files, sourcing
@pindex NO_RCS
@item NO_RCS (-f)
Source only the @file{/etc/zshenv} file.
Do not source the @file{.zshenv}, @file{/etc/zprofile}, @file{.zprofile},
@file{/etc/zshrc}, @file{.zshrc}, @file{/etc/zlogin}, @file{.zlogin}, or 
@file{.zlogout} files.@refill

@pindex NO_SHORT_LOOPS
@item NO_SHORT_LOOPS
Disallow the short forms of @code{for}, @code{select}, @code{if}, and
@code{function} constructs.@refill

@cindex background jobs, notification
@cindex notification of background jobs
@pindex NOTIFY
@item NOTIFY (-5)
Report the status of background jobs immediately, rather than waiting
until just before printing a prompt.

@cindex parameters, error on substituting unset
@cindex unset parameters, error on substituting
@pindex NO_UNSET
@item NO_UNSET (-u)
Treat unset parameters as an error when substituting.

@cindex globbing, no matches
@pindex NULL_GLOB
@item NULL_GLOB (-G)
If a pattern for filename generation has no matches, delete the pattern
from the argument list instead of reporting an error.  Overrides
@code{NO_NOMATCH}.@refill

@cindex sorting, numerically
@pindex NUMERIC_GLOBSORT
@item NUMERIC_GLOBSORT
If numeric filenames are matched by a filename generation pattern, sort
the filenames numerically rather than lexicographically.

@cindex editor, overstrike mode
@cindex overstrike mode, of editor
@pindex OVERSTRIKE
@item OVERSTRIKE
Start up the line editor in overstrike mode.

@cindex path search, extended
@pindex PATH_DIRS
@item PATH_DIRS (-Q)
Perform a path search even on command names with slashes in them.  Thus
if @*@samp{/usr/local/bin} is in the user's path, and he types
@samp{X11/xinit}, the command @samp{/usr/local/bin/X11/xinit} will be
executed (assuming it exists).  This applies to the @code{.} builtin as
well as to command execution.  Commands explicitly beginning with
@samp{./} or @samp{../} are not subject to path search.@refill

@cindex exit status, printing
@pindex PRINT_EXIT_VALUE
@item PRINT_EXIT_VALUE (-C)
Print the exit value of programs with non-zero exit status.

@pindex PROMPT_SUBST
@item PROMPT_SUBST
Expressions like @code{$@{@dots{}@}}, @code{$(@dots{})}, and @code{$[@dots{}]}
in prompts will be expanded.@refill

@cindex directory stack, ignoring dups
@pindex PUSHD_IGNORE_DUPS
@item PUSHD_IGNORE_DUPS
Don't push multiple copies of the same directory onto the directory
stack.

@cindex popd, controlling syntax
@pindex PUSHD_MINUS
@item PUSHD_MINUS
@xref{Shell Builtin Commands}, for the @code{popd} command.

@cindex directory stack, silencing
@pindex PUSHD_SILENT
@item PUSHD_SILENT (-E)
Do not print the directory stack after @code{pushd} or @code{popd}.

@cindex pushd, to home
@pindex PUSHD_TO_HOME
@item PUSHD_TO_HOME (-D)
Have @code{pushd} with no arguments act like @code{pushd $HOME}.

@pindex RC_EXPAND_PARAM
@item RC_EXPAND_PARAM (-P)
@xref{Parameter Expansion}.

@cindex rc, quoting style
@cindex quoting style, rc
@pindex RC_QUOTES
@item RC_QUOTES
@ifinfo
Allow the character sequence @code{@'@'} to signify a single quote within
@end ifinfo
@iftex
Allow the character sequence @code{''} to signify a single quote within
@end iftex
singly quoted strings.@refill

@cindex completion, exact matches
@pindex REC_EXACT
@item REC_EXACT (-S)
In completion, recognize exact matches even if they are ambiguous.

@cindex rm *, querying before
@cindex querying before rm *
@pindex RM_STAR_SILENT
@item RM_STAR_SILENT (-H)
Do not query the user before executing @code{rm *} or @code{rm path/*}.

@pindex SHIN_STDIN
@item SHIN_STDIN (-s)
Read commands from the standard input.

@cindex sh, word splitting style
@cindex word splitting, sh style
@pindex SH_WORD_SPLIT
@item SH_WORD_SPLIT (-y)
@xref{Parameter Expansion}.

@cindex editor, single line mode
@pindex SINGLE_LINE_ZLE
@item SINGLE_LINE_ZLE (-M)
Use single-line command line editing instead of multi-line.

@cindex sun keyboard, annoying
@cindex annoying keyboard, sun
@pindex SUN_KEYBOARD_HACK
@item SUN_KEYBOARD_HACK (-L)
If a line ends with a backquote, and there are an odd number of
backquotes on the line, ignore the trailing backquote.  This is useful
on some keyboards where the return key is too small, and the backquote
key lies annoyingly close to it.

@cindex tracing, of input lines
@pindex VERBOSE
@item VERBOSE (-v)
Print shell input lines as they are read.

@cindex tracing, of commands
@pindex XTRACE
@item XTRACE (-x)
Print commands and their arguments as they are executed.

@cindex editor, disabling
@cindex disabling the editor
@pindex ZLE
@item ZLE (-Z)
Use the zsh line editor.
@end table

@node Shell Builtin Commands, Invocation, Options, Top
@chapter Shell Builtin Commands
@cindex builtin commands

@table @code
@findex .
@item . @var{file} [ @var{arg} @dots{} ]
Read and execute commands from @var{file} in the current shell
environment.  If @var{file} does not contain a slash, or if
@code{PATH_DIRS} is set, the shell looks in the components of
@code{path} to find the directory containing @var{file}.  Files in the
current directory are not read unless @samp{.} appears somewhere in
@code{path}.  If any arguments @var{arg} are given, they become the
positional parameters; the old positional parameters are restored when
the @var{file} is done executing.  The exit status is the exit status of
the last command executed.@refill

@cindex parameters, expanding
@cindex expanding parameters
@item : [ @var{arg} @dots{} ]
This command only expands parameters.  A zero exit code is returned.

@cindex alias
@findex alias
@item alias [ -grm ] [ @var{name}[=@var{value}] ] @dots{}
With no arguments, print the list of aliases in the form
@code{@var{name}=@var{value}} on the standard output.  For each
@var{name} with a corresponding @var{value}, define an alias with that
value.  A trailing space in @var{value} causes the next word to be
checked for alias substitution.  If the @code{-g} flag is given, define
a global alias; global aliases are expanded even if they do not occur in
command position.  For each @var{name} with no @var{value}, print the
value of @var{name}, if any.  If only the @code{-g} or the @code{-r}
flag is given only global or regular aliases are listed.  If the
@code{-m} flag is given the arguments are taken as patterns (they should
be quoted to preserve them from being interpreted as glob patterns) and
the aliases matching these patterns are printed.  The exit status is
nonzero if a @var{name} (with no @var{value}) is given for which no
alias has been defined.@refill

@cindex functions, autoloading
@cindex autoloading functions
@findex autoload
@item autoload [ @var{name} @dots{} ]
For each of the @var{name}s (which are names of functions), create a
function marked undefined.  The @code{fpath} variable will be searched
to find the actual function definition when the function is first
referenced.@refill

@findex bg
@item bg [ @var{job} @dots{} ]
@itemx @var{job} @dots{} &
Put each specified @var{job} in the background, or the current job if
none is specified.@refill

@cindex rebinding the keys
@cindex keys, rebinding
@findex bindkey
@item bindkey -mevd
@itemx bindkey -r @var{in-string} @dots{}
@itemx bindkey [ -a ] @var{in-string} [ @var{command} ] @dots{}
@itemx bindkey -s [ -a ] @var{in-string} @var{out-string} @dots{}
The @code{-e} and @code{-v} options put the keymaps in emacs mode and vi
mode respectively; they cannot be used simultaneously.  The @code{-d}
option resets all bindings to the compiled-in settings.  If not used
with options @code{-e} or @code{-v}, the maps will be left in emacs
mode, or in vi mode if the @code{VISUAL} or @code{EDITOR} variables
contain the string @samp{vi}.  Metafied characters are bound to
self-insert by default.  The @code{-m} option loads the compiled-in
bindings of these characters for the mode determined by the previous
options, or the current mode if used alone.  Any previous binding done
by the user will be preserved.  If the @code{-r} option is given, remove
any binding for each @var{in-string}.  If the @code{-s} option is not
specified, bind each @var{in-string} to a specified @var{command}.  If
no @var{command} is specified, print the binding of @var{in-string} if
it is bound, or return a nonzero exit code if it is not bound.  If the
@code{-s} option is specified, bind each @var{in-string} to each
specified @var{out-string}.  When @var{in-string} is typed,
@var{out-string} will be pushed back and treated as input to the line
editor.  The process is recursive, but to avoid infinite loops the shell
will report an error if more than 20 consecutive replacements happen.
If the @code{-a} option is specified, bind the @var{in-string}s in the
alternative keymap instead of the standard one.  The alternative keymap
is used in vi command mode.@refill

@noindent
It's possible for an @var{in-string} to be bound to something and also
be the beginning of a longer bound string.  In this case the shell will
wait a certain time to see if more characters are typed, otherwise it
will execute the shorter binding.  This timeout is defined by the
@code{KEYTIMEOUT} parameter; the default is 0.4 seconds.  No timeout is
done if the prefix string is not bound.@refill

@noindent
For either @var{in-string} or @var{out-string}, control characters may
be specified in the form @code{^X}, and the backslash may be used to
introduce one of the following escape sequences:@refill

@table @code
@item \a
Bell character
@item \n
Linefeed (newline)
@item \b
Backspace
@item \t
Horizontal tab
@item \v
Vertical tab
@item \f
Form feed
@item \r
Carriage return
@item \e
@itemx \E
Escape
@item \@var{nnn}
Character code in octal
@item \x@var{nn}
Character code in hexadecimal
@item \M-@var{xxx}
Character or escape sequence with meta bit set.  The @code{-} after the
@code{M} is optional.@refill
@item \C-X
Control character.  The @code{-} after the @code{M} is optional.
@end table

In all other cases, @code{\} escapes the following character.  Delete is
written as @code{^?}.  Note that @code{\M^?} and @code{^\M?} are not the
same.@refill

@noindent
Multi-character @var{in-strings} cannot contain the null character
(@code{^@@} or @code{^ }).  If they appear in a bindkey command, they
will be silently translated to @code{\M-^@@}.  This restriction does not
apply to @var{out-strings}, single-character @var{in-strings} and the
first character of a multi-char @var{in-string}.@refill

@cindex loops, exitting
@cindex exitting loops
@findex break
@item break [ @var{n} ]
Exit from an enclosing @code{for}, @code{while}, @code{until},
@code{select}, or @code{repeat} loop.  If @var{n} is specified, then
break @var{n} levels instead of just one.@refill

@findex builtin
@item builtin @var{name} [ @var{args} ] @dots{}
Executes the builtin @var{name}, with the given @var{args}.

@findex bye
@item bye
Same as @code{exit}.

@cindex directories, changing
@findex cd
@item cd [ @var{arg} ]
@itemx cd @var{old} @var{new}
@itemx cd [+-]n
Change the current directory.  In the first form, change the current
directory to @var{arg}, or to the value of @code{HOME} if @var{arg} is
not specified.  If @var{arg} is @code{-}, change to the value of
@code{OLDPWD}, the previous directory.  If a directory named @var{arg}
is not found in the current directory and @var{arg} does not begin with
a slash, search each component of the shell parameter @code{cdpath}.  If
the option @code{CDABLEVARS} is set, and a parameter named @var{arg}
exists whose value begins with a slash, treat its value as the
directory.@refill

@noindent
The second form of @code{cd} substitutes the string @var{new} for the
string @var{old} in the name of the current directory, and tries to
change to this new directory.@refill

@noindent
The third form of @code{cd} is equivalent to @code{popd}.

@findex chdir
@item chdir
Same as @code{cd}.

@cindex completion, controlling
@findex compctl
@item compctl [ -cfqovbCDAIFpEjBaRGuderzNOZn ] [ -k @var{name} ] [ -X @var{explanation} ]
@itemx [ -K @var{function} ] [ -P @var{prefix} ] [ -S @var{suffix} ] [ -g @var{globstring} ]
@itemx [ -s @var{substring} ] [ -H @var{num pattern} ] [ -l @var{cmd} ] [ @var{arg} @dots{} ]
@itemx compctl @var{flags} + @var{flags} + @dots{}
@itemx compctl @var{flags} -x @var{pattern} @var{flags} - @dots{} -- @var{arg} @dots{}
Control the editor's completion behavior when one of @var{arg} is the
current command.  (Note that aliases are expanded before this is
determined, unless the @code{COMPLETE_ALIASES} option is set.)  With the
@code{-D} flag, control default completion
behavior for commands not assigned any special behavior; with
@code{-C}, control completion when there is no current command.  The
remaining options specify the type of command arguments to look for
during completion.  If completion is attempted for a command with a
pathname containing slashes and no completion is found the search is
retried with the last pathname component.@refill

@table @code
@item -c
Expect command names.

@item -f
Expect filenames and filesystem paths.

@item -o
Expect option names.

@item -v
Expect variable names.

@item -b
Expect key binding names.

@item -A
Expect array names.

@item -I
Expect integer variable names.

@item -F
Expect function names.

@item -p
Expect parameter names.

@item -E
Expect environment variable names.

@item -j
Expect job names (the first word of the job leader's command line, useful
with the @code{kill} builtin).@refill

@item -r
Expect names of running jobs.

@item -z
Expect names of suspended jobs.

@item -B
Expect names of builtin commands.

@item -a
Expect alias names.

@item -R
Expect names of regular aliases.

@item -G
Expect names of global aliases.

@item -u
Expect user names.

@item -d
Expect names of disabled commands.

@item -e
Expect names of executable (and enabled) commands.

@item -N
Expect names of scalar parameters.

@item -n
Expect named directories.

@item -O
Expect names of readonly variables.

@item -Z
Expect names of shell special parameters.

@item -q
If given together with a suffix (see the @code{-S} flag below) it makes
this suffix be removed if the next character typed is a blank or does
not insert anything (this is the same rule as used for the
@code{AUTO_REMOVE_SLASH} option).@refill

@item -k @var{name}
Expect names taken from the elements of @code{$name} (which should be an
array).  Alternatively,
the argument @var{name} itself may be a set of space- or comma-separated
values in parentheses, in which any delimiter may be escaped with a
backslash.  Example: @samp{compctl -k "(cputime filesize datasize
stacksize coredumpsize resident descriptors)" limit}.@refill

@item -K @var{function}
Call the given function to get the completions.  The function gets two
arguments: the prefix and the suffix of the word on which completion is
tried.  The function should set the variable @code{reply} to an array
containing the completions (one completion per element); note that
@code{reply} should not be made local.  From such a function the command
line can be accessed with the @code{-c} and @code{-l} flags to the
@code{read} builtin.  Example: @samp{function whoson @{ reply=(`users`);
@}; compctl -K whoson talk} completes only logged-on users after
@samp{talk}.  Note that @code{whoson} must return an array so that just
@samp{reply=`users`} is incorrect.@refill

@item -X @var{explanation}
Print the explanation string before the list of completions.  A @code{%n}
in this string is replaced by the number of matches.@refill

@item -P @var{prefix}
The @var{prefix} is inserted just before the completed string; any
initial part already typed will be completed and the whole @var{prefix}
ignored for completion purposes.  Example: @samp{compctl -j -P "%"
kill}.@refill

@item -S @var{suffix}
After a unique completion is found the @var{suffix} is inserted after
the completed string.@refill

@item -g @var{globstring}
The @var{globstring} is expanded using filename globbing; it should be
quoted to protect it from immediate expansion.  The resulting filenames
are taken as the possible completions.  Use @code{*(/)} instead of
@code{*/} for directories.  The @code{fignore} special parameter is not
used.  More than one of these pattern may be given separated by blanks.
Note that brace expansion is @emph{not} part of globbing.@refill

@item -s @var{substring}
The @var{substring} is split into words and these words are than
expanded using all shell expansion mechanisms.  The resulting words are
taken as possible completions.  The @code{fignore} special parameter is
@emph{not} used.  Note that @code{-g} is faster for filenames.@refill

@item -H @var{num pattern}
The possible completions are taken from the last @var{num} history
lines.  Only words matching @var{pattern} are taken.  If @var{num} is
zero or negative the whole history is searched and if @var{pattern} is
the empty string (or @code{*}, of course) all words are taken.@refill

@item -l @var{cmd}
This option cannot be combined with any other option.  If it is given it
restricts the range of command line words that are considered to be
arguments.  By default this range contains all arguments without the
command string.  If combined with extended completion (see below) and one of
@code{p[@dots{}]}, @code{r[@dots{}]}, or @code{R[@dots{}]} the range is
restricted to the arguments between the ones that are specified in the
brackets.  After the range of arguments is determined completion is done
in it as if they were arguments to the @var{cmd} given with this option.
If this string is empty the first word in the range is taken as the
command name for which to complete.  In this case, if the cursor is in
@ifinfo
the first word, command names are completed.  Example: @samp{compctl -x
'r[-exec,;]' -l @'@' -- find} completes the arguments between @code{-exec}
@end ifinfo
@iftex
the first word, command names are completed.  Example: @samp{compctl -x
'r[-exec,;]' -l '' -- find} completes the arguments between @code{-exec}
@end iftex
and the following @code{;} (or the end of the command line if there is
no such string) as if they were specifying a command on their
own.@refill

@item -U
Use the whole list of possible completions, whether or not they actually
match the word on the command line.  The word typed so far will be
deleted.  This is most useful with a function (@code{-K} option), which
can examine the word via the @code{read} builtin's @code{-c} and
@code{-l} flags and use its own criterion to decide what matches.@refill
@end table

@noindent
The second form specifies alternative options.  First completion is
tried with the options before the first @code{+}.  If this produces no
matches completion is tried with the flags after the @code{+} and so on.
If there are no flags after the last @code{+} this means that default
completion is tried if no matches were found.@refill

@noindent
The third form specifies extended completion for the commands given as
@var{arg}.  Each @var{pattern} is examined in turn; when a match is
found, the corresponding @var{flags}, as described above for the
ordinary case, are used to generate possible completions.  If no
@var{pattern} matches, the @var{flags} given before the @code{-x} are
used.  Note that each pattern should be supplied as a single argument
and should be quoted to prevent expansion of metacharacters by the
shell.  A @var{pattern} is built of sub-patterns separated by commas; it
matches if at least one of these sub-patterns matches (they are or'ed).
These sub-patterns are in turn composed of other sub-patterns separated
by white space which match if all of the sub-patterns match (they are
and'ed).  An element of the sub-patterns is of the form
@code{c[@dots{}][@dots{}]}, where the pairs of brackets may be repeated as
often as necessary, and matches if any of the sets of brackets match (an
or).  These elements may be any of the following:@refill

@table @code
@item s[@var{string}] @dots{}
The pattern matches if the current word on the command line starts with
one of the strings given in brackets.  The @var{string} is not removed
and is not part of the completion.@refill

@item S[@var{string}] @dots{}
Like @code{s[@var{string}]} but the @var{string} is part of the
completion.@refill

@item p[@var{from},@var{to}] @dots{}
The pattern matches if the number of the current word is between one of
the @var{from} and @var{to} pairs.  The comma and @var{to} are optional;
@var{to} defaults to the same value as @var{from}.  The numbers may be
negative: @var{-n} refers to the @var{n}'th last word on the
line.@refill

@item c[@var{offset},@var{string}] @dots{}
The pattern matches if one of the @var{string}s matches the word offset
by @var{offset} from the current word position.@refill

@item C[@var{offset},@var{pattern}] @dots{}
Like @code{c} but uses pattern matching instead.

@item w[@var{index},@var{string}] @dots{}
The pattern matches if the word in position @var{index} is equal to the
corresponding @var{string}.  Note that the word count is made after
alias expansion.@refill

@item W[@var{index},@var{pattern}] @dots{}
Like @code{w} but uses pattern matching instead.

@item n[@var{index},@var{string}] @dots{}
Matches if the current word contains @var{string}.  Anything up to the
@var{index}'th ocurrence of this string will not be considered part of
the completion, but the rest will.@refill

@item N[@var{index},@var{string}] @dots{}
Like @code{n[@var{index},@var{string}]} but the string will be taken as
a character class (anything up to the @var{index}'th ocurrence of any of
the characters in @var{string} will not be considered part of the
completion).@refill

@item m[@var{min},@var{max}] @dots{}
Matches if the total number of words lies between @var{min} and
@var{max} (inclusive).@refill

@item r[@var{str1},@var{str2}]@dots{}
Matches if the cursor is after a word with prefix @var{str1}.  If there
is also a word with prefix @var{str2} on the command line it matches
only if the cursor is before this word.@refill

@item R[@var{str1},@var{str2}]@dots{}
Like @code{r} but uses pattern matching instead.
@end table

@noindent
Example:
@noindent
@samp{compctl -u -x 's[+] c[-1,-f],s[-f+]' -g '~/Mail/*(:t)' -
's[-f],c[-1,-f]' -f -- mail}
@noindent
Complete users by default.  After a @code{-f} with an optional space,
complete file names; if a @code{+} follows the @code{-f}, whether or not
there is a space in between, complete with the non-directory part of
files in the directory @samp{~/Mail}.@refill

@cindex loops, continuing
@cindex continuing loops
@findex continue
@item continue [ @var{num} ]
Resume the next iteration of the enclosing @code{for}, @code{while},
@code{until}, @code{select}, or @code{repeat} loop.  If @var{n} is
specified, break out of @var{n}-1 loops and resume at the @var{n}'th
enclosing loop.@refill

@findex declare
@item declare [ @var{arg} @dots{} ]
Same as @code{typeset}.

@cindex directory stack, printing
@findex dirs
@item dirs [ -v ] [ @var{arg} @dots{} ]
With no arguments, print the contents of the directory stack.  If the
@code{-v} option is given, number the directories in the stack when
printing.  Directories are added to this stack with the @code{pushd}
command, and removed with the @code{cd} or @code{popd} commands.  If
arguments are specified, load them onto the directory stack, replacing
anything that was there, and push the current directory onto the
stack.@refill

@cindex disabling commands
@cindex commands, disabling
@findex disable
@item disable [ -m ] @var{arg} @dots{}
Disable the builtin @var{arg} temporarily.  This allows you to use an
external command with the same name as a shell builtin.  Without
arguments all disabled builtins are printed; with the @code{-m} flag the
arguments are taken as patterns (which should be quoted to preserve them
from being taken as glob patterns) and all builtins matching these
patterns are disabled.  Actually the same as @code{unhash}.  Builtins
can be enabled with the @code{enable} command.@refill

@findex disown
@item disown @var{job} @dots{}
Remove the specified jobs from the job table; the shell will no longer
report their status, and will not complain if you try to exit an
interactive shell with them running or stopped.

@findex echo
@item echo [ -n ] [ @var{arg} @dots{} ]
Write each @var{arg} on the standard output, with a space separating
each one.  If the @code{-n} flag is not present, print a newline at the
end.  @code{echo} recognizes the following escape sequences:@refill

@table @code
@item \a
Bell
@item \b
Backspace
@item \c
Don't print an ending newline
@item \e
Escape
@item \f
Form feed
@item \n
Newline
@item \r
Carriage return
@item \t
Horizontal tab
@item \v
Vertical tab
@item \\
Backslash
@item \0NNN
Character code in octal, with a maximum of three digits after the zero.
A non-octal digit terminates the number.
@item \xNN
Character code in hexadecimal, with a maximum of two digits after the
@code{x}.  A non-hexadecimal digit terminates the number.@refill
@end table

@cindex termcap string, printing
@findex echotc
@item echotc @var{cap} [ @var{arg} @dots{} ]
Output the termcap string corresponding to the capability @var{cap},
with optional arguments.@refill

@findex enable
@item enable [ -m ] @var{arg} @dots{}
Enable the specified builtin commands, presumably disabled earlier with
@code{disable}.  Without arguments the enabled builtins are printed;
with the @code{-m} flag the arguments are taken as patterns (and hence
should be quoted), and all builtins matching these patterns are
enabled.@refill

@cindex evaluating arguments as commands
@findex eval
@item eval [ @var{arg} @dots{} ]
Read the arguments as input to the shell and execute the resulting
command(s) in the current shell process.

@pindex IGNORE_EOF, use of
@findex exit
@item exit [ @var{n} ]
Exit the shell with the exit code specified by @var{n}; if none is
specified, use the exit code from the last command executed.  An
@code{EOF} condition will also cause the shell to exit, unless the
@code{IGNORE_EOF} option is set.@refill

@findex export
@item export [ @var{name}[=@var{value}] @dots{} ]
The specified @var{name}s are marked for automatic export to the
environment of subsequently executed commands.@refill

@findex false
@item false
Do nothing and return an exit code of 1.

@cindex history, editting
@cindex editting the history
@findex fc
@item fc [ -e @var{ename} ] [ -nlrdDfEm ] [ @var{old}=@var{new} @dots{} ] [ @var{first} [ @var{last} ]]
@itemx fc -ARWI [ @var{filename} ]
Select a range of commands from @var{first} to @var{last} from the
history list.  The arguments @var{first} and @var{last} may be specified
as a number or as a string.  A negative number is used as an offset to
the current history event number.  A string specifies the most recent
event beginning with the given string.  All substitutions
@var{old}=@var{new}, if any, are then performed on the commands.  If the
@code{-l} flag is given, the resulting commands are listed on standard
output.  If the @code{-m} flag is also given the first argument is taken
as a pattern (which should be quoted), and only the history events
matching this pattern will be shown.  Otherwise the editor program
@var{ename} is invoked on a file containing these history events.  If
@var{ename} is not given, the value of the parameter @code{FCEDIT} is
used.  If @var{ename} is @code{-}, no editor is invoked.  When editing
is complete, the edited command(s) is executed.  If @var{first} is not
specified, it will be set to -1 (the most recent event), or to -16 if
the @code{-l} flag is given.  If @var{last} is not specified, it will be
set to @var{first}, or to -1 if the @code{-l} flag is given.  The flag
@code{-r} reverses the order of the commands and the flag @code{-n}
suppresses command numbers when listing.  Also when listing, @code{-d}
prints timestamps for each command, @code{-f} prints full time and date
stamps, and @code{-D} prints elapsed times.  Adding the @code{-E} flag
causes the dates to be printed in the European format
(@var{dd.mm.yyyy}).@refill

@cindex history, file
@cindex file, history
@noindent
@code{fc -R} reads the history from the given file, @code{fc -W} writes
the history out to the given file, and @code{fc -A} appends the history
to the given file.  @code{fc -AI} (@code{-WI}) appends (writes) only
those events that are new since the last incremental append (write) to
the history file.  In any case the file will have no more than
@code{SAVEHIST} entries.@refill

@findex fg
@item fg [ @var{job} @dots{} ]
@itemx @var{job} @dots{}
Bring the specified @var{job}s to the foreground.  If no @var{job} is
specified, use the current job.@refill

@findex functions
@item functions [ +-tum ] [ @var{name} @dots{} ]
Equivalent to @code{typeset -f}.

@cindex line, reading
@cindex reading a line
@findex getln
@item getln @var{name} @dots{}
Read the top value from the buffer stack and put it in the shell
parameter @var{name}.  Equivalent to @code{read -zr}.  The flags
@code{-c}, @code{-l}, @code{-A}, @code{-e}, @code{-E}, and @code{-n} are
also supported.@refill

@cindex options, processing
@findex getopts
@item getopts @var{optstring} @var{name} [ @var{arg} @dots{} ]
Checks @var{arg} for legal options.  If @var{arg} is omitted, use the
positional parameters.  A valid option argument begins with a @code{+}
or a @code{-}.  An argument not beginning with a @code{+} or a @code{-},
or the argument @code{--}, ends the options.  @var{optstring} contains
the letters that @code{getopts} recognizes.  If a letter is followed by
a @code{:}, that option is expected to have an argument.  The options
can be separated from the argument by blanks.@refill

@vindex OPTIND, use of
@vindex OPTARG, use of
@noindent
Each time it is invoked, @code{getopts} places the option letter it
finds in the shell parameter @var{name}, prepended with a @code{+} when
@var{arg} begins with a @code{+}.  The index of the next @var{arg} is
stored in @code{OPTIND}.  The option argument, if any, is stored in
@code{OPTARG}.@refill

@noindent
A leading @code{:} in @var{optstring} causes @code{getopts} to store the
letter of the invalid option in @code{OPTARG}, and to set @var{name} to
@code{?} for an unknown option and to @code{:} when a required option is
missing.  Otherwise, @code{getopts} prints an error message.  The exit
status is nonzero when there are no more options.@refill

@findex hash
@item hash @var{name} @var{path}
Puts @var{name} in the command hash table, associating it with the
pathname @var{path}.  Whenever @var{name} is used as a command argument,
the shell will try to execute the file given by @var{path}.@refill

@findex history
@item history [ -nrdDfEm ] [ @var{first} [ @var{last} ]]
Same as @code{fc -l}.

@findex integer
@item integer [ +-lrtux ] [ @var{name}[=@var{value}] ]
Same as @code{typeset -i}, except that options irrelevant to integers
are not permitted.@refill

@findex jobs
@item jobs [ -lprs ] [ @var{job} @dots{} ]
Lists information about each given job, or all jobs if @var{job} is
omitted.  The @code{-l} flag lists process ids, and the @code{-p} flag
lists process groups.  If the @code{-r} flag is given only running jobs
will be listed; if the @code{-s} flag is given only stopped jobs are
shown.@refill

@cindex jobs, killing
@cindex killing jobs
@findex kill
@item kill [ -@var{sig} ] @var{job} @dots{}
@itemx kill -l
Sends either @code{SIGTERM} or the specified signal to the given jobs or
processes.  Signals are given by number or by names (with the prefix
@code{SIG} removed).  If the signal being sent is not @code{KILL} or
@code{CONT}, then the job will be sent a @code{CONT} signal if it is
stopped.  The argument @var{job} can be the process id of a job not in
the job list.  In the second form, @code{kill -l}, the signal names are
listed.@refill

@findex let
@item let @var{arg} @dots{}
Evaluate each @var{arg} as an arithmetic expression.
@c
@c Why does the next line cause Info-validate to say "invalid reference"?
@c
@xref{Arithmetic Evaluation}, for a description of arithmetic
expressions.  The exit status is 0 if the value of the last expression
is nonzero, and 1 otherwise.@refill

@cindex resource limits
@cindex limits, resource
@findex limit
@item limit [ -h ] [ @var{resource} [ @var{limit} ]] @dots{}
@itemx limit -s
Limit the resource consumption of children of the current shell.  If
@var{limit} is not specified, print the current limit placed on
@var{resource}; otherwise set the limit to the specified value.  If the
@code{-h} flag is given, use hard limits instead of soft limits.  If no
@var{resource} is given, print all limits.  See also @code{ulimit}.
@var{resource} is one of:@refill

@table @code
@item cputime
Maximum CPU seconds per process.
@item filesize
Largest single file allowed.
@item datasize
Maximum data size (including stack) for each process.
@item stacksize
Maximum stack size for each process.
@item coredumpsize
Maximum size of a core dump.
@item resident
@itemx memoryuse
Maximum resident set size.
@item memorylocked
Maximum amount of memory locked in RAM.
@item descriptors
Maximum value for a file descriptor.
@item openfiles
Maximum number of open files.
@item vmemorysize
Maximum amount of virtual memory.
@end table

Which of these resource limits are available depends on the system.
@var{limit} is a number, with an optional scaling factor, as
follows:@refill

@table @code
@item @var{n}h
Hours.
@item @var{n}k
Kilobytes.  This is the default for all but cputime.
@item @var{n}m
Megabytes or minutes.
@item @var{mm}:@var{ss}
Minutes and seconds.
@end table

@findex local
@item local [ +-LRZilrtu [@var{n}]] [ @var{name}[=@var{value}] ]
Same as @code{typeset}, except that the options @code{-x} and @code{-f}
are not permitted.@refill

@cindex users, watching
@cindex watching users
@vindex watch, use of
@findex log
@item log
List all users currently logged in who are affected by the current
setting of the @code{watch} parameter.@refill

@findex logout
@item logout
Exit the shell, if this is a login shell.

@pindex PUSHD_MINUS, use of
@findex popd
@item popd [ +-@var{n} ]
Removes entries from the directory stack.  With no arguments, removes
the top directory from the stack, and performs a @code{cd} to the new
top directory.  With an argument of the form @code{+@var{n}}, remove the
@var{n}'th entry counting from the left of the list shown by the
@code{dirs} command, starting with zero, and change to that directory.
With an argument of the form @code{-@var{n}}, remove the @var{n}'th entry
counting from the right.  If the @code{PUSHD_MINUS} option is set, the
meanings of @code{+} and @code{-} in this context are swapped.@refill

@findex print
@item print [ -RnrslzpNDPoOic ] [ -u@var{n} ] [ @var{arg} @dots{} ]
With no flags or with flag @code{-}, the arguments are printed on the
standard output as described by @code{echo}, with the following
differences: the escape sequence @code{\M-x} metafies the character
@code{x} (sets the highest bit), @code{\C-x} produces a control
character (@code{\C-@@} and @code{\C-?} give the characters NULL and
delete) and @code{\E} is a synonym for @code{\e}.  Finally, if not in an
escape sequence, @code{\} escapes the following character and is not
printed.@refill

@table @code
@item -R
@itemx -r
Ignore the escape conventions of @code{echo}.  The @code{-R} option
will print all subsequent arguments and options.@refill
@item -s
Place the results in the history list instead of on the standard
output.@refill
@item -n
Do not add a newline to the output.
@item -l
Print the arguments separated by newlines instead of spaces.
@item -N
Print the arguments separated and terminated by nulls.
@item -o
Print the arguments sorted in ascending order.
@item -O
Print the arguments sorted in descending order.
@item -i
If given together with @code{-o} or @code{-O}, makes the sort be
case-insensitive.@refill
@item -c
Print the arguments in columns.
@item -u@var{n}
Print the arguments to file descriptor @var{n}.
@item -p
Print the arguments to the input of the coprocess.
@item -z
Push the arguments onto the editing buffer stack, separated by spaces;
no escape sequences are recognized.@refill
@item -D
Treat the arguments as directory names, replacing prefixes with @code{~}
expressions, as appropriate.@refill
@item -P
Recognize the same escape sequences as in the @code{PROMPT}
parameter.@refill
@end table

@findex pushd
@pindex PUSHD_TO_HOME, use of
@pindex CDABLEVARS, use of
@pindex PUSHD_SILENT, use of
@item pushd [ @var{arg} ]
@itemx pushd @var{old} @var{new}
@itemx pushd +-@var{n}
Change the current directory, and push the old current directory onto
the directory stack.  In the first form, change the current directory to
@var{arg}.  If @var{arg} is not specified, change to the second
directory on the stack (that is, exchange the top two entries), or
change to the value of @code{HOME} if the @code{PUSHD_TO_HOME} option is
set or if there is only one entry on the stack.  If @var{arg} is
@code{-}, change to the value of @code{OLDPWD}, the previous directory.
If a directory named @var{arg} is not found in the current directory and
@var{arg} does not contain a slash, search each component of the shell
parameter @code{cdpath}.  If the option @code{CDABLEVARS} is set, and a
parameter named @var{arg} exists whose value begins with a slash, treat
its value as the directory.  If the option @code{PUSHD_SILENT} is not
set, the directory stack will be printed after a @code{pushd} is
performed.@refill

@noindent
The second form of @code{pushd} substitutes the string @var{new} for the
string @var{old} in the name of the current directory, and tries to
change to this new directory.@refill

@noindent
The third form of @code{pushd} is equivalent to @code{popd}.

@findex pushln
@item pushln
Equivalent to @code{print -nZ}.

@findex pwd
@item pwd
Equivalent to @code{print -R $PWD}.

@findex r
@item r
Equivalent to @code{fc -e -}.

@vindex IFS
@findex read
@item read [ -rzpqAclneE ] [ -k [@var{num}] ] [ -u@var{n} ] [ @var{name}?@var{prompt} ] [ @var{name} @dots{} ] 
Read one line and break it into fields using the characters in
@code{IFS} as separators.  In raw mode, @code{-r}, a @code{\} at the end
of a line does not signify line continuation.  With the @code{-q} flag
read only one character and set @var{name} to @samp{y} if this character
was @samp{y} or @samp{Y}, and to @samp{n} otherwise.  With this flag set
the return value is zero only if the character was @samp{y} or @samp{Y}.
If the @code{-k}
flag is given read only one (or @var{num}) characters.  If the @code{-z}
flag is given, read from the editor buffer stack.  The first field is
assigned to the first @var{name}, the second field to the second
@var{name}, etc, with leftover fields assigned to the last @var{name}.
If the @code{-e} or the @code{-E} flag is given, the words read are
printed after the whole line is read.  If the @code{-e} flag is given,
the words are not assigned to the parameters.  If the @code{-A} flag is
given, the first @var{name} is taken as the name of an array and all
words are assigned to it.  If @var{name} is omitted then @code{REPLY} is
used for scalars and @code{reply} for arrays.  The @code{-c} and
@code{-l} flags are allowed only if called inside a function used for
completion (specified with the @code{-K} flag to @code{compctl}).  If
the @code{-c} flag is given, the words of the current command are read.
If the @code{-l} flag is given, the whole line is assigned as a scalar.
Together with the @code{-n} flag these options give the number of the
word the cursor is on and the index of the character the cursor is on
respectively.  If @code{-u@var{n}} is specified, then input is read from
file descriptor @var{n}; if @code{-p} is specified, then input is read
from the coprocess.  If the first argument contains a @code{?}, the remainder
of this word is used as a @var{prompt} on standard error when the shell
is interactive.  The exit status is 0 unless an end-of-file is
encountered.@refill

@cindex parameters, marking readonly
@findex readonly
@item readonly [ @var{name}[=@var{value}]] @dots{}
The given @var{names} are marked readonly; these names cannot be changed
by subsequent assignment.@refill

@findex rehash
@item rehash [ -f ]
Throw out the command hash table and start over.  If the @code{-f}
option is given, rescan the command path immediately, instead of
rebuilding the hash table incrementally.@refill

@cindex functions, returning from
@findex return
@item return [ @var{n} ]
Causes a shell function or @code{.} script to return to the invoking
script with the return status specified by @var{n}.  If @var{n} is
omitted then the return status is that of the last command
executed.@refill

@noindent
If @code{return} was executed from a trap, whether set by the
@code{trap} builtin or by defining a @code{TRAP@var{xxx}} function, the
effect is different for zero and non-zero return status.  With zero
status (or after an implicit return at the end of the trap), the shell
will return to whatever it was previously processing; with a non-zero
status, the shell will behave as interrupted except that the return
status of the trap is retained.  Note that the signal which caused the
trap is passed as the first argument, so the statement @samp{return
$[128+$1]} will return the same status as if the signal had not been
trapped.@refill

@cindex timed execution
@cindex execution, timed
@findex sched
@item sched [+]@var{hh}:@var{mm} @var{command} @dots{}
@itemx sched [ -@var{item} ]
Make an entry in the scheduled list of commands to execute.  The time
may be specified in either absolute or relative time.  With no
arguments, prints the list of scheduled commands.  With the argument
@code{-@var{item}}, removes the given item from the list.@refill

@cindex parameters, positional
@cindex parameters, array
@cindex array parameter, declaring
@findex set
@item set [ +-@var{options} ] [ +-o @var{option name} ] @dots{} [ -A [@var{name}] ] [ @var{arg} ] @dots{} 
Set the options for the shell and/or set the positional parameters, or
declare an array.  @xref{Options}, for the meaning of the flags.  Flags
may be specified by name using the @code{-o} option.  If the @code{-A}
flag is given, @var{name} is set to an array containing the given
@var{arg}s; if no @var{name} is specified, all arrays are printed.
Otherwise the positional parameters are set.  If no arguments are given,
then the names and values of all parameters are printed on the standard
output.  If the only argument is @code{+}, the names of all parameters
are printed.@refill

@cindex options, setting
@findex setopt
@item setopt [ -m ] [ +-@var{options} ] [ @var{name} @dots{} ]
Set the options for the shell.  All options specified either with flags
or by name are set.  If no arguments are supplied, the names of all
options currently set are printed.  In option names, case is
insignificant, and all underscore characters are ignored.  If the
@code{-m} flag is given the arguments are taken as patterns (which
should be quoted to preserve them from being interpreted as glob
patterns), and all options with matching names are set.@refill

@cindex parameters, positional
@findex shift
@item shift [ @var{n} ] [ @var{name} @dots{} ]
The positional parameters from @code{$@var{n}+1} @dots{} are renamed
@code{$1}, where @var{n} is an arithmetic expression that defaults to 1.
If any @var{name}s are given then the arrays with these names are
shifted, instead of the positional parameters.@refill

@findex source
@item source
Same as @samp{.}, except that the current directory is always searched
and is always searched first, before directories in @code{path}.@refill

@cindex shell, suspending
@findex suspend
@item suspend [ -f ]
Suspend the execution of the shell (send it a @code{SIGTSTP}) until it
receives a @code{SIGCONT}.  If the @code{-f} option is not given,
complain if this is a login shell.@refill

@findex test
@item test @var{arg} @dots{}
@itemx [ @var{arg} @dots{} ]
Like the system version of @code{test}.  Added for compatibility; use
conditional expressions instead.@refill

@cindex shell, timing
@cindex timing the shell
@findex times
@item times
Print the accumulated user and system times for the shell and for
processes run from the shell.

@cindex signals, trapping
@cindex trapping signals
@findex trap
@item trap [ @var{arg} ] [ @var{sig} ] @dots{}
@var{arg} is a command to be read and executed when the shell receives
@var{sig}.  Each @var{sig} can be given as a number or as the name of a
signal.  Inside the command, @code{$1} refers to the number of the
signal that caused the trap.
If @var{arg} is @code{-}, then all traps @var{sig} are reset to
their default values.  If @var{arg} is the null string, then this signal
is ignored by the shell and by the commands it invokes.  If @var{sig} is
@code{ZERR} then @var{arg} will be executed after each command with a
nonzero exit status.  If @var{sig} is @code{DEBUG} then @var{arg} will
be executed after each command. If @var{sig} is @code{0} or @code{EXIT}
and the @code{trap} statement is executed inside the body of a function,
then the command @var{arg} is executed after the function completes.  If
@var{sig} is @code{0} or @code{EXIT} and the @code{trap} statement is
not executed inside the body of a function, then the command @var{arg}
is executed when the shell terminates.  The @code{trap} command with no
arguments prints a list of commands associated with each signal.@refill

@findex true
@item true
Do nothing and return an exit code of 0.

@cindex tty, freezing
@findex ttyctl
@item ttyctl [ -fu ]
The @code{-f} option freezes the tty, and @code{-u} unfreezes it.  When
the tty is frozen, no changes made to the tty settings by external
programs will be honored by the shell, except for changes in the size of
the screen; the shell will simply reset the
settings to their previous values as soon as each command exits.  Thus,
@code{stty} and similar programs have no effect when the tty is
frozen.  Without options it reports whether the terminal is frozen or
not.@refill

@findex type
@item type
Same as @code{whence -v}.

@cindex parameters, setting
@findex typeset
@item typeset [ +-LRZfilrtuxm [@var{n}]] [ @var{name}[=@var{value}]] @dots{}
Set attributes and values for shell parameters.  When invoked inside a
function, a new parameter is created which will be unset when the
function completes.  The new parameter will not be exported unless
@code{ALL_EXPORT} is set, in which case the parameter will be exported
provided no parameter of that name already exists.  The following
attributes are valid:@refill

@table @code
@item -L
Left justify and remove leading blanks from @var{value}.  If @var{n} is
nonzero, it defines the width of the field; otherwise it is determined
by the width of the value of the first assignment.  When the parameter
is printed, it is filled on the right with blanks or truncated if
necessary to fit the field.  Leading zeros are removed if the @code{-Z}
flag is also given.@refill

@item -R
Right justify and fill with leading blanks.  If @var{n} is nonzero it
defines the width of the field; otherwise it is determined by the width
of the value of the first assignment.  When the parameter is printed,
the field is left filled with blanks or truncated from the end.@refill

@item -Z
Right justify and fill with leading zeros if the first non-blank
character is a digit and the @code{-L} flag has not been set.  If
@var{n} is nonzero it defines the width of the field; otherwise it is
determined by the width of the value of the first assignment.@refill

@item -f
The names refer to functions rather than parameters.  No assignments can
be made, and the only other valid flags are @code{-t} and @code{-u}.
The flag @code{-t} turns on execution tracing for this function.  The
flag @code{-u} causes this function to be marked for autoloading.  The
@code{fpath} parameter will be searched to find the function definition
when the function is first referenced.@refill

@item -i
Use an internal integer representation.  If @var{n} is nonzero it
defines the output arithmetic base, otherwise it is determined by the
first assignment.@refill

@item -l
Convert to lower case.

@item -r
The given @var{name}s are marked readonly.

@item -t
Tags the named parameters.  Tags have no special meaning to the
shell.@refill

@item -u
Convert to upper case.

@item -x
Mark for automatic export to the environment of subsequently executed
commands.@refill
@end table

@noindent
Using @code{+} rather than @code{-} causes these flags to be turned off.
If no arguments are given but flags are specified, a list of named
parameters which have these flags set is printed.  Using @code{+}
instead of @code{-} keeps their values from being printed.  If no
arguments or options are given, the names and attributes of all
parameters are printed.  If just the @code{-m} flag is given the
arguments are taken as patterns (which should be quoted), and all
parameters or functions (with the @code{-f} flag) with matching names
are printed.@refill

@cindex resource limits
@cindex limits, resource
@findex ulimit
@item ulimit [ -Hacdflmnopstv ] [ @var{limit} ]
Set or display a resource limit.  When setting a limit it will apply to
the children of the shell but not to the shell itself.
The value of limit can be a number in
the unit specified below or the value @samp{unlimited}.  If the @code{-H}
flag is given use hard limits instead of soft limits.  See also
@code{limit}.@refill

@table @code
@item -a
Lists all of the current resource limits.
@item -c
Maximum size of core dumps, in 512-byte blocks.
@item -d
Maximum size of the data segment, in Kbytes.
@item -f
Maximum size of individual files written, in 512-byte blocks.
@item -l
Maximum size of locked-in memory, in Kbytes.
@item -m
Maximum size of physical memory, in Kbytes.
@item -n
Maximum number of file descriptors.
@item -o
Maximum number of open files.
@item -p
Maximum number of processes.
@item -s
Maximum size of stack, in Kbytes.
@item -t
Maximum number of CPU seconds.
@item -v
Maximum size of virtual memory, in Kbytes.
@end table

@cindex umask
@findex umask
@item umask [ @var{mask} ]
The umask is set to @var{mask}.  @var{mask} can be either an octal
number or a symbolic value as described in @code{chmod(1)}.  If
@var{mask} is omitted, the current value is printed.  Note that in the
symbolic form the permissions you specify are those which are to be
allowed (not denied) to the users specified).@refill

@cindex aliases, removing
@findex unalias
@item unalias [ -m ] @var{name} @dots{}
The alias definition, if any, for each @var{name} is removed.  With the
@code{-m} flag, the arguments are taken as patterns (which should be
quoted), and all aliases with matching names are removed.@refill

@cindex functions, removing
@findex unfunction
@item unfunction [ -m ] @var{name} @dots{}
The function definition, if any, for each @var{name} is removed.  With
the @code{-m} flag, the arguments are taken as patterns (which should be
quoted), and all function with matching names are removed.@refill

@findex unhash
@item unhash [ -m ] @var{name} @dots{}
The entry in the command hash table, if any, for each @var{name} is
removed.  With the @code{-m} flag, the arguments are taken as patterns
(which should be quoted), and all entries for commands with matching
names are removed.@refill

@cindex limits, resource
@cindex resource limits
@findex unlimit
@item unlimit [ -h ] @var{resource} @dots{}
The resource limit for each @var{resource} is set to the hard limit.  If
the @code{-h} flag is given and the shell is running as root, the hard
resource limit for each @var{resource} is removed.@refill

@cindex parameters, unsetting
@findex unset
@item unset [ -m ] @var{name} @dots{}
Each named parameter is unset.  With the @code{-m} flag, the arguments
are taken as patterns (which should be quoted), and all parameters with
matching names are unset.@refill

@cindex options, unsetting
@findex unsetopt
@item unsetopt [ -m ]  [ +-@var{options} ] [ @var{name} @dots{} ]
Unset the options for the shell.  All options specified either with
flags or by name are unset.  With the @code{-m} flag, the arguments are
taken as patterns (which should be quoted), and all options with
matching names are unset.@refill

@cindex parameters, editting
@cindex editting parameters
@findex vared
@item vared [ -c ] [ -p @var{prompt}] [ -r @var{rprompt} ] @var{name}
The value of the parameter @var{name} is loaded into the edit buffer,
and the line editor is invoked.  When the editor exits, @var{name} is
set to the string value returned by the editor.  If the @code{-c} flag
is given, the parameter is created if it doesn't already exist.  If the
@code{-p} flag is given, @var{prompt} will be taken as the prompt to
display at the left.  If the @code{-r} flag is given, @var{rprompt} will
be taken as the prompt to display at the right.@refill

@cindex jobs, waiting for
@cindex waiting for jobs
@findex wait
@item wait [ @var{job} @dots{} ]
Wait for the specified jobs or processes.  If @var{job} is not given
then all currently active child processes are waited for.  Each
@var{job} can be either a job specification or the process-id of a job
in the job table.  The exit status from this command is that of the job
waited for.@refill

@findex whence
@item whence [ -acpvm ] @var{name} @dots{}
For each name, indicate how it would be interpreted if used as a command
name.  The @code{-v} flag produces a more verbose report.  The @code{-p}
flag does a path search for @var{name} even if it is a shell function,
alias, or reserved word.  The @code{-c} flag prints the results in a
csh-like format.  The @code{-a} flag does a search for all occurences of
@var{name} throughout the command path.  With the @code{-m} flag, the
arguments are taken as patterns (which should be quoted), and the
information is displayed for each command matching one of these
patterns.@refill

@findex which
@item which
Same as @code{whence -c}.
@end table

@node Invocation, Wrapping Up, Shell Builtin Commands, Top
@chapter Invocation
@cindex invocation

@noindent
@code{zsh [ +-@var{options} ] [ +-o @var{option} ] @dots{}  [ -c @var{string} ] [ @var{arg} @dots{} ]}

@pindex NO_RCS, use of
@cindex files, startup
@cindex startup files
@noindent
Commands are first read from @file{/etc/zshenv}.  If the @code{-f} flag
is given or if the @code{NO_RCS} option is set within
@file{/etc/zshenv}, all other initialization files are skipped.
Otherwise, commands are read from @file{$ZDOTDIR/.zshenv} (if
@code{ZDOTDIR} is unset, @code{HOME} is used instead).  If the first
character of argument zero passed to the shell is @code{-}, or if the
@code{-l} flag is present, then the shell is assumed to be a login
shell, and commands are read from @file{/etc/zprofile} and then
@file{$ZDOTDIR/.zprofile}.  Then, if the shell is interactive and the
@code{NO_RCS} option is unset, commands are read from @file{/etc/zshrc}
and then @file{$ZDOTDIR/.zshrc}.  Finally, if the shell is a login
shell, @file{/etc/zlogin} and @file{$ZDOTDIR/.zlogin} are read.@refill

@noindent
If the @code{-s} flag is not present and an argument is given,
the first argument is taken to be the pathname of a script to execute.
The remaining arguments are assigned to the positional parameters.  The
following flags are interpreted by the shell when invoked:@refill

@cindex flags, shell
@cindex shell flags
@table @code
@item -c @var{string}
Read commands from @var{string}.

@item -s
Read command from the standard input.

@item -i
If this flag is present or the shell input and output are attached to a
terminal, this shell is interactive.
@end table

@node Wrapping Up, Concept Index, Invocation, Top
@chapter Wrapping Up

@section See Also

@noindent
sh(1), csh(1), tcsh(1), itcsh(1), rc(1), bash(1), ash(1), ksh(1),
clam(1), strftime(3).

@section Files
@cindex files used

@noindent
$ZDOTDIR/.zshenv@*
@noindent
$ZDOTDIR/.zprofile@*
@noindent
$ZDOTDIR/.zshrc@*
@noindent
$ZDOTDIR/.zlogin@*
@noindent
$ZDOTDIR/.zlogout@*
@noindent
/tmp/zsh*@*
@noindent
/etc/zshenv@*
@noindent
/etc/zprofile@*
@noindent
/etc/zshrc@*
@noindent
/etc/zlogin

@section Author

@noindent
Paul Falstad (pf@@z-code.com).  Programmable completion was implemented
by Sven Wischnowsky (oberon@@cs.tu-berlin.de) and Peter Stephenson
(pws@@s-a.amtp.liv.ac.uk).@refill

@section Availability
@cindex availability

@noindent
The latest official release of zsh is available via anonymous ftp from
@code{ftp.sterling.com}, in the directory @code{/zsh} and from
@code{carlo.phys.uva.nl}, in the directory @code{/pub/bas/zsh}.@refill

@section Undocumented Features
@cindex undocumented features

@noindent
Known only to the recipients of the zsh mailing list,
@code{zsh-list@@sterling.com}.  If you run into problems, please
send your questions and patches to the mailing list.  To subscribe to
zsh-list, send an email message with the body @samp{subscribe zsh-list}
to @code{Majordomo@@sterling.com}.@refill


@node Concept Index, Variables Index, Wrapping Up, Top
@unnumbered Concept Index

@printindex cp

@node Variables Index, Options Index, Concept Index, Top
@unnumbered Variables Index

@printindex vr

@node Options Index, Functions Index, Variables Index, Top
@unnumbered Options Index

@printindex pg

@node Functions Index, Editor Functions Index, Options Index, Top
@unnumbered Functions Index

@printindex fn

@node Editor Functions Index, Keystroke Index, Functions Index, Top
@unnumbered Editor Functions Index

@printindex tp

@node Keystroke Index,  , Editor Functions Index, Top
@unnumbered Keystroke Index

@printindex ky


@setchapternewpage odd
@contents
@bye

@c v0.1, July 8th 1992.  Added documentation for Rick's
@c (pclink@@qld.tne.oz.au) four new glob qualifiers (a/m/c/L)
@c v0.2, August 11th 1992.  Added documentation for the new PSVAR
@c variable, the f E and I flags for the fc command, and the
@c appendhistory and extendedhistory options.  Also corrected a typo in
@c the description of the ${ := } modifier.  Now current to zsh2.3beta
@c (patch level 28).
@c v0.3, August 21 1992.  Unified to the zsh.1 (patchlevel 30) patches
@c supplied by Hans Albertsson.  This meant rewriting most of the extra
@c text I added in v0.1 and v0.2, in order to match Hans'.  Corrected
@c some more typos ("is has" in several places). 
@c       [ added to the archive sometime around here ]
@c v0.4, November 1 1992.  Added up-line-or-search to complement
@c down-line-or-search.  Moved information about availability and the
@c mailing list to the end of the file, to match zsh.1.  Should now be
@c current to patchlevel 65.
@c v0.5, February 5 1993.  Has been kept mostly up-do-date by denizens
@c of the mailing list.  Final clean-up to conform to the new release
@c of zsh version 2.3 (man page dated 1 February 1993), and to the new
@c Texinfo standards (but should remain compatible with old Texinfo).
Eventually I want to rewrite to use the new features of Texinfo v2.0
and above, but we'll have to wait for the rest of the world to catch
up first.  <sigh>
v0.6, June 20th 1993.  Now matches zsh.1 from zsh2.4 patchlevel 158.
Also fixed a few typographical niceties (blank lines between items,
added some more refills, capitalized item descriptions).  Todo: more
cross-referencing, more indexing of new features, and separate vi
and emacs keystroke indices.
v0.7, September 29th 1993.  Now matches zsh.1 from zsh2.4 patchlevel
162, as supplied with 2.4.264.  Also separated out multiple table
entries, compressed secondary tables, and used the new @kbd construct
where possible.
v0.8, December 30th 1993.  Now matches zsh.1 as supplied with zsh
2.4.291.  Changed occurrences of @code{..} @var{..} into @code{..
@var{..}} to make info version cleaner, removed extraneous @code in
@item lines, escaped occurrences of '', other minor bugfixes.
v0.9. June 20th 1994.  Final (I hope) revision before 2.5 is released.
v1.0. June 20th 1994.  Add latest manpage additions and update zsh
version numbers throughout the document. (by Bas)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # This file gives some examples of compctl commands. The name zcomp
# does not mean anything to zsh, you can either put the compctl commands
# in your .zshrc or include a separate file from your .zshrc with the
# source command.

# These are just examples, use and modify to personal taste.  Copying this
# file without thought will needlessly increase zsh's memory usage and
# startup time.

# For an explanation of what all this means, read either the
# introduction for some explanation or the manual for a detailed
# description.

# Rmdir only real directories
compctl -g '*(/)' rmdir dircmp

# Strip, profile, and debug only executables.  The compctls for the
# debuggers could be better, of course.
compctl -g '*(*)' strip gprof adb dbx xdbx ups

# See the func/cdmatch function in the distribution
compctl -K cdmatch -S '/' -x 'S[/][~]' -g '*(-/)' -- cd pushd

# For rcs users, co and rlog from the RCS directory.  We don't want to see
# the RCS and ,v though.
compctl -g 'RCS/*(:t:s/\,v//)' co rlog rcs

# Run ghostscript on postscript files, but if no postscript file matches what
# we already typed, complete directories as the postscript file may not be in
# the current directory.
compctl -g '*.ps' + -g '*(-/)' gs ghostview psps pstops psmulti psselect

# Similar things for tex, texinfo and dvi files.
compctl -g '*.tex*' + -g '*(-/)' tex latex texi2dvi glatex slitex gslitex
compctl -g '*.dvi' + -g '*(-/)' xdvi dvips

# Anything after nohup is a command by itself with its own completion
# (the one for the trap builtin isn't perfect -- it does not complete
# signal names)
compctl -l '' nohup exec nice eval trap
compctl -l '' -x 'p[1]' -B -- builtin

# If the command is rsh, make the first argument complete to hosts and treat the
# rest of the line as a command on its own.
compctl -k hosts -x 'p[2,-1]' -l '' -- rsh

# kill takes signal names as the first argument after -, but job names after %
compctl -j -P % -x 's[-] p[1]' -k signals -- kill

# gzip files, but gzip -d only gzipped or compressed files
compctl -f -x 'R[-*d,^*]' -g '*.gz *.z *.Z' + -g '*(-/)' -- gzip
compctl -g '*.gz *.z *.Z' + -g '*(-/)' gunzip   # zcat if you use GNU
compctl -g '*.Z' + -g '*(-/)' uncompress zmore  # zcat if you don't use GNU
compctl -g '*.F' + -g '*(-/)' melt fcat

# find is very system dependend, this one is for GNU find.
compctl -x 's[-]' -k "(daystart depth follow maxdepth mindepth noleaf version xdev \
amin anewer cmin cnewer ctime empty false fstype gid group inum links lname mmin \
mtime name newer nouser nogroup path perm regex size true type uid used user xtype \
exec fprint fprint0 fprintf ok print print0 printf prune ls)" - \
'p[1]' -g '. .. *(-/)' - \
'c[-1,-anewer][-1,-cnewer][-1,-newer][-1,-fprint][-1,fprint0][-1,fprintf]' -f - \
'c[-1,-fstype]' -k '(ufs 4.2 4.3 nfs tmp mfs S51K S52K)' - \
'c[-1,-group]' -s '$(groups)' - \
'c[-1,-user]' -u - \
'r[-exec,;][-ok,;]' -l '' -- find

# xsetroot: gets possible colours, cursors and bitmaps from wherever.
# Uses two auxiliary functions.  You might need to change the path names.
Xcolours() { reply=($(awk '{ print $4 }' < /usr/lib/X11/X11/rgb.txt)) }
Xcursor() { reply=($(awk '/^#define/ {print $2}' \
</usr/include/X11/cursorfont.h | sed 's/^XC_//')) }
compctl -k '(-help -def -display -cursor -cursor_name -bitmap -mod -fg -bg
  -grey -rv -solid -name)' -x 'c[-1,-display]' -k hosts -S ':0.0' - \
  'c[-1,-cursor]' -f -  'c[-2,-cursor]' -f - \
  'c[-1,-bitmap]' -g '/usr/include/X11/bitmaps/*' - \
  'c[-1,-cursor_name]' -K Xcursor - \
  'C[-1,-(solid|fg|bg)]' -K Xcolours -- xsetroot

# Default completion.  See func/multicomp
compctl -D -f + -U -K multicomp
# If completion of usernames is slow for you, you may want to add something
# like
#    -x 'C[0,*/*]' -f - 's[~]' -S/ -k users + -u
# where `users' contains the names of the users you want to complete often.
# If you want to use this and to be able to complete named directories after
# the `~' you should add `+ -n' at the end


# rlogin takes hosts and users after `-l'
compctl -k hosts -x 'c[-1,-l]' -u -- rlogin

# su takes an username and args for the shell, the `-c' case is
# handled specially here
compctl -u -x 'w[2,-c] p[3,-1]' -l '' -- su

# Some systems have directories containing indices of ftp servers.
# For example: we have the directory /home/ftp/index/INDEX containing
# files of the form `<name>-INDEX.Z', this leads to:
compctl -g '/home/ftp/index/INDEX/*-INDEX.Z(:t:r:s/-INDEX//)' ftp tftp

# There are (at least) two ways to complete manual pages.  This one is
# extremely memory expensive if you have lots of man pages
man_var() {
  man_pages=( $^manpath/man*/*(N:t:r) )   # Check your setting of SH_WORD_SPLIT
  compctl -k man_pages man
  reply=( $man_pages )
}
compctl -K man_var man
# This one isn't that expensive but somewhat slower
man_glob () {
  local a
  read -cA a
  if [[ $a[2] = -s ]] then         # Or [[ $a[2] = [0-9]* ]] for BSD
    reply=( $^manpath/man$a[3]/$1*$2(N:t:r) )    # See above
  else
    reply=( $^manpath/man*/$1*$2(N:t:r) )    # See above
  fi
}
compctl -K man_glob man

# Misc.
compctl -s '$(groups)' newgrp
compctl -f -x 'p[1]' -s '$(groups)' -- chgrp
compctl -f -x 'p[1]' -u -- chown
compctl -g '*.x' + -g '*(-/)' rpcgen
compctl -g "*.[cCoa]" -x 's[-I]' -g "*(/)" - \
  's[-l]' -s '${(s.:.)LD_LIBRARY_PATH}/lib*.a(:t:r:s/lib//)' -- cc gcc
compctl -f -x 'C[-1,*f*] p[2]' -g "*.tar" -- tar
compctl -u -x 's[+] c[-1,-f],s[-f+]' -g '~/Mail/*(:t)' - \
  's[-f],c[-1,-f]' -f -- mail elm

# Some builtins.
compctl -j -P % fg bg wait jobs disown
compctl -A shift
compctl -caF type whence which
compctl -F unfunction
compctl -a unalias
compctl -v unset typeset declare vared readonly export integer
compctl -e disable
compctl -d enable
compctl -k '(cputime filesize datasize stacksize coredumpsize resident \
  memoryuse memorylocked descriptors openfiles vmemorysize)' limit ulimit
compctl -l '' -x 'p[1]' -f -- . source

# Various MH completions by Peter Stephenson
# Still to do:
# Support for searching for files in standard MH locations.

# mhcomp is best autoloaded.  Edit path where indicated.
function mhcomp {
  # Completion function for MH folders.
  # Works with both + (rel. to top) and @ (rel. to current).
  local nword args pref char mhpath
  integer ngtrue
  read -nc nword
  read -cA args

  [[ -o nullglob ]] && ngtrue=1 || setopt nullglob

  pref=$args[$nword]
  char=$pref[1]
  pref=$pref[2,-1]

# The `...`'s here account for most of the time spent in this function.
  if [[ $char = + ]]; then
#    mhpath=`mhpath +`
# EDIT ME:  Use a hard wired value here: it's faster.
    mhpath=~/Mail
  elif [[ $char = @ ]]; then
    mhpath=`mhpath`
  fi

  reply="reply=($mhpath/$pref*(-/))"
  eval $reply

  # I'm frankly amazed that this next step works, but it does.
  reply=(${reply#$mhpath/})

  (( ngtrue )) || unsetopt nullglob
}

mhfseq() { set -A reply $(mark | awk -F: '{print $1}') \
next cur prev first last all unseen }

compctl -K mhfseq -x 's[+][@]' -K mhcomp -S / -q - \
  's[-]' -k '(all fast nofast header noheader help list nolist \
  pack nopack pop push recurse norecurse total nototal)' -- folder
compctl -K mhfseq -x 's[+][@],c[-1,-draftfolder] s[+][@]' \
  -K mhcomp -S / -q - 'c[-1,-draftmessage]' -K mhfseq - \
  'C[-1,-(editor|whatnowproc)]' -c - \
  's[-]' -k '(draftfolder draftmessage nodraftfolder editor noedit \
  file form use nouse whatnowproc nowhatnowproc help)' -- comp
compctl -K mhfseq + -x 's[+][@]' -K mhcomp -S / -q - \
  's[-]' -k '(audit noaudit changecur nochangecur form format \
  file silent nosilent truncate notruncate width help)' - \
  'C[-1,-(audit|form|file)]' -f -- inc
compctl -K mhfseq -x 's[+][@],C[-1,-src] s[+][@]' \
  -K mhcomp -S / -q - 'c[-1,-file]' -f - 'c[-1,-rmmprov]' -c - \
  's[-]' -k '(draft link nolink preserve nopreserve src file \
  rmmproc normmproc help)' -- refile
compctl -K mhfseq -x 's[+][@],C[-1,-(draftfolder|fcc)] s[+][@]' \
  -K mhcomp -S / -q - 'c[-1,-draftmessage]' -K mhfseq -\
  's[-]' -k '(annotate noannotate cc nocc draftfolder nodraftfolder \
  draftmessage editor noedit fcc filter form inplace noinplace query \
  noquery width whatnowproc nowhatnowproc help)' - 'c[-1,(cc|nocc)]' \
  -k '(all to cc me)' - 'C[-1,-(filter|form)]' -f - \
  'C[-1,-(editor|whatnowproc)]' -c -- repl
compctl -K mhfseq -x 's[+][@]' -K mhcomp -S / -q - \
  's[-]' -k '(clear noclear form format header noheader reverse noreverse \
  file help width)' - 'C[-1,-(file|form)]' -f -- scan
compctl -K mhfseq -x 's[+][@]'  -K mhcomp -S / -q - \
  's[-]' -k '(draft header noheader showproc noshowproc)' - \
  'c[-1,showproc]' -c -- show
compctl -K mhfseq -x 's[+][@]' -K mhcomp -S / -q - 's[-]' \
  -k '(help)' -- rmm

# End of MH completions

# By Bart Schaefer
# CVS -- there's almost no way to make this all-inclusive, but ...
#
cvsflags=(-H -Q -q -r -w -l -n -t -v -b -e -d)
cvscmds=(add admin checkout commit diff history import export log rdiff
	    release remove status tag rtag update)

# diff assumes gnu rcs using gnu diff
# log assumes gnu rcs

compctl -k "($cvscmds $cvsflags)" \
    -x "c[-1,-D]" -k '(today yesterday 1\\\ week\\\ ago)' \
    - "r[add,;]" -k "(-k -m)" -f \
    - "r[admin,;]" -K cvstargets \
    - "r[checkout,;]" -k "(-A -N -P -Q -c -f -l -n -p -q -s -r -D -d -k -j)" \
    - "r[commit,;]" -k "(-n -R -l -f -m -r)"  -K cvstargets \
    - "r[diff,;]" -k "(-l -D -r -c -u -b -w)" -K cvstargets \
    - "r[history,;]" \
	-k "(-T -c -o -m -x -a -e -l -w -D -b -f -n -p -r -t -u)" \
	-K cvstargets \
    - "r[history,;] c[-1,-u]" -u \
    - "r[import,;]" -k "(-Q -q -I -b -m)" -f \
    - "r[export,;]" -k "(-N -Q -f -l -n -q -r -D -d)" -f \
    - "R[(r|)log,;]" -k "(-l -R -h -b -t -r -w)" -K cvstargets \
    - 'R[(r|)log,;] s[-w] n[-1,,],s[-w]' -u -S , -q \
    - "r[rdiff,;]" -k "(-Q -f -l -c -u -s -t -D -r -V)" -K cvstargets \
    - "r[release,;]" -k "(-Q -d -q)" -f \
    - "r[remove,;]" -k "(-l -R)" -K cvstargets \
    - "r[status,;]" -k "(-v -l -R)" -K cvstargets \
    - "r[tag,;]" -k "(-Q -l -R -q -d -b)" -K cvstargets \
    - "r[rtag,;]" -k "(-Q -a -f -l -R -n -q -d -b -r -D)" -f \
    - "r[update,;]" -k "(-A -P -Q -d -f -l -R -p -q -k -r -D -j -I)" \
	-K cvstargets \
    -- cvs
unset cvsflags cvscmds

cvstargets() {
    local nword args pref ngtrue f
    [[ -o nullglob ]] && ngtrue=1
    setopt nullglob
    read -nc nword; read -Ac args
    pref=$args[$nword]
    if [[ -d $pref:h && ! -d $pref ]]
    then
	pref=$pref:h
    elif [[ $pref != */* ]]
    then
	pref=
    fi
    [[ -n "$pref" && "$pref" != */ ]] && pref=$pref/
    reply=($(for f in $(cat ${pref}CVS/Entries 2>/dev/null | \
    		sed 's/^\/\([^\/]*\).*/\1/'); do echo $pref$f; done)
	   $(echo ${pref}**/CVS(:h) | sed 's/CVS//'))
    [[ $ngtrue = 1 ]] || unsetopt nullglob
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             clear
cd
stty dec new cr0 -tabs
ttyctl -f  # freeze the terminal modes... can't change without a ttyctl -u
umask 022
export MAIL=/usr/spool/mail/$USER
MAILCHECK=60
mesg y
uptime
fortune
log
from 2>/dev/null
cat notes
unlimit
limit core 0
msgs -fp
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         path=(~/scr ~/bin/$HOSTTYPE
	/usr/princeton/bin /usr/ucb /usr/bin /bin
	/usr/hosts /usr/princeton/bin/X11 /usr/etc /etc .)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     #
# my rc file for zsh 2.2
# all this runs in interactive shells only
#

# search path for the cd command
cdpath=(. ~ ~/src/cs320 ~/src)

# where to look for function definitions
# fpath=(~/func)

# useful directory
csrc=/usr/princeton/common/src

# use hard limits, except for a smaller stack and no core dumps
unlimit
limit stack 8192
limit core 0
limit -s

umask 022

# define some aliases
alias a=alias
a a.out=./a.out sendmail=/usr/lib/sendmail c=cp 0=vi 09='vi -t' 00=r
a d=dirs en='enscript -2rGh' fm='finger -m' grep=egrep h=history
a hinfo='host -t hinfo' j=jobs l='ls -AF' lock='lock -p -60000'
a lsd='ls -d */' m=make mm=less
a nrable='ls -AFltrd *(^R)' sz='ls -l | sort -n +3 | tail -20'
a sn='sed -n' nw='l -ltr | tail' pd=pushd pop=popd mroe=more
a rable='ls -AFltrd *(R)' strings='strings -' t=cat
a v=mv where='hostname; echo >/dev/null' k9='kill -9' whoami='echo root'
a find='noglob find' bindkey='noglob bindkey' dh='dirs -v'
a mv='nocorrect mv' z=suspend

# global aliases
a -g 'GF'='| fgrep -f ~/.friends' G='| grep' M='| less' cex='/u/pup/centrex'

# setenv for csh junkies (including tset)
setenv() { export $1=$2 }

manpath=(/usr/man /usr/princeton/man /u/cad/man /usr/lang/man)
export MANPATH

# filename completion suffixes to ignore
fignore=(.o .pro .old)

# hosts to use for completion
hosts=(uunet.uu.net `hostname` wuarchive.wustl.edu quiche.cs.mcgill.ca)

PROMPT='%l %T %m[%h] '

# prompt on the right side of the screen
RPROMPT=' %~'

# some environment variables
export MAILCALL='NEW MAIL! '
export YOUSAID='In %C you wrote:'
export ATTRIBUTION='%f wrote:'

# functions to autoload
# autoload cx acx mere yu yp randline proto namedir ilogin

MAILCHECK=30
HISTSIZE=600
DIRSTACKSIZE=50

# lots of options
setopt notify globdots correct pushdtohome cdablevars autolist \
	sunkeyboardhack correctall autocd recexact longlistjobs mailwarning \
	autoresume histignoredups pushdsilent noclobber \
	autopushd pushdminus extendedglob rcquotes
unsetopt bgnice

# watch for my friends
watch=($(cat ~/.friends))
WATCHFMT='%n %a %l from %m at %t.'
LOGCHECK=0

export LESS=-ainx3
unhash p

# some nice bindings
bindkey '^X^Z' universal-argument ' ' magic-space
bindkey '^X^A' vi-find-prev-char-skip
bindkey '^Z' accept-and-hold
bindkey -s '\M-/' \\\\
bindkey -s '\M-=' \|
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 .       ..      acx     cdmatch     cx *    harden      mere kÊ     	multicomp ‹¸    proto Ê     randline £‹¸    run-help £‹¸    yp *    yu *   <zed                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #! /bin/sh
#
# zsh shell function to make its arguments 755
# also works as an sh script
#
chmod 755 $*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Start of cdmatch.
# Save in your functions directory and autoload, then do
#   compctl -K cdmatch -S '/' cd pushd
# or if you prefer
#   compctl -K cdmatch -S '/' -x 'S[/][~][./][../]' -g '*(-/)' -- cd pushd
# (to use ordinary globbing for absolute paths).
#
# Completes directories for cd, pushd, ... anything which knows about cdpath.
# Note that . is NOT automatically included.  It's up to you to put it in
# cdpath somewhere.

local dir nword args pref ngtrue gdtrue

[[ -o nullglob ]] && ngtrue=1
[[ -o globdots ]] && gdtrue=1
setopt nullglob globdots

read -nc nword
read -Ac args
pref=$args[$nword]

if [[ $pref[1] = [/\~] ]]; then
  eval "reply=($pref*(-/))"
else
  reply=()

  for dir in $cdpath
  do
    eval "reply=(\$reply $dir/$pref*(-/:s,$dir/,,:gs/ /\\\\\\\\ /))"
  done
fi

[[ $ngtrue = 1 ]] || unsetopt nullglob
[[ $gdtrue = 1 ]] || unsetopt globdots

return
# End of cdmatch.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #! /bin/sh
#
# zsh shell function to make its arguments executable
# also works as a sh script
#
chmod +x $*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #! /bin/sh
# harden a link (convert it to a singly linked file)
cp $1 $1.foo
rm $1
mv $1.foo $1

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               #! /bin/sh
# read a man page in the current directory
nroff -man -Tman $1 | less -s
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # multicomp() {
# Completes all manner of files given prefixes for each path segment.
# e.g. s/z/s -> src/zsh-2.4/src
#
# Usage: e.g.
# compctl -D -f + -U -K multicomp
#
# Note that exactly matched directories are not expanded, e.g.
# s/zsh-2.4/s<TAB> will not expand to src/zsh-2.4old/src.
# Will expand glob patterns already in the word, but use complete-word,
# not TAB (expand-or-complete), or you will get ordinary glob expansion.
# Requires the -U option to compctl.
# Menucompletion is highly recommended for ambiguous matches.
# Liable to screw up escaped metacharacters royally.
# $fignore is not used: feel free to add your own bit.

local pref head rceptrue ngtrue sofar origtop newtop globdir="(-/)" wild

# No point using the toggle for rcexpandparam,
# since we don't know if the option is set already.
# (This is always the case, so what's the point in the toggle?)
# This stuff is going to be superceded by `setopt localopts' eventually.
[[ -o rcexpandparam ]] && rceptrue=1
[[ -o nullglob ]] && ngtrue=1
setopt rcexpandparam nullglob

pref=${1}$2
# Hack to allow programmable completion to select multicomp after a :
# (e.g.
# compctl -D -f -x 's[:]' -U -K multicomp
# )
[[ $pref = :* ]] && pref=$pref[2,-1]

sofar=('')
reply=('')

if [[ $pref[1] = '~' ]]; then
  # If the string started with ~, save the head and what it will become.
  origtop=${pref%%/*}
  [[ $origtop = */ ]] && origtop[-1]=
  # Next line assumes cshjunkietilde was not set.  See note on toggles above.
  newtop=${~origtop}
  # Save the expansion as the bit matched already
  sofar=($newtop)
  pref=$pref[$#origtop+1,-1]
fi

while [[ -n $pref ]]; do
  [[ $pref = /* ]] && sofar=(${sofar}/) && pref=$pref[2,-1]
  head=${pref%%/*}
  [[ $head = */ ]] && head[-1]=
  pref=$pref[$#head+1,-1]
  if [[ $pref = /* && -z $sofar[2] && -d ${sofar}$head ]]; then
    # Exactly matched directory: don't try to glob
    reply=("${sofar}$head")
  else
    [[ $pref = /* ]] || globdir=
    # if path segment contains wildcards, don't add another.
    if [[ $head = *[\*\?]* ]]; then
      wild=
    else
      wild='*'
    fi
    # $sofar must be expanded with rcexpandparam here, in such a way
    # that metacharacters are expanded in the eval step.
    reply=(${sofar}"${head}${wild}${globdir}")
    eval "reply=($reply)"
  fi

  [[ -z $reply[1] ]] && reply=() && break
  [[ -n $pref ]] && sofar=($reply)
done

# Restore ~'s in front if there were any.
# There had better not be anything funny in $newtop.
[[ -n $origtop ]] && eval "reply=(\$reply:gs?$newtop?\\$origtop?)"

[[ rceptrue = 1 ]] || unsetopt rcexpandparam
[[ ngtrue = 1 ]] || unsetopt nullglob

# }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    #! /bin/sh
# generate prototypes, if your style is the same as mine
for i
do
	rm $i:r.pro 2>/dev/null
	grep -v '[{};:#]' $i | grep '^[A-Za-z]' |
		grep -v static | sed 's/$/;/' >! $i:r.pro
done
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              # get a random line from a file
integer z=$(wc -l <$1)
sed -n $[RANDOM%z+1]p $1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                #! /bin/zsh
# zsh script to peruse the help directory
#
if [[ $1 = "-l" ]]; then
  if [[ ${HELPDIR:-} != "" ]]; then
    echo 'Here is a list of topics for which help is available:'
    echo ""
    ls $HELPDIR
  else
    echo 'There is no help available at this time'
  fi
elif [[ ${HELPDIR:-} != "" && -r $HELPDIR/$1 ]]
then
    ${=PAGER:-more} $HELPDIR/$1
else
    man $1
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       #! /bin/sh
ypmatch $1 passwd
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   #! /bin/sh
ypmatch $1 passwd.byuid
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # zed():  Peter Stephenson <pws@s-a.amtp.liv.ac.uk>
# No other shell could do this.
# Edit small files with the command line editor.
# Use ^X^W to save, ^C to abort.
# Option -f: edit shell functions.  (Also if called as fned.)
#
# Completion: use
# compctl -f -x 'w[1,-f]' -F -- zed

local var nb fun

[[ $1 = -f || $0 = fned ]] && fun=1
[[ $1 = -(|-|f) ]] && shift

[[ -z "$1" ]] && echo 'Usage: "zed filename" or "zed -f function"' && return 1

# catch interrupts
TRAPINT() {
  bindkey "^M" accept-line
  [[ $nb = 1 ]] || unsetopt nobanghist
  trap - INT
  (($1 > 0)) && return $[128+$1]
}

# don't mangle !'s
[[ -o nobanghist ]] && nb=1
setopt nobanghist

bindkey "^M" self-insert-unmeta
# Depending on your stty's, you may be able to use ^J as accept-line, else:
bindkey "^X^W" accept-line

if [[ $fun = 1 ]]; then
  var="$(functions $1)"
  # If function is undefined but autoloadable, load it
  if [[ $var = undefined* ]]; then
    local dir
    for dir in $fpath; do
      if [[ -f $dir/$1 ]]; then
	var="$1() {
$(<$dir/$1)
}"
	break
      fi
    done
  elif [[ -z $var ]]; then
    var="$1() {
}"
  fi
  vared var
  # remember there\'s a memory leak in eval...
  eval function "$var"
else
  [[ -f $1 ]] && var="$(<$1)"
  vared var
  (( $? == 0 )) && print -R "$var" >! $1
fi

bindkey "^X^W" undefined-key

# Restore setup
TRAPINT 0
return 0

# End of zed
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 .       ..      TRAP kÊ      alias Ê    ! autoload £‹¸   " bg *   # bindkey    $ break Ê    % builtin    & bye    ' case kÊ    ( cd *   ( chdir Ê    ) chpwd Ê    * compctl    + continue £‹¸   , coproc     - declare    . dirs kÊ    / disable    0 disown     1 echo kÊ    2 echotc     3 elif kÊ    3 else kÊ    4 enable     5 eval kÊ    & exit kÊ    6 export     7 false Ê    8 fc *   9 fg *   : for            : foreach    ; function £‹¸   - 	functions ›–   < getln Ê    = getopts    > hash kÊ    8 history    3 if     - integer    ? jobs k˛Ä   @ kill £‹∞   A let    B limit ˛Ä   - local ˛Ä   C log    D logout Ä   E periodic £‹¸   F popd k˛Ä   G precmd Ä   H print ˛Ä   I pushd ˛Ä   H pwd    8 r „*   J read k˛Ä   K readonly £‹¸   L rehash Ä   M repeat Ä   N return Ä   O sched ‹∞   P select ∞   Q set    R setopt Ä           S shift Ê    T source ∞   U suspend    V test £‹∞   W time kÊ    X times Ê    Y trap kÊ    7 true kÊ    Z ttyctl     [ type £‹∞   - typeset    \ ulimit ∞   ] umask Ê      unalias    ^ 
unfunction ¸   > unhash     _ unlimit    Q unset Ê    R unsetopt £›–   ` until Ê    a vared Ê    b wait kÊ    [ whence     [ which Ê    c while Ê    # hzle                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    TRAPxxx
              If defined and non-null, this function will be exe-
              cuted whenever the shell catches a  signal  SIGxxx,
              where  xxx  is  a  signal name as specified for the
              kill builtin (see below).  The signal  number  will
              be  passed  as the first parameter to the function.
              In addition, TRAPZERR is executed whenever  a  com-
              mand  has a non-zero exit status, TRAPDEBUG is exe-
              cuted after each command, and TRAPEXIT is  executed
              when  the shell exits, or when the current function
              exits if defined inside a function.  If a  function
              of  this  form  is  defined and null, the shell and
              processes spawned by it will ignore SIGxxx.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        alias [ -grm ] [ name[=value] ] ...
              With no arguments, print the list of aliases in the
              form name=value on the standard output.   For  each
              name  with  a  corresponding value, define an alias
              with that value.  A trailing space in value  causes
              the next word to be checked for alias substitution.
              If the -g flag is present, define a  global  alias;
              global  aliases  are  expanded  even if they do not
              occur in command position.  For each name  with  no
              value,  print  the  value of name, if any.  If only
              the -g or the -r flags are  given  only  global  or
              regular aliases are listed. If the -m flag is given
              the arguments are taken as patterns (they should be
              quoted  to  preserve them from being interpreted as
              glob patterns) and the aliases matching these  pat-
              terns are printed.  The exit status is nonzero if a
              name (with no value) is given for  which  no  alias
              has been defined.

       unalias [ -m ] name ...
              The  alias  definition,  if  any,  for each name is
              removed.  With the -m flag the arguments are  taken
              as patterns (should be quoted) and all aliases with
              matching names are removed.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            autoload [ name ... ]
              For  each  of  the  names (which are names of func-
              tions), create a function  marked  undefined.   The
              fpath  variable will be searched to find the actual
              function definition when the function is first ref-
              erenced.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           bg [ job ... ]
       job ... &
              Put  each  specified  job in the background, or the
              current job if none is specified.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ept-line (^J ^M)
              Execute the contents of the buffer.

       accept-line-and-down-history (^O)
              Execute the current line, and push the next history
              event on the the buffer stack.

       vi-cmd-mode (^X^V) (^[)
              Enter  command  mode;  that  is,  use the alternate
              keymap.  Yes, this is bound  by  default  in  emacs
              mode.

       vi-caps-lock-panic (unbound) (H K)
              Hang  until  any lowercase key is pressed.  This is
              for vi users without the mental  capacity  to  keep
              track of their caps lock key (like the author).

       clear-screen (^L ESC-^L)
              Clear the screen and redraw the prompt.

       exchange-point-and-mark (^X^X)
              Exchange  the  cursor position with the position of
              the mark.

       get-line (ESC-G ESC-g)
              Pop the top line off the buffer stack and insert it
              at the cursor position.

       pound-insert (unbound) (#)
              If  there is no # character at the beginning of the
              current line, add one.  If there is one, remove it.
              In  either  case,  accept  the  current  line.  The
              INTERACTIVE_COMMENTS option must be set for this to
              have any usefulness.

       push-input
              Push  the  entire  current multiline construct onto
              the buffer stack and return to the top-level  (PS1)
              prompt.   If the current parser construct is only a
              single line, this is exactly like push-line.   Next
              time  the  editor  starts up or is popped with get-
              line, the construct will be popped off the  top  of
              the  buffer  stack  and  loaded  into  the  editing
              buffer.

       push-line (^Q ESC-Q ESC-q)
              Push the current buffer onto the buffer  stack  and
              clear  the buffer.  Next time the editor starts up,
              the buffer will be popped off the top of the buffer
              stack and loaded into the editing buffer.

       push-line-or-edit
              At  the top-level (PS1) prompt, equivalent to push-
              line.  At a secondary (PS2) prompt, move the entire
              current multiline construct into the editor buffer.
              The latter is equivalent to push-input followed  by
              get-line.

       redisplay (unbound) (^R)
              Redisplays the edit buffer.

       send-break (^G)
              Abort  the  current  editor  function, eg. execute-
              named-command, or the editor itself, eg. if you are
              in  vared.  Otherwise abort the parsing of the cur-
              rent line.

       run-help (ESC-H ESC-h)
              Push the buffer onto the buffer stack, and  execute
              the  command  "run-help cmd", where cmd is the cur-
              rent command.  run-help is normally aliased to man.

       vi-set-buffer (unbound) (")
              Specify  a  buffer to be used in the following com-
              mand.

       vi-set-mark (unbound) (m)
              Set the specified mark at the cursor position.

       set-mark-command (^@)
              Set the mark at the cursor position.

       spell-word (ESC-$ ESC-S ESC-s)
              Attempt spelling correction on the current word.

       undefined-key
              Beep.

       undo (^_ ^Xu ^X^U) (u)
              Incrementally undo the last text modification.

       which-command (ESC-?)
              Push the buffer onto the buffer stack, and  execute
              the  command  "which-command cmd", where cmd is the
              current command.  which-command is normally aliased
              to whence.
                                                                                                                                                                                                                                                                                                                                             break [ n ]
              Exit from an enclosing for, while,  until,  select,
              or  repeat  loop.   If n is specified, then break n
              levels instead of just one.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      bindkey -mevd
       bindkey -r in-string ...
       bindkey [ -a ] in-string [ command ] ...
       bindkey -s [ -a ] in-string out-string ...
              The -e and -v options put the keymaps in emacs mode
              or vi mode respectively; they cannot be used simul-
              taneously. The -d option resets all bindings to the
              compiled-in  settings.  If not used with options -e
              or -v, the maps will be left in emacs mode,  or  in
              vi mode if the VISUAL or EDITOR variables exist and
              contain the string "vi".  Metafied  characters  are
              bound  to  self-insert  by  default.  The -m option
              loads the compiled-in bindings of these  characters
              for  the  mode determined by the preceding options,
              or the current mode if  used  alone.  Any  previous
              bindings done by the user will be preserved. If the
              -r option is given, remove any binding for each in-
              string.  If  the  -s  option is not specified, bind
              each in-string to a specified command. If  no  com-
              mand  is  specified, print the binding of in-string
              if it is bound, or return a nonzero exit code if it
              is  not  bound. If the -s option is specified, bind
              each in-string to each specified  out-string.  When
              in-string  is typed, out-string will be pushed back
              and treated as input to the line editor. This  pro-
              cess is recursive but, to avoid infinite loops, the
              shell will report an error if more than 20 consecu-
              tive replacements happen. If the -a option is spec-
              ified,  bind  the  in-strings  in  the  alternative
              keymap  instead  of the standard one.  The alterna-
              tive keymap is used in vi command mode.

              It's possible for an in-string to be bound to some-
              thing  and  also be the beginning of a longer bound
              string. In this case the shell will wait a  certain
              time to see if more characters are typed and if not
              it  will  execute  the  binding.  This  timeout  is
              defined by the KEYTIMEOUT parameter; its default is
              0.4 sec. No timeout is done if the prefix string is
              not bound.

              For either in-string or out-string, control charac-
              ters may be specified in the form ^X, and the back-
              slash may be used to introduce one of the following
              escape sequences:
                      \a     bell character
                      \n     linefeed (newline)
                      \b     backspace
                      \t     horizontal tab
                      \v     vertical tab
                      \f     form feed
                      \r     carriage return
                      \e, \E escape
                      \nnn   character code in octal
                      \M-xxx character or  escape  sequence  with
                             meta  bit set. The `-' after the `M'
                             is optional.
                      \C-X   control character.   The  `-'  after
                             the `C' is optional.

              In all other cases, \ escapes the following charac-
              ter.  Delete is written as `^?'. Note  that  `\M^?'
              and `^\M?' are not the same.

              Multi-character  in-strings cannot contain the null
              character ("^@" or "^ "). If they appear in a bind-
              key  command,  they  will be silently translated to
              "\M-^@". This restriction does not  apply  to  out-
              strings,  single-character in-strings and the first
              character of a multi-char in-string.

   Movement
       vi-backward-blank-word (unbound) (B)
              Move backward one word, where a word is defined  as
              a series of non-blank characters.

       backward-char (^B ESC-[D) ()
              Move backward one character.

       vi-backward-char () (h)
              Move   backward  one  character,  without  changing
              lines.

       backward-word (ESC-B ESC-b) (unbound)
              Move to the beginning of the previous word.

       emacs-backward-word
              Move to the beginning of the previous word.

       vi-backward-word (unbound) (b)
              Move to the beginning of  the  previous  word,  vi-
              style.

       beginning-of-line (^A) (0)
              Move  to  the beginning of the line.  If already at
              the beginning of the line, move to the beginning of
              the previous line, if any.

       vi-beginning-of-line
              Move to the beginning of the line, without changing
              lines.

       end-of-line (^E)
              Move to the end of the line.  If already at the end
              of  the  line, move to the end of the next line, if
              any.

       vi-end-of-line (unbound) ($)
              Move to the end of the line.

       vi-forward-blank-word (unbound) (W)
              Move forward one word, where a word is defined as a
              series of non-blank characters.

       vi-forward-blank-word-end (unbound) (E)
              Move  to the end of the current word, or, if at the
              end of the current word, to the  end  of  the  next
              word,  where  a word is defined as a series of non-
              blank characters.

       forward-char (^F ESC-[C)
              Move forward one character.

       vi-forward-char (unbound) (space l)
              Move forward one character.

       vi-find-next-char (^X^F) (f)
              Read a character from the keyboard, and move to the
              next occurrence of it in the line.

       vi-find-next-char-skip (unbound) (t)
              Read a character from the keyboard, and move to the
              position just before the next occurrence of  it  in
              the line.

       vi-find-prev-char (unbound) (F)
              Read a character from the keyboard, and move to the
              previous occurrence of it in the line.

       vi-find-prev-char-skip (unbound) (T)
              Read a character from the keyboard, and move to the
              position  just  after the previous occurrence of it
              in the line.

       vi-first-non-blank (unbound) (^)
              Move to the first non-blank character in the  line.

       vi-forward-word (unbound) (w)
              Move forward one word, vi-style.

       forward-word (ESC-F ESC-f) (unbound)
              Move  to  the  beginning  of  the  next  word.  The
              editor's idea of a word is specified with the WORD-
              CHARS parameter.

       emacs-forward-word
              Move to the end of the next word.

       vi-forward-word-end (unbound) (e)
              Move to the end of the next word.

       vi-goto-column (ESC-|) (|)
              Move  to  the column specified by the numeric argu-
              ment.

       vi-goto-mark (unbound) (`)
              Move to the specified mark.

       vi-goto-mark-line (unbound) (')
              Move to beginning of the line containing the speci-
              fied mark.

       vi-repeat-find (unbound) (;)
              Repeat the last vi-find command.

       vi-rev-repeat-find (unbound) (,)
              Repeat  the  last  vi-find  command in the opposite
              direction.

   History
       beginning-of-buffer-or-history (ESC-<)
              Move to the beginning of the buffer, or if  already
              there, move to the first event in the history list.

       beginning-of-line-hist
              Move to the beginning of the line.  If  already  at
              the  beginning  of the buffer, move to the previous
              history line.

       beginning-of-history
              Move to the first event in the history list.

       down-line-or-history (^N ESC-[B) (+ j)
              Move down a line in the buffer, or  if  already  at
              the bottom line, move to the next event in the his-
              tory list.

       down-line-or-search
              Move down a line in the buffer, or  if  already  at
              the  bottom line, search forward in the history for
              a line beginning with the first word in the buffer.

       down-history (unbound) (^N)
              Move to the next event in the history list.

       history-beginning-search-backward (unbound)
              Search backward in the history for a line beginning
              with the current  line  up  to  the  cursor.   This
              leaves the cursor in its original position.

       end-of-buffer-or-history (ESC->)
              Move to the end of the buffer, or if already there,
              move to the last event in the history list.

       end-of-line-hist
              Move to the end of the line.  If already at the end
              of the buffer, move to the next history line.

       end-of-history
              Move to the last event in the history list.

       vi-fetch-history (unbound) (G)
              Fetch  the  history  line  specified by the numeric
              argument.

       history-incremental-search-backward (^R ^Xr)
              Search  backward  incrementally  for  a   specified
              string.   The  string  may begin with `^' to anchor
              the  search  to  the  beginning  of  the  line.   A
              restricted set of editing functions is available in
              the mini-buffer. An interrupt signal, as defined by
              the stty setting,  will stop the search and go back
              to the original line. An undefined  key  will  have
              the same effect. The supported functions are: back-
              ward-delete-char,  quoted-insert,  accept-and-hold,
              accept-and-infer-next-history,    accept-line   and
              accept-line-and-down-history;   magic-space    just
              inserts  a  space.  Any  string that is bound to an
              out-string (via bindkey -s) will behave as if  out-
              string  were typed directly.  Typing the binding of
              history-incremental-search-backward  will  get  the
              next occurrence of the contents of the mini-buffer.
              Typing the binding  of  history-incremental-search-
              forward inverts the sense of the search. The direc-
              tion of the search is indicated in the mini-buffer.
              Any multi-character string that is not bound to one
              of the above functions will beep and interrupt  the
              search,  leaving the last found line in the buffer.
              Any single character that is not bound  to  one  of
              the above functions, or self-insert or self-insert-
              unmeta, will have the same effect but the  function
              will be executed.

       history-incremental-search-forward (^Xs)
              Search   forward   incrementally  for  a  specified
              string.  The string may begin with  `^'  to  anchor
              the  search to the beginning of the line. The func-
              tions available in the mini-buffer are the same  as
              for history-incremental-search-backward.

       history-search-backward (ESC-P ESC-p) (K)
              Search backward in the history for a line beginning
              with the first word in the buffer.

       vi-history-search-backward (unbound) (/)
              Search backward in  the  history  for  a  specified
              string.   The  string  may begin with `^' to anchor
              the  search  to  the  beginning  of  the  line.   A
              restricted set of editing functions is available in
              the mini-buffer. An interrupt signal, as defined by
              the  stty setting,  will stop the search, as will a
              character  bound  to  vi-cmd-mode.  The   functions
              available  in  the  mini-buffer  are:  accept-line,
              backward-delete-char,  vi-backward-delete-char  and
              quoted-insert.  Any string that is bound to an out-
              string (via bindkey -s)  will  behave  as  if  out-
              string  were  typed  directly.  Any other character
              that is not bound to  self-insert  or  self-insert-
              unmeta will beep and be ignored. If the function is
              called from vi command mode,  the  bindings  of  vi
              insert mode will be used.

       history-search-forward (ESC-N ESC-n) (J)
              Search  forward in the history for a line beginning
              with the first word in the buffer.

       vi-history-search-forward (unbound) (?)
              Search forward  in  the  history  for  a  specified
              string.   The  string  may begin with `^' to anchor
              the search to the beginning of the line. The  func-
              tions  available in the mini-buffer are the same as
              for vi-history-search-backward.

       infer-next-history (^X^N)
              Search in the history list for a line matching  the
              current one and fetch the event following it.

       insert-last-word (ESC-_ ESC-.)
              Insert  the  last  word  from  the previous history
              event at the cursor position.

       vi-repeat-search (unbound) (n)
              Repeat the last vi history search.

       vi-rev-repeat-search (unbound) (N)
              Repeat the last vi history search, but in  reverse.

       toggle-literal-history (ESC-R ESC-r)
              Toggle  between  literal  and lexical history.  The
              default  is  lexical  history  unless  the  HISTLIT
              option is set.

       up-line-or-history (^P ESC-[A) (- k)
              Move  up a line in the buffer, or if already at the
              top line, move to the previous event in the history
              list.

       up-line-or-search
              Move  up a line in the buffer, or if already at the
              top line, search backward in the history for a line
              beginning with the first word in the buffer.

       up-history (unbound) (^P)
              Move to the previous event in the history list.

       history-beginning-search-forward (unbound)
              Search  forward in the history for a line beginning
              with the current  line  up  to  the  cursor.   This
              leaves the cursor in its original position.

   Modifying Text
       vi-add-eol (unbound) (A)
              Move  to the end of the line and enter insert mode.

       vi-add-next (unbound) (a)
              Move forward one character and enter insert mode.

       backward-delete-char (^H ^?) (^?)
              Delete the character behind the cursor.

       vi-backward-delete-char (unbound) (X)
              Delete the character  behind  the  cursor,  without
              changing lines.

       backward-delete-word
              Delete the word behind the cursor.

       backward-kill-line
              Kill  from  the beginning of the line to the cursor
              position.

       backward-kill-word (^W ESC-^H ESC-^?)
              Kill the word behind the cursor.

       vi-backward-kill-word (unbound) (^W)
              Kill the word behind the cursor.

       capitalize-word (ESC-C ESC-c)
              Capitalize the current word and move past it.

       vi-change (unbound) (c)
              Read a movement command from the keyboard, and kill
              from  the  cursor  position  to the endpoint of the
              movement.  Then enter insert mode.  If the  command
              is vi-change, kill the current line.

       vi-change-eol (unbound) (C)
              Kill  to the end of the line and enter insert mode.

       vi-change-whole-line (unbound) (S s)
              Kill the current line and enter insert mode.

       copy-region-as-kill (ESC-W ESC-w)
              Copy the area from the cursor to the  mark  to  the
              kill buffer.

       copy-prev-word (ESC-^_)
              Duplicate the word behind the cursor.

       vi-delete (unbound) (d)
              Read a movement command from the keyboard, and kill
              from the cursor position to  the  endpoint  of  the
              movement.   If  the  command is vi-delete, kill the
              current line.

       delete-char (unbound) (x)
              Delete the character under the cursor.

       vi-delete-char (unbound) (x)
              Delete the character under the cursor.

       delete-word (ESC-D ESC-d)
              Delete the current word.

       down-case-word (ESC-L ESC-l)
              Convert the current word to all lowercase and  move
              past it.

       kill-word
              Kill the current word.

       gosmacs-transpose-chars
              Exchange the two characters behind the cursor.

       vi-indent (unbound) (>)
              Indent a number of lines.

       vi-insert (unbound) (i)
              Enter insert mode.

       vi-insert-bol (unbound) (I)
              Move  to the beginning of the line and enter insert
              mode.

       vi-join (^X^J)
              Join the current line with the next one.

       kill-line (^K) (D)
              Kill from the cursor to the end of the line.

       vi-kill-line
              Kill from the cursor to the beginning of the  line.

       kill-region
              Kill from the cursor to the mark.

       kill-buffer (^X^K) (^U)
              Kill the entire buffer.

       kill-whole-line (^U) (unbound)
              Kill the current line.

       vi-match-bracket (^X^B) (%)
              Move  to  the  bracket character (one of {}, (), or
              []) that matches the one under the cursor.

       vi-open-line-above (unbound) (O)
              Open a line above the cursor and enter insert mode.

       vi-open-line-below (unbound) (o)
              Open a line below the cursor and enter insert mode.

       vi-oper-swap-case
              Read a movement command from the keyboard, and swap
              the case of all characters from the cursor position
              to the endpoint of the movement.  If  the  movement
              command  is vi-oper-swap-case, swap the case of all
              characters on the current line.

       overwrite-mode (^X^O)
              Toggle between overwrite mode and insert mode.

       vi-put-after (unbound) (p)
              Insert the contents of the kill  buffer  after  the
              cursor.

       quoted-insert (^V)
              Insert  the  next  character  typed into the buffer
              literally.

       quote-line (ESC-')
              Quote the current line; that is, put a '  character
              at  the  beginning  and  the end, and convert all '
              characters to '\''.

       quote-region (ESC-")
              Quote the region from the cursor to the mark.

       vi-replace (unbound) (R)
              Enter overwrite mode.

       vi-repeat-change (unbound) (.)
              Repeat the last vi mode text modification.

       vi-replace-chars (unbound) (r)
              Replace the character under the cursor with a char-
              acter read from the keyboard.

       self-insert (printable characters)
              Put  a  character in the buffer at the cursor posi-
              tion.

       self-insert-unmeta (ESC-^I ESC-^J ESC-^M)
              Put a character in the buffer after  stripping  the
              meta bit and converting ^M to ^J.

       vi-substitute (unbound) (s)
              Substitute the next character(s).

       vi-swap-case (unbound) (~)
              Swap the case of the character under the cursor and
              move past it.

       transpose-chars (^T)
              Exchange the two characters to the left of the cur-
              sor  if at end of line, else exchange the character
              under the cursor with the character to the left.

       transpose-words (ESC-T ESC-t)
              Exchange the current word with the one before it.

       vi-unindent (unbound) (<)
              Unindent a number of lines.

       up-case-word (ESC-U ESC-u)
              Convert the current word to all caps and move  past
              it.

       yank (^Y) (P)
              Insert  the contents of the kill buffer at the cur-
              sor position.

       yank-pop (ESC-y) (unbound)
              Remove the text just yanked, rotate the  kill-ring,
              and yank the new top.  Only works following yank or
              yank-pop.

       vi-yank (unbound) (y)
              Read a movement command from the keyboard, and copy
              the region from the cursor position to the endpoint
              of the movement into the kill buffer.  If the  com-
              mand is vi-yank, copy the current line.

       vi-yank-eol (unbound) (Y)
              Copy the region from the cursor position to the end
              of the line into the kill buffer.

   Arguments
       digit-argument (ESC-0..ESC-9) (0-9)
              Start a new numeric argument, or add to the current
              one.

       neg-argument (ESC-- unbound)
              Changes the sign of the following argument.

       universal-argument
              Multiply the argument of the next command by 4.

   Completion
       accept-and-menu-complete
              In a menu completion, insert the current completion
              into the buffer, and advance to the  next  possible
              completion.

       complete-word (unbound) (\)
              Attempt completion on the current word.

       delete-char-or-list (^D)
              Delete the character under the cursor.  If the cur-
              sor is at the end of the line, list  possible  com-
              pletions for the current word.

       execute-named-cmd (ESC-x)
              Read the name of a editor command and execute it. A
              restricted set of editing functions is available in
              the mini-buffer. An interrupt signal, as defined by
              the stty setting,  will  abort  the  function.  The
              allowed  functions  are:  backward-delete-char, vi-
              backward-delete-char, kill-region (kills  the  last
              word),  backward-kill-word,  vi-backward-kill-word,
              kill-whole-line,  vi-kill-line,  backward-kill-line
              and  accept-line.  The space and tab characters, if
              not bound to one of these functions, will  complete
              the name and then list the possibilities.

       execute-last-named-cmd (ESC-z)
              Redo the last function executed with execute-named-
              cmd.

       expand-cmd-path
              Expand the current command to its full pathname.

       expand-or-complete (TAB) (TAB ^X)
              Attempt shell expansion on the  current  word.   If
              that fails, attempt completion.

       expand-or-complete-prefix (unbound)
              Attempt  shell  expansion  on the current word upto
              cursor.

       expand-history (ESC-space ESC-!)
              Perform history expansion on the edit buffer.

       expand-word (^X*)
              Attempt shell expansion on the current word.

       list-choices (ESC-^D) (^D =)
              List possible completions for the current word.

       list-expand (^Xg ^XG) (^G)
              List the expansion of the current word.

       magic-space
              Perform history expansion and insert a  space  into
              the buffer.  This is intended to be bound to space.

       menu-complete
              Like complete-word, except that menu completion  is
              used.  See the MENU_COMPLETE option below.

       menu-expand-or-complete
              Like  expand-or-complete,  except that menu comple-
              tion is used.

       reverse-menu-complete
              See the MENU_COMPLETE option below.

   Miscellaneous
       accept-and-hold (ESC-A ESC-a)
              Push the contents of the buffer on the buffer stack
              and execute it.

       accept-and-infer-next-history
              Execute  the  contents  of the buffer.  Then search
              the history list for a line  matching  the  current
              one  and  push  the event following onto the buffer
              stack.

       acc       builtin name [ args ] ...
              Executes the builtin name, with the given args.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        bye    Same as exit.

       exit [ n ]
              Exit the shell with the exit code specified  by  n;
              if  none  is  specified, use the exit code from the
              last command executed.  An EOF condition will  also
              cause  the  shell  to  exit,  unless  the IGNOREEOF
              option is set.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          case word in [ pattern ) list ;; ] ...  esac
                     Execute the list associated with  the  first
                     pattern that matches word, if any.  The form
                     of the patterns is the same as that used for
                     filename  generation.   See Filename Genera-
                     tion below.

              case word { [ pattern ) list ;; ] ...  }
                     Another form of case.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                cd [ arg ]
       cd old new
       cd +-n Change the current directory.  In the  first  form,
              change  the  current  directory  to  arg, or to the
              value of HOME if arg is not specified.  If  arg  is
              -,  change  to  the  value  of OLDPWD, the previous
              directory.  If a directory named arg is  not  found
              in  the  current  directory  and arg does not begin
              with a slash, search each component  of  the  shell
              parameter cdpath.  If the option CDABLEVARS is set,
              and a parameter named arg exists whose value begins
              with a slash, treat its value as the directory.

              The  second  form  of cd substitutes the string new
              for the string old  in  the  name  of  the  current
              directory,  and  tries to change to this new direc-
              tory.

              The third form of cd is equivalent to popd.

       chdir  Same as cd.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  chpwd  Executed whenever the current working directory  is
              changed.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ead builtin's -c and -l flags
                     and use its own  criterion  to  decide  what
                     matches.
              The  second  form  specifies  alternative  options.
              First completion is tried with the  options  before
              the  first `+'. If this produces no matches comple-
              tion is tried with the flags after the `+'  and  so
              on.  If  there are no flags after the last `+' this
              means  that  default  completion  is  tried  if  no
              matches were found.
              The  third  form  specifies extended completion for
              the commands given as arg. Each pattern is examined
              in  turn;  when a match is found, the corresponding
              flags, as described above for  the  ordinary  case,
              are  used  to generate possible completions.  If no
              pattern matches, the flags given before the -x  are
              used.  Note that each pattern should be supplied as
              a single argument and should be quoted  to  prevent
              expansion of metacharacters by the shell. A pattern
              is built of sub-patterns separated  by  commas;  it
              matches  if  at  least  one  of  these sub-patterns
              matches (they are `or'ed'). These sub-patterns  are
              in turn composed of other sub-patterns separated by
              white spaces which match if all of the sub-patterns
              match  (they  are  `and'ed').   An  element  of the
              sub-patterns is of the  form  'c[...][...]',  where
              the  pairs  of brackets may be repeated as often as
              necessary, and matches if any of the sets of brack-
              ets  match (an `or').  These elements may be any of
              the following:

                      s[string] ...
                             The pattern matches if  the  current
                             word on the command line starts with
                             one of the strings given  in  brack-
                             ets.   The string is not removed and
                             is not part of the completion.
                      S[string] ...
                             Like s[string]  but  the  string  is
                             part of the completion.
                      p[from,to] ...
                             The pattern matches if the number of
                             the current word is between  one  of
                             the from and to pairs. The comma and
                             to are optional; to defaults to  the
                             same  value as from. The numbers may
                             be negative: -n refers to  the  n'th
                             last word on the line.
                      c[offset,string] ...
                             The  pattern  matches  if one of the
                             strings matches the word  offset  by
                             offset  from  the current word posi-
                             tion.
                      C[offset,pattern] ...
                             This is  like  c  but  uses  pattern
                             matching instead.
                      w[index,string] ...
                             The  pattern  matches if the word in
                             position index is equal to the  cor-
                             responding  string.   Note  that the
                             word  count  is  made  after   alias
                             expansion.
                      W[index,pattern] ...
                             Like  w  but  using pattern matching
                             instead.
                      n[index,string] ...
                             Matches if the current word contains
                             string.  Anything up to the index'th
                             occurrence of this string  will  not
                             be  considered  part  of the comple-
                             tion, but the rest will.
                      N[index,string] ...
                             Like n[index,string] but the  string
                             will  be  taken as a character class
                             (anything up to the index'th  occur-
                             rence  of  any  of the characters in
                             string will not be  considered  part
                             of the completion).
                      m[min,max] ...
                             Matches if the total number of words
                             lies    between    min    and    max
                             (inclusive).
                      r[str1,str2]...
                             Matches  if  the  cursor  is after a
                             word with prefix str1. If  there  is
                             also  a word with prefix str2 on the
                             command line it matches only if  the
                             cursor is before this word.
                      R[str1,str2]...
                             Like  r  but  using pattern matching
                             instead.

              Example:

                     compctl -u -x 's[+] c[-1,-f],s[-f+]' -g '~/Mail/*(:t)' \
                     - 's[-f],c[-1,-f]' -f -- mail

              Complete users by default.   After  a  -f  with  an
              optional space, complete file names; if a + follows
              the -f, whether or not there is a space in between,
              complete  with  the  non-directory part of files in
              the directory ~/Mail.
                                                                                                                                                                                                                                                                                                                                                                                                                                                     compctl [ -cfqovbCDAIFpEjBaRGuderzNOZ ] [ -k name ]
              [ -X explanation ] [ -K function ]
              [ -P prefix ] [ -S suffix ]
              [ -g globstring ] [ -s subststring ] [ arg ... ]
              [ -H num pattern ] [ -l cmd ]
       compctl flags + flags + ...
       compctl flags -x pattern flags - ... -- arg ...
              Control the editor's completion behavior  when  one
              of  arg is the current command.  (Note that aliases
              are expanded before this is determined.)  With  the
              -D  flag,  control  default completion behavior for
              commands not assigned any  special  behavior;  with
              -C,  control  completion  when  there is no current
              command.  The remaining options specify the type of
              command  arguments  to  look for during completion.
              If completion is attempted for  a  command  with  a
              pathname  containing  slashes  and no completion is
              found the search is retried with the last  pathname
              component.

              -c     Expect command names.
              -f     Expect filenames and filesystem paths.
              -o     Expect option names.
              -v     Expect variable names.
              -b     Expect key binding names.
              -A     Expect array names.
              -I     Expect integer variable names.
              -F     Expect function names.
              -p     Expect parameter names.
              -E     Expect environment variable names.
              -j     Expect  job names (the first word of the job
                     leader's command line, useful with the  kill
                     builtin).
              -r     Expect names of running jobs.
              -z     Expect names of suspended jobs.
              -B     Expect names of builtin commands.
              -a     Expect alias names.
              -R     Expect names of regular aliases.
              -G     Expect names of global aliases.
              -u     Expect user names.
              -d     Expect names of disabled commands.
              -e     Expect  names  of  executable  (and enabled)
                     commands.
              -N     Expect names of scalar parameters.
              -O     Expect names of readonly variables.
              -Z     Expect names of shell special parameters.
              -q     If given together with a suffix (see the  -S
                     flag  below) it makes this suffix be removed
                     if the next character typed is  a  blank  or
                     does  not  insert anything (this is the same
                     rule  as  used  for  the   AUTO_REMOVE_SLASH
                     option).
              -k name
                     Expect  names  taken  from  the  elements of
                     $name.   Alternatively,  the  argument  name
                     itself  may  be  a  set  of space- or comma-
                     separated values in  parentheses,  in  which
                     any  delimiter  may  be escaped with a back-
                     slash.   (Example:  `compctl  -k   "(cputime
                     filesize   datasize  stacksize  coredumpsize
                     resident descriptors)" limit'.)
              -K function
                     Call the given function to get  the  comple-
                     tions.  The function gets two arguments: the
                     prefix and the suffix of the word  on  which
                     completion  is  tried.   The function should
                     set the variable reply to an array  contain-
                     ing the completions (one completion per ele-
                     ment); note that reply should  not  be  made
                     local.   Currently  the  command line is not
                     available to the function; an argument pass-
                     ing mechanism will be added shortly.  (Exam-
                     ple: `function whoson { reply=(`users`);  };
                     compctl   -K  whoson  talk'  completes  only
                     logged-on users  after  `talk'.)  Note  that
                     whoson  must  return  an  array so that just
                     "reply=`users`" is incorrect.
              -X explanation
                     Print the explanation string before the list
                     of  completions.  A  `%n'  in this string is
                     replaced by the number of matches.
              -P prefix
                     The prefix is inserted just before the  com-
                     pleted  string;  any  initial  part  already
                     typed will be completed and the whole prefix
                     ignored  for  completion purposes. (Example:
                     `compctl -j -P "%" kill').
              -S suffix
                     After a unique completion is found the  suf-
                     fix  is inserted after the completed string.
              -g globstring
                     The globstring is  expanded  using  filename
                     globbing;  it should be quoted to protect it
                     from  immediate  expansion.  The   resulting
                     filenames  are taken as the possible comple-
                     tions.   Use  `*(/)'  instead  of  `*/'  for
                     directories.   The fignore special parameter
                     is not used.  More than one pattern  may  be
                     given separated by blanks.
              -s subststring
                     The  substring is split into words and these
                     words are  than  expanded  using  all  shell
                     expansion  mechanisms.  The  resulting words
                     are taken as possible completions. The  fig-
                     nore  special  parameter  is not used.  Note
                     that -g is faster for filenames.
              -H num pattern
                     The possible completions are taken from  the
                     last  num history lines. Only words matching
                     pattern are taken. If num is zero  or  nega-
                     tive  the  whole  history is searched and if
                     pattern is the  empty  string  (or  '*',  of
                     course) all words are taken.
              -l cmd This  option  can  not  be combined with any
                     other option. If it is  given  it  restricts
                     the  range  of  command  line words that are
                     considered to be arguments. By default  this
                     range  contains  all  arguments  without the
                     command string. If  combined  with  extended
                     completion and one of `p[...]', `r[...]', or
                     `R[...]' the  range  is  restricted  to  the
                     arguments  between  the ones that are speci-
                     fied in the brackets.  After  the  range  of
                     arguments  is  determined completion is done
                     in it as if they were arguments to  the  cmd
                     given  with  this  option. If this string is
                     empty the first word in the range  is  taken
                     as  the  command name for which to complete.
                     In this case, if the cursor is in the  first
                     word, command names are completed.  Example:
                     `compctl -x 'r[-exec,;]' -l '' -- find' com-
                     pletes the arguments between `-exec' and the
                     following `;' (or the  end  of  the  command
                     line  if there is no such string) as if they
                     were specifying a command on there own.
              -U     Use the whole list of possible  completions,
                     whether  or not they actually match the word
                     on the command line.  The word typed so  far
                     will be deleted.  This is most useful with a
                     function (-K option), which can examine  the
                     word  via the r       continue [ num ]
              Resume the next iteration  of  the  enclosing  for,
              while,  until,  select,  or  repeat  loop.  If n is
              specified, break out of n - 1 loops and  resume  at
              the nth enclosing loop.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   If a pipeline is preceded by coproc, it is executed  as  a
       coprocess;  a  two-way  pipe is established between it and
       the parent shell.  The shell can read from or write to the
       coprocess  by  means of the >&p and <&p redirection opera-
       tors.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  disable [ -m ] arg ...
              Disable the builtin arg temporarily.   This  allows
              you  to  use an external command with the same name
              as a shell builtin.  Without arguments all disabled
              builtins  are  printed,  with the -m flag the argu-
              ments are taken as patterns (should  be  quoted  to
              preserve  them  from  being taken as glob patterns)
              and all builtins matching these patterns  are  dis-
              abled.   Actually the same as unhash.  Builtins can
              be enabled with the enable command.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       disown job ...
              Remove the specified jobs from the job  table;  the
              shell  will no longer report their status, and will
              not complain if you  try  to  exit  an  interactive
              shell with them running or stopped.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         declare [ arg ... ]
              Same as typeset.

       functions [ +-tum ] [ name ... ]
              Equivalent to typeset -f.

       integer [ +-FBlrtux ] [ name[=value] ] ...
              Same as typeset -i, except that options  irrelevant
              to integers are not permitted.

       local [ +-LRZilrtu [n]] [ name[=value] ] ...
              Same as typeset, except that the options -x and  -f
              are not permitted.

       typeset [ +-LRZfilrtuxm [n]] [ name[=value] ] ...
              Set  attributes  and  values  for shell parameters.
              When invoked inside a function a new  parameter  is
              created  which will be unset when the function com-
              pletes.  The new parameter  will  not  be  exported
              unless  ALLEXPORT is set, in which case the parame-
              ter will be exported provided no parameter of  that
              name  already exists.  The following attributes are
              valid:
              -L     Left justify and remove leading blanks  from
                     value.   If  n  is  nonzero,  it defines the
                     width of the field; otherwise it  is  deter-
                     mined by the width of the value of the first
                     assignment.  When the parameter is  printed,
                     it  is  filled  on  the right with blanks or
                     truncated if necessary  to  fit  the  field.
                     Leading  zeros are removed if the -Z flag is
                     also set.
              -R     Right justify and fill with leading  blanks.
                     If  n is nonzero if defines the width of the
                     field; otherwise it  is  determined  by  the
                     width  of the value of the first assignment.
                     When the parameter is printed, the field  is
                     left  filled  with  blanks or truncated from
                     the end.
              -Z     Right justify and fill with leading zeros if
                     the first non-blank character is a digit and
                     the -L flag has  not  been  set.   If  n  is
                     nonzero  it  defines the width of the field;
                     otherwise it is determined by the  width  of
                     the value of the first assignment.
              -f     The  names  refer  to  functions rather than
                     parameters.  No assignments can be made, and
                     the  only  other  valid flags are -t and -u.
                     The flag -t turns on execution  tracing  for
                     this  function.   The  flag  -u  causes this
                     function to be marked for autoloading.   The
                     fpath parameter will be searched to find the
                     function definition  when  the  function  is
                     first referenced.
              -i     Use  an internal integer representation.  If
                     n is nonzero it defines  the  output  arith-
                     metic  base,  otherwise  it is determined by
                     the first assignment.
              -l     Convert to lower case.
              -r     The given names are marked readonly.
              -t     Tags the named  parameters.   Tags  have  no
                     special meaning to the shell.
              -u     Convert to upper case.
              -x     Mark for automatic export to the environment
                     of subsequently executed commands.

              Using + rather than - causes these flags to be
              turned off.
              If no arguments are given but flags are  specified,
              a  list  of named parameters which have these flags
              set is printed.  Using + instead of -  keeps  their
              values  from  being  printed.   If  no arguments or
              options are given, the names and attributes of  all
              parameters  are  printed.  If  only  the -m flag is
              given the arguments are taken as  patterns  (should
              be  quoted)  and  all parameters or functions (with
              the -f flag) with matching names are printed.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             dirs [ -v ] [ arg ... ]
              With no arguments, print the contents of the direc-
              tory stack.  If the -v option is given, number  the
              directories  in  the stack when printing.  Directo-
              ries are added to this stack with  the  pushd  com-
              mand, and removed with the cd or popd commands.  If
              arguments are specified, load them onto the  direc-
              tory  stack, replacing anything that was there, and
              push the current directory onto the stack.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 echo [ -n ] [ arg ... ]
              Write each arg on the standard output, with a space
              separating each one.  If the -n flag  is  not  pre-
              sent,  print a newline at the end.  echo recognizes
              the following escape sequences:
              \a     bell character
              \b     backspace
              \c     don't print an ending newline
              \e     escape
              \f     form feed
              \n     newline
              \r     carriage return
              \t     horizontal tab
              \v     vertical tab
              \\     backslash
              \nnn   character code in octal, with a  maximum  of
                     four  digits.  A  non-octal digit terminates
                     the number. It must start with zero.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              echotc cap [ arg ... ]
              Output the  termcap  string  corresponding  to  the
              capability cap, with optional arguments.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if list
              then list
              [ elif list ; then list ] ...
              [ else list ]
              fi     The if list is executed, and, if it  returns
                     a  zero  exit  status, the then list is exe-
                     cuted.  Otherwise, the elif list is executed
                     and,  if its value is zero, the then list is
                     executed.   If  each   elif   list   returns
                     nonzero, the else list is executed.

              if ( list ) sublist
                     A short form of if.

              if ( list ) {
              list
              } elif ( list ) {
              list
              } ... else {
              list
              }      An  alternate  form  of  if. The parentheses
                     surrounding list can be omitted if the  only
                     command in the list is a conditional expres-
                     sion of the form [[ exp ]] (see below).
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              enable [ -m ] arg ...
              Enable  the  specified builtin commands, presumably
              disabled earlier with disable.   Without  arguments
              the  enabled  builtins  are printed and with the -m
              flag the arguments are taken as patterns (should be
              quoted)  and  all  builtins matching these patterns
              are enabled.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     eval [ arg ... ]
              Read the arguments as input to the shell  and  exe-
              cute  the resulting command(s) in the current shell
              process.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    export [ name[=value] ... ]
              The specified names are marked for automatic export
              to  the  environment  of subsequently executed com-
              mands.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           false  Do nothing and return an exit code of 1.

       true   Do nothing and return an exit code of 0.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        fg [ job ... ]
       job ...
              Bring the specified jobs to the foreground.  If  no
              job is specified, use the current job.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           fc [ -e ename ] [ -nlrdDfEm ] [ old=new ... ] [ first [
              last ] ]
       fc -ARWI [ filename ]
              Select  a range of commands from first to last from
              the history list.  The arguments first and last may
              be  specified  as a number or as a string.  A nega-
              tive number is used as an  offset  to  the  current
              history  event number.  A string specifies the most
              recent event beginning with the given string.   All
              substitutions  old=new,  if any, are then performed
              on the commands.  If the  -l  flag  is  given,  the
              resulting  commands  are listed on standard output.
              If the -m flag is also given the first argument  is
              taken  as a pattern (should be quoted) and only the
              history events matching this pattern will be shown.
              Otherwise  the editor program ename is invoked on a
              file containing these history events.  If ename  is
              not  given,  the  value  of the parameter FCEDIT is
              used.  If ename is "-", no editor is invoked.  When
              editing  is complete, the edited command(s) is exe-
              cuted.  If first is not specified, it will  be  set
              to  -1 (the most recent event), or to -16 if the -l
              flag is given.  If last is not specified,  it  will
              be  set to first, or to -1 if the -l flag is given.
              The flag -r reverses the order of the commands  and
              the  flag  -n suppresses command numbers when list-
              ing.  Also when listing, -d prints  timestamps  for
              each  command, and -f prints full time-date stamps.
              Adding the -E flag causes the dates to  be  printed
              as  `dd.mm.yyyy'.   With  the  -D  flag,  fc prints
              elapsed times.

              fc -R reads the history from the given file, fc  -W
              writes the history out to the given file, and fc -A
              appends the history out to the given file.  fc  -AI
              (-WI)  appends  (writes) only those events that are
              new since last incremental append  (write)  to  the
              history  file.  In  any  case the file will have no
              more than SAVEHIST entries.

       history [ -nrdDfEm ] [ first [ last ] ]
              Same as fc -l.

       r      Equivalent to fc -e -.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              for name [ in word ... ]
              do list
              done   Expand the list of words, and set the param-
                     eter name to each of them in turn, executing
                     list each time.  If the in word is  omitted,
                     use the positional parameters instead of the
                     words.

              for name [ in word ... ] ; sublist
                     This is a shorthand for for.  Though it  may
                     cause  confusion,  it is included for conve-
                     nience; its use in scripts  is  discouraged,
                     unless  sublist  is  a command of the form {
                     list }.

              foreach name ( word ... )
              list
              end    Another form of for.

              for name in word ...
              {
              list
              }      Another form of for.

              for name ( word ... ) {
              list
              }      Another form of for.

              for name ( word ... ) sublist
                     Another form of for.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    function word [ () ] ... { list }
              word ... () { list }
              word ... () sublist
                     Define a function which is referenced by any
                     one  of  word.   Normally,  only one word is
                     provided; multiple words  are  usually  only
                     useful  for  setting traps.  The body of the
                     function is the list between the  {  and  }.
                     See FUNCTIONS below.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              getln name ...
              Read the top value from the buffer stack and put it
              in the shell parameter name.   Equivalent  to  read
              -zr.  The flags -c, -l, -A, -e, -E, and -n are sup-
              ported, too.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                getopts optstring name [ arg ... ]
              Checks arg for legal options.  If arg  is  omitted,
              use  the  positional  parameters.   A  valid option
              argument begins with a + or a -.  An  argument  not
              beginning with a + or a -, or the argument --, ends
              the options.  optstring contains the  letters  that
              getopts  recognizes.   If a letter is followed by a
              `:', that option is expected to have  an  argument.
              The  options  can be separated from the argument by
              blanks.

              Each time it is invoked, getopts places the  option
              letter  it  finds  in  the  shell  parameter  name,
              prepended with a + when arg begins with a  +.   The
              index  of  the  next  arg is stored in OPTIND.  The
              option argument, if any, is stored in OPTARG.

              A leading : in optstring causes  getopts  to  store
              the  letter of the invalid option in OPTARG, and to
              set name to `?' for an unknown option  and  to  `:'
              when  a  required  option  is  missing.  Otherwise,
              getopts prints an error message.  The  exit  status
              is nonzero when there are no more options.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              hash name path
              Puts name in the command hash table, associating it
              with the pathname path.  Whenever name is used as a
              command argument, the shell will try to execute the
              file given by path.

       unhash [ -m ] name ...
              The  entry  in  the command hash table, if any, for
              each name is removed. If the -m flag is  given  the
              arguments  are taken as patterns (should be quoted)
              and all entries for commands  with  matching  names
              will be removed.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   jobs [ -lprs ] [ job ... ]
              Lists information about each given job, or all jobs
              if job is omitted.  The -l flag lists process  ids,
              and  the  -p  flag lists process groups.  If the -r
              flag is specified only running jobs will be  listed
              and  if  the -s flag is given only stopped jobs are
              shown.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      kill [ -sig ] job ...
       kill -l
              Sends either SIGTERM or the specified signal to the
              given jobs or processes.  Signals are given by num-
              ber or by names (with the  prefix  "SIG"  removed).
              If  the signal being sent is not KILL or CONT, then
              the job will  be  sent  a  CONT  signal  if  it  is
              stopped.  The argument job can be the process id of
              a job not in the job list.   In  the  second  form,
              kill -l, the signal names are listed.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         let arg ...
              Evaluate each arg as an arithmetic expression.  See
              ARITHMETIC EVALUATION above for  a  description  of
              arithmetic  expressions.   The  exit status is 0 if
              the value of the last expression is nonzero, and  1
              otherwise.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   limit [ -h ] [ resource [ limit ] ] ...
       limit -s
              Limit the resource consumption of the current shell
              and its children.  If limit is not specified, print
              the current limit placed on resource; otherwise set
              the limit to the specified value.  If the  -h  flag
              is  given,  use hard limits instead of soft limits.
              If no resource is given, print all limits.

              resource is one of:

              cputime
                     Maximum CPU seconds per process.
              filesize
                     Largest single file allowed.
              datasize
                     Maximum data size (including stack) for each
                     process.
              stacksize
                     Maximum stack size for each process.
              coredumpsize
                     Maximum size of a core dump.
              resident
                     Maximum resident set size.
              memoryuse
                     The same as resident.
              memorylocked
                     Maximum amount of memory locked in RAM.
              descriptors
                     Maximum value for a file descriptor.
              openfiles
                     Maximum number of open files.
              vmemorysize
                     Maximum amount of virtual memory.

              Which   of  these  resource  limits  are  available
              depends on the system.  limit is a number, with  an
              optional scaling factor, as follows:

              nh     hours.
              nk     kilobytes.   This is the default for all but
                     cputime.
              nm     megabytes or minutes.
              mm:ss  minutes and seconds.
                                                                                                                                                                                                                                                                                          log    List all users currently logged in who are affected
              by the current setting of the watch parameter.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        logout Exit the shell, if this is a login shell.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               periodic
              If  the  parameter  PERIOD is set, this function is
              executed  every  PERIOD  seconds,  just  before   a
              prompt.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             popd [ +-n ]
              Removes entries from the directory stack.  With  no
              arguments,  removes  the  top  directory  from  the
              stack, and performs a cd to the new top  directory.
              With  an  argument  of  the form +n, remove the nth
              entry counting from the left of the list  shown  by
              the dirs command, starting with zero, and change to
              that directory.  With an argument of the  form  -n,
              remove  the  nth entry counting from the right.  If
              the PUSHD_MINUS option is set, the  meanings  of  +
              and - in this context are swapped.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                precmd Executed before each prompt.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            print [ -RnrslzpNDPoOic ] [ -un ] [ arg ... ]
              With  no  flags  or  with flag -, the arguments are
              printed on the  standard  output  as  described  by
              echo,  with  the  following differences: the escape
              sequence \M-x metafies the character  x  (sets  the
              highest  bit),  \C-x  produces  a control character
              (\C-@ and \C-? give the characters NULL and delete)
              and  \E is a synonym for \e.  Finally, if not in an
              escape sequence, \ escapes the following  character
              and is not printed.
              -R, -r ignore  the escape conventions of echo.  The
                     -R option will print  all  subsequent  argu-
                     ments and options.
              -s     place   the  results  in  the  history  list
                     instead of on the standard output.
              -n     do not add a newline to the output.
              -l     print the arguments  separated  by  newlines
                     instead of spaces.
              -N     print the arguments separated and terminated
                     by nulls.
              -o     print  the  arguments  sorted  in  ascending
                     order.
              -O     print  the  arguments  sorted  in descending
                     order.
              -i     if given together with -o or -O  makes  them
                     work case independently
              -c     print the arguments in columns
              -un    print the arguments to file descriptor n.
              -p     print  the  arguments  to  the  input of the
                     coprocess.
              -z     push the arguments onto the  editing  buffer
                     stack,   separated   by  spaces;  no  escape
                     sequences are recognized.
              -D     treat  the  arguments  as  directory  names,
                     replacing  prefixes  with  ~ expressions, as
                     appropriate.
              -P     recognize the same escape  sequences  as  in
                     the PROMPT parameter.

       pwd    Equivalent to print -R $PWD.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    pushd [ arg ]
       pushd old new
       pushd +-n
              Change the current directory, and push the old cur-
              rent directory onto the directory  stack.   In  the
              first  form,  change  the current directory to arg.
              If arg is  not  specified,  change  to  the  second
              directory  on  the stack (that is, exchange the top
              two entries), or change to the value of HOME if the
              PUSHD_TO_HOME option is set or if there is only one
              entry on the stack.  If arg is  -,  change  to  the
              value  of  OLDPWD,  the  previous  directory.  If a
              directory named arg is not  found  in  the  current
              directory  and arg does not contain a slash, search
              each component of the shell parameter  cdpath.   If
              the option CDABLEVARS is set, and a parameter named
              arg exists whose value begins with a  slash,  treat
              its   value   as  the  directory.   If  the  option
              PUSHD_SILENT is not set, the directory  stack  will
              be printed after a pushd is performed.

              The second form of pushd substitutes the string new
              for the string old  in  the  name  of  the  current
              directory,  and  tries to change to this new direc-
              tory.

              The third form of pushd is equivalent to popd.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              readonly [ name[=value] ] ...
              The  given  names  are marked readonly; these names
              cannot be changed by subsequent assignment.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      read [ -rzpqAclneE ] [ -k [ num ] ] [ -un ]  [
              name?prompt  ]  [ name ...  ]
              Read one line and break it into  fields  using  the
              characters  in IFS as separators.  In raw mode, -r,
              a \ at the end of a line does not signify line con-
              tinuation.   With the -q flag read only one charac-
              ter and set name to `y' if this character  was  `y'
              or  `Y'  and  to  `n' otherwise.  If the -k flag is
              given read only one (or num) characters.  If the -z
              flag  is  set,  read  from the editor buffer stack.
              The first field is assigned to the first name,  the
              second  field  to the second name, etc., with left-
              over fields assigned to the last name.  If  the  -e
              or the -E flag is given, the words read are printed
              after the whole line is read. If  the  -e  flag  is
              set,  the words are not assigned to the parameters.
              If the -A flag is set, the first name is  taken  as
              the  name of an array and all words are assigned to
              it.  The -c and -l flags are allowed only if called
              inside  a  function  used for completion (specified
              with the -K flag to compctl). If  the  -c  flag  is
              given,  the  words of the current command are read.
              If the -l flag is given, the whole line is assigned
              as  a  scalar.  Together  with  the  -n  flag these
              options give the number of the word the  cursor  is
              on  and the index of the character the cursor is on
              respectively.  If name is  omitted  then  REPLY  is
              used  for  scalars and reply for arrays.  If -un is
              specified, then input is read from file  descriptor
              n;  if -p is specified, then input is read from the
              coprocess.  If the first argument contains a ?, the
              remainder of this word is used as a prompt on stan-
              dard error when the shell is interactive.  The exit
              status is 0 unless an end-of-file is encountered.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       rehash [ -f ]
              Throw out the command hash table  and  start  over.
              If  the  -f  option is set, rescan the command path
              immediately, instead of rebuilding the  hash  table
              incrementally.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      repeat word
              do list
              done   word is expanded and treated  as  an  arith-
                     metic  expression,  which must evaluate to a
                     number n.  list is then executed n times.

              repeat word sublist
                     This is a short form of repeat.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            return [ n ]
              Causes  a  shell  function or . script to return to
              the invoking script with the return  status  speci-
              fied  by n.  If n is omitted then the return status
              is that of the last command executed.

              If return was executed from a trap, whether set  by
              the trap builtin or by defining a TRAPxxx function,
              the effect  is  different  for  zero  and  non-zero
              return  status.   With  zero  status  (or  after an
              implicit return at the end of the trap), the  shell
              will  return to whatever it was previously process-
              ing; with a non-zero status, the shell will  behave
              as interrupted except that the return status of the
              trap is  retained.   Note  that  the  signal  which
              caused the trap is passed as the first argument, so
              the statement `return $[128+$1]'  will  return  the
              same  status as if the signal had not been trapped.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                sched [+]hh:mm command ...
       sched [ -item ]
              Make an entry in the scheduled list of commands  to
              execute.  The time may be specified in either abso-
              lute or relative time.  With no  arguments,  prints
              the  list of scheduled commands.  With the argument
              -item, removes the given item from the list.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  select name [ in word ... ]
              do list
              done   Print the set of words, each preceded  by  a
                     number.   If the in word is omitted, use the
                     positional parameters.  The  PROMPT3  prompt
                     is  printed and a line is read from standard
                     input.  If this line consists of the  number
                     of one of the listed words, then the parame-
                     ter name is set to the word corresponding to
                     this  number.   If  this  line is empty, the
                     selection list is printed again.  Otherwise,
                     the  value  of  the parameter name is set to
                     null.  The contents of the  line  read  from
                     standard  input  is  saved  in the parameter
                     REPLY.  list is executed for each  selection
                     until a break or end-of-file is encountered.

              select name [ in word ] ; sublist
                     A short form of select.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             set [ +-options ] [ +-o option name ] ... [ -A [name] ] [
              arg  ] ...
              Set the options for the shell and/or set the  posi-
              tional  parameters,  or  declare an array.  For the
              meaning of the flags, see OPTIONS above.  Flags may
              be  specified  by name using the -o option.  If the
              -A flag is specified, name is set to an array  con-
              taining  the  given  args; if no name is specified,
              all arrays are printed.  Otherwise  the  positional
              parameters  are  set.   If  no arguments are given,
              then the names and values  of  all  parameters  are
              printed  on the standard output.  If the only argu-
              ment is +, the names of all parameters are printed.

       unset [ -m ] name ...
              Each named parameter is unset. If the  -m  flag  is
              specified  the  arguments  are  taken  as  patterns
              (should be quoted) and all parameters with matching
              names are unset.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    setopt [ +-options ] [ name ... ]
              Set  the options for the shell.  All options speci-
              fied either with flags or by name are set.   If  no
              arguments  are  supplied,  the names of all options
              currently set are printed.  In option  names,  case
              is insignificant, and all underscore characters are
              ignored.  If the -m flag is given the arguments are
              taken  as  patterns  (should  be quoted to preserve
              them from being interpreted as glob  patterns)  and
              all  options with names matching these patterns are
              set.

       unsetopt [ +-options ] [ name ... ]
              Unset the options for the shell.  All options spec-
              ified either with flags or by name  are  unset.  If
              the  -m  flag is given the arguments are considered
              to be patterns (don't forget to quote them) and all
              options  with  names  matching  these  patterns are
              unset.

       The  following  options  may be set upon invocation of the
       shell, or with the set or setopt builtins. They  are  case
       insensitive  and underscores are ignored, that is, "allex-
       port" is equivalent to "A__lleXP_ort".
              ALL_EXPORT (-a)
                     All  parameters  subsequently  defined   are
                     automatically exported.
              ALWAYS_LAST_PROMPT
                     If unset key functions that list completions
                     try to return to the last prompt if given  a
                     numeric argument. If set these functions try
                     to return to the last  prompt  if  given  no
                     numeric argument.
              ALWAYS_TO_END
                     If  a completion with the cursor in the word
                     was started  and  it  results  in  only  one
                     match,  the  cursor  is placed at the end of
                     the word.
              APPEND_HISTORY
                     If this is set,  zsh  sessions  will  append
                     their  history  list  to  the  history file,
                     rather than  overwrite  it.  Thus,  multiple
                     parallel  zsh  sessions  will all have their
                     history lists added to the history file,  in
                     the order they are killed.
              AUTO_CD (-J)
                     If  a  command is not in the hash table, and
                     there exists an executable directory by that
                     name,  perform the cd command to that direc-
                     tory.
              AUTO_LIST (-9)
                     Automatically list choices on  an  ambiguous
                     completion.
              AUTO_MENU
                     Automatically  use menu completion after the
                     second consecutive request  for  completion,
                     for  example by pressing the TAB key repeat-
                     edly.   This   option   is   overridden   by
                     MENU_COMPLETE.
              AUTO_PARAM_KEYS
                     If  a  parameter  name was completed and the
                     next character typed is one  of  those  that
                     have  to  come directly after the name (like
                     `}', `:', etc.) they are placed there  auto-
                     matically.
              AUTO_PUSHD (-N)
                     Make cd act like pushd.
              AUTO_REMOVE_SLASH
                     When  the  last  character  resulting from a
                     completion is a slash and the next character
                     typed is a word delimiter, remove the slash.
              AUTO_RESUME (-W)
                     Treat single word  simple  commands  without
                     redirection  as candidates for resumption of
                     an existing job.
              BGNICE (-6)
                     Run all background jobs at a lower priority.
                     This option is set by default.
              BRACE_CCL
                     Allow brace expansions of the form {a-zA-Z},
                     etc.
              CDABLE_VARS (-T)
                     If the argument  to  a  cd  command  (or  an
                     implied  cd  with the AUTO_CD option set) is
                     not a directory, and does not begin  with  a
                     slash, try to expand the expression as if it
                     were preceded by a ~ (see Filename Expansion
                     above).
              CHASE_LINKS (-w)
                     Resolve symbolic links to their true values.
              COMPLETE_ALIASES
                     If set aliases on the command line  are  not
                     internally  substituted before completion is
                     attempted.
              COMPLETE_IN_WORD
                     If unset the cursor is set to the end of the
                     word  if completion is started. Otherwise it
                     stays there and completion is done from both
                     ends.
              CORRECT (-0)
                     Try to correct the spelling of commands.
              CORRECT_ALL (-O)
                     Try to correct the spelling of all arguments
                     in a line.
              CSH_JUNKIE_HISTORY
                     A history reference without an event  speci-
                     fier  will always refer to the previous com-
                     mand.
              CSH_JUNKIE_LOOPS
                     Allow loop bodies to take  the  form  "list;
                     end" instead of "do list; done".
              CSH_JUNKIE_QUOTES
                     Complain if a quoted expression runs off the
                     end of a line;  prevent  quoted  expressions
                     from containing unescaped newlines.
              CSH_JUNKIE_TILDE
                     Any  unquoted = and ~ resulting from parame-
                     ter  substitution  are  eligible  for   file
                     expansion.
              CSH_NULL_GLOB
                     If  a pattern for filename generation has no
                     matches, delete the pattern from  the  argu-
                     ment list; do not report an error unless all
                     the patterns in a command have  no  matches.
                     Overrides NULLGLOB.
              ERR_EXIT (-e)
                     If  a  command  has  a non-zero exit status,
                     execute the ZERR trap, if set, and exit.
              EXTENDED_GLOB
                     Treat the # and ^ characters as part of pat-
                     terns for filename generation, etc.
              EXTENDED_HISTORY
                     Save  beginning and ending timestamps to the
                     history file.  The format  of  these  times-
                     tamps     is    :<beginning    time>:<ending
                     time>:<command>.
              GLOB_COMPLETE
                     When the current word has a glob pattern, do
                     not  insert all the words resulting from the
                     expansion  but  cycle  through   them   like
                     MENU_COMPLETE.  If no matches are found, a *
                     is added to the end of the word or  inserted
                     at  the  cursor  if COMPLETE_IN_WORD is set,
                     and  expansion  is  attempted  again.  Using
                     patterns  works  not  only for files but for
                     all  completions,  such  as  options,   user
                     names, etc.
              GLOB_DOTS (-4)
                     Do  not require a leading . in a filename to
                     be matched explicitly.
              HASH_CMDS
                     Place the location of each  command  in  the
                     hash  table  the  first time it is executed.
                     If this option is  unset,  no  path  hashing
                     will be done at all.
              HASH_DIRS
                     Whenever  a  command  is  executed, hash the
                     directory containing  it,  as  well  as  all
                     directories  that occur earlier in the path.
                     Has no effect if HASH_CMDS is unset.
              HASH_LIST_ALL
                     Whenever a command completion is  attempted,
                     make  sure the entire command path is hashed
                     first.   This  makes  the  first  completion
                     slower.
              HIST_IGNORE_DUPS (-h)
                     Do  not enter command lines into the history
                     list if they are duplicates of the  previous
                     event.
              HIST_IGNORE_SPACE (-g)
                     Do  not enter command lines into the history
                     list if they begin with a blank.
              HIST_LIT (-j)
                     Use literal (unparsed) versions of the  his-
                     tory lines in the editor.
              HIST_NO_STORE
                     Remove  the history (fc -l) command from the
                     history when invoked.
              HIST_VERIFY
                     Whenever the user enters a line with history
                     substitution,   don't   execute   the   line
                     directly; instead, perform history substitu-
                     tion  and  reload  the line into the editing
                     buffer.
              IGNORE_BRACES (-I)
                     Do not perform brace expansion.
              IGNORE_EOF (-7)
                     Do not exit on end-of-file.  Require the use
                     of exit or logout instead.
              INTERACTIVE (-i)
                     This is an interactive shell.
              INTERACTIVE_COMMENTS (-k)
                     Allow comments even in interactive shells.
              KSH_OPTION_PRINT
                     Alters the way options settings are printed.
              LIST_AMBIGUOUS
                     If this option is set completions are  shown
                     only   if   the  completions  don't  have  a
                     unambiguous prefix or suffix that  could  be
                     inserted in the command line.
              LIST_TYPES (-X)
                     When listing files that are possible comple-
                     tions, show the type of  each  file  with  a
                     trailing identifying mark.
              LOGIN (-l)
                     This is a login shell.
              LONG_LIST_JOBS (-R)
                     List jobs in the long format by default.
              MAIL_WARNING (-U)
                     Print  a  warning message if a mail file has
                     been accessed since the shell last  checked.
              MARK_DIRS (-8)
                     Append  a  trailing / to all directory names
                     resulting from  filename  generation  (glob-
                     bing).
              MENU_COMPLETE (-Y)
                     On an ambiguous completion, instead of list-
                     ing possibilities  or  beeping,  insert  the
                     first  match immediately.  Then when comple-
                     tion is requested again,  remove  the  first
                     match  and  insert  the  second  match, etc.
                     When there are no more matches, go  back  to
                     the  first one again.  reverse-menu-complete
                     may be used to loop through the list in  the
                     other   direction.   This  option  overrides
                     AUTO_MENU.
              MONITOR (-m)
                     Allow job control.  Set by default in inter-
                     active shells.
              NO_BAD_PATTERN (-2)
                     If  a  pattern  for  filename  generation is
                     badly formed,  leave  it  unchanged  in  the
                     argument  list instead of printing an error.
              NO_BANG_HIST (-K)
                     Do not perform textual history substitution.
                     Do not treat the ! character specially.
              NO_BEEP (-B)
                     Do not beep.
              NO_CLOBBER (-1)
                     Prevents   >   redirection  from  truncating
                     existing files.  >! may be used to  truncate
                     a  file instead.  Also prevents >> from cre-
                     ating files.  >>! may be used instead.
              NO_EQUALS
                     Don't perform = filename substitution.
              NO_EXEC (-n)
                     Read commands  and  check  them  for  syntax
                     errors, but do not execute them.
              NO_GLOB (-F)
                     Disable filename generation.
              NO_FLOW_CONTROL
                     Disable  output  flow control via start/stop
                     characters (usually assigned  to  ^S/^Q)  in
                     the shell's editor.
              NO_HIST_BEEP
                     Don't beep when an attempt is made to access
                     a history entry which isn't there.
              NO_HUP Don't send the HUP signal  to  running  jobs
                     when the shell exits.
              NO_LIST_BEEP
                     Don't beep on an ambiguous completion.
              NO_NOMATCH (-3)
                     If  a pattern for filename generation has no
                     matches, leave it unchanged in the  argument
                     list  instead  of  printing  an error.  This
                     also applies to file expansion of an initial
                     ~ or =.
              NO_PROMPT_CR (-V)
                     Don't  print  a  carriage return just before
                     printing a prompt in the line editor.
              NO_RCS (-f)
                     Source only the /etc/zshenv  file.   Do  not
                     source  the  .zshenv,  /etc/zprofile, .zpro-
                     file, /etc/zshrc, .zshrc, /etc/zlogin, .zlo-
                     gin, or .zlogout files.
              NO_SHORT_LOOPS
                     Disallow the short forms of for, select, if,
                     and function constructs.
              NOTIFY (-5)
                     Report the status of background jobs immedi-
                     ately, rather than waiting until just before
                     printing a prompt.
              NO_UNSET (-u)
                     Treat unset parameters as an error when sub-
                     stituting.
              NULL_GLOB (-G)
                     If  a pattern for filename generation has no
                     matches, delete the pattern from  the  argu-
                     ment  list  instead  of  reporting an error.
                     Overrides NO_NOMATCH.
              NUMERIC_GLOB_SORT
                     If numeric filenames are matched by a  file-
                     name  generation pattern, sort the filenames
                     numerically rather than lexicographically.
              OVER_STRIKE
                     Start up the line editor in overstrike mode.
              PATH_DIRS (-Q)
                     Perform  a path search even on command names
                     with   slashes    in    them.     Thus    if
                     "/usr/local/bin"  is in the user's path, and
                     he   types    "X11/xinit",    the    command
                     "/usr/local/bin/X11/xinit"  will be executed
                     (assuming it exists).  This applies to the .
                     builtin  as  well  as  to command execution.
                     Commands explicitly beginning with  "./"  or
                     "../" are not subject to path search.
              MAGIC_EQUAL_SUBST
                     All  unquoted  arguments of the from identi-
                     fier=expression  have  file  expansion  per-
                     formed on expression as if it were a parame-
                     ter assignment, although the argument is not
                     otherwise treated specially.
              PRINT_EXIT_VALUE (-C)
                     Print  the  exit value of programs with non-
                     zero exit status.
              PROMPT_SUBST
                     If set expressions like ${...}, $(...),  and
                     $[...]  in prompts will be expanded.
              PUSHD_IGNORE_DUPS
                     Don't  push  multiple  copies  of  the  same
                     directory onto the directory stack.
              PUSHD_MINUS
                     See popd below.
              PUSHD_SILENT (-E)
                     Do not print the directory stack after pushd
                     or popd.
              PUSHD_TO_HOME (-D)
                     Have  pushd with no arguments act like pushd
                     $HOME.
              RC_EXPAND_PARAM (-P)
                     See Parameter Expansion.
              RC_QUOTES
                     Allow the character sequence '' to signify a
                     single quote within singly quoted strings.
              REC_EXACT (-S)
                     In  completion, recognize exact matches even
                     if they are ambiguous.
              RM_STAR_SILENT (-H)
                     Do not query the user before  executing  "rm
                     *" or "rm path/*".
              SHIN_STDIN (-s)
                     Read commands from the standard input.
              SH_WORD_SPLIT (-y)
                     See Parameter Expansion.
              SINGLE_LINE_ZLE (-M)
                     Use single-line command line editing instead
                     of multi-line.
              SUN_KEYBOARD_HACK (-L)
                     If a line ends with a backquote,  and  there
                     are an odd number of backquotes on the line,
                     ignore the trailing backquote.  This is use-
                     ful  on  some keyboards where the return key
                     is too small, and  the  backquote  key  lies
                     annoyingly close to it.
              VERBOSE (-v)
                     Print shell input lines as they are read.
              XTRACE (-x)
                     Print  commands  and their arguments as they
                     are executed.
              ZLE (-Z)
                     Use the zsh line editor.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   shift [ n ] [ name ... ]
              The positional parameters from $n+1 ... are renamed
              $1,  where  n  is  an  arithmetic  expression  that
              defaults to 1.  If any names  are  given  then  the
              arrays  with these names are shifted instead of the
              positional parameters.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          source Same as ., except that  the  current  directory  is
              always  searched  and  is  always  searched  first,
              before directories in path.

       . file [ arg ... ]
              Read commands from file and  execute  them  in  the
              current  shell  environment.  If file does not con-
              tain a slash, or if PATH_DIRS  is  set,  the  shell
              looks  in the components of path to find the direc-
              tory containing file.  Files in the current  direc-
              tory  are  not read unless "." appears somewhere in
              path.  If any arguments arg are given, they  become
              the   positional  parameters;  the  old  positional
              parameters are restored when the file is done  exe-
              cuting.   The exit status is the exit status of the
              last command executed.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     suspend [ -f ]
              Suspend the execution of the shell (send it a SIGT-
              STP) until it receives a SIGCONT.  If the -f option
              is not given, complain if this is a login shell.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              test arg ...
       [ arg ... ]
              Like the system version of test.  Added for compat-
              ibility; use conditional expressions instead.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         time [ pipeline ]
                     The pipeline is executed, and timing statis-
                     tics are reported on the standard  error  in
                     the form specified by the TIMEFMT parameter.
                     If pipeline  is  omitted,  print  statistics
                     about the shell process and its children.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                times  Print the accumulated user and system times for the
              shell and for processes run from the shell.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           trap [ arg ] [ sig ] ...
              arg is a command to be read and executed  when  the
              shell  receives  sig.   Each  sig can be given as a
              number or as the name of a signal.  Inside the com-
              mand,  $1  refers to the number of the signal which
              caused the trap.  If arg is -, then all  traps  sig
              are  reset  to their default values.  If arg is the
              null string, then this signal  is  ignored  by  the
              shell  and  by  the commands it invokes.  If sig is
              ZERR then arg will be executed after  each  command
              with  a  nonzero exit status.  If sig is DEBUG then
              arg will be executed after each command.  If sig is
              0 or EXIT and the trap statement is executed inside
              the body of a function, then  the  command  arg  is
              executed after the function completes.  If sig is 0
              or EXIT and the  trap  statement  is  not  executed
              inside the body of a function, then the command arg
              is executed when the shell  terminates.   The  trap
              command with no arguments prints a list of commands
              associated with each signal.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ttyctl -fu
              The -f option freezes the tty, and -u unfreezes it.
              When  the tty is frozen, no changes made to the tty
              settings by external programs will  be  honored  by
              the  shell,  except  for changes in the size of the
              screen; the shell will simply reset the settings to
              their previous values as soon as each command exits
              or is suspended.  Thus, stty and  similar  programs
              have  no  effect  when  the  tty is frozen. Without
              options it reports whether the terminal  is  frozen
              or not.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             type   Same as whence -v.

       whence [ -acpvm ] name ...
              For each name, indicate how it would be interpreted
              if used as a command name.  The -v flag produces  a
              more  verbose  report.   The  -p  flag  does a path
              search for name even if it  is  a  shell  function,
              alias,  or  reserved  word.  The -c flag prints the
              results in a csh-like format.  The -a flag  does  a
              search  for  all occurrences of name throughout the
              command path.  With the -m flag the  arguments  are
              taken as patterns (should be quoted) and the infor-
              mation is displayed for each command  matching  one
              of these patterns.

       which  Same as whence -c.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ulimit [ -Hacdflmnopstv ] [ limit ]
              Set or display a resource  limit.  When  setting  a
              limit  it  will  apply to the children of the shell
              but not to the shell itself. The value of limit can
              be  a  number  in  the  unit specified below or the
              value unlimited.  If the H flag is given  use  hard
              limits instead of soft limits.
              -a     Lists all of the current resource limits.
              -c     The number of 512-byte blocks on the size of
                     core dumps.
              -d     The number of K-bytes on  the  size  of  the
                     data segment.
              -f     The number of 512-byte blocks on the size of
                     files written.
              -l     The number of K-bytes on the size of locked-
                     in memory.
              -m     The  number of K-bytes on the size of physi-
                     cal memory.
              -n     The number of file descriptors.
              -o     The number of open files.
              -p     The number of processes.
              -s     The number of K-bytes on  the  size  of  the
                     stack.
              -t     The number of CPU seconds to be used.
              -v     The number of K-bytes on the size of virtual
                     memory.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         umask [ mask ]
              The umask is set to mask.  mask can  be  either  an
              octal  number  or  a symbolic value as described in
              chmod(1).  If mask is omitted, the current value is
              printed.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    unfunction [ -m ] name ...
              The function definition, if any, for each  name  is
              removed.  If the -m flag is specified the arguments
              are taken as patterns (should be  quoted)  and  all
              functions with matching names are removed.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      unlimit [ -h ] resource ...
              The  resource limit for each resource is set to the
              hard limit.  If the -h flag is given and the  shell
              is  running  as  root,  the hard resource limit for
              each resource is removed.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             until list
              do list
              done   Execute  the  do  list as long as until list
                     returns a nonzero exit status.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  vared [ -c ] [ -p prompt ] [ -r rprompt ] name
              The value of the parameter name is loaded into  the
              edit  buffer, and the line editor is invoked.  When
              the editor exits, name is set to the  string  value
              returned  by  the  editor.  If the -c flag is given
              the parameter is  created  if  it  doesn't  already
              exist.   If  the  -p  flag  is  given the following
              string will be taken as the prompt  to  display  at
              the  left and if the -r flag is given the following
              string gives the prompt to display at the right.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  wait [ job ... ]
              Wait for the specified jobs or processes.   If  job
              is  not  given then all currently active child pro-
              cesses are waited for.  Each job can  be  either  a
              job specification or the process-id of a job in the
              job table.  The exit status from  this  command  is
              that of the job waited for.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  while list
              do list
              done   Execute the do list as  long  as  the  while
                     list returns a zero exit status.

              while ( list ) {
              list
              }      An alternate form of while.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        d .       ..     eËzsh.1 Ê                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         .\"
.TH ZSH 1 "3 June 1994" "zsh version 2.5.0"
.SH NAME
zsh \- the Z shell
.SH SYNOPSIS
\fBzsh\fP [ \(+-\fIoptions\fP ] [ \(+-\fBo\fP \fIoption\fP ] ...  [ \-\fBc\fP \fIstring\fP ] [ \fIarg\fP ... ]
.SH "SHELL GRAMMAR"
A \fIsimple command\fP is a sequence of optional parameter
assignments followed by blank-separated words,
with optional redirections interspersed.
The first word is the command to be executed, and the remaining
words, if any, are arguments to the command.
If a command name is given, the parameter assignments modify
the environment of the command when it is executed.
The value of a simple command is its exit status,
or 128 plus the signal number if terminated by a signal.
.PP
If a simple command is preceded by the word \fBexec\fP,
it is executed in the parent shell without forking.
If preceded by \fBcommand\fP, the command word is taken
to be the name of an external command, rather than a
shell function or builtin.
If preceded by \fBnoglob\fP, filename generation is not performed
on any of the words.  If preceded by a \-, the command
is executed with a \- prepended to its \fBargv[0]\fP string.
If preceded by \fBnocorrect\fP, spelling correction is not
done on any of the words.
.PP
A \fIpipeline\fP is a sequence of one or more commands
separated by \fB|\fP or \fB|&\fP.  \fB|&\fP is shorthand
for \fB2>&1 |\fP.  The standard output of each command is
connected to the standard input of the next command in the
pipeline.
.PP
The value of a pipeline is the value of the last command.
If a pipeline is preceded by a \fB!\fP, the value
of that pipeline is the logical NOT of the value of the last
command.
.PP
If a pipeline is preceded by \fBcoproc\fP, it is
executed as a coprocess; a two-way pipe is established
between it and the parent shell.  The shell can read from or write to
the coprocess by means of the \fB>&p\fP and \fB<&p\fP
redirection operators.
.PP
A \fIsublist\fP is a sequence of one or more pipelines
separated by \fB&&\fP or \fB|\||\fP.  If two pipelines
are separated by \fB&&\fP, the second pipeline is executed
only if the first is successful (returns a zero value).
If two pipelines are separated by \fB|\||\fP, the second is executed
only if the first is unsuccessful (returns a nonzero value).  Both
operators have equal precedence and are left associative.
.PP
A \fIlist\fP is a sequence of one or more sublists
separated by, and optionally terminated by, \fB;\fP, \fB&\fP,
or a newline.
Normally the shell waits for each list to finish before executing
the next one.
If a list is terminated by a \fB&\fP, the shell executes
it in the background, and does not wait for it to finish.
.PP
A \fIcomplex command\fP is one of the following:
.PP
.RS
.PD 0
.TP
\fBfor\fP \fIname\fP [ \fBin\fP \fIword\fP ... ]
.TP
\fBdo\fP \fIlist\fP
.TP
\fBdone\fP
.PD
Expand the list of \fIword\fPs, and set the parameter
\fIname\fP to each of them in turn, executing
\fIlist\fP each time.  If the \fBin\fP \fIword\fP is omitted,
use the positional parameters instead of the \fIword\fPs.
.TP
\fBfor\fP \fIname\fP [ \fBin\fP \fIword\fP ... ] ; \fIsublist\fP
This is a shorthand for \fBfor\fP.
Though it may cause confusion, it is included for convenience;
its use in scripts is discouraged,
unless \fIsublist\fP is a command of the form { \fIlist\fP }.
.PP
.PD 0
.TP
\fBforeach\fP \fIname\fP \fB(\fP \fIword\fP ... \fB)\fP
.TP
\fIlist\fP
.TP
\fBend\fP
.PD
Another form of \fBfor\fP.
.PP
.PD 0
.TP
\fBfor\fP \fIname\fP \fBin\fP \fIword\fP ...
.TP
\fB{\fP
.TP
\fIlist\fP
.TP
\fB}\fP
.PD
Another form of \fBfor\fP.
.PP
.PD 0
.TP
\fBfor\fP \fIname\fP \fB(\fP \fIword\fP ... \fB) {\fP
.TP
\fIlist\fP
.TP
\fB}\fP
.PD
Another form of \fBfor\fP:  this requires the option \fBCSH_JUNKIE_PAREN\fP.
.PP
.PD 0
.TP
\fBfor\fP \fIname\fP \fB(\fP \fIword\fP ... \fB) \fIsublist\fP
.PD
Another form of \fBfor\fP:  this also requires \fBCSH_JUNKIE_PAREN\fP.
.PP
.PD 0
.TP
\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP ... ]
.TP
\fBdo\fP \fIlist\fP
.TP
\fBdone\fP
.PD
Print the set of \fIword\fPs, each preceded by a number.
If the \fBin\fP \fIword\fP is omitted, use the positional parameters.
The \fBPROMPT3\fP prompt is printed and a line is read from standard
input.  If this line consists of the number of one of the listed
\fIword\fPs, then the parameter \fIname\fP
is set to the \fIword\fP corresponding to this number.
If this line is empty, the selection list is printed again.
Otherwise, the value of the parameter \fIname\fP is set to null.
The contents of the line read from standard input is saved
in the parameter \fBREPLY\fP.  \fIlist\fP is executed
for each selection until a break or end-of-file is encountered.
.TP
\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP ] ; \fIsublist\fP
A short form of \fBselect\fP.
.TP
\fBcase\fP \fIword\fP \fBin\fP [ \fIpattern\fP ) \fIlist\fP ;; ] ...  \fBesac\fP
Execute the \fIlist\fP associated with the first \fIpattern\fP
that matches \fIword\fP, if any.  The form of the patterns
is the same as that used for filename generation.  See
\fIFilename Generation\fP below.
.TP
\fBcase\fP \fIword\fP \fB{\fP [ \fIpattern\fP ) \fIlist\fP ;; ] ...  \fB}\fP
Another form of \fBcase\fP.
.TP
.PD 0
\fBif\fP \fIlist\fP
.TP
\fBthen\fP \fIlist\fP
.TP
[ \fBelif\fP \fIlist\fP ; \fBthen\fP \fIlist\fP ] ...
.TP
[ \fBelse\fP \fIlist\fP ]
.TP
\fBfi\fP
.PD
The \fBif\fP \fIlist\fP is executed, and,
if it returns a zero exit status,
the \fBthen\fP \fIlist\fP is executed.
Otherwise, the \fBelif\fP \fIlist\fP is
executed and, if its value is zero,
the \fBthen\fP \fIlist\fP is executed.
If each \fBelif\fP \fIlist\fP returns
nonzero, the \fBelse\fP \fIlist\fP is executed.
.TP
\fBif (\fP \fIlist\fP \fB)\fP \fIsublist\fP
A short form of \fBif\fP:  this requires the option \fBCSH_JUNKIE_PAREN\fP.
.PP
.PD 0
.TP
\fBif\fP \fB(\fP \fIlist\fP \fB) {\fP
.TP
\fIlist\fP
.TP
\fB} elif (\fP \fIlist\fP \fB) {\fP
.TP
\fIlist\fP
.TP
\fB} ... else {\fP
.TP
\fIlist\fP
.TP
\fB}\fP
.PD
An alternative form of \fBif\fP. The parentheses surrounding
\fIlist\fP can be omitted if the only command in the list is a
conditional expression of the form [[ exp ]] (see below).  This form
also requires \fBCSH_JUNKIE_PAREN\fP.
.TP
.PD 0
\fBwhile\fP \fIlist\fP
.TP
\fBdo\fP \fIlist\fP
.TP
\fBdone\fP
.PD
Execute the \fBdo\fP \fIlist\fP as long as the \fBwhile\fP \fIlist\fP
returns a zero exit status.
.PP
.PD 0
.TP
\fBwhile (\fP \fIlist\fP \fB) {\fP
.TP
\fIlist\fP
.TP
\fB}\fP
.PD
An alternative form of \fBwhile\fP:  this requires the option
\fBCSH_JUNKIE_PAREN\fP.
.TP
.PD 0
\fBuntil\fP \fIlist\fP
.TP
\fBdo\fP \fIlist\fP
.TP
\fBdone\fP
.PD
Execute the \fBdo\fP \fIlist\fP as long as \fBuntil\fP \fIlist\fP
returns a nonzero exit status.
.TP
.PD 0
\fBrepeat\fP \fIword\fP
.TP
\fBdo\fP \fIlist\fP
.TP
\fBdone\fP
.PD
\fIword\fP is expanded and treated as an arithmetic expression,
which must evaluate to a number \fIn\fP.
\fIlist\fP is then executed \fBn\fP times.
.TP
\fBrepeat\fP \fIword\fP \fIsublist\fP
This is a short form of \fBrepeat\fP.
.TP
( \fIlist\fP )
Execute \fIlist\fP in a subshell.
.TP
{ \fIlist\fP }
Execute \fIlist\fP.
.TP
.PD 0
\fBfunction\fP \fIword\fP [ (\|) ] ... { \fIlist\fP }
.TP
\fIword\fP ... (\|) { \fIlist\fP }
.TP
\fIword\fP ... (\|) \fIsublist\fP
.PD
Define a function which is referenced by any one of \fIword\fP.
Normally, only one \fIword\fP is provided; multiple \fIword\fPs
are usually only useful for setting traps.
The body of the function is the \fIlist\fP between
the { and }.
See \fBFUNCTIONS\fP below.
.TP
\fBtime\fP [ \fIpipeline\fP ]
The \fIpipeline\fP is executed, and timing statistics are
reported on the standard error in the form specified
by the \fBTIMEFMT\fP parameter.
If \fIpipeline\fP is omitted, print statistics about the
shell process and its children.
.TP
[[ \fIexp\fP ]]
Evaluates the conditional expression \fIexp\fP
and return a zero exit status if it is true.
See \fBConditional Expressions\fP below for a description
of \fIexp\fP.
.SH "RESERVED WORDS"
The following words are recognized as reserved words when used 
as the first word of a command
unless quoted or removed using the \fBunalias\fP builtin:
.RS
.PP
\fBdo done esac then elif else fi for case
if while function repeat time until exec command
select coproc noglob \- nocorrect foreach end\fP
.RE
.SH COMMENTS
In noninteractive shells, or in interactive shells with the
\fBINTERACTIVE_COMMENTS\fP option set, a word beginning
with the third character of the \fBHISTCHARS\fP parameter
(`#' by default) causes that word and all the following
characters up to a newline to be ignored.
.SH ALIASING
Every token in the shell input is checked to see if there
is an alias defined for it.
If so, it is replaced by the text of the alias if it is in command
position (if it could be the first word of a simple command),
or if the alias is global.
If the text ends with a space, the next word in the shell input
is treated as though it were in command position for purposes of alias
expansion.
An alias is defined using the \fBalias\fP builtin; global aliases
may be defined using the \-\fBg\fP option to that builtin.
.PP
Alias substitution is done on the shell input before any
other substitution except history substitution.  Therefore,
if an alias is defined for the word \fBfoo\fP, alias substitution
may be avoided by quoting part of the word, e.g. \fB\efoo\fP.
But there is nothing to prevent an alias being defined
for \fB\efoo\fP as well.
.SH QUOTING
A character may be \fIquoted\fP (that is, made
to stand for itself) by preceding it with a \e\|.
\e followed by a newline is ignored.
All characters enclosed between a pair of single quotes ('')
are quoted, except the first character of HISTCHARS ( `!' by default).
A single quote cannot appear within single quotes.
Inside double quotes (""), parameter and command substitution
occurs, and \e quotes the characters \e\|, `, ", and $.
.SH EXPANSION
Expansion is performed on the command line after it has been
parsed.  The types of expansions performed are
\fIfilename expansion\fP, 
\fIprocess substitution\fP,
\fIparameter expansion\fP,
\fIcommand substitution\fP,
\fIarithmetic expansion\fP,
\fIbrace expansion\fP,
and \fIfilename generation\fP.
.SS Filename Expansion
Each word is checked to see if it begins with an unquoted ~.
If it does, then the word up to a / is checked to see if it matches
the name of a named directory.  If so, then the ~ and the matched portion
are replaced with the value of the named directory.
A ~ by itself or followed by a / is replaced by the value of the
\fBHOME\fP parameter.
A ~ followed by a + or a \- is replaced by the value of 
\fBPWD\fP or \fBOLDPWD\fP, respectively.
.PP
Named directories are typically login directories for users on the system.
They may also be defined if the text after the ~ is the name
of a string shell parameter whose value begins with a /.
In certain circumstances (in prompts, for instance), when the shell
prints a path, the path is checked to see if it has a named
directory as its prefix.  If so, then the prefix portion
is replaced with a ~ followed by the name of the directory.
The longest match is preferred.
.PP
If a word begins with an unquoted \fB=\fP and the
\fBNO_EQUALS\fP option is not set,
the remainder of the word is taken as the
name of a command or alias.  If a command
exists by that name, the word is replaced
by the full pathname of the command.
If an alias exists by that name, the word
is replaced with the text of the alias.
Otherwise the word is checked up to a /
to see if it is a number or a \-.  If so,
the matched portion is replaced with
the \fIn\fPth directory in the directory stack,
where \fIn\fP is the number matched, or
the last directory in the directory stack
if a \- is matched.
.PP
Filename expansion is performed on the right hand side of a parameter
assignment, including those appearing after commands of the
\fBtypeset\fR family.  In this case, the right hand side will be treated
as a colon-separated list in the manner of \fBPATH\fR so that a ~ or an
= following a : is eligible for expansion.  All such behavior can be
disabled by quoting the ~, the =, or the whole expression (but not
simply the colon); the \fBNO_EQUALS\fP option is also respected.
.PP
If the option \fBMAGIC_EQUAL_SUBST\fP is set, any unquoted shell
argument in the form \fIidentifier\fP=\fIexpression\fP becomes eligible
for file expansion as described in the previous paragraph.  Quoting the
first = also inhibits this.
.SS Process Substitution
Each command argument of the form
\fB<(\fIlist\^\fB)\fR
or
\fB>(\fIlist\^\fB)\fR
or
\fB=(\fIlist\^\fB)\fR
is subject to process substitution.
In the case of the
.B <
or
.B >
forms, the shell will run process
.I list
asynchronously connected to a named pipe (FIFO).
The name of this pipe will become the argument to the command.
If the form with
.B >
is selected then writing on this file will provide input for
.IR list .
If
.B <
is used,
then the file passed as an argument will
be a named pipe connected to the output of the
.I list
process.
For example,
.RS
.PP
\fBpaste <(cut \-f1\fP \fIfile1\fB) <(cut \-f3\fP \fIfile2\fB) | tee >(\fIprocess1\fB) >(\fIprocess2\fB)\fR >/dev/null
.RE
.PP
.BR cut s
fields 1 and 3 from
the files
.I file1
and
.I file2
respectively,
.BR paste s
the results together, and sends it to the processes
.I process1
and
.IR process2 .
Note that the file, which is passed as an argument to the command,
is a system
pipe 
so programs that expect to
.BR lseek (2)
on the file will not work.
Also note that the previous example can be more compactly and
efficiently written as:
.RS
.PP
\fBpaste <(cut \-f1\fP \fIfile1\fB) <(cut \-f3\fP \fIfile2\fB) > >(\fIprocess1\fB) > >(\fIprocess2\fB)\fR
.RE
.PP
The shell uses pipes instead of FIFOs to implement the latter
two process substitutions in the above example.
.PP
If
.B =
is used,
then the file passed as an argument will be the name
of a temporary file containing
the output of the
.I list
process.  This may be used instead of the
.B <
form for a program that expects to \fBlseek\fP(2) on the input file.
.SS Parameter Expansion
The character \fB$\fP is used to introduce parameter expansions.
See \fBPARAMETERS\fP below for a description of parameters.
.PD
.RS
.TP
\fB${\fIname\fB}\fR
The value, if any, of the parameter \fIname\fP is substituted.
The braces are required if \fIname\fP is followed by
a letter, digit, or underscore that is not to be interpreted
as part of its name.
If \fIname\fP is an array parameter, then the values of each
element of \fIname\fP is substituted, one element per word.
Otherwise, the expansion results in one word only; no
word splitting is done on the result.
.TP
\fB${+\fIname\fB}\fR
If \fIname\fP is the name of a set parameter `1' is substituted,
otherwise `0' is substituted.
.TP
\fB${\fIname\fB:\-\fIword\fB}\fR
If \fIname\fP is set and is non-null then substitute its
value; otherwise substitute \fIword\fP.
.TP
\fB${\fIname\fB:=\fIword\fB}\fR
If \fIname\fP is unset or is null then
set it to \fIword\fP; the value of the parameter is then
substituted.
.TP
\fB${\fIname\fB:?\fIword\fB}\fR
If \fIname\fP is set and is non-null, then substitute
its value; otherwise, print \fIword\fP and exit from the shell.
If \fIword\fP is omitted, then a standard message is printed.
.TP
\fB${\fIname\fB:+\fIword\fB}\fR
If \fIname\fP is set and is non-null then substitute
\fIword\fP; otherwise substitute nothing.
.PD 0
.TP
\fB${\fIname\fB#\fIpattern\fB}\fR
.TP
\fB${\fIname\fB##\fIpattern\fB}\fR
.PD
If the \fIpattern\fP matches the beginning of the value of
\fIname\fP, then substitute the value of \fIname\fP with
the matched portion deleted; otherwise, just
substitute the value of \fIname\fP.  In the first
form, the smallest matching pattern is preferred;
in the second form, the largest matching pattern is preferred.
.PD 0
.TP
${\fIname\fB%\fIpattern\fR}
.TP
${\fIname\fB%%\fIpattern\fR}
.PD
If the \fIpattern\fP matches the end of the value of
\fIname\fP, then substitute the value of \fIname\fP with
the matched portion deleted; otherwise, just
substitute the value of \fIname\fP.  In the first
form, the smallest matching pattern is preferred;
in the second form, the largest matching pattern is preferred.
.TP
${\fB#\fIspec\fR}
If \fIspec\fP is one of the above substitutions, substitute
the length in characters of the result instead of
the result itself.  If \fIspec\fP is an array expression,
substitute the number of elements of the result.
.TP
${\fB^\fIspec\fR}
Toggle the value of the \fBRC_EXPAND_PARAM\fP option for the
evaluation of \fIspec\fP.
When this option is set, array expansions of the form
\fIfoo\fB${\fIxx\fB}\fIbar\fR, where the parameter
\fIxx\fP is set to (\fIa b c\fP), are substituted with
\fIfooabar foobbar foocbar\fP instead of the default
\fIfooa b cbar\fP.
.TP
${\fB=\fIspec\fR}
Toggle the value of the \fBSH_WORD_SPLIT\fP option for the
evaluation of \fIspec\fP.
When this option is set, parameter values are split into
separate words using \fBIFS\fP as a delimiter
before substitution.
This is done by default in most other shells.
.TP
${\fB~\fIspec\fR}
Toggle the value of the \fBGLOB_SUBST\fP option for the evaluation of
\fIspec\fP.  When this option is set, any pattern characters resulting
from the substitution become eligible for file expansion and filename
generation.
.PD
.RE
.PP
If the colon is omitted from one of the above expressions
containing a colon, then the shell only checks whether
\fIname\fP is set or not, not whether it is null.
.PP
If the opening brace is directly followed by an opening parentheses
the string up to the matching closing parentheses will be taken as a
list of flags.  Where arguments are valid, any character, or the
matching pairs `(...)', `{...}', `[...]', or `<...>',  may be used
in place of the colon as delimiters.  The following flags are supported:
.PD
.RS
.TP
.B o
Sort the resulting words in ascending order.
.TP
.B O
Sort the resulting words in descending order.
.TP
.B i
With \fBo\fP or \fBO\fP, sort case-independently.
.TP
.B L
Convert all letters in the result to lower case.
.TP
.B U
Convert all letters in the result to upper case.
.TP
.B C
Capitalize the resulting words.
.TP
.B c
With ${#\fIname\fP}, count the total number of characters in an array,
as if the elements were concatenated with spaces between them.
.TP
.B w
With ${#\fIname\fP}, count words in arrays or strings; the \fIs\fP
flag may be used to set a word delimiter.
.TP
.B l:\fIexpr\fB::\fIstring1\fB::\fIstring2\fB:
Pad the resulting words on the left.  Each word will be truncated if
required and placed in a field \fIexpr\fP characters wide.  The space
to the left will be filled with \fIstring1\fP (concatenated as often
as needed) or spaces if \fIstring1\fP is not given.  If both
\fIstring1\fP and \fIstring2\fP are given, this string will be placed
exactly once directly to the left of the resulting word.
.TP
.B r:\fIexpr\fB::\fIstring1\fB::\fIstring2\fB:
As \fBl...\fP, but pad the words on the right.
.TP
.B j:\fIstring\fB:
Join the words of arrays together using \fIstring\fP as a separator.
Note that this occurs before word splitting by the \fBSH_WORD_SPLIT\fP
option.
.TP
.B s:\fIstring\fB:
Force word splitting (see the option \fBSH_WORD_SPLIT\fP) at the
separator \fIstring\fP.  Splitting only occurs in places where an
array value is valid.
.TP
.B S
(This and all remaining flags are used with the \fB${...#...}\fP or
\fB${...%...}\fP forms):
search substrings as well as beginnings or ends.
.TP
.B I:\fIexpr\fB:
Search the \fIexpr\fP'th match (where \fIexpr\fP evaluates to a number).
.TP
.B M
Include the matched portion in the result.
.TP
.B R
Include the unmatched portion in the result (the \fIR\fPest).
.TP
.B B
Include the index of the beginning of the match in the result.
.TP
.B E
Include the index of the end of the match in the result.
.TP
.B N
Include the length of the match in the result.
.PD
.RE
.PP
.SS Command Substitution
A command enclosed in parentheses
preceded by a dollar sign, like so: $(...) or quoted with grave
accents: `...` is replaced with its standard output.
If the substitution is not enclosed in double quotes, the
output is broken into words using the \fBIFS\fP parameter.
The substitution \fB$(cat foo)\fP may be replaced
by the equivalent but faster \fB$(<foo)\fP.  In either case, if the
option \fBGLOB_SUBST\fP is set the output is eligible for filename
generation.
.SS Arithmetic Expansion
A string of the form \fB$[\fIexp\fB]\fR is substituted
with the value of the arithmetic expression \fIexp\fP.
See \fBARITHMETIC EVALUATION\fP below.
.SS Brace Expansion
A string of the form
\fIfoo\fB{\fIxx\fB,\fIyy\fB,\fIzz\fB}\fIbar\fR
is expanded to the individual words
\fIfooxxbar\fP, \fIfooyybar\fP, and \fIfoozzbar\fP.
Left-to-right order is preserved.  This construct
may be nested.  Malformed brace expansion expressions,
including expressions without a comma, are left unchanged
by the shell.
.PP
An expression of the form
\fB{\fIx\fB\-\fIy\fB}\fR,
where \fIx\fP and \fIy\fP are single characters,
is expanded to every character between
\fIx\fP and \fIy\fP, inclusive.
.SS Filename Generation
If a word contains an unquoted instance of one of the characters
*, |, <, [, or ?, it is regarded
as a pattern for filename generation, unless the \fBNO_GLOB\fP option is set.
If the \fBEXTENDED_GLOB\fP option is set, the
^,  ~ and # characters also denote a pattern; otherwise
(except for an initial ~, see \fBFilename Expansion\fP above)
they are not treated specially by the shell.
The word is replaced with a list of sorted filenames that match
the pattern.  If no matching pattern is found, the shell gives
an error message, unless the \fBNULL_GLOB\fP option is set,
in which case the word is deleted; or unless the \fBNO_NOMATCH\fP
option is set, in which case the word is left unchanged.
In filename generation,
the character / must be matched explicitly; also, a . must be matched
explicitly at the beginning of a pattern or after a /, unless the
\fBGLOB_DOTS\fP option is set.  No filename generation pattern
matches the files "." or "..".  In other instances of pattern
matching, the / and . are not treated specially.
.PP
.RS
.PD 0
.TP
.B *
matches any string, including the null string.
.TP
.B ?
matches any character.
.TP
\fB[ ... ]\fP
matches any of the enclosed characters.
.TP
\fB[^ ... ]\fP
matches any character except the enclosed characters.
\fB[! ... ]\fP
is the same as the above.
.TP
\fB<x\-y>\fP
matches any number in the range x to y, inclusive.
If x is omitted, the number must be less than or equal to y.
If y is omitted, the number must be greater than or equal to x.
A pattern of the form \fB<\->\fP or
simply \fB<>\fP matches any number.
.TP
\fB^x\fP
matches anything except the pattern x.
.TP
\fBx|y\fP
matches either x or y.
.TP
\fBx#\fP
matches zero or more occurrences of the pattern x.
.TP
\fBx##\fP
matches one or more occurrences of the pattern x.
.RE
.PD
.PP
Parentheses may be used for grouping.  Note that the \fB|\fP character
must be within parentheses, so that the lexical analyzer does
not think it is a pipe character.  Also note that "/" has a
higher precedence than "^"; that is:
.RS
.PP
ls
.BI ^ foo / bar
.RE
.PP
will search directories in "." except "./foo" for a file named bar.
.PP
A pathname component of the form
.BI ( foo /)#
matches a path consisting of zero or more directories
matching the pattern foo.
As a shorthand,
.B **/
is equivalent to
.BR (*/)# .
Thus:
.RS
.PP
ls
.BI (*/)# bar
.RE
.PP
or
.RS
.PP
ls
.BI **/ bar
.RE
.PP
does a recursive directory search for files named bar.
.PP
If used for filename generation, a pattern may contain an exclusion
specifier.  Such patterns are of the form \fIpat1\fB~\fIpat2\fR.
This pattern will generate all files matching \fIpat1\fP, but which
do not match \fIpat2\fP.  For example, \fB*.c~lex.c\fP will match
all files ending in .c, except the file \fBlex.c\fP.  This may appear
inside parentheses.  Note that "~" has a higher precedence than "|",
so that \fIpat1\fB|\fIpat2\fB~\fIpat3\fR matches any time that
\fIpat1\fR matches, or if \fIpat2\fR matches while \fIpat3\fR does
not.  Note also that "/" characters are not treated specially in the
exclusion specifier so that a "*" will match multiple path segments if
they appear in the pattern to the left of the "~".
.PP
Patterns used for filename generation may also end in a
list of qualifiers enclosed in parentheses.
The qualifiers
specify which filenames that otherwise match the given pattern
will be inserted in the argument list.
A qualifier may be any one of the following:
.PD 0
.RS
.TP
.B /
directories
.TP
.B .
plain files
.TP
.B @
symbolic links
.TP
.B =
sockets
.TP
.B p
named pipes (FIFOs)
.TP
.B *
executable plain files (0100)
.TP
.B %
device files (character or block special)
.TP
.B %b
block special files
.TP
.B %c
character special files
.TP
.B r
readable files (0400)
.TP
.B w
writable files (0200)
.TP
.B x
executable files (0100)
.TP
.B R
world-readable files (0004)
.TP
.B W
world-writable files (0002)
.TP
.B X
world-executable files (0001)
.TP
.B s
setuid files (04000)
.TP
.B S
setgid files (02000)
.TP
\fBd\fIdev\fR
files on the device \fIdev\fP
.TP
\fBl\fI[-|+]ct\fR
files having a link count less than \fIct\fP (-), greater than
\fIct\fP (+), or is equal to \fIct\fP
.TP
\fBU\fP
files owned by the effective user id
.TP
\fBG\fP
files owned by the effective group id
.TP
\fBu\fIid\fR
files owned by user id \fIid\fP if it is a number, if not, than the
character after the \fBu\fP will be used as a separator and the string
between it and the next matching separator (`(', `[', `{', and `<'
match `)', `]', `}', and `>' respectively, any other character matches
itself) will be taken as a user name and the user id of this user will
be taken (e.g. \fBu:foo:\fP or \fBu[foo]\fP for user \fBfoo\fP)
.TP
\fBg\fIid\fR
like \fBu\fIid\fR but with group ids or names
.TP
\fBa\fI[-|+]n\fR
files accessed within last \fIn\fP days (-), more than \fIn\fP days
ago (+), or \fIn\fP days ago\fP
.TP
\fBm\fI[-|+]n\fR
files modified within last \fIn\fP days (-), more than \fIn\fP days
ago (+), or \fIn\fP days ago\fP
.TP
\fBc\fI[-|+]n\fR
files whose inode changed within last \fIn\fP days (-), more than
\fIn\fP days ago (+), or \fIn\fP days ago.
If any of the flags \fBa\fP, \fBm\fP, or \fBc\fP is directly followed by a
\fBM\fP, \fBw\fP, \fBh\fP, or \fBm\fP (e.g. \fBmh+5\fP) the check is
performed with months (of 30 days), weeks, hours, or minutes instead
of days, respectively.
.TP
\fBL\fI[+|-]n\fR
files less than n bytes (-), more than n bytes (+), or
exactly n bytes in length.
.TP
\fB^\fP
negates all qualifiers following it
.TP
\fB\-\fP
toggles between making the qualifiers work on symbolic links (the
default) and the files they point to
.TP
\fBM\fP
sets the \fBMARK_DIRS\fP option for the current pattern
.TP
\fBT\fP
appends a traling qualifier mark to the file names, analogous to the
\fBLIST_TYPES\fP option, for the current pattern (overrides \fBM\fP)
.TP
\fBN\fP
sets the \fBNULL_GLOB\fP option for the current pattern
.TP
\fBD\fP
sets the \fBGLOB_DOTS\fP option for the current pattern
.PD
.RE
.PP
More than one of these lists can be combined, separated by commas. The
whole list matches if at least one of the sublists matches (they are
`or'ed', the qualifiers in the sublists are `and'ed').
.PP
If a : appears in a qualifier list, the remainder of the expression in
parenthesis is interpreted as a modifier (see the subsection
\fBModifiers\fR of the section \fBHISTORY\fR).  Note that each modifier
must be introduced by a separate :.  Note also that the result after
modification does not have to be an existing file.  The name of any
existing file can be followed by a modifier of the form (:..) even if no
filename generation is performed.
.PP
Thus:
.RS
.PP
ls
.B *(\-/)
.RE
.PP
lists all directories and symbolic links that point to directories,
and
.RS
.PP
ls
.B *(%W)
.RE
.PP
lists all world-writable device files in the current directory,
and
.RS
.PP
ls
.B *(W,X)
.RE
.PP
lists all files in the current directory that are 
world-writable or world-executable, and
.RS
.PP
echo
.B /tmp/foo*(u0^@:t)
.RE
.PP
outputs the basename of all root-owned files beginning with the string
"foo" in /tmp, ignoring symlinks, and
.RS
.PP
ls
.B *.*~(lex|parse).[ch](^D^l1)
.RE
.PP
lists all files having a link count of one whose names contain a dot
(but not those starting with a dot, since \fBGLOB_DOTS\fP is explicitly
switched off) except for lex.c, lex.h, parse.c, and parse.h.
A "/" at the end of a pattern
is equivalent to "(\|/\|)".
.SH REDIRECTION
Before a command is executed, its input and output
may be redirected.
The following may appear anywhere in a simple command
or may precede or follow a complex command.
Substitution occurs before
.I word
is used except as noted below.
If the result of substitution on
.I word
produces more than one filename,
redirection occurs for each
separate filename in turn.
.TP
.BI < word
Open file
.I word
as standard input.
.TP
.BI > word
Open file
.I word
as standard output.
If the file does not exist then it is created.
If the file exists, and the
.B NO_CLOBBER
option is set,
this causes an error;
otherwise, it is truncated to zero length.
.TP
.BI >! " word"
Same as
.BR > ,
except that the file is truncated to zero length
if it exists, even if
.B NO_CLOBBER
is set.
.TP
.BI >> word
Open file
.I word
as standard output.
If the file exists then output is appended to it.
If the file does not exist, and the
.B NO_CLOBBER
option is set,
this causes an error;
otherwise, the file is created.
.TP
.BI >>! " word"
Same as
.BR >> ,
except that the file is created if it does not
exist, even if
.B NO_CLOBBER
is set.
.TP
\fB<<\fP[\-] \fIword\fP
The shell input is read up to a line that is the same as
.IR word ,
or to an end-of-file.
No parameter substitution, command substitution or
filename generation is performed on
.IR word .
The resulting document,
called a
.IR here-document ,
becomes
the standard input.
If any character of \fIword\fP is quoted with
single or double quotes or a \e,
no interpretation
is placed upon the characters of the document.
Otherwise, parameter and command substitution
occurs, \e followed by a newline is removed,
and \e must be used to quote the characters
\e, $, `, and the first character of \fIword\fP.
If <<\- is used, then all leading
tabs are stripped from \fIword\fP and from the document.
.TP
.BI <<< word
Open a file containing \fIword\fP, after expansion,
as standard input.
.TP
.BI <& digit
The standard input
is duplicated from file descriptor
.I digit
(see
.IR dup (2)).
Similarly for standard output using
\fB>&\fIdigit\fP.
.TP
.BI >& word
Same as
.BI > word
\fB2>&\fP1.
.TP
.BI >>& word
Same as
.BI >> word
\fB2>&\fP1.
.TP
.BI <&\-
Close the standard input.
.TP
.BI >&\-
Close the standard output.
.TP
.BI <&p
The input from the coprocess is moved to the standard input.
.TP
.BI >&p
The output to the coprocess is moved to the standard output.
.PP
If one of the above is preceded by a digit, then the file
descriptor referred to is that specified by the digit
(instead of the default 0 or 1).
The order in which redirections are specified is significant.
The shell evaluates each redirection in terms of the
.RI ( "file descriptor" ", " file )
association at the time of evaluation.
For example:
.RS
.PP
\&.\|.\|. \|1>\fIfname\^\fP 2>&1
.RE
.PP
first associates file descriptor 1 with file
.IR fname .
It then associates file descriptor 2 with the file associated with file
descriptor 1 (that is,
.IR fname ).
If the order of redirections were reversed, file descriptor 2 would be associated
with the terminal (assuming file descriptor 1 had been) and then file descriptor
1 would be associated with file
.IR fname .
.PP
If the user tries to open a file descriptor for writing more than once,
the shell opens the file descriptor as a pipe to a process that copies
its input to all the specified outputs, similar to tee(1).  Thus:
.RS
.PP
.B date >foo >bar
.RE
.PP
writes the date to two files, named "foo" and "bar".
Note that a pipe is an implicit indirection; thus
.RS
.PP
.B date >foo | cat
.RE
.PP
writes the date to the file "foo", and also pipes it to cat.
.PP
If the user tries to open a file descriptor for reading more than once,
the shell opens the file descriptor as a pipe to a process that copies
all the specified inputs to its output in the order
specified, similar to cat(1).  Thus
.RS
.PP
.B sort <foo <fubar
.RE
.PP
or even
.RS
.PP
.B sort <f{oo,ubar}
.RE
.PP
is equivalent to "cat foo bar | sort".  Similarly, you can do
.RS
.PP
.B echo exit 0 >> *.sh
.RE
.PP
Note that a pipe is in implicit indirection; thus
.RS
.PP
.B cat bar | sort <foo
.RE
.PP
is equivalent to "cat bar foo | sort" (note the order of the inputs).
.PP
If a simple command consists of one or more redirection operators
and zero or more parameter assignments, but no command name,
the command \fBcat\fP is assumed.  Thus
.RS
.PP
.B < file
.RE
.PP
prints the contents of \fBfile\fP.
.PP
If a command is followed by
.B &
and job control is not active,
then the default standard input
for the command
is the empty file
.BR /dev/null .
Otherwise, the environment for the execution of a command contains the
file descriptors of the invoking shell as modified by
input/output specifications.
.SH "COMMAND EXECUTION"
If a command name contains no slashes, the shell attempts to locate
it.  If there exists a shell function by that name, the function
is invoked as described below in \fBFUNCTIONS\fP.  If there exists
a shell builtin by that name, the builtin is invoked.
.PP
Otherwise, the shell searches each element of \fBpath\fP for a
directory containing an executable file by that name.  If the
search is unsuccessful, the shell prints an error message and returns
a nonzero exit status.
.PP
If execution fails because the file is not in executable format,
and the file is not a directory, it is assumed to be a shell
script.  /bin/sh is spawned to execute it.  If the program
is a file beginning with \fB#!\fP, the remainder of the first line
specifies an interpreter for the program.  The shell will
execute the specified interpreter on operating systems that do
not handle this executable format in the kernel.
.SH FUNCTIONS
.PP
The
.B function
reserved word is used to define shell functions.
Shell functions are read in and stored internally.
Alias names are resolved when the function is read.
Functions are executed like commands with the arguments
passed as positional parameters.
(See
.I Execution
below).
.PP
Functions execute in the same process as the caller and
share all files
and present working directory with the
caller.
A trap on
.B EXIT
set inside a function
is executed after the function completes in the environment
of the caller.
.PP
The
.B return
builtin is used to return
from function calls.
.PP
Function identifiers
can be listed with the
.B functions
builtin.
Functions can be undefined with the
.B unfunction
builtin.
.PP
The following functions, if defined, have special meaning to
the shell:
.PP
.PD 0
.TP
\fBchpwd\fP
Executed whenever the current working directory is changed.
.TP
\fBprecmd\fP
Executed before each prompt.
.TP
\fBperiodic\fP
If the parameter
.B PERIOD
is set, this function is executed every
.B PERIOD
seconds, just before a prompt.
.TP
\fBTRAPxxx\fP
If defined and non-null,
this function will be executed whenever the shell
catches a signal \fBSIGxxx\fP, where \fBxxx\fP is a signal
name as specified for the \fBkill\fP builtin (see below).
The signal number will be passed as the first parameter to the function.
In addition, \fBTRAPZERR\fP is executed whenever a command has a non-zero
exit status, \fBTRAPDEBUG\fP is executed after each command, and
\fBTRAPEXIT\fP
is executed when the shell exits,
or when the current function exits if defined
inside a function.
If a function of this form is defined and null,
the shell and processes spawned by it will ignore \fBSIGxxx\fP.
.PD
.SH JOBS
.PP
If the
.B MONITOR
option is set,
an interactive shell associates a \fIjob\fR with each pipeline.
It keeps
a table of current jobs, printed by the
.B jobs
command, and assigns them small integer numbers.
When a job is started asynchronously with
.BR & ,
the shell prints a line which looks
like:
.PP
.DT
	[1] 1234
.PP
indicating that the job which was started asynchronously was job number
1 and had one (top-level) process, whose process id was 1234.
.PP
If you are running a job and wish to do something else you may hit the key
\fB^Z\fR (control-Z) which sends a TSTP signal to the current job.
The shell will then normally indicate that the job has been `suspended',
and print another prompt.
You can then manipulate the state of this job,
putting it in the background with the
.B bg
command, or run some other
commands and then eventually bring the job back into the foreground with
the foreground command
.BR fg .
A \fB^Z\fR takes effect immediately and
is like an interrupt in that pending output and unread input are discarded
when it is typed.
.PP
A job being run in the background will suspend if it tries to read
from the terminal.
Background jobs are normally allowed to produce output,
but this can be disabled by giving the command ``stty tostop''.
If you set this
tty option, then background jobs will suspend when they try to produce
output like they do when they try to read input.
.PP
There are several ways to refer to jobs in the shell.
A job can be referred to by the process id of any process of the job
or by one of the following:
.PD 0
.TP
.BI % number
The job with the given number.
.TP
.BI % string
Any job whose command line begins with
.IR string .
.TP
.BI %? string
Any job whose command line contains
.IR string .
.TP
.BI %%
Current job.
.TP
.BI %+
Equivalent to
.BR %% .
.TP
.BI %\-
Previous job.
.PD
.PP
The shell learns immediately whenever a process changes state.
It normally informs you whenever a job becomes blocked so that
no further progress is possible.  If
.B notify
is not set, it waits until
just before it prints
a prompt before it informs you.
.PP
When the monitor mode is on, each background job that completes
triggers any trap set for
.BR CHLD .
.PP
When you try to leave the shell while jobs are running or suspended, you will
be warned that `You have suspended (running) jobs.'
You may use the
.B jobs
command to see what they are.
If you do this or immediately try to
exit again, the shell will not warn you a second time; the suspended
jobs will be terminated, and the running jobs will be sent
a \fBSIGHUP\fP signal.
To avoid having the shell terminate the running jobs, either
use the \fBnohup\fP(1) command or the \fBdisown\fP builtin (see below).
.SH SIGNALS
The INT and QUIT signals for an invoked
command are ignored if the command is followed by
.B &
and the job
.B MONITOR
option is not active.
Otherwise, signals have the values
inherited by the shell from its parent
(but see the \fBTRAPxxx\fP special function above).
.SH HISTORY
History substitution allows you to use words from previous command
lines in the command line you are typing.  This simplifies spelling
corrections and the repetition of complicated commands or arguments.
Command lines are saved in the history list, the size of which
is controlled by the
.B HISTSIZE
variable.  The most recent command is retained in any case.
A history substitution begins with a
.B !
and may occur anywhere on the command line; history
substitutions do not nest.  The
.B !
can be escaped with
.B \e
to suppress its special meaning.
Single or double quotes will \fInot\fP work for this.
.PP
Input lines containing history substitutions are echoed on the
terminal after being expanded, but before any other
substitutions take place or the command gets executed.
.SS Event Designators
.PP
An event designator is a reference to a command-line entry in
the history list.
.RS
.PD 0
.TP
.B !
Start a history substitution, except when followed by a blank, newline,
.BR = ,
or
.BR ( .
.TP
.B !!
Refer to the previous command. 
By itself, this substitution
repeats the previous command.
.TP
.BI ! n
Refer to command-line
.IR n .
.TP
.BI ! \-n
Refer to the current command-line minus
.IR n .
.TP
.BI  ! str
Refer to the most recent command starting with
.IR str .
.TP
.BI  !? str\fR[\fP ? \fR]\fP
Refer to the most recent command containing
.IR str .
.TP
.B !#
Refer to the current command line typed in so far.
.TP
.BR !{ .\|.\|. }
Insulate a history reference from adjacent characters (if necessary).
.PD
.RE
.SS Word Designators
.PP
A word designator indicates which word or words of a given command line will
be included in a history reference.  A
.RB ` : '
separates the event specification from the word designator. 
It can be omitted if the word designator begins with a
.BR ^ ,
.BR $ ,
.BR * ,
.B \-
or
.BR % .
Word designators include:
.RS
.PD 0
.TP
.B 0
The first input word (command).
.TP
.I n
The
.IR n 'th
argument.
.TP
.B ^
The first argument, that is,
.BR 1 .
.TP
.B $
The last argument.
.TP
.B %
The word matched by (the most recent)
.BI ? str
search.
.TP
.IB x \- y
A range of words;
.BI \- y
abbreviates
.BI 0\- y\fR.
.TP
.B *
All the arguments, or a null value if there is just
one word in the event.
.TP
.IB x *
Abbreviates
.IB x \-$ .
.TP
.IB x \-
Like
.I x*
but omitting word
.BR $ .
.PD
.RE
Note that a
.RB ` % '
word designator will only work when used as
.B !%,
.B !:%,
.BI !? str ?:%
and only when used after a !? substitution.  Anything else will result
in an error, although the error may not be the most obvious one.
.PP
.SS Modifiers
.PP
After the optional word designator, you can add
a sequence of one or more of the following modifiers,
each preceded by a
.BR : .
These modifiers also work on the result
of filename and parameter expansion.
.RS
.TP
.B h
Remove a trailing pathname component, leaving the head.
.PD 0
.TP
.B r
Remove a trailing suffix of the form
.RB ` "\&.\fIxxx" ',
leaving the basename.
.TP
.B e
Remove all but the suffix.
.TP
.B t
Remove all leading pathname components, leaving the tail.
.TP
.B &
Repeat the previous substitution.
.TP
.B g
Apply the change to the first occurrence of a match in each word,
by prefixing the above (for example,
.BR g& ).
.TP
.B p
Print the new command but do not execute it.
.TP
.B q
Quote the substituted words, escaping further substitutions.
.TP
.B x
Like
.BR q ,
but break into words at each blank.
.TP
.B l
Convert the words to all lowercase.
.TP
.B u
Convert the words to all uppercase.
.TP
.B f
Repeats the immediately (without a colon) following modifier until the
resulting word doesn't change any more. This one and the following
four only work with parameter and filename expansion.
.TP
.B F:\fIexpr\fB:
Like \fBf\fP, but repeats only \fIn\fP times if the expression
\fIexpr\fP evaluates to \fIn\fP. Any character can be used instead of
the `:', if any of `(', `[', or `{' is used as the opening delimiter
the second one has to be ')', `]', or `}' respectively.
.TP
.B w
Makes the immediately following modifier work on each word in the
string.
.TP
.B W:\fIsep\fB:
Like \fBw\fP but words are considered to be the parts of the string
that are separated by \fIsep\fP. Any character can be used instead of
the `:', opening parentheses are handled specially, see above.
.TP
.BI s/ l / r\fR[\fP / \fR]\fP
Substitute
.I r
for
.IR l .
.PD
.RE
.PP
Unless preceded by a
.BR g ,
the substitution is done only for the
first string that matches
.IR l .
.PP
The left-hand side of substitutions are not regular expressions,
but character strings.
Any character can be used as the delimiter in place of
.BR / .
A backslash quotes the delimiter character.
The character
.BR & ,
in the right hand side, is replaced by the text
from the left-hand-side. 
The
.B &
can be quoted with a backslash. 
A null
.I l
uses the previous string either from a
.I l
or from a contextual scan string
.I s
from
.BI !? s\fR.
You can omit the rightmost delimiter if a newline
immediately follows
.IR r ;
the rightmost
.B ?
in a context scan can similarly be omitted.
.PP
By default, a history reference with no event specification refers to the same
line as the last history reference on that command line, unless it is the
first history reference in a command.  In that case, a history reference
with no event specification always refers to the previous command.  However,
if the option \fBCSH_JUNKIE_HISTORY\fP is set, then history reference with no
event specification will \fIalways\fP refer to the previous command.
For example,
.B !!:1
will always refer to the first word of the previous command and
.B !!$
will always refer to the last word of the previous command.  And with
\fBCSH_JUNKIE_HISTORY\fP set, then
.B !:1
and
.B !$
will function in the same manner as
.B !!:1
and
.B !!$,
respectively.  However, if \fBCSH_JUNKIE_HISTORY\fP is unset, then
.B !:1 
and
.B !$
will refer to the first and last words respectively, of the last command
referenced on the current command line.  However, if they are the first history
reference on the command line, then they refer to the previous command.
.PP
The character sequence
.BI ^ foo ^ bar
repeats the last command, replacing the string "foo" with the
string "bar".
.PP
If the shell encounters the character sequence
\fB!"\fP
in the input, the history mechanism is temporarily disabled until
the current list is fully parsed.  The
\fB!"\fP
is removed from the input, and any subsequent
.B !
characters have no special significance.
.PP
A less convenient but more comprehensible
form of command history support
is provided by the
.B fc
builtin (see below).
.SH "ARITHMETIC EVALUATION"
An ability to perform integer arithmetic
is provided with the builtin
.BR let .
Evaluations are performed using
.I long
arithmetic.
Constants are of the form
[\fIbase\fB#\^\fR]\fIn\^\fP
where
.I base
is a decimal number between two and thirty-six
representing the arithmetic base
and
.I n
is a number in that base (for example, `16#ff' is 255 in hexadecimal).
If
.I base
is omitted
then base 10 is used.  For backwards compatibility the form `[16]ff'
is also accepted.
.PP
An arithmetic expression uses nearly the same syntax, precedence, and
associativity of
expressions in C.
The following operators are supported (listed in decreasing order
of precedence):
.PP
.PD 0
.RS
.TP
.B + \- ! \(ap ++ \-\|\-
unary plus/minus, logical NOT, complement, {pre,post}{in,de}crement
.TP
.B &
logical AND
.TP
.B ^
logical XOR
.TP
.B |
logical OR
.TP
.B * / % **
multiplication, division, remainder, exponentiation
.TP
.B + \-
addition, subtraction
.TP
.B << >>
logical shift left, shift right
.TP
.B < > <= >=
comparison
.TP
.B == !=
equality and inequality
.TP
.B &&
boolean AND
.TP
.B |\|| ^^
boolean OR, XOR
.TP
.B ? :
ternary operator
.TP
.B
= += \-= *= /= %= &= ^= |= <<= >>= &&= |\||= ^^= **=
assignment
.TP
.B ,
comma operator
.PD
.RE
.PP
The operators &&, |\||, &&=, and |\||= are short-circuiting,
and only one of the latter two expressions in a ternary operator
is evaluated.  Note the precedence of the logical AND, OR,
and XOR operators.
.PP
An expression of the form \fB#\\x\fP where \fBx\fP is any character
gives the ascii value of this character and an expression of the form
\fB#foo\fP gives the ascii value of the first character of the value
of the parameter \fBfoo\fP.
.PP
Named parameters can be referenced by name within an arithmetic expression
without using the parameter substitution syntax, but if it is an array
with a subscript the leading \fB$\fP is needed.
.PP
An internal integer representation of a named parameter
can be specified with the
.B integer
builtin.
Arithmetic evaluation is performed on the value of each
assignment to a named parameter declared integer
in this manner.
.PP
Since many of the arithmetic operators require
quoting, an alternative form of the
.B let
command is provided.
For any command which begins with a
.BR (( ,
all the characters until a matching
.B ))
are treated as a quoted expression.
More precisely,
.BR (( ... ))
is equivalent to
.B let
\fB"\fP...\fB"\fP.
.SH "CONDITIONAL EXPRESSIONS"
A \fIconditional expression\fP is used with the
.B [[
compound command to test attributes of files and to compare strings.
Each expression can be constructed from one or more
of the following unary or binary expressions:
.PD 0
.TP
\fB\-a\fP \fIfile\fP
true if
.I file
exists.
.TP
\fB\-b\fP \fIfile\fP
true if
.I file
exists and is a block special file.
.TP
\fB\-c\fP \fIfile\fP
true if
.I file
exists and is a character special file.
.TP
\fB\-d\fP \fIfile\fP
true if
.I file
exists and is a directory.
.TP
\fB\-e\fP \fIfile\fP
true if
.I file
exists.
.TP
\fB\-f\fP \fIfile\fP
true if
.I file
exists and is an ordinary file.
.TP
\fB\-g\fP \fIfile\fP
true if
.I file
exists and has its setgid bit set.
.TP
\fB\-h\fP \fIfile\fP
true if
.I file
exists and is a symbolic link.
.TP
\fB\-k\fP \fIfile\fP
true if
.I file
exists and has its sticky bit set.
.TP
\fB\-n\fP \fIstring\fP
true if length of
.I string
is non-zero.
.TP
\fB\-o\fP \fIoption\fP
true if option named
.I option
is on.
.TP
\fB\-p\fP \fIfile\fP
true if
.I file
exists and is a fifo special file or a pipe.
.TP
\fB\-r\fP \fIfile\fP
true if
.I file
exists and is readable by current process.
.TP
\fB\-s\fP \fIfile\fP
true if
.I file
exists and has size greater than zero.
.TP
\fB\-t\fP \fIfd\fP
true if file descriptor number
.I fd
is open and associated with a terminal device.
(note: \fIfd\fP is not optional)
.TP
\fB\-u\fP \fIfile\fP
true if
.I file
exists and has its setuid bit set.
.TP
\fB\-w\fP \fIfile\fP
true if
.I file
exists and is writable by current process.
.TP
\fB\-x\fP \fIfile\fP
true if
.I file
exists and is executable by current process.
If
.I file
exists and is a directory, then the current process
has permission to search in the directory.
.TP
\fB\-z\fP \fIstring\fP
true if length of
.I string
is zero.
.TP
\fB\-L\fP \fIfile\fP
true if
.I file
exists and is a symbolic link.
.TP
\fB\-O\fP \fIfile\fP
true if
.I file
exists and is owned by the effective user id of this process.
.TP
\fB\-G\fP \fIfile\fP
true if
.I file
exists and its group matches the effective group id of this process.
.TP
\fB\-S\fP \fIfile\fP
true if
.I file
exists and is a socket.
.TP
\fIfile1\fP \fB\-nt\fP \fIfile2\fP
true if
.I file1
exists and is newer than
.IR file2 .
.TP
\fIfile1\fP \fB\-ot\fP \fIfile2\fP
true if
.I file1
exists and is older than
.IR file2 .
.TP
\fIfile1\fP \fB\-ef\fP \fIfile2\fP
true if
.I file1
and 
.I file2
exist and refer to the same file.
.TP
\fIstring\fP \fB=\fP \fIpattern\fP
true if
.I string
matches
.IR pattern .
.TP
\fIstring\fP \fB!=\fP \fIpattern\fP
true if
.I string
does not match
.IR pattern .
.TP
\fIstring1\fP \fB<\fP \fIstring2\fP
true if
.I string1
comes before
.I string2
based on ASCII value of their characters.
.TP
\fIstring1\fP \fB>\fP \fIstring2\fP
true if
.I string1
comes after
.I string2
based on ASCII value of their characters.
.TP
\fIexp1\fP \fB\-eq\fP \fIexp2\fP
true if
.I exp1
is equal to
.IR exp2.
.TP
\fIexp1\fP \fB\-ne\fP \fIexp2\fP
true if
.I exp1
is not equal to
.IR exp2.
.TP
\fIexp1\fP \fB\-lt\fP \fIexp2\fP
true if
.I exp1
is less than
.IR exp2.
.TP
\fIexp1\fP \fB\-gt\fP \fIexp2\fP
true if
.I exp1
is greater than
.IR exp2.
.TP
\fIexp1\fP \fB\-le\fP \fIexp2\fP
true if
.I exp1
is less than or equal to
.IR exp2.
.TP
\fIexp1\fP \fB\-ge\fP \fIexp2\fP
true if
.I exp1
is greater than or equal to
.IR exp2.
.TP
\fB(\fP \fIexp\fP \fB)\fP
true if \fIexp\fP is true.
.TP
\fB!\fP \fIexp\fP
true if \fIexp\fP is false.
.TP
\fIexp1\fP \fB&&\fP \fIexp2\fP
true if \fIexp1\fP and \fIexp2\fP are both true.
.TP
\fIexp1\fP \fB|\||\fP \fIexp2\fP
true if either \fIexp1\fP or \fIexp2\fP is true.
.PD
.PP
In each of the above expressions, if
.I file
is of the form
\fB/dev/fd/\fP\fIn\fR,
where
.I n
is an integer,
then the test applied to the open file whose
descriptor number is
.IR n ,
even if the underlying system does not support
the \fB/dev/fd\fP directory.
.PD
.SH "ZSH LINE EDITOR"
If the \fBZLE\fP option is set (it is by default)
and the shell input is attached to the terminal, the user
is allowed to edit command lines.
.PP
There are two display modes.  The first, multiline mode, is the
default.  It only works if the \fBTERM\fP parameter is set to a valid
terminal type that can move the cursor up.  The second, single line
mode, is used if \fBTERM\fP is invalid or incapable of moving the
cursor up, or if the \fBSINGLE_LINE_ZLE\fP option is set.  This mode
is similar to ksh, and uses no termcap sequences.  If \fBTERM\fP is
"emacs", the \fBZLE\fP option will be unset by the shell.
.SS Bindings
Command bindings may be set using the \fBbindkey\fP builtin.
There are two keymaps\-the main keymap and the alternate keymap.
The alternate keymap is bound to vi command mode.
The main keymap is bound to emacs mode by default.
To bind the main keymap to vi insert mode, use 
\fBbindkey \-v\fP. However, if one of the \fBVISUAL\fP or
\fBEDITOR\fP environment variables contain the string \fBvi\fP when the shell
starts up the main keymap will be bound to vi insert mode by default.
.PP
The following is a list of all the key commands
and their default bindings in emacs and vi command mode.
.SS Movement
.TP
\fBvi-backward-blank-word\fP (unbound) (B)
Move backward one word, where a word is defined as a series of
non-blank characters.
.TP
\fBbackward-char\fP (^B ESC-[D) (\|)
Move backward one character.
.TP
\fBvi-backward-char\fP (\|) (h)
Move backward one character, without changing lines.
.TP
\fBbackward-word\fP (ESC-B ESC-b) (unbound)
Move to the beginning of the previous word.
.TP
\fBemacs-backward-word\fP
Move to the beginning of the previous word.
.TP
\fBvi-backward-word\fP (unbound) (b)
Move to the beginning of the previous word, vi-style.
.TP
\fBbeginning-of-line\fP (^A) (0)
Move to the beginning of the line.  If already at the beginning
of the line, move to the beginning of the previous line, if any.
.TP
\fBvi-beginning-of-line\fP
Move to the beginning of the line, without changing lines.
.TP
\fBend-of-line\fP (^E)
Move to the end of the line.  If already at the end 
of the line, move to the end of the next line, if any.
.TP
\fBvi-end-of-line\fP (unbound) ($)
Move to the end of the line.
.TP
\fBvi-forward-blank-word\fP (unbound) (W)
Move forward one word, where a word is defined as a series of
non-blank characters.
.TP
\fBvi-forward-blank-word-end\fP (unbound) (E)
Move to the end of the current word,
or, if at the end of the current word,
to the end of the next word,
where a word is defined as a series of
non-blank characters.
.TP
\fBforward-char\fP (^F ESC-[C)
Move forward one character.
.TP
\fBvi-forward-char\fP (unbound) (space l)
Move forward one character.
.TP
\fBvi-find-next-char\fP (^X^F) (f)
Read a character from the keyboard, and move to
the next occurrence of it in the line.
.TP
\fBvi-find-next-char-skip\fP (unbound) (t)
Read a character from the keyboard, and move to
the position just before the next occurrence of it in the line.
.TP
\fBvi-find-prev-char\fP (unbound) (F)
Read a character from the keyboard, and move to
the previous occurrence of it in the line.
.TP
\fBvi-find-prev-char-skip\fP (unbound) (T)
Read a character from the keyboard, and move to
the position just after the previous occurrence of it in the line.
.TP
\fBvi-first-non-blank\fP (unbound) (^)
Move to the first non-blank character in the line.
.TP
\fBvi-forward-word\fP (unbound) (w)
Move forward one word, vi-style.
.TP
\fBforward-word\fP (ESC-F ESC-f) (unbound)
Move to the beginning of the next word.
The editor's idea of a word is specified with the \fBWORDCHARS\fP
parameter.
.TP
\fBemacs-forward-word\fP
Move to the end of the next word.
.TP
\fBvi-forward-word-end\fP (unbound) (e)
Move to the end of the next word.
.TP
\fBvi-goto-column\fP (ESC-|) (|)
Move to the column specified by the numeric argument.
.TP
\fBvi-goto-mark\fP (unbound) (`)
Move to the specified mark.
.TP
\fBvi-goto-mark-line\fP (unbound) (')
Move to beginning of the line containing the specified mark.
.TP
\fBvi-repeat-find\fP (unbound) (;)
Repeat the last \fBvi-find\fP command.
.TP
\fBvi-rev-repeat-find\fP (unbound) (,)
Repeat the last \fBvi-find\fP command in the opposite direction.
.SS History
.TP
\fBbeginning-of-buffer-or-history\fP (ESC-<)
Move to the beginning of the buffer, or if already there,
move to the first event in the history list.
.TP
\fBbeginning-of-line-hist\fP
Move to the beginning of the line.  If already at the
beginning of the buffer, move to the previous history line.
.TP
\fBbeginning-of-history\fP
Move to the first event in the history list.
.TP
\fBdown-line-or-history\fP (^N ESC-[B) (+ j)
Move down a line in the buffer, or if already at the bottom line,
move to the next event in the history list.
.TP
\fBdown-line-or-search\fP
Move down a line in the buffer, or if already at the bottom line,
search forward in the history for a line beginning with the first
word in the buffer.
.TP
\fBdown-history\fP (unbound) (^N)
Move to the next event in the history list.
.TP
\fBhistory-beginning-search-backward\fP (unbound)
Search backward in the history for a line beginning with the current
line up to the cursor.
This leaves the cursor in its original position.
.TP
\fBend-of-buffer-or-history\fP (ESC->)
Move to the end of the buffer, or if already there,
move to the last event in the history list.
.TP
\fBend-of-line-hist\fP
Move to the end of the line.  If already at the end of
the buffer, move to the next history line.
.TP
\fBend-of-history\fP
Move to the last event in the history list.
.TP
\fBvi-fetch-history\fP (unbound) (G)
Fetch the history line specified by the numeric argument.
.TP
\fBhistory-incremental-search-backward\fP (^R ^Xr)
Search backward incrementally for a specified string.
The string may begin with `^' to anchor the search to the
beginning of the line. A restricted set of editing functions is available in
the mini-buffer. An interrupt signal, as defined by the stty setting,  will
stop the search and go back to the original line. An undefined key will have
the same effect. The supported functions are: backward-delete-char,
quoted-insert, accept-and-hold, accept-and-infer-next-history, accept-line and
accept-line-and-down-history; magic-space just inserts a space. Any string
that is bound to an out-string (via bindkey -s) will behave as if out-string
were typed directly.
Typing the binding of \fBhistory-incremental-search-backward\fP will get the
next occurrence of the contents of the mini-buffer. Typing the binding of
\fBhistory-incremental-search-forward\fP inverts the sense of the search. The
direction of the search is indicated in the mini-buffer. Any multi-character
string 
that is not bound to one of the above functions will beep and interrupt the
search, leaving the last found line in the buffer. Any single character that
is not bound to one of the above functions, or self-insert or
self-insert-unmeta, will have the same effect but the function will be
executed.
.TP
\fBhistory-incremental-search-forward\fP (^Xs)
Search forward incrementally for a specified string.
The string may begin with `^' to anchor the search to the
beginning of the line. The functions available in the mini-buffer are the same
as for \fBhistory-incremental-search-backward\fP.
.TP
\fBhistory-search-backward\fP (ESC-P ESC-p) (K)
Search backward in the history for a line beginning with the first
word in the buffer.
.TP
\fBvi-history-search-backward\fP (unbound) (/)
Search backward in the history for a specified string.
The string may begin with `^' to anchor the search to the
beginning of the line. A restricted set of editing functions is available in
the mini-buffer. An interrupt signal, as defined by the stty setting,  will
stop the search, as will a character bound to vi-cmd-mode. The functions
available in the mini-buffer are: accept-line, backward-delete-char,
vi-backward-delete-char and quoted-insert. Any string
that is bound to an out-string (via bindkey -s) will behave as if out-string
were typed directly. Any other character that is not bound to self-insert or
self-insert-unmeta will beep and be ignored. If the function is called from vi
command mode, the bindings of vi insert mode will be used.
.TP
\fBhistory-search-forward\fP (ESC-N ESC-n) (J)
Search forward in the history for a line beginning with the first
word in the buffer.
.TP
\fBvi-history-search-forward\fP (unbound) (?)
Search forward in the history for a specified string.
The string may begin with `^' to anchor the search to the
beginning of the line. The functions available in the mini-buffer are the same
as for \fBvi-history-search-backward\fP.
.TP
\fBinfer-next-history\fP (^X^N)
Search in the history list for a line matching the current one and
fetch the event following it.
.TP
\fBinsert-last-word\fP (ESC-_ ESC-.)
Insert the last word from the previous history event at the
cursor position.
.TP
\fBvi-repeat-search\fP (unbound) (n)
Repeat the last vi history search.
.TP
\fBvi-rev-repeat-search\fP (unbound) (N)
Repeat the last vi history search, but in reverse.
.TP
\fBtoggle-literal-history\fP (ESC-R ESC-r)
Toggle between literal and lexical history.  The default is
lexical history unless the \fBHISTLIT\fP option is set.
.TP
\fBup-line-or-history\fP (^P ESC-[A) (- k)
Move up a line in the buffer, or if already at the top line,
move to the previous event in the history list.
.TP
\fBup-line-or-search\fP
Move up a line in the buffer, or if already at the top line,
search backward in the history for a line beginning with the
first word in the buffer.
.TP
\fBup-history\fP (unbound) (^P)
Move to the previous event in the history list.
.TP
\fBhistory-beginning-search-forward\fP (unbound)
Search forward in the history for a line beginning with the current
line up to the cursor.
This leaves the cursor in its original position.
.SS Modifying Text
.TP
\fBvi-add-eol\fP (unbound) (A)
Move to the end of the line and enter insert mode.
.TP
\fBvi-add-next\fP (unbound) (a)
Move forward one character and enter insert mode.
.TP
\fBbackward-delete-char\fP (^H ^?) (^?)
Delete the character behind the cursor.
.TP
\fBvi-backward-delete-char\fP (unbound) (X)
Delete the character behind the cursor, without changing lines.
.TP
\fBbackward-delete-word\fP
Delete the word behind the cursor.
.TP
\fBbackward-kill-line\fP
Kill from the beginning of the line to the cursor position.
.TP
\fBbackward-kill-word\fP (^W ESC-^H ESC-^?)
Kill the word behind the cursor.
.TP
\fBvi-backward-kill-word\fP (unbound) (^W)
Kill the word behind the cursor.
.TP
\fBcapitalize-word\fP (ESC-C ESC-c)
Capitalize the current word and move past it.
.TP
\fBvi-change\fP (unbound) (c)
Read a movement command from the keyboard, and kill
from the cursor position to the endpoint of the movement.
Then enter insert mode.
If the command is \fBvi-change\fP, kill the current line.
.TP
\fBvi-change-eol\fP (unbound) (C)
Kill to the end of the line and enter insert mode.
.TP
\fBvi-change-whole-line\fP (unbound) (S s)
Kill the current line and enter insert mode.
.TP
\fBcopy-region-as-kill\fP (ESC-W ESC-w)
Copy the area from the cursor to the mark to the kill buffer.
.TP
\fBcopy-prev-word\fP (ESC-^_)
Duplicate the word behind the cursor.
.TP
\fBvi-delete\fP (unbound) (d)
Read a movement command from the keyboard, and kill 
from the cursor position to the endpoint of the movement.
If the command is \fBvi-delete\fP, kill the current line.
.TP
\fBdelete-char\fP (unbound) (x)
Delete the character under the cursor.
.TP
\fBvi-delete-char\fP (unbound) (x)
Delete the character under the cursor.
.TP
\fBdelete-word\fP (ESC-D ESC-d)
Delete the current word.
.TP
\fBdown-case-word\fP (ESC-L ESC-l)
Convert the current word to all lowercase and move past it.
.TP
\fBkill-word\fP
Kill the current word.
.TP
\fBgosmacs-transpose-chars\fP
Exchange the two characters behind the cursor.
.TP
\fBvi-indent\fP (unbound) (>)
Indent a number of lines.
.TP
\fBvi-insert\fP (unbound) (i)
Enter insert mode.
.TP
\fBvi-insert-bol\fP (unbound) (I)
Move to the beginning of the line and enter insert mode.\fP
.TP
\fBvi-join\fP (^X^J)
Join the current line with the next one.
.TP
\fBkill-line\fP (^K) (D)
Kill from the cursor to the end of the line.
.TP
\fBvi-kill-line
Kill from the cursor to the beginning of the line.
.TP
\fBkill-region\fP
Kill from the cursor to the mark.
.TP
\fBkill-buffer\fP (^X^K) (^U)
Kill the entire buffer.
.TP
\fBkill-whole-line\fP (^U) (unbound)
Kill the current line.
.TP
\fBvi-match-bracket\fP (^X^B) (%)
Move to the bracket character (one of {\|}, (\|), or [\|]) that
matches the one under the cursor.
.TP
\fBvi-open-line-above\fP (unbound) (O)
Open a line above the cursor and enter insert mode.
.TP
\fBvi-open-line-below\fP (unbound) (o)
Open a line below the cursor and enter insert mode.
.TP
\fBvi-oper-swap-case\fP
Read a movement command from the keyboard, and swap
the case of all characters
from the cursor position to the endpoint of the movement.
If the movement command is \fBvi-oper-swap-case\fP,
swap the case of all characters on the current line.
.TP
\fBoverwrite-mode\fP (^X^O)
Toggle between overwrite mode and insert mode.
.TP
\fBvi-put-after\fP (unbound) (p)
Insert the contents of the kill buffer after the cursor.
.TP
\fBquoted-insert\fP (^V)
Insert the next character typed into the buffer literally.
.TP
\fBquote-line\fP (ESC-')
Quote the current line; that is, put a ' character at the
beginning and the end, and convert all ' characters
to '\e''.
.TP
\fBquote-region\fP (ESC-")
Quote the region from the cursor to the mark.
.TP
\fBvi-replace\fP (unbound) (R)
Enter overwrite mode.
.TP
\fBvi-repeat-change\fP (unbound) (.)
Repeat the last vi mode text modification.
.TP
\fBvi-replace-chars\fP (unbound) (r)
Replace the character under the cursor with a character
read from the keyboard.
.TP
\fBself-insert\fP (printable characters)
Put a character in the buffer at the cursor position.
.TP
\fBself-insert-unmeta\fP (ESC-^I ESC-^J ESC-^M)
Put a character in the buffer after stripping the meta bit
and converting \fB^M\fP to \fB^J\fP.
.TP
\fBvi-substitute\fP (unbound) (s)
Substitute the next character(s).
.TP
\fBvi-swap-case\fP (unbound) (~)
Swap the case of the character under the cursor and move past it.
.TP
\fBtranspose-chars\fP (^T)
Exchange the two characters to the left of the
cursor if at end of line, else exchange the
character under the cursor with the character
to the left.
.TP
\fBtranspose-words\fP (ESC-T ESC-t)
Exchange the current word with the one before it.
.TP
\fBvi-unindent\fP (unbound) (<)
Unindent a number of lines.
.TP
\fBup-case-word\fP (ESC-U ESC-u)
Convert the current word to all caps and move past it.
.TP
\fByank\fP (^Y) (P)
Insert the contents of the kill buffer at the cursor position.
.TP
\fByank-pop\fP (ESC-y) (unbound)
Remove the text just yanked, rotate the kill\-ring,
and yank the new top.  Only works following
\fByank\fP or \fByank-pop\fP.
.TP
\fBvi-yank\fP (unbound) (y)
Read a movement command from the keyboard, and copy the region
from the cursor position to the endpoint of the movement
into the kill buffer.
If the command is \fBvi-yank\fP, copy the current line.
.TP
\fBvi-yank-eol\fP (unbound) (Y)
Copy the region from the cursor position to the end of the line
into the kill buffer.
.SS Arguments
.TP
\fBdigit-argument\fP (ESC-0..ESC-9) (0-9)
Start a new numeric argument, or add to the current one.
.TP
\fBneg-argument\fP (ESC-- unbound)
Changes the sign of the following argument.
.TP
\fBuniversal-argument\fP
Multiply the argument of the next command by 4.
.SS Completion
.TP
\fBaccept-and-menu-complete\fP
In a menu completion, insert the current completion into the buffer,
and advance to the next possible completion.
.TP
\fBcomplete-word\fP (unbound) (\|\e\|)
Attempt completion on the current word.
.TP
\fBdelete-char-or-list\fP (^D)
Delete the character under the cursor.  If the cursor
is at the end of the line, list possible completions for the
current word.
.TP
\fBexecute-named-cmd\fP (ESC-x) Read the name of a editor command and
execute it. A restricted set of editing functions is available in the
mini-buffer. An interrupt signal, as defined by the stty setting, will
abort the function. The allowed functions are: backward-delete-char,
vi-backward-delete-char, kill-region (kills the last word),
backward-kill-word, vi-backward-kill-word, kill-whole-line,
vi-kill-line, backward-kill-line, list-choices, delete-char-or-list
and accept-line. The space and tab characters, if not bound to one of
these functions, will complete the name and then list the
possibilities if the autolist option is set.
.TP
\fBexecute-last-named-cmd\fP (ESC-z)
Redo the last function executed with \fBexecute-named-cmd\fP.
.TP
\fBexpand-cmd-path\fP
Expand the current command to its full pathname.
.TP
\fBexpand-or-complete\fP (TAB) (TAB ^X)
Attempt shell expansion on the current word.
If that fails,
attempt completion.
.TP
\fBexpand-or-complete-prefix\fP (unbound)
Attempt shell expansion on the current word upto cursor.
.TP
\fBexpand-history\fP (ESC-space ESC-!)
Perform history expansion on the edit buffer.
.TP
\fBexpand-word\fP (^X*)
Attempt shell expansion on the current word.
.TP
\fBlist-choices\fP (ESC-^D) (^D =)
List possible completions for the current word.
.TP
\fBlist-expand\fP (^Xg ^XG) (^G)
List the expansion of the current word.
.TP
\fBmagic-space\fP
Perform history expansion and insert a space into the
buffer.  This is intended to be bound to space.
.TP
\fBmenu-complete\fP
Like \fBcomplete-word\fP, except that menu completion is used.
See the \fBMENU_COMPLETE\fP option below.
.TP
\fBmenu-expand-or-complete\fP
Like \fBexpand-or-complete\fP, except that menu completion is used.
.TP
\fBreverse-menu-complete\fP
See the \fBMENU_COMPLETE\fP option below.
.SS Miscellaneous
.TP
\fBaccept-and-hold\fP (ESC-A ESC-a)
Push the contents of the buffer on the buffer stack
and execute it.
.TP
\fBaccept-and-infer-next-history\fP
Execute the contents of the buffer.
Then search the history list for a line matching the current one
and push the event following onto the buffer stack.
.TP
\fBaccept-line\fP (^J ^M)
Execute the contents of the buffer.
.TP
\fBaccept-line-and-down-history\fP (^O)
Execute the current line, and push the next history
event on the the buffer stack.
.TP
\fBvi-cmd-mode\fP (^X^V) (^[)
Enter command mode; that is, use the alternate keymap.
Yes, this is bound by default in emacs mode.
.TP
\fBvi-caps-lock-panic\fP (unbound) (H K)
Hang until any lowercase key is pressed.
This is for vi users without the mental capacity to keep
track of their caps lock key (like the author).
.TP
\fBclear-screen\fP (^L ESC-^L)
Clear the screen and redraw the prompt.
.TP
\fBexchange-point-and-mark\fP (^X^X)
Exchange the cursor position with the position of the mark.
.TP
\fBget-line\fP (ESC-G ESC-g)
Pop the top line off the buffer stack and insert it at the
cursor position.
.TP
\fBpound-insert\fP (unbound) (#)
If there is no # character at the beginning of the current line,
add one.  If there is one, remove it.  In either case, accept the
current line.  The \fBINTERACTIVE_COMMENTS\fP option must be set
for this to have any usefulness.
.TP
\fBpush-input\fP
Push the entire current multiline construct onto the buffer stack and
return to the top-level (\fBPS1\fP) prompt.
If the current parser construct is only a single line, this is exactly
like \fBpush-line\fP.
Next time the editor starts up or is popped with \fBget-line\fP, the
construct will be popped off the top of the buffer stack and loaded
into the editing buffer.
.TP
\fBpush-line\fP (^Q ESC-Q ESC-q)
Push the current buffer onto the buffer stack and clear
the buffer.
Next time the editor starts up, the buffer will be popped
off the top of the buffer stack and loaded into the editing
buffer.
.TP
\fBpush-line-or-edit\fP
At the top-level (\fBPS1\fP) prompt, equivalent to \fBpush-line\fP.
At a secondary (\fBPS2\fP) prompt, move the entire current multiline
construct into the editor buffer.
The latter is equivalent to \fBpush-input\fP followed by \fBget-line\fP.
.TP
\fBredisplay\fP (unbound) (^R)
Redisplays the edit buffer.
.TP
\fBsend-break\fP (^G)
Abort the current editor function, eg. \fBexecute-named-command\fP, or the
editor itself, eg. if you are in \fBvared\fP. Otherwise abort the parsing of
the current line.
.TP
\fBrun-help\fP (ESC-H ESC-h)
Push the buffer onto the buffer stack, and execute the
command "\fBrun-help\fP \fIcmd\fP", where \fIcmd\fP is the current
command.  \fBrun-help\fP is normally aliased to \fBman\fP.
.TP
\fBvi-set-buffer\fP (unbound) (")
Specify a buffer to be used in the following command.
.TP
\fBvi-set-mark\fP (unbound) (m)
Set the specified mark at the cursor position.
.TP
\fBset-mark-command\fP (^@)
Set the mark at the cursor position.
.TP
\fBspell-word\fP (ESC-$ ESC-S ESC-s)
Attempt spelling correction on the current word.
.TP
\fBundefined-key\fP
Beep.
.TP
\fBundo\fP (^_ ^Xu ^X^U) (u)
Incrementally undo the last text modification.
.TP
\fBwhich-command\fP (ESC-?)
Push the buffer onto the buffer stack, and execute the
command "\fBwhich-command\fP \fIcmd\fP", where \fIcmd\fP is the current
command.  \fBwhich-command\fP is normally aliased to \fBwhence\fP.
.SH PARAMETERS
A parameter has a name, a value, and a number of attributes.
A name may be any sequence of alphanumeric
characters and _'s, or the single characters
*, @, #, ?, \-, $, or !.
The value may be either a \fIscalar\fP (a string),
an integer, or an array.
To assign a scalar or integer value to a parameter,
use the \fBtypeset\fP builtin.
To assign an array value, use \fBset \-A\fP \fIname\fP \fIvalue\fP ....
The value of a parameter may also be assigned by writing:
.RS
.PP
\fIname\fP=\fIvalue\fP ...
.RE
.PP
If the integer attribute, \-\fBi\fP, is set for \fIname\fP,
the \fIvalue\fP is subject to arithmetic evaluation.
.PP
The value of an array parameter may be assigned by writing:
.RS
.PP
\fIname\fP=(\fIvalue\fP ...) ...
.RE
Individual elements of an array may be selected using a 
subscript.  A subscript of the form \fB[\fIexp\fB]\fR
selects the single element \fIexp\fP, where \fIexp\fP is
an arithmetic expression which will be subject to arithmetic
expansion as if it were surrounded by "$[...]".  
The elements are numbered beginning with 1.
A subscript of the form \fB[*]\fP or \fB[@]\fP evaluates to all
elements of an array; there is no difference between the two
except when they appear within double quotes.
"$foo[*]" evaluates to "$foo[1] $foo[2] ...", while
"$foo[@]" evaluates to "$foo[1]" "$foo[2]", etc.
A subscript of the form \fB[\fIexp1\fP,\fIexp2\fB]\fR
selects all elements in the range \fIexp1\fP to \fIexp2\fP,
inclusive.
If one of the subscripts evaluates to a negative number,
say \-\fIn\fP, then the \fIn\fPth element from the end
of the array is used.  Thus "$foo[-3]" is the third element
from the end of the array \fIfoo\fP, and
"$foo[1,-1]" is the same as "$foo[*]".
.PP
Subscripting may also be performed on non-array values, in which
case the subscripts specify a substring to be extracted.
For example, if \fBFOO\fP is set to \fBfoobar\fP, then
\fBecho $FOO[2,5]\fP prints \fBooba\fP.
.PP
If a subscript is used on the left side of an assignment the selected
range is replaced by the expression on the right side.
.PP
If the opening bracket or the comma is directly followed by an opening
parentheses the string up to the matching closing one is considered to
be a list of flags. The flags currently understood are:
.PP
.RS
.PD
.TP
.B e
the argument is expanded using full shell expansion first
.TP
.B w
if the parameter subscripted is a scalar than this flag makes
subscription work on a per-word basis instead of characters
.TP
.B s:\fIstring\fB:
this gives the \fIstring\fP that separates words (for use with the
\fBw\fP flag)
.TP
.B r
if this flag is given the \fIexp\fP is taken as a pattern and the
result is the first matching array element, substring or word (if the
parameter is an array, if it is a scalar, or if it is a scalar and the
\fBw\fP flag is given, respectively); note that this is like giving a
number: \fB$foo[(r)??,3]\fP and \fB$foo[(r)??,(r)f*]\fP work
.TP
.B R
like \fBr\fP, but gives the last match
.TP
.B i
like \fBr\fP, but gives the index of the match instead; this may not
be combined with a second argument
.TP
.B I
like \fBi\fP, but gives the index of the last match
.TP
.B n:\fIexpr\fB:
if combined with \fBr\fP, \fBR\fP, \fI\fP, or \fBI\fP, makes them give
the \fIn\fP'th or \fIn\fP'th last match (if \fIexpr\fP evaluates to
\fIn\fP)
.PD
.RE
.SS Positional Parameters
Positional parameters are set by the shell on invocation,
by the \fBset\fP builtin, or by direct assignment.
The parameter \fIn\fP, where \fIn\fP is a number,
is the \fIn\fPth positional parameter.
The parameters \fB*\fP, \fB@\fP, and \fBargv\fP are
arrays containing all the positional parameters;
thus \fBargv\fP[\fIn\fP], etc. is equivalent to simply \fIn\fP.
.PP
.SS Special Parameters
The following parameters are automatically set by the shell:
.PP
.RS
.PD 0
.TP
.B !
The process id of the last background command invoked.
.TP
.B #
The number of positional parameters in decimal.
.TP
.B ARGC
Same as \fB#\fP.
.TP
.B $
The process id of this shell.
.TP
.B \-
Flags supplied to the shell on invocation or by the \fBset\fP
or \fBsetopt\fP commands.
.TP
.B *
An array containing the positional parameters.
.TP
.B argv
Same as \fB*\fP.
.TP
.B @
Same as \fBargv[@]\fP.
.TP
.B ?
The exit value returned by the last command.
.TP
.B status
Same as \fB?\fP.
.TP
.B _
The last argument of the previous command.
Also, this parameter is set in the environment of every command
executed to the full pathname of the command.
.TP
.B EGID
The effective group id of the shell process.
.TP
.B EUID
The effective user id of the shell process.
.TP
.B ERRNO
The value of errno as set by the most recently failed system call.
This value is system dependent and is intended for debugging
purposes.
.TP
.B GID
The group id of the shell process.
.TP
.B HOST
The current hostname.
.TP
.B HOSTTYPE
A string corresponding to the type of the host the shell
is running on.
.TP
.B LINENO
The line number of the current line within the current script
being executed.
.TP
.B OLDPWD
The previous working directory.
.TP
.B OPTARG
The value of the last option argument processed by the \fBgetopts\fP
command.
.TP
.B OPTIND
The index of the last option argument processed by the \fBgetopts\fP
command.
.TP
.B PPID
The process id of the parent of the shell.
.TP
.B PWD
The present working directory.
.TP
.B RANDOM
A random integer from 0 to 32767, newly generated each time
this parameter is referenced.  The random number generator
can be seeded by assigning a numeric value to \fBRANDOM\fP.
.TP
.B SECONDS
The number of seconds since shell invocation.  If this parameter
is assigned a value, then the value returned upon reference
will be the value that was assigned plus the number of seconds
since the assignment.
.TP
.B SHLVL
Incremented by one each time a new shell is started.
.TP
.B signals
An array containing the names of the signals.
.TP
.B TTY
The name of the tty associated with the shell, if any.
.TP
.B UID
The user id of the shell process.
.TP
.B USERNAME
.TP
.B LOGNAME
The username corresponding to the user id of the shell process.
.TP
.B VERSION
The version number of this \fBzsh\fP.
.PD
.RE
.PP
The following parameters are used by the shell:
.PP
.RS
.PD 0
.TP
.B ARGV0
If exported, it's value is used as argv[0] of external commands.
Usually used in constructs like 'ARGV0=emacs nethack'.
.TP
.B BAUD
The baud rate of the current connection.  Used by the line editor
update mechanism to compensate for a slow terminal by delaying
updates until necessary.  This may be profitably set to a lower value
in some circumstances, e.g.
for slow modems dialing into a communications server which is connected
to a host via a fast link; in this case, this variable
would be set by default to the speed of the fast link, and not
the modem.
This parameter should be set to the baud
rate of the slowest part of the link for best performance. The compensation
mechanism can be turned off by setting the variable to zero.
.TP
.B cdpath (CDPATH)
An array (colon-separated list)
of directories specifying the search path for the \fBcd\fP command.
.TP
.B COLUMNS
The number of columns for this terminal session.
Used for printing select lists and for the line editor.
.TP
.B DIRSTACKSIZE
The maximum size of the directory stack.  If the 
stack gets larger than this, it will be truncated automatically.
This is useful with the \fBAUTO_PUSHD\fP option.
.TP
.B FCEDIT
The default editor for the \fBfc\fP builtin.
.TP
.B fignore (FIGNORE)
An array (colon separated list)
containing the suffixes of files to be ignored
during filename completion.
.TP
.B fpath (FPATH)
An array (colon separated list)
of directories specifying the search path for
function definitions.  This path is searched when a function
with the \-\fBu\fP attribute is referenced.  If an executable
file is found, then it is read and executed in the current environment.
.TP
.B HISTCHARS
Three characters used by the shell's history and lexical analysis
mechanism.  The first character signals the start of a history
substitution (default `!').  The second character signals the
start of a quick history substitution (default `^').  The third
character is the comment character (default `#').
.TP
.B HISTFILE
The file to save the history in when an interactive shell exits.
If unset, the history is not saved.
.TP
.B HISTSIZE
The maximum size of the history list.
.TP
.B HOME
The default argument for the \fBcd\fP command.
.TP
.B IFS
Internal field separators, normally space, tab, and newline, that
are used to separate words which result from
command or parameter substitution and words read by
the \fBread\fP builtin.
.TP
.B KEYTIMEOUT
The time the shell waits, in hundredths of seconds, for another key to
be pressed when reading bound multi-character sequences.
.TP
.B LINES
The number of lines for this terminal session.
Used for printing select lists and for the line editor.
.TP
.B LISTMAX
In the line editor,
the number of filenames to list without asking first.
If set to zero, the shell asks only if the top of the listing would scroll
off the screen.
.TP
.B LITHISTSIZE
The maximum size of the literal history list (before history expansion).
.TP
.B LOGCHECK
The interval in seconds between checks for login/logout activity
using the \fBwatch\fP parameter.
.TP
.B MAIL
If this parameter is set and \fBmailpath\fP is not set,
the shell looks for mail in the specified file.  By default it is set to
the user's system mailbox.
.TP
.B MAILCHECK
The interval in seconds between checks for new mail. 
.TP
.B mailpath (MAILPATH)
An array (colon-separated list)
of filenames to check for new mail.  Each filename can
be followed by a ? and a message that will be printed.
The sequence $_ in the message will be replaced by the name 
of the mail file.
The default message is "You have new mail." If an element is a directory
instead of a file the shell will recursively check every file in every
subdirectory of the element.
.TP
.B manpath (MANPATH)
An array (colon-separated list)
whose value is not used by the shell.  The \fBmanpath\fP
array can be useful, however, since setting it also sets
\fBMANPATH\fP, and vice versa.
.TP
.B NULLCMD
The command name to assume if a redirection is specified
with no command.  Defaults to \fBcat\fP.  For sh/ksh-like
behavior, change this to \fB:\fP.  For csh-like
behavior, unset this parameter; the shell will print an
error message if null commands are entered.
.TP
.B path (PATH)
An array (colon-separated list)
of directories to search for commands.
When this parameter is set, each directory is scanned
and all files found are put in a hash table.
.TP
.B POSTEDIT
This string is output whenever the line editor exits.
It usually contains termcap strings to reset the terminal.
.TP
.B PROMPT
The primary prompt string, printed before a command is read;
the default is "%m%# ".  If the escape sequence takes an optional
integer, it should appear between the '%' and the next character of the
sequence.  The following escape sequences are recognized:
.PD
.PP
.PD 0
.RS
.TP
.B %d
.TP
.B %/
Present working directory ($PWD).
.TP
.B %~
$PWD.
If it has a named directory as its prefix, that part is replaced
by a ~ followed by the name of the directory.
If it starts with $HOME, that part is
replaced by a ~.
.TP
.B %c
.TP
.B %.
.TP
.B %C
Trailing component of $PWD.
An integer may follow the '%' to get more than one component.
Unless \fB%C\fP is used, tilde expansion is performed first.
.TP
.B !
.TP
.B %h
.TP
.B %!
Current history event number
.TP
.B %M
The full machine hostname.
.TP
.B %m
The hostname up to the first '.'.
An integer may follow the '%' to specify
how many components of the hostname are desired.
.TP
.B %S (%s)
Start (stop) standout mode.
.TP
.B %U (%u)
Start (stop) underline mode.
.TP
.B %B (%b)
Start (stop) boldface mode.
.TP
.B %t
.TP
.B %@
Current time of day, in 12-hour, am/pm format.
.TP
.B %T
Current time of day, in 24-hour format.
.TP
.B %*
Current time of day in 24-hour format, with seconds.
.TP
.B %n
\fB$USERNAME\fP.
.TP
.B %w
The date in day\-dd format.
.TP
.B %W
The date in mm/dd/yy format.
.TP
.B %D
The date in yy\-mm\-dd format.
.TP
.B %D{\fIstring\fP}
\fIstring\fP is formatted using the \fBstrftime\fP function.
See \fBstrftime(3)\fP for more details, if your system has it.
.TP
.B %l
The line (tty) the user is logged in on.
.TP
.B %?
The return code of the last command executed just before the prompt.
.TP
.B %_
The status of the parser, i.e. the shell constructs (like `if' and
`for') that have been started on the command line. If given an integer
number that many strings will be printed.
.TP
.B
%E
Clears to end of line.
.TP
.B %#
A '#' if the shell is running as root, a '%' if not.
Equivalent to %(#.#.%%).
.TP
.B %v
The value of the first element of the $psvar array parameter.  Following
the '%' with an integer gives that element of the array.
.TP
\fB%{\fP...\fB%}\fP
Include a string as a literal escape sequence.
The string within the braces should not change the cursor
position.
.TP
.B %(x\fI.true-text.false-text\fB)\fP
Specifies a ternary expression.  The character following the \fBx\fP is
arbitrary; the same character is used to separate the text for the
"true" result from that for the "false" result.  Both the separator and
the right parenthesis may be escaped with a backslash.  \fITrue-text\fP
and \fIfalse-text\fP may both contain arbitrarily-nested escape
sequences, including further ternary expressions.  The left
parenthesis may be preceded or followed by a positive integer \fIn\fP,
which defaults to zero.  The test character \fBx\fP may be any of the
following:
.PD
.PP
.PD 0
.RS
.B c
.TP 
.B .
.TP
.B ~
True if the current path, with prefix replacement, has at least \fIn\fP
elements.
.TP
.B /
.TP
.B C
True if the current absolute path has at least \fIn\fP elements.
.TP
.B t
True if the time in minutes is equal to \fIn\fP.
.TP
.B T
True if the time in hours is equal to \fIn\fP.
.TP
.B d
True if the day of the month is equal to \fIn\fP.
.TP
.B D
True if the month is equal to \fIn\fP (January = 0).
.TP
.B w
True if the day of the week is equal to \fIn\fP (Sunday = 0).
.TP
.B ?
True if the exit status of the last command was \fIn\fP.
.TP
.B #
True if the effective uid of the current process is \fIn\fP.
.TP
.B g
True if the effective gid of the current process is \fIn\fP.
.TP
.B L
True if the SHLVL parameter is at least \fIn\fP.
.TP
.B S
True if the SECONDS parameter is at least \fIn\fP.
.TP
.B v
True if the array psvar has at least \fIn\fP elements.
.TP
.B _
True if at least \fIn\fP shell constructs were started.
.RE
.RE
.PD
.PP
.PD 0
.TP
.B PROMPT2
The secondary prompt, printed when the shell needs more information
to complete a command.
Recognizes the same escape sequences as \fB$PROMPT\fP.
The default is "> ".
.TP
.B PROMPT3
Selection prompt used within a \fBselect\fP loop.
Recognizes the same escape sequences as \fB$PROMPT\fP.
The default is "?# ".
.TP
.B PROMPT4
The execution trace prompt.  Default is "+ ".
.TP
.B PS1
.TP
.B PS2
.TP
.B PS3
.TP
.B PS4
Same as \fBPROMPT\fP, \fBPROMPT2\fP, \fBPROMPT3\fP, and \fBPROMPT4\fP,
respectively.
.TP
.B psvar (PSVAR)
An array (colon-separated list) whose first nine values can be used in
\fBPROMPT\fP strings.  Setting \fBpsvar\fP also sets \fBPSVAR\fP, and
vice versa.
.TP
.B prompt
Same as \fBPROMPT\fP.
.TP
.B READNULLCMD
The command name to assume if a single input redirection
is specified with no command.  Defaults to \fBmore\fP.
.TP
.B REPORTTIME
If nonnegative, commands whose combined user and system execution times
(measured in seconds) are greater than this value have timing
statistics printed for them.
.TP
.B RPROMPT
.TP
.B RPS1
This prompt is displayed on the right-hand side of the screen
when the primary prompt is being displayed on the left.
This does not work if the \fBSINGLELINEZLE\fP option is set.
Recognizes the same escape sequences as \fBPROMPT\fP.
.TP
.B SAVEHIST
The maximum number of history events to save in the history file.
.TP
.B SPROMPT
The prompt used for spelling correction.  The sequence
\fB%R\fP expands to the string which presumably needs spelling
correction, and \fB%r\fP expands to the proposed correction.
All other \fBPROMPT\fP escapes are also allowed.
.TP
.B STTY
If this parameter is set in a command's environment, the shell runs the
\fBstty\fP command with the value of this parameter as arguments in order to
set up the terminal before executing the command. The modes apply only to the
command, and are reset when it finishes or is suspended. If the command is
suspended and continued later with the \fBfg\fP or \fBwait\fP builtins it will
see the modes specified by STTY, as if it were not suspended.  This
(intentionally) does not apply if the command is continued via "kill -CONT".
STTY is ignored if the command is run in the background, or if it is in the
environment of the shell but not explicitly assigned to in the input line. This
avoids running stty at every external command by accidentally exporting it.
Also note that STTY should not be used for window size specifications; these
will not be local to the command.
.TP
.B TIMEFMT
The format of process time reports with the \fBtime\fP keyword.
The default is "%E real  %U user  %S system  %P %J".
Recognizes the following escape sequences:
.PD
.PP
.PD 0
.RS
.TP
.B %U
CPU seconds spent in user mode.
.TP
.B %S
CPU seconds spent in kernel mode.
.TP
.B %E
Elapsed time in seconds.
.TP
.B %P
The CPU percentage, computed as (%U+%S)/%E.
.TP
.B %W
Number of times the process was swapped.
.TP
.B %X
The average amount in (shared) text space used in Kbytes.
.TP
.B %D
The average amount in (unshared) data/stack space used in Kbytes.
.TP
.B %K
The total space used (%X+%D) in Kbytes.
.TP
.B %M
The maximum memory the process had in use at any time in Kbytes.
.TP
.B %F
The number of major page faults (page needed to be brought from disk).
.TP
.B %R
The number of minor page faults.
.TP
.B %I
The number of input operations.
.TP
.B %O
The number of output operations.
.TP
.B %r
The number of socket messages received.
.TP
.B %s
The number of socket messages sent.
.TP
.B %k
The number of signals received.
.TP
.B %w
Number of voluntary context switches (waits).
.TP
.B %c
Number of involuntary context switches.
.TP
.B %J
The name of this job.
.RE
.PD
.PP
.PD 0
.TP
.B TMOUT
If this parameter is nonzero, the shell will terminate if a command is not
entered within the specified number of seconds after issuing
a prompt.
.TP
.B TMPPREFIX
A pathname prefix which the shell will use for all temporary files.
Note that this should include an initial part for the file name as
well as any directory names.  The default is /tmp/zsh.
.TP
.B watch (WATCH)
An array (colon-separated list) of login/logout events to report.
If it contains the single word "all", then all login/logout events
are reported.  If it contains the single word "notme", then all
events are reported as with "all" except $USERNAME.
An entry in this list may consist of a username,
an `@' followed by a remote hostname,
and a `%' followed by a line (tty).
Any or all of these components may be present in an entry;
if a login/logout event matches all of them,
it is reported.
.TP
.B WATCHFMT
The format of login/logout reports if the \fBwatch\fP parameter is set.
Default is "%n has %a %l from %m."
Recognizes the following escape sequences:
.PD
.PP
.PD 0
.RS
.TP
.B %n
The name of the user that logged in/out.
.TP
.B %a
The observed action, i.e. "logged on" or "logged off".
.TP
.B %l
The line (tty) the user is logged in on.
.TP
.B %M
The full hostname of the remote host.
.TP
.B %m
The hostname up to the first ".".  If only the
ip address is available or the utmp field contains
the name of an X-windows display, the whole name is printed.
.TP
.B NOTE:
The %m and %M escapes will work only if there is a host name
field in the utmp on your machine.  Otherwise they are
treated as ordinary strings.
.TP
.B %S (%s)
Start (stop) standout mode.
.TP
.B %U (%u)
Start (stop) underline mode.
.TP
.B %B (%b)
Start (stop) boldface mode.
.TP
.B %t
.TP
.B %@
The time, in 12-hour, am/pm format.
.TP
.B %T
The time, in 24-hour format.
.TP
.B %w
The date in day\-dd format.
.TP
.B %W
The date in mm/dd/yy format.
.TP
.B %D
The date in yy\-mm\-dd format.
.TP
.B %(x\fI:true-text:false-text\fB)\fP
Specifies a ternary expression.
The character following the \fBx\fP is
arbitrary; the same character is used to separate the text
for the "true" result from that for the "false" result.
Both the separator and the right parenthesis may be escaped
with a backslash.
Ternary expressions may be nested.
.sp
The test character \fBx\fP may be any one of \fBl\fP, \fBn\fP, \fBm\fP,
or \fBM\fP, which indicate a "true" result if the corresponding
escape sequence would return a non-empty value; or may be \fBa\fP,
which indicates a "true" result if the watched user has logged in,
or "false" if he has logged out.
Other characters evaluate to neither true nor false; the entire
expression is omitted in this case.
.sp
If the result is "true", then the \fItrue-text\fP
is formatted according to the rules above and printed,
and the \fIfalse-text\fP is skipped.
If "false", the \fItrue-text\fP is skipped and the \fIfalse-text\fP
is formatted and printed.
Either or both of the branches may be empty, but
both separators must be present in any case.
.RE
.PD
.PP
.PD 0
.TP
.B WORDCHARS
A list of nonalphanumeric characters considered part of a word
by the line editor.
.TP
.B ZDOTDIR
The directory to search for shell startup files (.zshrc, etc),
if not \fB$HOME\fP.
.PD
.RE
.PP
.SH OPTIONS
The following options may be set upon invocation of the shell,
or with the \fBset\fP or \fBsetopt\fP builtins. They are case insensitive and
underscores are ignored, that is, "allexport" is equivalent to "A__lleXP_ort".
.RS
.PD 0
.TP
\fBALL_EXPORT\fP (\-\fBa\fP)
All parameters subsequently defined are automatically exported.
.TP
\fBALWAYS_LAST_PROMPT\fP
If unset, key functions that list completions try to return to the last
prompt if given a numeric argument. If set these functions try to
return to the last prompt if given \fBno\fP numeric argument.
.TP
\fBALWAYS_TO_END\fP
If a completion with the cursor in the word was started and it results
in only one match, the cursor is placed at the end of the word.
.TP
\fBAPPEND_HISTORY\fP
If this is set, zsh sessions will append their history list to
the history file, rather than overwrite it. Thus, multiple parallel
zsh sessions will all have their history lists added to the
history file, in the order they are killed.
.TP
\fBAUTO_CD\fP (\-\fBJ\fP)
If a command is not in the hash table, and there exists an
executable directory by that name, perform the \fBcd\fP
command to that directory.
.TP
\fBAUTO_LIST\fP (\-\fB9\fP)
Automatically list choices on an ambiguous completion.
.TP
\fBAUTO_MENU\fP
Automatically use menu completion after the second consecutive request for
completion, for example by pressing the \fPTAB\fP key repeatedly. This option
is overridden by \fBMENU_COMPLETE\fP.
.TP
\fBAUTO_NAME_DIRS
Any parameter that is set to the absolute name of a directory
immediately becomes a name for that directory in the usual form
~param.  If this option is not set, the parameter must be used in that
form for it to become a name (a command-line completion is sufficient
for this).
.TP
\fBAUTO_PARAM_KEYS\fP
If a parameter name was completed and the next character typed is one
of those that have to come directly after the name (like `}', `:',
etc.) they are placed there automatically.
.TP
\fBAUTO_PUSHD\fP (\-\fBN\fP)
Make \fBcd\fP act like \fBpushd\fP.
.TP
\fBAUTO_REMOVE_SLASH\fP
When the last character resulting from a completion is a slash and the next
character typed is a word delimiter, remove the slash.
.TP
\fBAUTO_RESUME\fP (\-\fBW\fP)
Treat single word simple commands without redirection
as candidates for resumption of an existing job.
.TP
\fBBG_NICE\fP (\-\fB6\fP)
Run all background jobs at a lower priority.  This option
is set by default.
.TP
\fBBRACE_CCL\fP
Allow brace expansions of the form \fB{a-zA-Z}\fP, etc.
.TP
\fBCDABLE_VARS\fP (\-\fBT\fP)
If the argument to a \fBcd\fP command (or an implied \fBcd\fP with the
\fBAUTO_CD\fP option set) is not a directory, and does not begin with a
slash, try to expand the expression as if it were preceded by a ~ (see
\fBFilename Expansion\fP above).
.TP
\fBCHASE_LINKS\fP (\-\fBw\fP)
Resolve symbolic links to their true values.
.TP
\fBCOMPLETE_ALIASES\fP
If set, aliases on the command line are not internally substituted
before completion is attempted.
.TP
\fBCOMPLETE_IN_WORD\fP
If unset, the cursor is set to the end of the word if completion is
started. Otherwise it stays there and completion is done from both ends.
.TP
\fBCORRECT\fP (\-\fB0\fP)
Try to correct the spelling of commands.
.TP
\fBCORRECT_ALL\fP (\-\fBO\fP)
Try to correct the spelling of all arguments in a line.
.TP
\fBCSH_JUNKIE_HISTORY\fP
A history reference without an event specifier will always refer to the
previous command.
.TP
\fBCSH_JUNKIE_LOOPS\fP
Allow loop bodies to take the form
"\fIlist\fP; \fBend\fP" instead of
"\fBdo\fP \fIlist\fP; \fBdone\fP".
.TP
\fBCSH_JUNKIE_PAREN\fP
Allow \fBfor\fP, \fBif\fP and \fBwhile\fP loops where the argument
list is given in parentheses.  Otherwise, the parentheses will be
treated as specifying a subshell.
.TP
\fBCSH_JUNKIE_QUOTES\fP
Complain if a quoted exp  ê  î  ò  ú  †  §  ®                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ression runs off the end of a line;
prevent quoted expressions from containing unescaped newlines.
.TP
\fBCSH_NULL_GLOB\fP
If a pattern for filename generation has no matches,
delete the pattern from the argument list;
do not report an error unless all the patterns
in a command have no matches.
Overrides \fBNULLGLOB\fP.
.TP
\fBERR_EXIT\fP (\-\fBe\fP)
If a command has a non-zero exit status, execute the \fBZERR\fP
trap, if set, and exit.  This is disabled while running initialization
scripts.
.TP
\fBEXTENDED_GLOB\fP
Treat the #, ~ and ^ characters as part of patterns for filename
generation, etc.  (An initial unquoted ~ always produces named
directory expansion as in \fBFilename Expansion\fP above.)
.TP
\fBEXTENDED_HISTORY\fP
Save beginning and ending timestamps to the history file.
The format of these timestamps is
\fI:<beginning time>:<ending time>:<command>.\fP
.TP
\fBGLOB_COMPLETE\fP
When the current word has a glob pattern, do not insert all the words
resulting from the expansion but cycle through them like
\fBMENU_COMPLETE\fP. If no matches are found, a `*' is added to the end of the
word or inserted at the cursor if \fBCOMPLETE_IN_WORD\fP is set, and expansion
is attempted again. Using patterns works not only for files but for all
completions, such as options, user names, etc.
.TP
\fBGLOB_DOTS\fP (\-\fB4\fP)
Do not require a leading . in a filename to be matched explicitly.
.TP
\fBGLOB_SUBST\fP
Treat any characters resulting from parameter substitution as being
eligible for file expansion and filename generation, and any
characters resulting from command substitution as being eligible for
filename generation.
.TP
\fBHASH_CMDS\fP
Place the location of each command in the hash table the first
time it is executed.  If this option is unset, no path hashing
will be done at all.
.TP
\fBHASH_DIRS\fP
Whenever a command is executed, hash the directory containing it,
as well as all directories that occur earlier in the path.
Has no effect if \fBHASH_CMDS\fP is unset.
.TP
\fBHASH_LIST_ALL\fP
Whenever a command completion is attempted, make sure the entire
command path is hashed first.  This makes the first completion slower.
.TP
\fBHIST_IGNORE_DUPS\fP (\-\fBh\fP)
Do not enter command lines into the history list
if they are duplicates of the previous event.
.TP
\fBHIST_IGNORE_SPACE\fP (\-\fBg\fP)
Do not enter command lines into the history list
if any command on the line begins with a blank.
.TP
\fBHIST_LIT\fP (\-\fBj\fP)
Use literal (unparsed) versions of the history lines
in the editor.
.TP
\fBHIST_NO_STORE\fP
Remove the \fBhistory\fP (\fBfc\fP \-\fBl\fP) command from
the history when invoked.
.TP
\fBHIST_VERIFY\fP
Whenever the user enters a line with history substitution,
don't execute the line directly; instead, perform
history substitution and reload the line into the editing buffer.
.TP
\fBIGNORE_BRACES\fP (\-\fBI\fP)
Do not perform brace expansion.
.TP
\fBIGNORE_EOF\fP (\-\fB7\fP)
Do not exit on end-of-file.  Require the use
of \fBexit\fP or \fBlogout\fP instead.
.TP
\fBINTERACTIVE\fP (\-\fBi\fP)
This is an interactive shell.
.TP
\fBINTERACTIVE_COMMENTS\fP (\-\fBk\fP)
Allow comments even in interactive shells.
.TP
\fBKSH_OPTION_PRINT\fP
Alters the way options settings are printed.
.TP
\fBLIST_AMBIGUOUS\fP
If this option is set, completions are shown only if the completions
don't have a unambiguous prefix or suffix that could be inserted in
the command line.
.TP
\fBLIST_TYPES\fP (\-\fBX\fP)
When listing files that are possible completions, show the
type of each file with a trailing identifying mark.
.TP
\fBLOGIN\fP (\-\fBl\fP)
This is a login shell.
.TP
\fBLONG_LIST_JOBS\fP (\-\fBR\fP)
List jobs in the long format by default.
.TP
\fBMAGIC_EQUAL_SUBST\fP
All unquoted arguments of the from \fIidentifier\fB=\fIexpression\fR
have file expansion performed on \fIexpression\fR as if it were a
parameter assignment, although the argument is not otherwise treated
specially.
.TP
\fBMAIL_WARNING\fP (\-\fBU\fP)
Print a warning message if a mail file has been
accessed since the shell last checked.
.TP
\fBMARK_DIRS\fP (\-\fB8\fP)
Append a trailing / to all directory
names resulting from filename generation (globbing).
.TP
\fBMENU_COMPLETE\fP (\-\fBY\fP)
On an ambiguous completion, instead of listing possibilities or beeping,
insert the first match immediately.  Then when completion is requested
again, remove the first match and insert the second match, etc.
When there are no more matches, go back to the first one again.
\fBreverse-menu-complete\fP may be used to loop through the list
in the other direction. This option overrides \fBAUTO_MENU\fP.
.TP
\fBMONITOR\fP (\-\fBm\fP)
Allow job control.  Set by default in interactive shells.
.TP
\fBNO_BAD_PATTERN\fP (\-\fB2\fP)
If a pattern for filename generation is badly formed,
leave it unchanged in the argument list instead of
printing an error.
.TP
\fBNO_BANG_HIST\fP (\-\fBK\fP)
Do not perform textual history substitution.  Do not
treat the ! character specially.
.TP
\fBNO_BEEP\fP (\-\fBB\fP)
Do not beep.
.TP
\fBNO_CLOBBER\fP (\-\fB1\fP)
Prevents \fB>\fP redirection from truncating existing files.
\fB>!\fP may be used to truncate a file instead.
Also prevents \fB>>\fP from creating files.
\fB>>!\fP may be used instead.
.TP
\fBNO_EQUALS\fP
Don't perform \fB=\fP filename substitution.
.TP
\fBNO_EXEC\fP (\-\fBn\fP)
Read commands and check them for syntax errors, but do not execute them.
.TP
\fBNO_GLOB\fP (\-\fBF\fP)
Disable filename generation.
.TP
\fBNO_FLOW_CONTROL\fP
Disable output flow control via start/stop characters (usually assigned to
^S/^Q) in the shell's editor.
.TP
\fBNO_HIST_BEEP\fP
Don't beep when an attempt is made to access a history entry which
isn't there.
.TP
\fBNO_HUP\fP
Don't send the \fBHUP\fP signal to running jobs when the
shell exits.
.TP
\fBNO_LIST_BEEP\fP
Don't beep on an ambiguous completion.
.TP
\fBNO_NOMATCH\fP (\-\fB3\fP)
If a pattern for filename generation has no matches,
leave it unchanged in the argument list instead of
printing an error.  This also applies to file expansion 
of an initial ~ or =.
.TP
\fBNO_PROMPT_CR\fP (\-\fBV\fP)
Don't print a carriage return just before printing
a prompt in the line editor.
.TP
\fBNO_RCS\fP (\-\fBf\fP)
Source only the /etc/zshenv file.
Do not source the .zshenv, /etc/zprofile, .zprofile,
/etc/zshrc, .zshrc, /etc/zlogin, .zlogin, or .zlogout files.
.TP
\fBNO_SHORT_LOOPS\fP
Disallow the short forms of \fBfor\fP, \fBselect\fP,
\fBif\fP, and \fBfunction\fP constructs.
.TP
\fBNOTIFY\fP (\-\fB5\fP)
Report the status of background jobs immediately, rather than
waiting until just before printing a prompt.
.TP
\fBNO_UNSET\fP (\-\fBu\fP)
Treat unset parameters as an error when substituting.
.TP
\fBNULL_GLOB\fP (\-\fBG\fP)
If a pattern for filename generation has no matches,
delete the pattern from the argument list instead
of reporting an error.  Overrides \fBNO_NOMATCH\fP.
.TP
\fBNUMERIC_GLOB_SORT\fP
If numeric filenames are matched by a filename generation pattern,
sort the filenames numerically rather than lexicographically.
.TP
\fBOVER_STRIKE\fP
Start up the line editor in overstrike mode.
.TP
\fBPATH_DIRS\fP (\-\fBQ\fP)
Perform a path search even on command names with slashes in them.
Thus if "/usr/local/bin" is in the user's path, and he types
"X11/xinit", the command "/usr/local/bin/X11/xinit" will be executed
(assuming it exists).
This applies to the \fB\&.\fP builtin as well as to command execution.
Commands explicitly beginning with "./" or "../" are not subject to
path search.
.TP
\fBPRINT_EXIT_VALUE\fP (\-\fBC\fP)
Print the exit value of programs with non-zero exit status.
.TP
\fBPROMPT_SUBST\fP
If set expressions like \fB${...}\fP, \fB$(...)\fP, and \fB$[...]\fP
in prompts will be expanded.
.TP
\fBPUSHD_IGNORE_DUPS\fP
Don't push multiple copies of the same directory onto the directory stack.
.TP
\fBPUSHD_MINUS\fP
See \fBpopd\fP below.
.TP
\fBPUSHD_SILENT\fP (\-\fBE\fP)
Do not print the directory stack after \fBpushd\fP
or \fBpopd\fP.
.TP
\fBPUSHD_TO_HOME\fP (\-\fBD\fP)
Have \fBpushd\fP with no arguments act like
\fBpushd\fP $HOME.
.TP
\fBRC_EXPAND_PARAM\fP (\-\fBP\fP)
See \fIParameter Expansion\fP.
.TP
\fBRC_QUOTES\fP
Allow the character sequence \fB''\fP to signify a single quote
within singly quoted strings.
.TP
\fBREC_EXACT\fP (\-\fBS\fP)
In completion, recognize exact matches even
if they are ambiguous.
.TP
\fBRM_STAR_SILENT\fP (\-\fBH\fP)
Do not query the user before executing "rm *" or "rm path/*".
.TP
\fBSHIN_STDIN\fP (\-\fBs\fP)
Read commands from the standard input.
.TP
\fBSH_WORD_SPLIT\fP (\-\fBy\fP)
See \fIParameter Expansion\fP.
.TP
\fBSINGLE_LINE_ZLE\fP (\-\fBM\fP)
Use single-line command line editing instead of multi-line.
.TP
\fBSUN_KEYBOARD_HACK\fP (\-\fBL\fP)
If a line ends with a backquote, and there are an odd number
of backquotes on the line, ignore the trailing backquote.
This is useful on some keyboards where the return key is
too small, and the backquote key lies annoyingly close to it.
.TP
\fBVERBOSE\fP (\-\fBv\fP)
Print shell input lines as they are read.
.TP
\fBXTRACE\fP (\-\fBx\fP)
Print commands and their arguments as they are executed.
.TP
\fBZLE\fP (\-\fBZ\fP)
Use the zsh line editor.
.RE
.PD
.SH "SHELL BUILTIN COMMANDS"
.TP
\fB\&.\fP \fIfile\fP [ \fIarg\fP ... ]
Read commands from \fIfile\fP and execute them in the current shell
environment.
If \fIfile\fP does not contain a slash, or if \fBPATH_DIRS\fP
is set, the shell looks in the components of \fBpath\fP to find the
directory containing \fIfile\fP.
Files in the current directory are not read unless "." appears
somewhere in \fBpath\fP.
If any arguments \fIarg\fP are given,
they become the positional parameters; the old positional
parameters are restored when the \fIfile\fP is done executing.
The exit status is the exit status of the last command executed.
.TP
\fB:\fP [ \fIarg\fP ... ]
This command only expands parameters.  A zero exit code is returned.
.TP
\fBalias\fP [ \-\fBgrm\fP ] [ \fIname\fP[=\fIvalue\fP] ] ...
With no arguments, print the list of aliases in the form
\fIname\fP=\fBvalue\fP on the standard output.
For each \fIname\fP with a corresponding \fIvalue\fP, define an alias 
with that value.
A trailing space in \fIvalue\fP causes the next
word to be checked for alias substitution.
If the \-\fBg\fP flag is present, define a global alias; global aliases
are expanded even if they do not occur in command position.
For each \fIname\fP with no \fIvalue\fP, print the value of \fIname\fP,
if any.
If only the \-\fBg\fP or the \-\fBr\fP flags are given only global or regular
aliases are listed. If the \-\fBm\fP flag is given the arguments are taken
as patterns (they should be quoted to preserve them from being
interpreted as glob patterns) and the aliases matching these patterns
are printed.
The exit status is nonzero if a \fIname\fP (with no \fIvalue\fP) is
given for which no alias has been defined.
.TP
\fBautoload\fP [ \fIname\fP ... ]
For each of the \fIname\fPs (which are names of functions),
create a function marked undefined.
The \fBfpath\fP variable will be searched to find the
actual function definition when the function is first referenced.
.TP
.PD 0
\fBbg\fP [ \fIjob\fP ... ]
.TP
\fIjob\fP ... \fB&\fP
.PD
Put each specified \fIjob\fP in the background,
or the current job if none is specified.
.TP
.PD 0
\fBbindkey\fP \-\fBmevd
.TP
\fBbindkey\fP \-\fBr\fP \fIin-string\fP ...
.TP
\fBbindkey\fP [ \-\fBa\fP ] \fIin-string\fP [ \fIcommand\fP ] ...
.TP
\fBbindkey\fP \-\fBs\fP [ \-\fBa\fP ] \fIin-string\fP \fIout-string\fP ...
.PD
The \-\fBe\fP and \-\fBv\fP options put the keymaps in emacs mode or vi mode
respectively; they cannot be used simultaneously. The \-\fBd\fP option resets
all bindings to the compiled-in settings. If not used with options \-\fBe\fP
or \-\fBv\fP, the maps will be left in emacs mode, or in vi mode if the
\fBVISUAL\fP or \fBEDITOR\fP variables exist and contain the string "vi".
Metafied characters are bound to self-insert by default. The \-\fBm\fP option
loads the compiled-in bindings of these characters for the mode determined by
the preceding options, or the current mode if used alone. Any previous bindings
done by the user will be preserved. If the \-\fBr\fP option is given, remove
any binding for each \fIin-string\fP. If the \-\fBs\fP option is not
specified, bind each \fIin-string\fP to a specified \fIcommand\fP. If no
\fIcommand\fP is specified, print the binding of \fIin-string\fP if it is
bound, or return a nonzero exit code if it is not bound. If the \-\fBs\fP
option is specified, bind each \fIin-string\fP to each specified
\fIout-string\fP. When \fIin-string\fP is typed, \fIout-string\fP will be
pushed back and treated as input to the line editor. This process is recursive
but, to avoid infinite loops, the shell will report an error if more than 20
consecutive replacements happen. If the \-\fBa\fP option is specified, bind
the \fIin-strings\fP in the alternative keymap instead of the standard one.
The alternative keymap is used in vi command mode.
.sp
It's possible for an \fIin-string\fP to be bound to something and also be the
beginning of a longer bound string. In this case the shell
will wait a certain time to see if more characters are typed and if not it
will execute the binding. This timeout is defined by the KEYTIMEOUT
parameter; its default is 0.4 sec. No timeout is done if the prefix string is
not bound.
.RS
.PP
For either \fIin-string\fP or \fIout-string\fP, control characters
may be specified in the form \fB^X\fP, and the backslash may
be used to introduce one of the following escape sequences:
.RS
.PD 0
.TP
.B \ea
bell character
.TP
.B \en
linefeed (newline)
.TP
.B \eb
backspace
.TP
.B \et
horizontal tab
.TP
.B \ev
vertical tab
.TP
.B \ef
form feed
.TP
.B \er
carriage return
.TP
.B \ee, \eE
escape
.TP
.B \eNNN
character code in octal
.TP
.B \exNN
character code in hexadecimal
.TP
.B \eM\-xxx
character or escape sequence with meta bit set. The `-' after the `M' is
optional.
.TP
.B \eC\-X
control character.  The `-' after the `C' is optional.
.PD
.PP
.RE
In all other cases, \e escapes the following character.  Delete is
written as `\fB^?\fP'. Note that `\eM^?' and `^\eM?' are not the same.
.sp
Multi-character \fIin-string\fPs cannot contain the null character ("^@" or
"^ "). If they appear in a bindkey command, they will be silently translated
to "\eM-^@". This restriction does not apply to \fIout-string\fPs,
single-character \fIin-string\fPs and the first character of a multi-char
\fIin-string\fP.
.RE
.TP
\fBbreak\fP [ \fIn\fP ]
Exit from an enclosing \fBfor\fP, \fBwhile\fP,
\fBuntil\fP, \fBselect\fP, or \fBrepeat\fP loop.  If \fIn\fP
is specified, then break \fIn\fP levels instead of just one.
.TP
\fBbuiltin\fP \fIname\fP [ \fIargs\fP ] ...
Executes the builtin \fIname\fP, with the given \fIargs\fP.
.TP
\fBbye\fP
Same as \fBexit\fP.
.TP
.PD 0
\fBcd\fP [ \fIarg\fP ]
.TP
\fBcd\fP \fIold\fP \fInew\fP
.TP
\fBcd\fP \(+-\fBn\fP
.PD
Change the current directory.  In the first form, change the
current directory to \fIarg\fP, or to the value of \fBHOME\fP if
\fIarg\fP is not specified.  If \fIarg\fP is \-, change to the
value of \fBOLDPWD\fP, the previous directory.
If a directory named \fIarg\fP is not found in the current directory
and \fIarg\fP does not begin with a slash,
search each component of the shell parameter \fBcdpath\fP.
If the option \fBCDABLEVARS\fP is set, and a parameter named \fIarg\fP
exists whose value begins with a slash, treat its value as
the directory.
.RS
.PP
The second form of \fBcd\fP substitutes the string \fInew\fP
for the string \fIold\fP in the name of the current directory,
and tries to change to this new directory.
.PP
The third form of \fBcd\fP is equivalent to \fBpopd\fP.
.RE
.TP
\fBchdir\fP
Same as \fBcd\fP.
.TP
.PD 0
\fBcompctl\fP [ \-\fBcfqovbCDAIFpEjBaRGuderzNOZn\fP ] [ \-\fBk\fP \fIname\fP ]
.br
[ \-\fBX\fP \fIexplanation\fP ] [ \-\fBK\fP \fIfunction\fP ] 
.br
[ \-\fBP\fP \fIprefix\fP ] [ \-\fBS\fP \fIsuffix\fP ]
.br
[ \-\fBg\fP \fIglobstring\fP ] [ \-\fBs\fP \fIsubststring\fP ] 
.br
[ \-\fBH\fP \fInum pattern\fP ] [ \-\fBl\fP \fIcmd\fP ] [
\fIarg\fP ... ]
.TP
\fBcompctl\fP \fIflags\fP \fB+\fP \fIflags\fP \fB+\fP ...
.TP
\fBcompctl\fP \fIflags\fP \-\fBx\fP \fIpattern\fP \fIflags\fP \- ... \-\- \fIarg\fP ...
.PD
Control the editor's completion behavior when one of \fIarg\fP is the current
command.  (Note that aliases are expanded before this is determined,
unless the \fBCOMPLETE_ALIASES\fP option is set.)
With the \-\fBD\fP flag, control default completion behavior
for commands not assigned any special behavior; with \-\fBC\fP, control
completion when there is no current command.  The remaining options
specify the type of command arguments to look for during completion.
If completion is attempted for a command with a pathname containing
slashes and no completion definition is found, the search is retried
with the last pathname component.
.RS
.TP
.PD 0
\-\fBc\fP
Expect command names.
.TP
\-\fBf\fP
Expect filenames and filesystem paths.
.TP
\-\fBo\fP
Expect option names.
.TP
\-\fBv\fP
Expect variable names.
.TP
\-\fBb\fP
Expect key binding names.
.TP
\-\fBA\fP
Expect array names.
.TP
\-\fBI\fP
Expect integer variable names.
.TP
\-\fBF\fP
Expect function names.
.TP
\-\fBp\fP
Expect parameter names.
.TP
\-\fBE\fP
Expect environment variable names.
.TP
\-\fBj\fP
Expect job names (the first word of the job leader's command line, useful
with the \fBkill\fP builtin).
.TP
\-\fBr\fP
Expect names of running jobs.
.TP
\-\fBz\fP
Expect names of suspended jobs.
.TP
\-\fBB\fP
Expect names of builtin commands.
.TP
\-\fBa\fP
Expect alias names.
.TP
\-\fBR\fP
Expect names of regular aliases.
.TP
\-\fBG\fP
Expect names of global aliases.
.TP
\-\fBu\fP
Expect user names.
.TP
\-\fBd\fP
Expect names of disabled commands.
.TP
\-\fBe\fP
Expect names of executable (and enabled) commands.
.TP
\-\fBN\fP
Expect names of scalar parameters.
.TP
\-\fBO\fP
Expect names of readonly variables.
.TP
\-\fBZ\fP
Expect names of shell special parameters.
.TP
\-\fBn\fP
Expect named directories.
.TP
\-\fBq\fP
If given together with a suffix (see the \-\fBS\fP flag below) it
makes this suffix be removed if the next character typed is a blank or
does not insert anything (this is the same rule as used for the
\fBAUTO_REMOVE_SLASH\fP option).
.TP
\-\fBk\fP \fIname\fP
Expect names taken from the elements of \fB$name\fP (which should be
an array).  Alternatively, the
argument \fIname\fP itself may be a set of space- or comma-separated
values in parentheses, in which any delimiter may be escaped with a
backslash.  (Example: `compctl -k "(cputime filesize datasize stacksize
coredumpsize resident descriptors)" limit'.)
.TP
\-\fBK\fP \fIfunction\fP
Call the given function to get the completions.  The function gets two
arguments: the prefix and the suffix of the word on which completion
is tried.
The function should set the variable \fBreply\fP to an array
containing the completions (one completion per element); note that
\fBreply\fP should not be made local.  From such a function the
command line can be accessed with the \fB\-c\fP and \fB\-l\fP flags to
the \fBread\fP builtin.
(Example: `function whoson { reply=(`users`); };
compctl -K whoson talk' completes only logged-on users after `talk'.) Note
that whoson must return an array so that just "reply=`users`" is incorrect.
.TP
\-\fBX\fP \fIexplanation\fP
Print the explanation string when trying completion. A `%n' in
this string is replaced by the number of matches.
.TP
\-\fBP\fP \fIprefix\fP
The \fIprefix\fP is inserted just before the completed string; any
initial part already typed will be completed and the whole \fIprefix\fP
ignored for completion purposes. (Example: `compctl -j -P "%"
kill').
.TP
\-\fBS\fP \fIsuffix\fP
After a unique completion is found the \fIsuffix\fP is inserted after
the completed string.
.TP
\-\fBg\fP \fIglobstring\fP
The \fIglobstring\fP is expanded using filename globbing; it should be
quoted to protect it from immediate expansion. The resulting
filenames are taken as the possible completions.  Use `*(/)' instead of
`*/' for directories.  The \fBfignore\fP special parameter is not used.
More than one pattern may be given separated by blanks. (Note that
brace expansion is \fInot\fP part of globbing.)
.TP
\-\fBs\fP \fIsubststring\fP
The \fIsubstring\fP is split into words and these words are than
expanded using all shell expansion mechanisms. The resulting words are
taken as possible completions. The \fBfignore\fP special parameter is
\fInot\fP used.  Note that \-\fBg\fP is faster for filenames.
.TP
\-\fBH\fP \fInum pattern\fP
The possible completions are taken from the last \fInum\fP history
lines. Only words matching \fIpattern\fP are taken. If \fInum\fP is
zero or negative the whole history is searched and if \fIpattern\fP is
the empty string (or \fB'*'\fP, of course) all words are taken.
.TP
\-\fBl\fP \fIcmd\fP
This option can not be combined with any other option. If it is given
it restricts the range of command line words that are considered to be
arguments. By default this range contains all arguments without the
command string. If combined with extended completion (see below) and
one of the patterns 
`\fBp\fP[...]', `\fBr\fP[...]', or `\fBR\fP[...]' the range is
restricted to the arguments between the ones that are specified in the
brackets. After the range of arguments is determined completion is
done in it as if they were arguments to the \fIcmd\fP given with this
option. If this string is empty the first word in the range is taken
as the command name for which to complete. In this case, if the cursor
is in the first word, command names are completed.
Example: `compctl -x 'r[-exec,;]' -l '' -- find' completes the
arguments between `-exec' and the following `;' (or the end of the
command line if there is no such string) as if they were specifying a
command on there own.
.TP
\-\fBU\fP
Use the whole list of possible completions, whether or not they actually
match the word on the command line.  The word typed so far will be
deleted.  This is most useful with a function (\-\fBK\fP option), which
can examine the word via the \fBread\fP builtin's \-\fBc\fP and
\-\fBl\fP flags and use its own criterion to decide what matches.
.LP
.PD 0
.PP
The second form specifies alternative options. First completion is
tried with the options before the first `+'. If this produces no
matches completion is tried with the flags after the `+' and so on. If
there are no flags after the last `+' this means that default
completion is tried if no matches were found.
.LP
.PD 0
.PP
The third form specifies extended completion for the commands given as
\fIarg\fP. Each \fIpattern\fP is examined in turn; when a match is found,
the corresponding \fIflags\fP, as described above for the ordinary case,
are used to generate possible completions.  If no \fIpattern\fP matches,
the \fIflags\fP given before the \-\fBx\fP are used.  Note that each
pattern should be supplied as a single argument and should be
quoted to prevent expansion of metacharacters by the shell. A \fIpattern\fP
is built of sub\-patterns separated by commas; it matches if at least one of 
these sub\-patterns matches (they are `or'ed'). These sub\-patterns are in
turn composed of other sub\-patterns separated by white spaces which match
if all of the sub\-patterns match (they are `and'ed'). 
An element of the sub\-patterns is of the form 'c[...][...]', where
the pairs of brackets may be repeated as often as necessary, and matches
if any of the sets of brackets match (an `or').  These elements may be
any of the following:
.sp
.RS
.TP
.PD 0
\fBs\fP[\fIstring\fP] ...
The pattern matches if the current word on the command line starts with
one of the strings given in brackets.  The \fIstring\fP is not removed
and is not part of the completion.
.TP
\fBS\fP[\fIstring\fP] ...
Like \fBs\fP[\fIstring\fP] but the \fIstring\fP is part of the completion.
.TP
\fBp\fP[\fIfrom\fP,\fIto\fP] ...
The pattern matches if the number of the current word is between one of
the \fIfrom\fP and \fIto\fP pairs. The comma and \fIto\fP are optional;
\fIto\fP defaults to the same value as \fIfrom\fP. The numbers may be
negative: \fI\-n\fP refers to the \fIn\fP'th last word on the line.
.TP
\fBc\fP[\fIoffset\fP,\fIstring\fP] ...
The pattern matches if one of the \fIstring\fPs matches the word offset by
\fIoffset\fP from the current word position.
.TP
\fBC\fP[\fIoffset\fP,\fIpattern\fP] ...
This is like \fBc\fP but uses pattern matching instead.
.TP
\fBw\fP[\fIindex\fP,\fIstring\fP] ...
The pattern matches if the word in position \fIindex\fP is equal
to the corresponding \fIstring\fP.  Note that the word count is made
after alias expansion.
.TP
\fBW\fP[\fIindex\fP,\fIpattern\fP] ...
Like \fBw\fP but using pattern matching instead.
.TP
\fBn\fP[\fIindex\fP,\fIstring\fP] ...
Matches if the current word contains \fIstring\fP. Anything up to and
including the
\fIindex\fP'th occurrence of this string will not be considered part of
the completion, but the rest will.
.TP
\fBN\fP[\fIindex\fP,\fIstring\fP] ...
Like \fBn\fP[\fIindex\fP,\fIstring\fP] but the string will be taken as
a character class (anything up to and including the \fIindex\fP'th
occurrence of any 
of the characters in \fIstring\fP will not be considered part of the
completion).
.TP
\fBm\fP[\fImin\fP,\fImax\fP] ...
Matches if the total number of words lies between \fImin\fP and
\fImax\fP (inclusive).
.TP
\fBr\fP[\fIstr1\fP,\fIstr2\fP]...
Matches if the cursor is after a word with prefix \fIstr1\fP. If there
is also a word with prefix \fIstr2\fP on the command line it matches
only if the cursor is before this word.
.TP
\fBR\fP[\fIstr1\fP,\fIstr2\fP]...
Like \fBr\fP but using pattern matching instead.
.RE
.sp
.PD
Example:
.RS
.PP
.nf
compctl -u -x 's[+] c[-1,-f],s[-f+]' -g '~/Mail/*(:t)' \e
- 's[-f],c[-1,-f]' -f -- mail
.fi
.RE
.PP
Complete users by default.  After a -f with an optional space, complete
file names; if a + follows the -f, whether or not there is a space in
between, complete with the non-directory part of files in the directory
~/Mail.
.PD
.RE
.TP
\fBcontinue\fP [ \fInum\fP ]
Resume the next iteration of the enclosing
\fBfor\fP, \fBwhile\fP, \fBuntil\fP, \fBselect\fP, or
\fBrepeat\fP loop.  If \fIn\fP is specified, break out of
\fIn\fP \- 1 loops and resume at the \fIn\fPth enclosing loop.
.TP
\fBdeclare\fP [ \fIarg\fP ... ]
Same as \fBtypeset\fP.
.TP
\fBdirs\fP [ \-\fBv\fP ] [ \fIarg\fP ... ]
With no arguments, print the contents of the directory stack.
If the \-\fBv\fP option is given, number the directories
in the stack when printing.
Directories are added to this stack with the \fBpushd\fP command,
and removed with the \fBcd\fP or \fBpopd\fP commands.
If arguments are specified, load them onto the directory stack,
replacing anything that was there, and push the current directory
onto the stack.
.TP
\fBdisable\fP [ \-\fBm\fP ] \fIarg\fP ...
Disable the builtin \fIarg\fP temporarily.  This allows you to use
an external command with the same name as a shell builtin.
Without arguments all disabled builtins are printed, with the
\-\fBm\fP flag the arguments are taken as patterns (should be quoted
to preserve them from being taken as glob patterns) and all builtins
matching these patterns are disabled.
Actually the same as \fBunhash\fP.
Builtins can be enabled with the \fBenable\fP command.
.TP
\fBdisown\fP \fIjob\fP ...
Remove the specified jobs from the job table; the shell will
no longer report their status, and will not complain if you
try to exit an interactive shell with them running or stopped.
.TP
\fBecho\fP [ \-\fBn\fP ] [ \fIarg\fP ... ]
Write each \fIarg\fP on the standard output, with a space separating
each one.
If the \-\fBn\fP flag is not present, print a newline at the end.
\fBecho\fP recognizes the following escape sequences:
.RS
.PD 0
.TP
.B \ea
bell character
.TP
.B \eb
backspace
.TP
.B \ec
don't print an ending newline
.TP
.B \ee
escape
.TP
.B \ef
form feed
.TP
.B \en
newline
.TP
.B \er
carriage return
.TP
.B \et
horizontal tab
.TP
.B \ev
vertical tab
.TP
.B \e\e
backslash
.TP
.B \e0NNN
character code in octal, with a maximum of three digits after the
zero; a non-octal digit terminates the number
.TP
.B \exNN
character code in hexadecimal, with a maximum of two digits after the
`x'; a non-hexadecimal digit terminates the number.
.PD
.RE
.TP
\fBechotc\fP \fIcap\fP [ \fIarg\fP ... ]
Output the termcap string corresponding to the capability
\fIcap\fP, with optional arguments.
.TP
\fBenable\fP [ \-\fBm\fP ] \fIarg\fP ...
Enable the specified builtin commands, presumably disabled earlier
with \fBdisable\fP.
Without arguments the enabled builtins are printed and with the
\-\fBm\fP flag the arguments are taken as patterns (should be quoted)
and all builtins matching these patterns are enabled.
.TP
\fBeval\fP [ \fIarg\fP ... ]
Read the arguments as input to the shell and execute the resulting
command(s) in the current shell process.
.TP
\fBexit\fP [ \fIn\fP ]
Exit the shell with the exit code specified by \fIn\fP; if none
is specified, use the exit code from the last command executed.
An EOF condition will also cause the shell to exit, unless
the \fBIGNOREEOF\fP option is set.
.TP
\fBexport\fP [ \fIname\fP[=\fIvalue\fP] ... ]
The specified \fIname\fPs are marked for automatic export
to the environment of subsequently executed commands.
.TP
\fBfalse\fP
Do nothing and return an exit code of 1.
.TP
.PD 0
\fBfc\fP [ \-\fBe\fP \fIename\fP ] [ \-\fBnlrdDfEm\fP ] [ \fIold\fP=\fInew\fP ... ] [ \fIfirst\fP [ \fIlast\fP ] ]
.TP
\fBfc\fP \-\fBARWI\fP [ \fIfilename\fP ]
.PD
Select a range of commands from \fIfirst\fP to \fIlast\fP from the
history list.
The arguments \fIfirst\fP and \fIlast\fP may be specified as a
number or as a string.  A negative number is used as an offset
to the current history event number.
A string specifies the most recent event
beginning with the given string.
All substitutions \fIold\fP=\fInew\fP, if any, are then performed
on the commands.
If the \-\fBl\fP flag is given, the resulting commands are listed on
standard output.
If the \-\fBm\fP flag is also given the first argument is taken as a
pattern (should be quoted) and only the history events matching this
pattern will be shown.
Otherwise the editor program \fIename\fP is invoked on a file containing
these history events.  If \fIename\fP is not given, the value
of the parameter \fBFCEDIT\fP is used.  If \fIename\fP is "\-",
no editor is invoked.  When editing is complete, the edited
command(s) is executed.  
If \fIfirst\fP is not specified, it will be set to \-1 (the most recent
event), or to -16 if the \-\fBl\fP flag is given.
If \fIlast\fP is not specified, it will be set to \fIfirst\fP,
or to \-1 if the \-\fBl\fP flag is given.
The flag \-\fBr\fP reverses the order of the commands and the
flag \-\fBn\fP suppresses command numbers when listing.
Also when listing, \-\fBd\fP prints timestamps for each command, and
\-\fBf\fP prints full time-date stamps. Adding the \-\fBE\fP flag
causes the dates to be printed as `dd.mm.yyyy'.
With the \-\fBD\fP flag, \fBfc\fP prints elapsed times.
.RS
.PP
\fBfc\fP \-\fBR\fP reads the history from the given file,
\fBfc\fP \-\fBW\fP writes the history out to the given file,
and \fBfc\fP \-\fBA\fP appends the history out to the given file.
\fBfc\fP \-\fBAI\fP (\-\fBWI\fP) appends (writes) only those
events that are new since last incremental append (write) to
the history file. In any case the file will have no more than SAVEHIST
entries.
.RE
.TP
.PD 0
\fBfg\fP [ \fIjob\fP ... ]
.TP
\fIjob\fP ...
.PD
Bring the specified \fIjob\fPs to the foreground.
If no \fIjob\fP is specified, use the current job.
.TP
\fBfunctions\fP [ \(+-\fBtum\fP ] [ \fIname\fP ... ]
Equivalent to \fBtypeset\fP \-\fBf\fP.
.TP
\fBgetln\fP \fIname\fP ...
Read the top value from the buffer stack and put it in
the shell parameter \fIname\fP.  Equivalent to
\fBread\fP \-\fBzr\fP. The flags \-\fBc\fP, \-\fBl\fP, \-\fBA\fP,
\-\fBe\fP, \-\fBE\fP, and \-\fBn\fP are supported, too.
.TP
\fBgetopts\fP \fIoptstring\fP \fIname\fP [ \fIarg\fP ... ]
Checks \fBarg\fP for legal options.  If \fIarg\fP is omitted,
use the positional parameters.  A valid option argument
begins with a + or a \-.  An argument not beginning with
a + or a \-, or the argument \-\-, ends the options.
\fIoptstring\fP contains the letters that \fBgetopts\fP
recognizes.  If a letter is followed by a `:', that option
is expected to have an argument.  The options can be
separated from the argument by blanks.
.RS
.PP
Each time it is invoked, \fBgetopts\fP places the option letter it finds
in the shell parameter \fIname\fP, prepended with a + when
\fIarg\fP begins with a +.  The index of the next \fIarg\fP
is stored in \fBOPTIND\fP.  The option argument, if any,
is stored in \fBOPTARG\fP.
.PP
A leading : in \fIoptstring\fP causes \fBgetopts\fP to store the
letter of the invalid option in \fBOPTARG\fP, and to set \fIname\fP
to `?' for an unknown option and to `:' when a required option
is missing.  Otherwise, \fBgetopts\fP prints an error
message.  The exit status is nonzero when there are no more options.
.RE
.TP
\fBhash\fP \fIname\fP \fIpath\fP
Puts \fIname\fP in the command hash table, associating it with
the pathname \fIpath\fP.  Whenever \fIname\fP is used as a command
argument, the shell will try to execute the file given by \fIpath\fP.
.TP
\fBhistory\fP [ \-\fBnrdDfEm\fP ] [ \fIfirst\fP [ \fIlast\fP ] ]
Same as \fBfc\fP \-\fBl\fP.
.TP
\fBinteger\fP [ \(+-\fBlrtux\fP ] [ \fIname\fP[=\fIvalue\fP] ] ...
Same as \fBtypeset\fP \-\fBi\fP, except that options irrelevant to
integers are not permitted.
.TP
\fBjobs\fP [ \-\fBlprs\fP ] [ \fIjob\fP ... ]
Lists information about each given job, or all jobs
if \fIjob\fP is omitted.  The \-\fBl\fP flag lists process
ids, and the \-\fBp\fP flag lists process groups.
If the \-\fBr\fP flag is specified only running jobs will be listed
and if the \-\fBs\fP flag is given only stopped jobs are shown.
.TP
.PD 0
\fBkill\fP [ \-\fIsig\fP ] \fIjob\fP ...
.TP
\fBkill\fP \-\fBl\fP
.PD
Sends either SIGTERM or the specified signal to the given
jobs or processes.
Signals are given by number or by names
(with the prefix "SIG" removed).
If the signal being sent is not KILL or CONT, then the job
will be sent a CONT signal if it is stopped.
The argument \fIjob\fP can be the process id of a job
not in the job list.
In the second form, \fBkill\fP \-\fBl\fP, the signal names
are listed.
.TP
\fBlet\fP \fIarg\fP ...
Evaluate each \fIarg\fP as an arithmetic expression.
See \fBARITHMETIC EVALUATION\fP above for a description
of arithmetic expressions.  The exit status is 0 if the
value of the last expression is nonzero, and 1 otherwise.
.TP
.PD 0
\fBlimit\fP [ \-\fBh\fP ] [ \fIresource\fP [ \fIlimit\fP ] ] ...
.TP
\fBlimit\fP \-\fBs\fP
.PD
Limit the resource consumption of the current shell and its children.
If \fIlimit\fP is not specified, print the current limit placed
on \fIresource\fP; otherwise
set the limit to the specified value.  If the \-\fBh\fP flag
is given, use hard limits instead of soft limits.
If no \fIresource\fP is given, print all limits.
.RS
.PP
\fIresource\fP is one of:
.PP
.PD 0
.TP
.B cputime
Maximum CPU seconds per process.
.TP
.B filesize
Largest single file allowed.
.TP
.B datasize
Maximum data size (including stack) for each process.
.TP
.B stacksize
Maximum stack size for each process.
.TP
.B coredumpsize
Maximum size of a core dump.
.TP
.B resident
Maximum resident set size.
.TP
.B memoryuse
The same as resident.
.TP
.B memorylocked
Maximum amount of memory locked in RAM.
.TP
.B descriptors
Maximum value for a file descriptor.
.TP
.B openfiles
Maximum number of open files.
.TP
.B vmemorysize
Maximum amount of virtual memory.
.PD
.PP
Which of these resource limits are available depends on the system.
\fIlimit\fP is a number, with an optional scaling factor, as follows:
.PP
.PD 0
.TP
\fIn\fPh
hours.
.TP
\fIn\fPk
kilobytes. 
This is the default for all but cputime.
.TP
\fIn\fPm
megabytes or minutes.
.TP
\fImm\fP:\fIss\fP
minutes and seconds.
.PD
.RE
.TP
\fBlocal\fP [ \(+-\fBLRZilrtu [\fIn\fP]] [ \fIname\fP[=\fIvalue\fP] ] ...
Same as \fBtypeset\fP, except that the options \-\fBx\fP and
\-\fBf\fP are not permitted.
.TP
\fBlog\fP
List all users currently logged in who are affected by
the current setting of the \fBwatch\fP parameter.
.TP
\fBlogout\fP
Exit the shell, if this is a login shell.
.TP
\fBpopd\fP [ \(+-\fIn\fP ]
Removes entries from the directory stack.  With no arguments,
removes the top directory from the stack, and performs a \fBcd\fP
to the new top directory.  With an argument of the form +\fIn\fP,
remove the \fIn\fPth entry counting from the left of the list
shown by the \fBdirs\fP command, starting with zero, and change
to that directory.  With an argument of the form \-\fIn\fP,
remove the \fIn\fPth entry counting from the right.
If the \fBPUSHD_MINUS\fP option is set, the meanings of +
and \- in this context are swapped.
.TP
\fBprint\fP [ \-\fBRnrslzpNDPoOic\fP ] [ \-\fBu\fP\fIn\fP ] [ \fIarg\fP ... ]
With no flags or with flag \-, the arguments are printed on
the standard output as described by \fBecho\fP, with the following differences:
the escape sequence \eM\-x metafies the character \fBx\fP (sets the highest
bit), \eC\-x produces a control character (\eC\-@ and \eC-? give the
characters NULL and delete) and \eE is a synonym for \ee.
Finally, if not in an escape
sequence, \e escapes the following character and is not printed.
.RS
.PD 0
.TP
\-\fBR\fP, \-\fBr\fP
ignore the escape conventions of \fBecho\fP.
The \-\fBR\fP option will print all subsequent
arguments and options.
.TP
\-\fBs\fP
place the results in the history list instead of on the standard output.
.TP
\-\fBn\fP
do not add a newline to the output.
.TP
\-\fBl\fP
print the arguments separated by newlines instead of spaces.
.TP
\-\fBN\fP
print the arguments separated and terminated by nulls.
.TP
\-\fBo\fP
print the arguments sorted in ascending order.
.TP
\-\fBO\fP
print the arguments sorted in descending order.
.TP
\-\fBi\fP
if given together with \-\fBo\fP or \-\fBO\fP makes them work case
independently
.TP
\-\fBc\fP
print the arguments in columns
.TP
\-\fBu\fP\fIn\fP
print the arguments to file descriptor \fIn\fP.
.TP
\-\fBp\fP
print the arguments to the input of the coprocess.
.TP
\-\fBz\fP
push the arguments onto the editing buffer stack, separated by spaces;
no escape sequences are recognized.
.TP
\-\fBD\fP
treat the arguments as directory names, replacing prefixes with ~
expressions, as appropriate.
.TP
\-\fBP\fP
recognize the same escape sequences as in the \fBPROMPT\fP parameter.
.PD
.RE
.TP
.PD 0
\fBpushd\fP [ \fIarg\fP ]
.TP
\fBpushd\fP \fIold\fP \fInew\fP
.TP
\fBpushd\fP \(+-\fBn\fP
.PD
Change the current directory, and push the old current directory
onto the directory stack.  In the first form, change the
current directory to \fIarg\fP.
If \fIarg\fP is not specified, change to the second directory
on the stack (that is, exchange the top two entries), or
change to the value of \fBHOME\fP if the \fBPUSHD_TO_HOME\fP
option is set or if there is only one entry on the stack.
If \fIarg\fP is \-, change to the
value of \fBOLDPWD\fP, the previous directory.
If a directory named \fIarg\fP is not found in the current directory
and \fIarg\fP does not contain a slash,
search each component of the shell parameter \fBcdpath\fP.
If the option \fBCDABLEVARS\fP is set, and a parameter named \fIarg\fP
exists whose value begins with a slash, treat its value as
the directory.
If the option \fBPUSHD_SILENT\fP is not set, the directory
stack will be printed after a \fBpushd\fP is performed.
.RS
.PP
The second form of \fBpushd\fP substitutes the string \fInew\fP
for the string \fIold\fP in the name of the current directory,
and tries to change to this new directory.
.PP
The third form of \fBpushd\fP is equivalent to \fBpopd\fP.
.RE
.TP
\fBpushln\fP
Equivalent to \fBprint \-nZ\fP.
.TP
\fBpwd\fP
Equivalent to \fBprint \-R $PWD\fP.
.TP
\fBr\fP
Equivalent to \fBfc \-e \-\fP.
.TP
\fBread\fP [ \-\fBrzpqAclneE\fP ] [ -k [ \fInum\fP ] ] [ \-\fBu\fIn\fR ] [ \fIname\fP?\fIprompt\fP ] [ \fIname\fP ...  ]
Read one line and break it into fields using the characters
in \fBIFS\fP as separators.  In raw mode, \-\fBr\fP, a \e
at the end of a line does not signify line continuation.
With the \-\fBq\fP flag read only one character and set \fIname\fP to
`y' if this character was `y' or `Y' and to `n' otherwise.  With this
flag set the return value is zero only if the character was `y' or `Y'.
If the \-\fBk\fP flag is given read only one (or \fInum\fP) characters.
If the \-\fBz\fP flag is set, read from the editor buffer stack.
The first field is assigned to the first \fIname\fP, the second field
to the second \fIname\fP, etc., with leftover
fields assigned to the last \fIname\fP.
If the \-\fBe\fP or the \-\fBE\fP flag is given, the words read are
printed after the whole line is read. If the \-\fBe\fP flag is set,
the words are not assigned to the parameters.
If the \-\fBA\fP flag is set, the first \fIname\fP is taken as the
name of an array and all words are assigned to it.
The \-\fBc\fP and \-\fBl\fP flags are allowed only if called inside a
function used for completion (specified with the \-\fBK\fP flag to
\fBcompctl\fP). If the \-\fBc\fP flag is given, the words of the
current command are read. If the \-\fBl\fP flag is given, the whole
line is assigned as a scalar. Together with the \-\fBn\fP flag these
options give the number of the word the cursor is on and the index of
the character the cursor is on respectively.
If \fIname\fP is omitted then \fBREPLY\fP is used for scalars and
\fBreply\fP for arrays.
If \-\fBu\fIn\fR is specified, then input is read from file
descriptor \fIn\fP; if \-\fBp\fP is specified, then input is
read from the coprocess.
If the first argument contains a \fB?\fP, the remainder of this
word is used as a \fIprompt\fP on standard error when the shell
is interactive.  The exit status is 0 unless an end-of-file
is encountered.
.TP
\fBreadonly\fP [ \fIname\fP[=\fIvalue\fP] ] ...
The given \fInames\fP are marked readonly; these names
cannot be changed by subsequent assignment.
.TP
\fBrehash\fP [ \-\fBf\fP ]
Throw out the command hash table and start over.
If the \-\fBf\fP option is set, rescan the command path
immediately, instead of rebuilding the hash table incrementally.
.TP
\fBreturn\fP [ \fIn\fP ]
Causes a shell function or \fB\&.\fP script to return to
the invoking script
with the return status specified by \fIn\fP.  If \fIn\fP
is omitted then the return status is that of the last command
executed.
.RS
.PP
If \fBreturn\fP was executed from a trap, whether set by the \fBtrap\fP
builtin or by defining a \fBTRAPxxx\fP function, the effect is different
for zero and non-zero return status.  With zero status (or after an
implicit return at the end of the trap), the shell will return to
whatever it was previously processing; with a non-zero status, the shell
will behave as interrupted except that the return status of the trap is
retained.  Note that the signal which caused the trap is passed as the
first argument, so the statement `\fBreturn $[128+$1]\fP' will return
the same status as if the signal had not been trapped.
.RE
.TP
.PD 0
\fBsched\fP [+]\fIhh\fP:\fImm\fP \fIcommand\fP ...
.TP
\fBsched\fP [ \-\fIitem\fP ]
.PD
Make an entry in the scheduled list of commands to execute.
The time may be specified in either absolute or relative time.
With no arguments, prints the list of scheduled commands.
With the argument \-\fIitem\fP, removes the given item
from the list.
.TP
\fBset\fP [ \(+-\fIoptions\fP ] [ \(+-\fBo\fP \fIoption name\fP ] ... [ \-\fBA\fP [\fIname\fP] ] [ \fIarg\fP ] ...
Set the options for the shell and/or set the positional parameters, or
declare an array.  For the meaning of the flags, see
\fBOPTIONS\fP above.
Flags may be specified by name using the \-\fBo\fP option.
If the \-\fBA\fP flag is specified, \fIname\fP is set to an
array containing the given \fIarg\fPs; if no \fIname\fP is specified,
all arrays are printed. Otherwise the positional parameters are set.
If no arguments are given, then the names and values
of all parameters are printed on the standard output.
If the only argument is +, the names of all parameters are printed.
.TP
\fBsetopt\fP [ \(+-\fIoptions\fP ] [ \fIname\fP ... ]
Set the options for the shell.  All options specified either
with flags or by name are set.  If no arguments are supplied,
the names of all options currently set are printed.
In option names, case is insignificant, and all underscore
characters are ignored.
If the \-\fBm\fP flag is given the arguments are taken as patterns
(should be quoted to preserve them from being interpreted as glob
patterns) and all options with names matching these patterns are set.
.TP
\fBshift\fP [ \fIn\fP ] [ \fIname\fP ... ]
The positional parameters from $\fIn\fP+\fB1\fP ... are renamed
$\fB1\fP, where \fIn\fP is an arithmetic expression that
defaults to 1.
If any \fIname\fPs are given then the arrays with these names are
shifted instead of the positional parameters.
.TP
\fBsource\fP
Same as \fB.\fP, except that the current directory is always searched and
is always searched first, before directories in \fBpath\fP.
.TP
\fBsuspend\fP [ \-\fBf\fP ]
Suspend the execution of the shell (send it a \fBSIGTSTP\fP)
until it receives a \fBSIGCONT\fP.
If the \-\fBf\fP option is not given, complain if this is a login shell.
.TP
.PD 0
\fBtest\fP \fIarg\fP ...
.TP
\fB[\fP \fIarg\fP ... \fB]\fP
.PD
Like the system version of \fBtest\fP.  Added for compatibility;
use conditional expressions instead.
.TP
\fBtimes\fP
Print the accumulated user and system times for the shell
and for processes run from the shell.
.TP
\fBtrap\fP [ \fIarg\fP ] [ \fIsig\fP ] ...
\fIarg\fP is a command to be read and executed when the shell
receives \fIsig\fP.  Each \fIsig\fP can be given as a number
or as the name of a signal.  Inside the command, $1 refers to the number
of the signal which caused the trap.
If \fIarg\fP is \-, then all traps \fIsig\fP are reset to their
default values.  If \fIarg\fP is the null string, then this signal
is ignored by the shell and by the commands it invokes.
If \fIsig\fP is \fBZERR\fP then \fIarg\fP will be executed
after each command with a nonzero exit status.
If \fIsig\fP is \fBDEBUG\fP then \fIarg\fP will be executed
after each command.
If \fIsig\fP is \fB0\fP or \fBEXIT\fP
and the \fBtrap\fP statement is executed inside the body of a function,
then the command \fIarg\fP is executed after the function completes.
If \fIsig\fP is \fB0\fP or \fBEXIT\fP
and the \fBtrap\fP statement is not executed inside the body of a function,
then the command \fIarg\fP is executed when the shell terminates.
The \fBtrap\fP command with no arguments prints a list of commands
associated with each signal.
.TP
\fBtrue\fP
Do nothing and return an exit code of 0.
.TP
\fBttyctl\fP \-\fBfu\fP
The \-\fBf\fP option freezes the tty, and \-\fBu\fP unfreezes it.
When the tty is frozen, no changes made to the tty settings by
external programs will be honored by the shell, except for changes in the
size of the screen; the shell will
simply reset the settings to their previous values as soon as each
command exits or is suspended.  Thus, \fBstty\fP and similar programs have
no effect when the tty is frozen. Without options it reports whether the
terminal is frozen or not.
.TP
\fBtype\fP
Same as \fBwhence\fP \-\fBv\fP.
.TP
\fBtypeset\fP [ \(+-\fBLRZfilrtuxm [\fIn\fP]] [ \fIname\fP[=\fIvalue\fP] ] ...
Set attributes and values for shell parameters.
When invoked inside a function a new parameter is created which will be
unset when the function completes.  The new parameter will not be
exported unless ALLEXPORT is set, in which case the parameter will be
exported provided no parameter of that name already exists.
The following attributes are valid:
.RS
.PD 0
.TP
\-\fBL\fP
Left justify and remove leading blanks from \fIvalue\fP.
If \fIn\fP is nonzero, it defines the width of the field;
otherwise it is determined by the width of the value of the first
assignment.
When the parameter is printed, it is filled on the right with
blanks or truncated if necessary to fit the field.
Leading zeros are removed if the \-\fBZ\fP flag is also set.
.TP
\-\fBR\fP
Right justify and fill with leading blanks.  If \fIn\fP is nonzero
if defines the width of the field;
otherwise it is determined by the width of the value of the first
assignment.
When the parameter is printed, the field is left filled with
blanks or truncated from the end.
.TP
\-\fBZ\fP
Right justify and fill with leading zeros if the first non-blank
character is a digit and the \-\fBL\fP flag has not been set.
If \fIn\fP is nonzero it defines the width of the field;
otherwise it is determined by the width of the value of the
first assignment.
.TP
\-\fBf\fP
The names refer to functions rather than parameters.  No assignments
can be made, and the only other valid flags are \-\fBt\fP
and \-\fBu\fP.  The flag \-\fBt\fP turns on execution tracing for this
function.  The flag \-\fBu\fP causes this function to be marked
for autoloading.  The \fBfpath\fP parameter will be searched to find the
function definition when the function is first referenced.
.TP
\-\fBi\fP
Use an internal integer representation.  If \fIn\fP is nonzero
it defines the output arithmetic base, otherwise it is determined by the first
assignment.
.TP
\-\fBl\fP
Convert to lower case.
.TP
\-\fBr\fP
The given \fIname\fPs are marked readonly.
.TP
\-\fBt\fP
Tags the named parameters.  Tags have no special meaning to the shell.
.TP
\-\fBu\fP
Convert to upper case.
.TP
\-\fBx\fP
Mark for automatic export to the environment of subsequently
executed commands.
.TP
.RE
.PD
.PP
Using + rather than \- causes these flags to be turned off.
If no arguments are given but flags are specified,
a list of named parameters which have these flags set is printed.
Using + instead of \- keeps their values from being printed.
If no arguments or options are given, the names and attributes
of all parameters are printed. If only the \-\fBm\fP flag is given the
arguments are taken as patterns (should be quoted) and all parameters
or functions (with the \-\fBf\fP flag) with matching names are printed.
.TP
\fBulimit\fP [ \-\fBHacdflmnopstv\fP ] [ \fIlimit\fP ]
Set or display a resource limit. When setting a limit it will apply to the
children of the shell but not to the shell itself. The value of limit can be a
number in the unit specified below or the value \fBunlimited\fP.  If the
\fBH\fP flag is given use hard limits instead of soft limits.
.RS
.PD 0
.TP
\-\fBa\fP
Lists all of the current resource limits.
.TP
\-\fBc\fP
The number of 512-byte blocks on the size of core dumps.
.TP
\-\fBd\fP
The number of K-bytes on the size of the data segment.
.TP
\-\fBf\fP
The number of 512-byte blocks on the size of files written.
.TP
\-\fBl\fP
The number of K-bytes on the size of locked-in memory.
.TP
\-\fBm\fP
The number of K-bytes on the size of physical memory.
.TP
\-\fBn\fP
The number of file descriptors.
.TP
\-\fBo\fP
The number of open files.
.TP
\-\fBp\fP
The number of processes.
.TP
\-\fBs\fP
The number of K-bytes on the size of the stack.
.TP
\-\fBt\fP
The number of CPU seconds to be used.
.TP
\-\fBv\fP
The number of K-bytes on the size of virtual memory.
.RE
.PD
.TP
\fBumask\fP [ \fImask\fP ]
The umask is set to \fImask\fP.  \fImask\fP can be either
an octal number or a symbolic value as described in \fBchmod\fP(1).
If \fImask\fP is omitted, the current value is printed.  Note that in
the symbolic form the permissions you specify are those which are to be
allowed (not denied) to the users specified.
.TP
\fBunalias\fP [ \-\fBm\fP ] \fIname\fP ...
The alias definition, if any, for each \fIname\fP is removed.
With the \-\fBm\fP flag the arguments are taken as patterns (should be
quoted) and all aliases with matching names are removed.
.TP
\fBunfunction\fP [ \-\fBm\fP ] \fIname\fP ...
The function definition, if any, for each \fIname\fP is removed.
If the \-\fBm\fP flag is specified the arguments are taken as patterns
(should be quoted) and all functions with matching names are removed.
.TP
\fBunhash\fP [ \-\fBm\fP ] \fIname\fP ...
The entry in the command hash table, if any, for each \fIname\fP
is removed. If the \-\fBm\fP flag is given the arguments are taken as
patterns (should be quoted) and all entries for commands with matching
names will be removed.
.TP
\fBunlimit\fP [ \-\fBh\fP ] \fIresource\fP ...
The resource limit for each \fIresource\fP is set to the hard limit.
If the \-\fBh\fP flag is given and the shell is running as root,
the hard resource limit for each \fIresource\fP is removed.
.TP
\fBunset\fP [ \-\fBm\fP ] \fIname\fP ...
Each named parameter is unset. If the \-\fBm\fP flag is specified the
arguments are taken as patterns (should be quoted) and all parameters
with matching names are unset.
.TP
\fBunsetopt\fP [ \(+-\fIoptions\fP ] [ \fIname\fP ... ]
Unset the options for the shell.  All options specified either
with flags or by name are unset. If the \-\fBm\fP flag is given the
arguments are considered to be patterns (don't forget to quote them)
and all options with names matching these patterns are unset.
.TP
\fBvared\fP [ \-\fBc\fP ] [ \-\fBp\fP \fIprompt\fP ] [ \-\fBr\fP \fIrprompt\fP ] \fIname\fP
The value of the parameter \fIname\fP is loaded into the edit
buffer, and the line editor is invoked.  When the editor exits,
\fIname\fP is set to the string value returned by the editor.
If the \-\fBc\fP flag is given the parameter is created if it doesn't
already exist.
If the \-\fBp\fP flag is given the following string will be taken as
the prompt to display at the left and if the \-\fBr\fP flag is given
the following string gives the prompt to display at the right.
.TP
\fBwait\fP [ \fIjob\fP ... ]
Wait for the specified jobs or processes.  If \fIjob\fP is not given
then all currently active child processes are waited for.
Each \fIjob\fP can be either a job specification or the process-id
of a job in the job table.
The exit status from this command is that of the job waited for.
.TP
\fBwhence\fP [ \-\fBacpvm\fP ] \fIname\fP ...
For each name, indicate how it would be interpreted if used
as a command name.  The \-\fBv\fP flag produces a more verbose
report.  The \-\fBp\fP flag does a path search for \fIname\fP
even if it is a shell function, alias, or reserved word.
The \-\fBc\fP flag prints the results in a csh-like format.
The \-\fBa\fP flag does a search for all occurrences of \fIname\fP
throughout the command path.
With the \-\fBm\fP flag the arguments are taken as patterns (should be
quoted) and the information is displayed for each command matching one
of these patterns.
.TP
\fBwhich\fP
Same as \fBwhence \-c\fP.
.RE
.SH INVOCATION
Commands are first read from /etc/zshenv.
If the \-\fBf\fP flag is present or if the \fBNO_RCS\fP option is set
within /etc/zshenv, all other
initialization files are skipped.
Otherwise, commands are read
from $ZDOTDIR/.zshenv.
(If \fBZDOTDIR\fP is unset, \fBHOME\fP is used instead).
If the first character of argument zero passed to the shell
is \-, or if the \-\fBl\fP flag is present, then the shell is
assumed to be a login shell, and commands
are read from /etc/zprofile and then $ZDOTDIR/.zprofile.
Then, if the shell is interactive,
commands are read from /etc/zshrc and then $ZDOTDIR/.zshrc.
Finally, if the shell is a login shell, /etc/zlogin and $ZDOTDIR/.zlogin
are read.
.PP
If the \-\fBs\fP flag is not present and an argument is given,
the first argument is taken to be the pathname of a script to
execute.  The remaining arguments are assigned to the positional
parameters.  The following flags are interpreted by the shell
when invoked:
.TP
.PD 0
\-\fBc\fP \fIstring\fP
Read commands from \fIstring\fP.
.TP
\-\fBs\fP
Read command from the standard input.
.TP
\-\fBi\fP
If this flag is present or the shell input and output
are attached to a terminal, this shell is interactive.
.PD
.SH "SEE ALSO"
sh(1),
csh(1),
tcsh(1),
itcsh(1),
rc(1),
bash(1),
ash(1),
ksh(1),
clam(1),
strftime(3).
.SH FILES
$ZDOTDIR/.zshenv
.br
$ZDOTDIR/.zprofile
.br
$ZDOTDIR/.zshrc
.br
$ZDOTDIR/.zlogin
.br
$ZDOTDIR/.zlogout
.br
/tmp/zsh*
.br
/etc/zshenv
.br
/etc/zprofile
.br
/etc/zshrc
.br
/etc/zlogin
.SH AUTHOR
Paul Falstad (pf@z-code.com)
.br
Programmable completion was implemented by Sven Wischnowsky
(oberon@cs.tu-berlin.de) and Peter Stephenson (pws@s-a.amtp.liv.ac.uk).
.SH AVAILABILITY
The latest official release of zsh is available via anonymous ftp at
ftp.sterling.com:/zsh (US) and carlo.phys.uva.nl:/pub/bas/zsh
(Europe).
.SH "UNDOCUMENTED FEATURES"
Known only to the recipients of the zsh mailing list,
zsh-list@sterling.com.  If you run into problems, please send your
questions and patches to the mailing list. To subscribe to zsh-list,
send an email message with body "subscribe zsh-list" to the address
"Majordomo@sterling.com".
                                                                                                                                                                                                                                                                                                                                                                                                    f .       ..     g c2z    h‹lete2ctl £‹¸                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        #! /bin/sh
#
# c2z - environment conversion tool
# Contributed by Bart Schaefer
# (Tweaked a bit by Paul Falstad)
#
# This is a quick script to convert csh aliases to zsh aliases/functions.
# It also converts the csh environment and local variables to zsh.  c2z
# uses the csh to parse its own dot-files, then processes csh output to
# convert the csh settings to zsh.
#
# When run as a zsh fuction, c2z runs csh as if it were an interactive
# shell whenever the parent zsh is interactive.  When run as a shell
# script, the -i switch can be used to force this behavior.
#
# The -l (login) switch causes csh to run as if it were a login shell.
# This is done "properly" if c2z is used as a zsh function, otherwise
# it's faked by explicitly sourcing .login.  Use with caution if your
# .login initializes an X server or does other one-time-only startup
# procedures.
#
# usage:
#	c2z [-i] [-l]
#
# You can use this script in your .zshrc or .zlogin files to load your
# regular csh environment into zsh; for example, in .zlogin:
#
#	. =(c2z -l)
#
# This is not perfect, but it gets most common aliases and variables.
# It's also rather time-consuming to do this every time you log in.
# However, if you're moving from csh to zsh for the first time, this
# can get you started with a familiar environment right away.
#
# In case your mailer eats tabs, $T is set to expand to a tab.
#
T="`echo x | tr x '\011'`"

# If we're zsh, we can run "- csh" to get the complete environment.
#
MINUS=""
LOGIN=""
INTERACT=""
case "$VERSION" in
zsh*)
    case $1 in
    -l*) MINUS="-" ;;
    -i*) INTERACT="-i" ;;
    esac
    if [[ -o INTERACTIVE ]]; then INTERACT="-i"; fi
    setopt nobanghist
    ;;
*)
    case $1 in
    -l*) LOGIN="source ~/.login" ;;
    -i*) INTERACT="-i" ;;
    esac
    ;;
esac

( eval $MINUS csh $INTERACT ) <<EOF 2>&1 >/dev/null
$LOGIN
alias >! /tmp/cz$$.a
setenv >! /tmp/cz$$.e
set >! /tmp/cz$$.v
EOF

# save stdin
exec 9<&0

# First convert aliases
exec < /tmp/cz$$.a

# Taken straight from ctoz except for $T and "alias --"
sed -e 's/'"$T"'(\(.*\))/'"$T"'\1/' >/tmp/cz$$.1
grep ! /tmp/cz$$.1 >/tmp/cz$$.2
grep -v ! /tmp/cz$$.1 >/tmp/cz$$.3
sed -e "s/'/'"\\\\"''"/g \
    -e 's/^\([^'"$T"']*\)'"$T"'\(.*\)$/alias -- \1='"'\2'/" \
    /tmp/cz$$.3
sed -e 's/![:#]*/$/g' \
    -e 's/^\([^'"$T"']*\)'"$T"'\(.*\)$/\1 () { \2 }/' \
    /tmp/cz$$.2

# Next, convert environment variables
exec < /tmp/cz$$.e

# Would be nice to deal with embedded newlines, e.g. in TERMCAP, but ...
sed -e '/^SHLVL/d' \
    -e "s/'/'"\\\\"''"/g \
    -e "s/^\([A-Za-z0-9_]*=\)/export \1'/" \
    -e "s/$/'/"

# Finally, convert local variables
exec < /tmp/cz$$.v

sed -e 's/'"$T"'/=/' \
    -e "s/'/'"\\\\"''"/g \
    -e '/^[A-Za-z0-9_]*=[^(]/{
	s/=/='"'/"'
	s/$/'"'/"'
	}' |
sed -e '/^argv=/d' -e '/^cwd=/d' -e '/^filec=/d' -e '/^status=/d' \
	 -e '/^histchars=/s//HISTCHARS=/' \
	 -e '/^history=/s//HISTSIZE=/' \
	 -e '/^home=/s//HOME=/' \
	 -e '/^ignoreeof=/s/.*/setopt ignoreeof/' \
	 -e '/^noclobber=/s/.*/setopt noclobber/' \
	 -e '/^notify=/d' \
	 -e '/^showdots=/s/.*/setopt globdots/' \
    -e '/^savehist=/s//HISTFILE=\~\/.zhistory SAVEHIST=/' \
	 -e '/^autolist=/s/.*/setopt autolist/' \
	 -e '/^correct=[cmd]*/s//setopt autocorrect/' \
	 -e '/^who=/s//WATCHFMT=/'


exec 0<&9

rm /tmp/cz$$.?
exit
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             h pattern
			($defmatch = '*') || ($pat = "W[0,$defmatch] $pat");
			push(@defaultword,defined($suffix) ?
			     "'$pat' $type -S '$suffix'" : "'$pat' $type");
		    }
		} else {
		    # Ordinary command
		    push(@stuff,defined($suffix) ?
			 "'$pat' $type -S '$suffix'" : "'$pat' $type");
		}
	    }
	}
        if (!defined($defmatch)) {
	    # Ordinary commands with no pattern
	    print("compctl $default");
	    defined($defsuf) && print("-S '$defsuf' ") && undef($defsuf);
	    defined(@stuff) && print("-x @stuff -- ");
	    print("$command\n");
	}
	if (defined($genfunc)) {
	    print $genfunc;
	    undef($genfunc);
	}
    }
}

(defined(@commandword) || defined($defcommand)) &&
    print("compctl -C ",
	  defined($defcommand) ? $defcommand : '-c',
	  defined(@commandword) ? " -x @commandword\n" : "\n");

if (defined($defaultdefault) || defined(@defaultword)) {
    defined($defaultdefault) || ($defaultdefault = "-f");
    print "compctl -D $defaultdefault";
    defined(@defaultword) && print(" -x @defaultword");
    print "\n";
}

__END__
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #!/usr/local/bin/perl -- -*-perl-*-
#
#   ``Wee have also Shelles, thee Lyke of whych you knowe not, wherein
#     thee User may with thee merest Presse of thee Tabbe-Keye expande
#     or compleat al Maner of Wordes and such-like Diversities.''
#            - Francis Bacon, `New Atlantis' (or not).
#
# Convert tcsh "complete" statements to zsh "compctl" statements.
# Runs as a filter.  Should ignore anything which isn't a "complete".
# It expects each "complete" statement to be the first thing on a line.
# All the examples in the tcsh manual give sensible results.
# Author:  Peter Stephenson <pws@s-a.amtp.liv.ac.uk>
#
# Option:
# -x (exact): only applies in the case of command disambiguation (is
#    that really a word?)  If you have lines like
#       complete '-co*' 'p/0/(compress)'
#    (which makes co<TAB> always complete to `compress') then the
#    resulting "compctl" statements will produce one of two behaviours:
#    (1) By default (like tcsh), com<TAB> etc. will also complete to
#        "compress" and nothing else.
#    (2) With -x, com<TAB> does ordinary command completion: this is
#        more flexible.
#    I don't understand what the hyphen in complete does and I've ignored it.
#
# Notes:
# (1) The -s option is the way to do backquote expansion.  In zsh,
#     "compctl -s '`users`' talk" works (duplicates are removed).
# (2) Complicated backquote completions should definitely be rewritten as
#     shell functions (compctl's "-K func" option).  Although most of
#     these will be translated correctly, differences in shell syntax
#     are not handled.
# (3) Replacement of $:n with the n'th word on the current line with
#     backquote expansion now works; it is not necessarily the most
#     efficient way of doing it in any given case, however.
# (4) I have made use of zsh's more sophisticated globbing to change
#     things like ^foo.{a,b,c,d} to ^foo.(a|b|c|d), which works better.
#     It's just possible in some cases you may want to change it back.
# (5) Make sure all command names with wildcards are processed together --
#     they need to be lumped into one "compctl -C" or "compctl -D"
#     statement for zsh.

# Handle options
($ARGV[0] eq '-x') && shift && ($opt_x = 1);
($ARGV[0] =~ /^-+$/) && shift;

# Function names used (via magic autoincrement) when cmdline words are needed
$funcnam = 'compfn001';

# Read next word on command line
sub getword {
    local($word, $word2, $ret);
    ($_) = /^\s*(.*)$/;
    while ($_ =~ /^\S/) {
	if (/^[\']/) {
	    ($word, $_) = /^\'([^\']*).(.*)$/;
	} elsif (/^[\"]/) {
	    ($word, $_) = /^\"([^\"]*).(.*)$/;
	    while ($word =~ /\\$/) {
		chop($word);
		($word2, $_) = /^([^\"]*).(.*)$/;
		$word .= '"' . $word2;
	    }
	} elsif (/\S/) {
	    ($word, $_) = /^([^\s\\\'\"#;]*)(.*)$/;
	    # Backslash: literal next character
	    /^\\(.)/ && (($word .= substr($_,1,1)),
			 ($_ = substr($_,2)));
	    # Rest of line quoted or end of command
	    /^[#;]/ && ($_ = '');
	} else {
	    return undef;
	}
	length($word) && ($ret = $ret . $word);
    }
    $ret;
}

# Interpret the x and arg in 'x/arg/type/'
sub getpat {
    local($pat,$arg) = @_;
    local($ret,$i);
    if ($pat eq 'p') {
	$ret = "p[$arg]";
    } elsif ($pat eq 'n' || $pat eq 'N') {
	$let = ($arg =~ /[*?|]/) ? 'C' : 'c';
	$num = ($pat eq 'N') ? 2 : 1;
	$ret = "${let}[-${num},$arg]";
    } elsif ($pat eq 'c' || $pat eq 'C') {
	# A few tricks to get zsh to ignore up to the end of
	# any matched pattern.
	if (($pat eq 'c' && $arg =~ /^\*([^*?]*)$/)) {
	    $ret = "n[-1,$1]";
	} elsif ($arg =~ /[*?]([^*?]*)$/) {
	    length($1) && ($ret = " n[-1,$1]");
	    $ret = "C[0,$arg] $ret";
	} else {
	    $let = ($pat eq 'c') ? 's' : 'S';
	    $ret = "${let}[$arg]";
	}
    }
    $ret =~ s/'/'\\''/g;
    $ret;
}

# Interpret the type in 'x/arg/type/'
sub gettype {
    local ($_) = @_;
    local($qual,$c,$glob,$ret,$b,$m,$e,@m);
    $c = substr($_,0,1);
    ($c =~ /\w/) && (substr($_,1,1) eq ':') && ($glob = substr($_,2));
# Nothing (n) can be handled by returning nothing.  (C.f. King Lear, I.i.)
    if ($c =~ /[abcjuv]/) {
	$ret = "-$c";
    } elsif ($c eq 'S') {
	$ret = '-k signals';
    } elsif ($c eq 'd') {
	$qual = '/';
    } elsif ($c eq 'e') {
	$ret = '-E';
    } elsif ($c eq 'f' && !$glob) {
	$ret = '-f';
    } elsif ($c eq 'l') {
	$ret = qq
-k  '(cputime filesize datasize stacksize coredumpsize resident descriptors)'
    ;
    } elsif ($c eq 'p') {
	# Use globbing, but make sure there's a star at the end
	($glob =~ /\*$/) || ($glob .= '*');
    } elsif ($c eq 's') {
	$ret = '-p';
    } elsif ($c eq 't') {
	$qual = '.';
    } elsif ($c eq 'x') {
	$glob =~ s/'/'\\''/g;
	$ret = "-X '$glob'";
	undef($glob);
    } elsif ($c eq '$') {     # '{
	$ret = "-k " . substr($_,1);
    } elsif ($c eq '(') {
	s/'/'\\''/g;
	$ret = "-k '$_'";
    } elsif ($c eq '`') {
	# this took some working out...
	if (s/\$:(\d+)/$foo=$1+1,"\${word[$foo]}"/ge) {
	    $ret = "-K $funcnam";
	    $genfunc .= <<"HERE";
function $funcnam {
    local word
    read -cA word
    reply=($_)
}
HERE
	    $funcnam++;
	} else {
	    s/'/'\\''/g;
	    $ret = "-s '$_'";
	}
    }

    # foo{bar,ba,blak,sheap} -> foo(bar|ba|blak|sheap).
    # This saves a lot of mess, since in zsh brace expansion occurs
    # before globbing.  I'm sorry, but I don't trust $` and $'.
    while ((($b,$m,$e) = ($glob =~ /^(.*)\{(.*)\}(.*)$/))
	   && ($m =~ /,/)) {
	@m = split(/,/, $m);
	for ($i = 0; $i < @m; $i++) {
	    while ($m[$i] =~ /\\$/) {
		substr($m[$i],-1,1) = "";
		splice(@m,$i,2,"$m[$i]\\,$m[$i+1]");
	    }
	}
	$glob = $b . "(" . join('|',@m) . ")" . $e;
    }

    if ($qual) {
	$glob || ($glob = '*');
	$glob .= "($qual)";
    }
    $glob && (($glob =~ s/'/'\\''/g),($glob = "-g '$glob'"));

    defined($ret) && defined($glob) && ($ret .= " $glob");
    defined($ret) ? $ret : $glob;
}

# Quoted array separator for extended completions
$" = " - ";

while (<>) {
    if (/^\s*complete\s/) {
	$wc = 0;
	undef(@stuff); undef($default);
	$_ = $';
	while (/\\$/) {
	    # Remove backslashed newlines: in principle these should become
	    # real newlines inside quotes, but what the hell.
	    ($_) = /^(.*)\\$/;
	    $_ .= <>;
	}
	$command = &getword;
	if ($command =~ /^-/ || $command =~ /[*?]/) {
	    # E.g. complete -co* ...
	    $defmatch = $command;
	    ($defmatch =~ /^-/) && ($defmatch = substr($defmatch,1));
	} else {
	    undef($defmatch);
	}
	while (defined($word = &getword)) {
	    # Loop over remaining arguments to "complete".
	    $sep = substr($word,1,1);
	    $sep =~ s/(\W)/\\$1/g;
	    @split = split(/$sep/,$word);
	    for ($i = 0; $i < 3; $i++) {
		while ($split[i] =~ /\\$/) {
		    substr($split[i],-1,1) = "";
		    splice(@split,$i,2,"$split[i]\\$sep$split[i+1]");
		}
	    }
	    ($pat,$arg,$type,$suffix,$crap) = @split;
	    ($suffix =~ /^\s*$/) && undef($suffix);
	    if (($word =~ /^n${sep}\*${sep}/) &&
		 (!defined($defmatch))) {
		 # The "complete" catch-all:  treat this as compctl\'s
		 # default (requiring no pattern matching).
		$default .= &gettype($type) . ' ';
		defined($suffix) && ($defsuf .= $suffix);
	    } else {
		$pat = &getpat($pat,$arg);
		$type = &gettype($type);
		if (defined($defmatch)) {
		    # The command is a pattern: use either -C or -D option.
		    if ($pat eq 'p[0]') {
			# Command word (-C): 'p[0]' is redundant.
			if ($defmatch eq '*') {
			    $defcommand = $type;
			} else {
			    ($defmatch =~ /\*$/) && chop($defmatch);
			    if ($opt_x) {
				$c = ($defmatch =~ /[*?]/) ? 'C' : c;
				$pat = "${c}[0,${defmatch}]";
			    } else {
				$pat = ($defmatch =~ /[*?]/) ?
				    "C[0,${defmatch}]" : "S[${defmatch}]";
			    }
			    push(@commandword,defined($suffix) ?
				 "'$pat' $type -S '$suffix'" : "'$pat' $type");
			}
		    } elsif ($pat eq "C[-1,*]") {
			# Not command word completion, but match
			# command word (only)
			if ($defmatch eq "*") {
			    # any word of any command
			    $defaultdefault .= " $type";
			} else {
			    $pat = "W[0,$defmatch]";
			    push(@defaultword,defined($suffix) ?
				 "'$pat' $type -S '$suffix'" : "'$pat' $type");
			}
		    } else {
		        # Not command word completion, but still command
			# word wit   i .       ..     j config    Å .indent.pro    Ç Makefile.sample    É buildzsh íê   Ñ 	builtin.c ‹¸   Ö cond.c ∞   Ü config.h.sample    á exec.c ∞   à funcs.h    â glob.c ∞   ä hist.c Ä   ã init.c ∞   å jobs.c     ç lex.c ‹∞   é loop.c ∞   è makepro.sed    ê math.c ∞   ë mem.c ‹∞   í params.c í÷   ì parse.c    î signals.h.sample      ï subst.c    ñ table.c    ó text.c ∞   ò utils.c    ô 	version.h í÷   ö watch.c        õ zle.h ‹∞   ú zle_bindings.c     ù 
zle_hist.c ÷   û 
zle_main.c ÷   ü 
zle_misc.c ÷   † 
zle_move.c ÷   ° zle_refresh.c      ¢ zle_tricky.c       £ zle_utils.c    § zle_vi.c í÷   • 
zle_word.c ¸   ¶ zsh.h Ê    ßztype.h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                j .      i ..     k bz.Makefile    l bz.argh    m bz.check £‹¸   n bz.config.h    o bz.defaults    p 	bz.define í÷   q bz.doksh í÷   r 	bz.finale ‹¸   s bz.help    t bz.hosttype    u bz.hs Ê    v bz.ifdef í÷   w bz.ifksh í÷   x bz.init    y 	bz.makecc ‹¸   z bz.makeprobe      { bz.makevpath      | 	bz.sanity ‹¸   } bz.saveargv    ~ bz.signals.h       bz.walk    Ä Lconfig.README                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       # --- (argument handling)

eval set X "$_argv"; shift

for parm
do
  case "$parm" in
  help)
	. ./config/bz.help
	;;
  *=* ) set Z `echo "$parm"|sed 's/=/ /'`
	var="$2"
	for cp in $CONFIG_PARMS
	do
	  if test Z"$cp" = Z"$var"
	  then
	    cpok=yep
	    break
	  fi
	done
	if test -z "$cpok"
	then
	  echo 'Unrecognized configurable parameter "'$var'" in assignment'
	  echo 'Configurable parameters : '$CONFIG_PARMS
	  echo 'Try "'$0' help" for more information.'
	  echo 'Aborting.'
	  exit 1
	fi
	shift
	shift
	eval "C_$var=\"$@\""
	;;
  hs)
	B_signals_h=yep
	B_config_h=yep
	;;
  Makefile | makefile | mf)
	B_Makefile=yep
	;;
  gcc|mediumgcc|strictgcc)
        eval "B_$parm=yep"
	B_gcc=yep
	CC=gcc
	;;
  signals.h|config.h)
        eval "B_`echo $parm|tr . _`=yep"
	;;
  ksh|query|probe|auto|noopt|debug|zshdebug|install|nomake)
        eval "B_$parm=yep"
	;;
  * )	echo 'Unrecognized parameter "'$parm'"'
	echo 'Assignable parameters : '$CONFIG_PARMS
	echo 'Boolean parameters : '$BOOL_PARMS
        echo 'Try "'$0' help" for more information.'
	echo 'Aborting.'
	exit 1
	;;
  esac
done
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            _sym_="$1"
_dfl_="$2"
_des_="$3"
_emp_="$4"
_quo_="$5"

_ans_=
while test Z"$_ans_" != Zok
do
  if test -n "$B_query"
  then
     if test -z "$F_define_warned"
     then
     {
       cat <<foo
	* to accept the default (which is inside [brackets]), just press
          Enter/Newline/Return.
	* some questions accept empty answers, they are indicated by
          "(empty ok)" text.
	* to give an empty answer, answer just "none" (but without ""s)
	* do not worry about possible missing "quotes" around your answers,
          they will automagically be added.
foo
     } >&2
       F_define_warned=yep
     fi
     test -z "$B_query"
     {
       echo
       echo "Define $_des_:"
       echo "$_sym_ [$_dfl_] "                | tr -d '\012'
       test -n "$_emp_" && echo "(empty ok) " | tr -d '\012'
       echo "? "                              | tr -d '\012'
     } >&2
     read _ans_
  else
     _ans_=$_dfl_
  fi
  _val_=
  case $_ans_ in
  none ) _val_=
         test -n "$_emp_" && _ans_=ok || _ans_=
         _msg_="$_sym_ is undefined"
	 eval $_sym_=
         _ans_=ok
         ;;
  *   )  test -n "$_ans_" && _val_=$_ans_ || _val_=$_dfl_
	 if test -z "$_dfl_" -a -z "$_val_"
	 then
           _msg_="$_sym_ is empty"
	 else
         test Z"$_quo_" = Z'"' && _val_=\"$_val_\"
         test Z"$_quo_" = Z"'" && _val_=\'$_val_\'
           _msg_="$_sym_ is \"$_val_\""
         fi
	 eval $_sym_=\"$_val_\"
         _ans_=ok
         ;;
  esac
done

test -n "$F_define" && echo "/* $_des_ */"
if test -n "$_val_"
then
  test -n "$F_define" && echo "#define $_sym_ $_val_"
else
  test -n "$F_define" && echo "#undef $_sym_"
fi
{
  echo "	$_msg_..."
  test -n "$B_query" && echo
} >&2
                                                                                                                                                                                                                                                                                                                                                                  # --- ${C_BLDDIR}Makefile

if test -n "$B_Makefile"
then

F_define=
F_using=yep

cat <<foo

Building $MAKEFILE...

foo

# configure the needed variables

test -z "$make_probe_done" && . ./config/bz.makeprobe

# just build it!

(exec >$MAKEFILE
cat <<foo
#! /bin/make -f
# Makefile
# architecture-customized Makefile for $VERSION
# for architecture "$arch",
# automagically generated by buildzsh -- do not edit

MAKE=make

AUX=buildzsh

SRC=$SRC

HEADER=$HEADER

PROTO=$PROTO

OBJS=$OBJS

BINDIR=$C_BINDIR
MANDIR=$C_MANDIR

# Debugging flags
DFLAGS=$DFLAGS

CC=$CC

CFLAGS=$CFLAGS

CFLAGS_WO_O=$CFLAGS_WO_O

LD=$LD

LDFLAGS=$LDFLAGS

LIBS=$LIBS

ZSHPATH=${C_BLDDIR}zsh

all: \$(PROTO) \$(ZSHPATH)

.SUFFIXES: .c .o .pro

foo

echo '	...possible notes' 1>&2

echo '	...special rules' 1>&2

# --- notes for various environments (and compilers)

# Past problems: (PLEASE COLLECT PAST PROBLEMS WITH COMPILERS
# HERE: NOT ERRORS/WARNINGS BUT STUFF ABOUT COMPILER CRASHES AND SUCH)
#
# AIX c89 -O -c builtin.c/2.4.60...2.4.2xx used to dump core,
# AIX 3.2.4 fixes the situation, harass your IBM rep until you get the patches.
# (the temporary patch is to use cc on builtin.c)
#
# IRIX cc -ansiposix -O zle_misc.c/2.4.75..2.4.2xx used to dump core,
# later zsh patchlevels do not have this problem
# (the temporary patch was to drop -O on zle_misc.c)
#

if test -n "$AIX"
then
cat <<foo
#	--- AIX notes
#	Note 1:	Pre-3.2.4 AIX c89 -O -c builtin.c dumps core,
#		the temporary cure is to use cc on builtin.c.
#
#	Note 2: 3.2.4-onwards AIX cc -O builtin.c gets stuck (optimizer
#		tries too hard), the temporary cure is to drop -O.
#
# @@@ NOTE: won't work if srcdir != blddir
${C_BLDDIR}builtin.o:     ${C_SRCDIR}builtin.c
	cc \$(CFLAGS_WO_O) \$(DFLAGS) -o builtin.o -c builtin.c

foo
elif test -n "$HPUX"
then
cat <<'foo'
#	--- HPUX notes
#	With c89 you will get warnings ftom
#	from zle_tricky.c: warning 530: Casting from loose to strict alignment.
#	this problem is caused by casting "char *"s to e.g. Cmdnam-
#	structures and then immediately accessing the elements, like this: 
#	char *s;
#	char *cn;
#	{
#	    if (((Cmdnam) cn)->type != DISABLED)
#
foo
elif test -n "$CONVEX"
then
cat <<'foo'
#	--- CONVEX notes
#	cc options NOT used:
#	-std (strict ANSI + POSIX, non-POSIX not recognized, e.g. long long)
#	-str (strict ANSI, UNIX functions not recognized)
#	diagnostics not used (zsh code too "hopeless"):
#	assign_in_condition metrics_file metrics_off
#	negative_to_uns pointer_alignment_efficiency skip_to_char skip_to_eof
#	Note 1: man cc lies that ptr_cvt_truncates is ptr_convert_truncates
#	Note 2: cc notices that init.c:main() never returns
#	Note 3: utils.c:intr() and holdintr() sigvec initializations
#	        are somehow suspicious
#
foo
elif test -n "$SOLARIS"
then
cat <<'foo'
#	--- SOLARIS notes
#	SunSoft cc assumed (CFLAGS derived from this assumption),
#	if you want to use gcc, try 'buildzsh gcc'
foo
elif test -n "$NEXT"
then
cat <<'foo'
#	--- NEXT notes
#	You will get two warnings for each file because
#	/NextDeveloper/Headers/bsd/memory.h:23 contains
#	ANSI-illegal trash after #endif.
#
foo
elif test -n "$UNICOS"
then
cat <<'foo'
#	--- UNICOS notes
#	Note 1: you will get five WARNINGs for each file because of
#	        a) <sys/param.h>, <sys/ioctl.h>:
#		   there is something else than just newline after
#		   directives #endif or #else (Cray's fault)
#	It *is* possible to get more picky by adding '-h port=insx'
#	to the CFLAGS but then a horde of complaints will jump at you:
#	Note 2: a) <stdio.h>:
#		   use bit fields other than signed int or unsigned int
#	        b) <sys/file.h>:
#		   union members have different types
#	        b1) f_uinode and f_udata
#	        b2) f_unext and f_udata
#	        (both of these Cray's fault)
#	Note 3: zsh.h: union members have different types
#	        a1) nam and binnum	a5) arr and val
#	        a2) nam and list		a6) str and val
#	        a3) binnum and list	a7) cfn and ifn
#	        a4) arr and str		a8) ifn and afn
#	        b) cond.c:
#	        pointer is cast to a pointer of another type
#	Note 4: from most of the zsh source files LOTS of:
#	        a) an assignment to a shorter integral type may cause truncation
#	        b) an integral type is cast to  pointer
#	        c) a character pointer cast may result in improprer alignment
#	        d) a "char" assigned to a larger "int" may sign-extend incorrectly
#
foo
# IRIX5 test before IRIX test because IRIX5 is also IRIX but we
# want IRIX5-specific stuff here
elif test -n "$IRIX5"
then
cat <<'foo'
#	-- IRIX5 notes
#	Warnings turned off:
#	799: /usr/include/sgidefs.h, line 141: 'long long' is not standard ANSI. (3.1.1)
#
foo
elif test -n "$IRIX"
then
cat <<'foo'
#	--- IRIX notes
#	Warnings turned off:
#	  2: %s redefinition hides earlier one
#	     (all the static-global c's, sigh...)
#	183: Previous declaration had prototype, this declaration does not(prototype declaration kept)
#	     (ANSI *.pro vs K&R *.c)
#	262: Previous declaration had prototype, this definition does not
#	     (ditto)
#	269: Evaluation gives an intermediate result type difference in ANSI versus K&R C;   int  versus   unsigned int
#	     (all the unsigned staff vs char and int literals, ugh)
#	302: bodyless for statement
#	     (not bad at all, just suspicious)
#	303: bodyless while statement
#	     (not bad at all, just suspicious)
#	309: Only int, signed int, unsigned int bit-fields defined in ANSI C. char, short, and long versions are allowed as an extension (ANSI C 3.5.2.1)
#	     (one of IRIX' own header files is bad in this way...)
#
foo
elif test -n "$TITAN"
then
cat <<'foo'
#	--- TITAN notes
#	Note 1: lots of (about 125) of "argument xxx is not used"
#	Note 2: LOTS of (about 420) of "conversion of xxx (0xyy) loses precision
#	Note 3: couple of (3) of "implied return [blah blah]"
#		(caused by poor flow analysis, not by poor code)
#
foo
fi

echo '	...general rules' 1>&2

if test -n "$ccseparate"
then
  if test -n "$make_groks_VPATH"
  then
    for _b in $BSRC
    do
cat <<foo
$_b.o:	$_b.c
	$ccit -c \$?

foo
    done
  else
    for _b in $BSRC
    do
cat <<foo
$_b.o:	$C_SRCDIR/$_b.c
	$ccit -c \$?

foo
     done
  fi
else	# the simple case
cat <<foo
.c.o:
	$ccit $ccdotc

foo
fi

if test -z "$make_groks_VPATH"
then
  for _proto in $PROTO
  do
    _c=`basename $_proto|sed 's/pro$/c/`
cat <<foo
$_proto:
	sed -n -f makepro.sed $_c > $_proto

foo
  done
else

cat <<foo

.c.pro:
	sed -n -f makepro.sed ${C_SRCDIR}$< > \`basename ${C_BLDDIR}\$@\`

foo
fi

cat <<foo
\$(ZSHPATH): \$(OBJS)
	\$(LD) \$(LDFLAGS) -o \$(ZSHPATH) \$(OBJS) \$(LIBS)
	
\$(PROTO): ${C_SRCDIR}makepro.sed

tags: /tmp
foo
test -z "$F_bld_eq_src" -a -n "$C_SRCDIR" && echo "	cd $C_SRCDIR"
cat <<foo
	ctags *.[cy]

# I hate this next line
\$(OBJS): ${C_BLDDIR}config.h ${C_BLDDIR}signals.h ${C_SRCDIR}zsh.h ${C_SRCDIR}zle.h ${C_SRCDIR}ztype.h ${C_SRCDIR}funcs.h

${C_BLDDIR}params.o: ${C_SRCDIR}version.h

${C_SRCDIR}makepro.sed:
	\$(CO) \$(COFLAGS) ${C_SRCDIR}makepro.sed

clean:
foo
test $C_SRCDIR && echo "	cd $C_SRCDIR"
cat <<'foo'
	rm -f $(OBJS) $(ZSHPATH) core

spotless:	clean
foo
test -z "$F_bld_eq_src" -a -n "$C_SRCDIR" && echo "	cd $C_SRCDIR"
cat <<foo
	rm -f \$(PROTO) Makefile ${C_BLDDIR}signals.h ${C_BLDDIR}config.h

install: ${C_BLDDIR}zsh
foo
test -z "$F_bld_eq_src" -a -n "$C_SRCDIR" && echo "	cd $C_SRCDIR"
cat <<foo
	cp ${C_BLDDIR}zsh \$(BINDIR)
	chmod 755 \$(BINDIR)/zsh
	cp ${C_SRCDIR}../man/zsh.1 \$(MANDIR)
	chmod 644 \$(MANDIR)/zsh.1
foo
)
fi

###
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         . ./config/bz.doksh

if test -z "$B_auto" -a -z "$B_justmake"
then
  if test -z "$B_query"
  then
    cat <<foo | $PAGER

	buildzsh will probe your system for all kinds of features that
	are useful to know when building zsh.  buildzsh will also
	suggest some site-dependent things like where to install
	the final zsh binary.

	You can either:

	* Let buildzsh do all the work for you.

	  This method is suggested either for the first time
	  zsh-builders who _hope_ that zsh will build ok -- or
	  for the experienced builders who _know_ that zsh will build ok.
	  This method can be selected by "buildzsh auto", this text
	  will then not be shown.
		
	* Try to answer the questions about the features and
	  to define yourself the site-dependent things.

	  This method requires both intimate knowledge about
	  your operating system and C compilation environment
	  (compiler, preprocessor, headers, libraries, linker)
	  and about your site-specific software installation
	  guidelines.  That is, most of the time you must be
	  a system administrator of sorts to use this option.
	  This method can be selected by "buildzsh query", this text
	  will then not be shown.

	  Note that some questions of the installation kind
	  (optimize or not, where the install the final executable binary)
	  can be more conveniently answered beforehand at the buildzsh
	  command line.  Try "buildzsh help" to find out how.
	  
        At any point you can interrupt buildzsh by hitting the interrupt
	key (normally ^C [ctrl+c]) and if your shell supports job control,
	suspend buildzsh for a while (normally done with ^Z [ctrl+z]).

	To summarize:					Answer:

	* this is your first time buildzing zsh		n
	* you _know_ that building zsh will work	n
	* you want to tweak various definitions		y

[proceed with $PAGER_quit]
foo
    F_define=
    F_using=yep
    G_verb1_=Will
    G_verb2_='want to answer'
    G_verb3a_='will ask'
    G_verb3b_=letting
    _savedB_query_=$B_query
    B_query=yep
    set false _ 1 'the questions' 'buildzsh have all the fun'
    . ./config/bz.ifdef
    test -n "$_yea" && B_query=yep || B_query=$_savedB_query_
  fi
else
  B_query=
fi

. ./config/bz.sanity
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          " -a -z "$MIPS" -a -z "$IRIX" -a -z "$TITAN" -a -z "$AIX" \
   && (man 2 sigset 2>/dev/null | grep handler >/dev/null )' \
    USE_SIGSET 1 'sigset() to install said signal handlers'
. ./config/bz.ifdef
fi

{
echo
echo '	finished probing features...'
} >&2

cat <<foo
#if defined(SIGVOID) || defined(IRIX5) || defined(SCO)
#define HANDTYPE void
#else
#define HANDTYPE int
#define INTHANDTYPE
#endif

/* a string corresponding to the host type */

#define HOSTTYPE "$host"

/* the default editor for the fc builtin */
#define DEFFCEDIT "vi"
foo
echo

if test -n "`egrep 'UTMP_FILE|_PATH_UTMP' $_utmp_hs_ 2>/dev/null`"
then :
else 
set WTMP wtmp "/etc /usr/etc /var/adm /usr/adm" /dev/null
. ./config/bz.walk
set UTMP utmp "/etc /usr/etc /var/adm /usr/adm" /dev/null
. ./config/bz.walk
cat <<foo
/* the path of wtmp */
#define WTMP_FILE "$WTMP"

/* the path of utmp */
#define UTMP_FILE "$UTMP"
foo
fi

{
  echo
  echo '	defining installation specifics...'
  echo
} >&2

set DEFTMPPREFIX /tmp/zsh 'default prefix for temporary files' '' '"'
. ./config/bz.define

ETCDIR=$C_ETCDIR

set GLOBALZSHENV ${ETCDIR}/zshenv \
"the global file to source absolutely first whenever zsh is run;
if undefined, don't source anything" 1 '"'
. ./config/bz.define

set GLOBALZSHRC ${ETCDIR}/zshrc \
"the global file to source whenever zsh is run;
if undefined, don't source anything" 1 '"'
. ./config/bz.define

set GLOBALZLOGIN ${ETCDIR}/zlogin \
"the global file to source whenever zsh is run as a login shell;
if undefined, don't source anything" 1 '"'
. ./config/bz.define

set GLOBALZPROFILE ${ETCDIR}/zprofile \
"the global file to source whenever zsh is run as a login shell,
before zshrc is read; if undefined, don't source anything" 1 '"'
. ./config/bz.define

F_define=yep

if test -n "$B_query"
then
{
  echo
  echo "The following question is about the text printed by zsh"
  echo "when a process is suspended/stopped under job control."
} >&2
fi
G_verb2_=prefer
set true USE_SUSPENDED 1 '"suspended" instead of "stopped"' '"stopped" instead of "suspended"'
. ./config/bz.ifdef

set DEFAULT_HISTSIZE 30 \
"the default history buffer size in lines"
. ./config/bz.define

cat <<'foo'
#define _BSD_COMPAT		/* this could be IRIX,  you never know */
#define _BSD_TYPES		/* this could be IRIX5, you never know */
#define _BSD			/* this could be HP-UX, you never know */
#define _BSD_INCLUDES		/* this could be AIX,   you never know */
#define _BBN_POSIX_SUPPORT	/* this could be nX,    you never know */

/* if your compiler doesn't like void *,
 * change this to char * and ignore all the warnings. */

typedef void * vptr;

#define JOB_CONTROL

/* define this if you want to use zsh's own allocator */
/* #define USE_ZSH_MALLOC */

#ifdef USE_ZSH_MALLOC

/* define this if you want the allocator to store information */

/* #define MEM_DEBUG */

/* define this if you want to get error messages from the allocator */

/* #define MEM_WARNING */

/* define this if you want free() to be really save */

/* #define SECURE_FREE */

#endif /* USE_ZSH_MALLOC */

/* end of config.h */
foo

{
  echo
  echo '	defined installation specifics...'
} >&2

)
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # --- ${C_BLDDIR}config.h

if test -n "$B_config_h"
then

F_define=yep
F_using=yep

echo
echo Building ${C_BLDDIR}config.h...

(exec >${C_BLDDIR}config.h

{
echo
echo '	starting features probing...'
echo
} >&2

cat <<foo
/* config.h */
/* architecture-customized config.h for $VERSION
 * for architecture "$arch",
 * automagically generated by buildzsh -- do not edit */

foo

set elfh elf.h ${headerdir}/sys
. ./config/bz.walk

set resourceh resource.h ${headerdir}/sys
. ./config/bz.walk

set 'test -n "$elfh" -o -z "$resourceh" -o -n "$SEQUENTPTX"' SYSV 1 'pure SYSV'
. ./config/bz.ifdef

if test -n "$_yea"
then
  PATH=/usr/bin:$PATH
  export PATH
  echo '	forcing /usr/bin early in PATH...' >&2
  if test -n "${elfh}"
  then
    echo '#define SYSVR4'
    echo '	looks like a SYSVR4 system...' >&2
    force_setpgid=1
    force_strftime=1
    if test -n "$SOLARIS"
    then
      echo '#define SOLARIS'
      echo '	looks like a Solaris...' >& 2
    fi
    echo
  fi
fi

echo '/* some environments have broken termios, for example ULTRIX */'
set 'test -z "$ULTRIX" -a -z "$APOLLO" -a -z "$BBN" -a -z "$NEXT" -a -f ${headerdir}/termios.h' HAS_TERMIOS 1 'termios'
. ./config/bz.ifdef

if test -z "$_nay"
then
  test -n "$DGUX" && echo '#define CLOBBERS_TYPEAHEAD 1'
else

set 'test -z "$ULTRIX" -a -z "`grep sgttyb ${headerdir}/sys/ioctl.h 2>/dev/null`"' HAS_TERMIO 1 'termio'
. ./config/bz.ifdef
echo '	using sgttyb...' >&2

if test -z "$ULTRIX" -a -z "$NEXT"
then
cat <<foo
#define TTY_NEEDS_DRAINING 1
#define CLOBBERS_TYPEAHEAD 1

foo
fi

fi

test -n "$IRIX5" && echo '#define IRIX5'
  
set 'test -f ${headerdir}/dirent.h \
          -a -z "$NEXT" -a -z "$ULTRIX"'\
    HAS_DIRENT 1 '<dirent.h>'
. ./config/bz.ifdef

set 'test -f ${headerdir}/unistd.h' HAS_UNISTD 1 '<unistd.h>'
. ./config/bz.ifdef

set stdlibh stdlib.h "/usr/include/ansi ${headerdir}"
. ./config/bz.walk

if test -n "$stdlibh"
then
   set 'grep alloc $stdlibh >/dev/null 2>&1' HAS_STDLIB 1 '<stdlib.h>'
  . ./config/bz.ifdef
fi

set 'test -f ${headerdir}/string.h' HAS_STRING 1 '<string.h>' '<strings.h>'
. ./config/bz.ifdef

if test -f ${headerdir}/strings.h -a -n "${NEXT}" -a Z"${NEXT}" != Z3.x
then
cat <<foo
/* BSD compat */
#define strchr	index
#define strrchr	rindex
foo
fi

set 'test -f ${headerdir}/memory.h' HAS_MEMORY 1 '<memory.h>'
. ./config/bz.ifdef

if test -n "$_nay"
then
set 'grep memset ${headerdir}/string.h >/dev/null 2>&1' '' '' 'memcpy(),memset(),memcmp() from <string.h>' 'redefined memcpy(), memset(), memcmp()' '' '' '
#define memcpy(dst, src, n)	bcopy(src, dst, n)
#define memset(dst, ch, n)	do {\
	char *__DST__ = (char *)(dst);\
	int __N__ = (int)(n), __CH__ = (int)(ch);\
	while (__N__--) { __DST__[__N__] = __CH__; } } while(0)
#define memcmp(s1, s2, n)	bcmp(s1, s2, n)'
. ./config/bz.ifdef
fi

set 'test -f ${headerdir}/locale.h' HAS_LOCALE 1 '<locale.h>'
. ./config/bz.ifdef

if test -f "${headerdir}/utmpx.h"
then
  _utmp_hs_="${headerdir}/utmpx.h ${headerdir}/utmp.h"
else
  _utmp_hs_="${headerdir}/utmp.h"
fi

set utmph "utmpx.h utmp.h" ${headerdir}
. ./config/bz.walk

set 'test Z$utmph = Z${headerdir}/utmpx.h' HAS_UTMPX 1 '<utmpx.h>' '<utmp.h>'
. ./config/bz.ifdef

set 'grep ut_host $utmph >/dev/null 2>&1 && ( test Z"$host" != Zmips || test -n "$OSF1" )' UTMP_HOST 1 'host field in utmp'
. ./config/bz.ifdef

set 'test -f ${headerdir}/time.h && (grep timeval ${headerdir}/time.h >/dev/null 2>&1 || test -n "$SCO" )' HAS_TIME 1 '<time.h>' '<sys/time.h>'
. ./config/bz.ifdef

set waith wait.h "${headerdir} ${headerdir}/sys" "${headerdir}/sys/wait.h"
. ./config/bz.walk

set 'test Z$waith = Z${headerdir}/wait.h' HAS_WAIT 1 '<wait.h>' '<sys/wait.h>'
. ./config/bz.ifdef

set 'test -z "$NEXT" && grep "waitpid.*(" $waith >/dev/null 2>&1 || man 2 wait 2>/dev/null | sed "s/_.//g" | grep waitpid >/dev/null' HAS_WAITPID 1 'waitpid()'
. ./config/bz.ifdef

set 'grep FD_SET ${headerdir}/sys/types.h >/dev/null 2>&1 || test -f ${headerdir}/sys/select.h || test -n "$LINUX"' HAS_SELECT 1 'select()'
. ./config/bz.ifdef

set 'test -f ${headerdir}/sys/select.h \
     && \
     grep "struct  *fd_set " ${headerdir}/sys/select.h >/dev/null 2>&1' \
     HAS_SYS_SELECT 1 \
     '<sys/select.h>' '' '"struct fd_set" in <sys/select.h>'
. ./config/bz.ifdef

cat <<foo
/* we can't just test for S_IFIFO or check to see if the mknod worked,
   because the NeXTs sold by a vendor which will remain nameless will
   happily create the FIFO for you, and then panic when you try to do
	something weird with them, because they aren't supported by the OS. */
foo
set 'test -z "$NEXT" -o Z"$NEXT" != Z2.x' HAS_FIFOS 1 'fifos'
. ./config/bz.ifdef

set 'test -n "$force_strftime" -o -n "$MIPS" -o -n "$AIX" -o -n "$LINUX" || \
     man 3 strftime 2>/dev/null | grep return >/dev/null || \
     man -s 3c strftime 2>/dev/null | grep return >/dev/null' \
    HAS_STRFTIME 1 'strftime()'
. ./config/bz.ifdef

set 'test -n "$MIPS" -o -n "$AIX" || \
     grep tcsetpgrp ${headerdir}/unistd.h >/dev/null 2>&1 || \
     man tcsetpgrp 2>/dev/null | grep process >/dev/null && test -z "$NEXT"' \
    HAS_TCSETPGRP 1 'tcsetpgrp()'
. ./config/bz.ifdef

_term_hs_="${headerdir}/termio.h ${headerdir}/sys/termio.h ${headerdir}/termios.h ${headerdir}/sys/termios.h"

set 'test -z "$NEXT" -a -n "`grep tcgetattr $_term_hs_ 2>/dev/null`"' \
     HAS_TCCRAP 1 'tcgetattr() and friends'
. ./config/bz.ifdef

if test -n "$_nay" -a \( -n "$IRIX" -o -n "$MIPS" \)
then
echo '
/* some environments like IRIX have a broken setpgid()
 * setpgrp() might come to rescue */'
fi
set 'test -n "$AIX" -o -n "$LINUX" -o -n "$force_setpgid" || \
     man setpgid 2>/dev/null | grep process >/dev/null && \
     test -z "$IRIX" -a -z "$MIPS" -a -z "$NEXT"' \
     HAS_SETPGID 1 'setpgid()' 'setpgrp()'
. ./config/bz.ifdef

if test -n "$TITAN"
then
echo '
/* TitanOS has sigrelse(), sighold() and sigset() but it cannot use
 * them simultaneously with -43 */'
fi

_signal_hs_="${headerdir}/signal.h ${headerdir}/sys/signal.h ${headerdir}/linux/signal.h"

set 'test -z "$HPUX" -a -z "$PYR" -a -z "$MIPS" -a -z "$AIX" -a -z "$TITAN" &&
    (grep SIGRELSE $_signal_hs_ > /dev/null 2>&1 || \
     man sigrelse 2>/dev/null | grep signal >/dev/null)' \
    HAS_SIGRELSE 1 'sigrelse()' 'sigblock()'
. ./config/bz.ifdef

set 'test -d /../.CONTROL' HAS_RFS 1 RFS
. ./config/bz.ifdef

cat <<foo
/* the stress is on "a working wait3()" because for example HP-UX has
 * sort of working getrusage() but nothing like wait3() */
foo
set 'test -f $resourceh -a -z "$HPUX" -a -z "$UNICOS" -a -z "$SOLARIS"' HAS_RUSAGE 1 'getrusage() and wait3()'
. ./config/bz.ifdef

if test Z"$host" = Zhp9000s700
then
echo '	using hp9000s700 rlimit kludge...' >&2
echo '
/* kludge RLIM code for HPUX s700 - These limits are all readable,and
 * some like coredumpsize are settable by users
 */
#define RLIMIT_CPU	0		/* cpu time in milliseconds */
#define RLIMIT_FSIZE	1		/* maximum file size */
#define RLIMIT_DATA	2		/* data size */
#define RLIMIT_STACK	3		/* stack size */
#define RLIMIT_CORE	4		/* core file size */
#define RLIMIT_RSS	5		/* resident set size */

#define RLIM_INFINITY	0x7fffffff
'
fi

STD_DUMP="cat /etc/passwd"
NIS_DUMP="ypcat passwd.byname"
NI_DUMP="nidump passwd /"
DUMP_USERS="$STD_DUMP"

set 'test -f /usr/bin/ypcat && $NIS_DUMP > /dev/null 2>&1' HAS_NIS 1 NIS
. ./config/bz.ifdef

if test -n "$_yea"
then
  DUMP_USERS="$NIS_DUMP"
else
  test -d /NextApps && $NI_DUMP > /dev/null 2>&1 && DUMP_USERS="$NI_DUMP"
fi

lot_user=`$DUMP_USERS | awk '{if(NR>'$LOTSA_USERS'){print;exit 1}}'`
if test -n "$B_query"
then
{
  echo
  echo "Username caching is useful if there are more than $LOTSA_USERS users..."
} >&2
fi
G_verb2_=use
set 'test -n "$lot_user"' CACHE_USERNAMES 1 'username caching'
. ./config/bz.ifdef

set 'egrep "SIG_DFL|sighandler_t" $_signal_hs_ 2>/dev/null | grep void > /dev/null && test -z "$IRIX" || test -n "$SCO" ' SIGVOID 1 'signal handlers returning void' 'signal handlers returning int'
. ./config/bz.ifdef

set 'test -n "`grep SIGTSTP $_signal_hs_ 2>/dev/null`"' \
    HAS_AUTORESETHAND 1 'automatically reset signal handlers' \
    'forced reset signal handlers'
. ./config/bz.ifdef

if test -n "$_yea"
then
set 'test -z "$HPUX# The configurable parameters
CONFIG_PARMS="CC CFLAGS CFLAGS_D CFLAGS_W CFLAGS_X CFLAGS_M CFLAGS_O CFLAGS_g CFLAGS_z LDFLAGS LIBS SRCDIR BLDDIR ARCH ARCHPATT INSTDIR BINDIR MANDIR MAKE ETCDIR"
# The boolean parameters
BOOL_PARMS="config.h signals.h hs Makefile makefile mf gcc mediumgcc strictgcc ksh help query auto noopt nodebug nozshdebug nomake justmake"
# The parameters that can contain $ARCHPATT
# $ARCHPATT will be substituted with $HOSTTYPE unless ARCH is specified
ARCH_PARMS="BINDIR BLDDIR"

GCC_BASE0_W='-Wall -Wno-implicit -Winline'
GCC_BASE1_W="$GCC_BASE0_W -Wmissing-prototypes"
GCC_MEDIUM_W='-Wimplicit -pedantic'
GCC_STRICT_W='-Wshadow -Wtraditional -Wwrite-strings -Wstrict-prototypes -Wpointer-arith -Wcast-qual -Wcast-align -Wconversion'

DEFAULT_C_CC=cc
# The following is changed to -O2 in bz.Makefile for GCC
DEFAULT_C_CFLAGS_O=-O
DEFAULT_C_CFLAGS_g=-g
DEFAULT_C_LD='$(CC)'
DEFAULT_C_LIBS=
DEFAULT_C_SRCDIR=.
DEFAULT_C_BLDDIR=.
DEFAULT_C_ARCHPATT="%(ARCH)"
DEFAULT_C_INSTDIR=
DEFAULT_C_BINDIR=/usr/local/bin
DEFAULT_C_MANDIR=/usr/local/man/man1
DEFAULT_C_ETCDIR=/etc
DEFAULT_C_MAKE=make

DEFAULT_B_config_h=yep
DEFAULT_B_signals_h=yep
DEFAULT_B_hs=yep
DEFAULT_B_mf=yep
DEFAULT_B_gcc=
DEFAULT_B_mediumgcc=
DEFAULT_B_strictgcc=
DEFAULT_B_ksh=
DEFAULT_B_help=
DEFAULT_B_query=
DEFAULT_B_probe=yep
DEFAULT_B_auto=
DEFAULT_B_noopt=
DEFAULT_B_debug=
DEFAULT_B_zshdebug=
DEFAULT_B_install=yep
DEFAULT_B_nomake=
DEFAULT_B_justmake=
DEFAULT_B_makeatbld=

PAGER_PROGS="less more pg cat"
PAGER_PATH="/usr/local/bin /usr/ucb /usr/bsd /usr/bin /bin"

# Which variables mean when non-empty that $CC groks simultaneous -c and -o ?
CC_GROK_c_o="AIX CONVEX GCC HPUX CC_MIPS_STYLE SUNOS"
# Which variables mean when non-empty that $CC fouls simultaneous -c and -o ?
CC_LOSE_c_o="UNICOS DGUX"
# Which variables mean when non-empty that $CC groks simultaneous -g and -O ?
# variables like test:foo:bar mean testing for variable "test",
# if that succeeds, setting CC_gFLAGS to "foo" and CC_OFLAGS to "bar"
# use 'quotes' to protect whitespace
CC_GROK_g_O="GCC:-g:-O6 AIX CC_MIPS_STYLE:-g3:'-O -Olimit 1000'"
# Which variables mean when non-empty that $CC fouls simultaneous -g and -O ?
CC_LOSE_g_O="HPUX"
# How many users is lots of? (enough to justify username caching)
LOTSA_USERS=150

# VPATHTMP: VPATH temporary top test directory
VPATHTMP=/tmp/vpath.$$
VPATHTMPa=$VPATHTMP/a
VPATHTMPb=$VPATHTMP/b

# TRASHF: known temporary files
#	ARGV set in bz.saveargv
#	ARGH in bz.argh
#	/tmp/sh/sh[0-9][0-9]* are sh temporary files
#		(used for example by <<here documents)
TRASHF="$ARGV $ARGH $VPATHTMPa/foo.c $VPATHTMPb/Makefile $VPATHTMPa/foo.o /tmp/sh[0-9][0-9]*"

# TRASHF: known temporary directories
#	VPATHTMP...	used for VPATH testing
TRASHD="$VPATHTMP $VPATHTMPa $VPATHTMPb"

# TRAPN: the last thing to do when trapped
TRAPN="echo '[Cleaning up]';test -n '$TRASHF' && rm -f $TRASHF 2>/dev/null;test -n '$TRASHD' && rm -rf '$TRASHD' 2>/dev/null;exit 9"

# the signals to trap
TRAPSIGS="1 2 3 15"

# the text pager to use
if [ -z "$PAGER" ]
then
    set PAGER "$PAGER_PROGS" "$PAGER_PATH" cat
    . ./config/bz.walk
fi
export PAGER
case "$PAGER" in
*pg) PAGER_quit='q and Enter/Newline/Return' ;;
  *) PAGER_quit=q ;;	# more, less, hopefully everything else
esac
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            # --- ksh?
# (hopefully sh does not barf before this point...)
#
# if we are not in ksh but we should try it
#
if test -n "$F_must_ksh" -o -n "$B_ksh"
then
  echo
# the following trick should tell us whether we have ksh or
# just bare sh: ksh has alias builtin, sh does not (I really hope that
# no one has "alias" in their PATH as an executable, this trick
# will fail major way...)
(alias) >/dev/null 2>&1 && echo 'Now running ksh...' || {
  set ksh ksh "/bin /usr/bin /usr/local/bin"
  . ./config/bz.walk
  if test -n "$ksh"
  then
    test -n "$F_cray" && echo "CRAY's /bin/sh cannot handle buildzsh, a stack overflow will occur."
    test -n "$B_ksh"      && echo Will | tr -d '\012'
    test -n "$F_must_ksh" && echo MUST | tr -d '\012'
    echo " refeed ourselves through $ksh"
    echo
    exec $ksh $0 `cat $ARGV`
    echo "Ooops, something went awfully wrong, failed to 'exec $ksh $0 `cat $ARGV`'"
  else
    echo 'Aaargh, we should run ksh but cannot find one.'
  fi
  exit 1
}
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                # -- finale

if test -z "$B_nomake"
then

# configure the needed variables

test -z "$make_probe_done" && . ./config/bz.makeprobe

# ---

makeit="$makeprecmd$C_MAKE"

if test -z "$F_bld_eq_src"
then
  if test -n "$make_groks_VPATH"
  then
    if test -z "$B_makeatbld"
    then
      makeit="$makeit VPATH=$C_BLDDIR"
    else
      makeit="$makeit VPATH=`pwd`"	
    fi
  fi
fi


if test -z "$B_justmake"
then

cat <<foo

You may want to look at the file(s) I just created:

foo
test -n "$B_config_h"  && echo "	${C_BLDDIR}config.h"
test -n "$B_signals_h" && echo "	${C_BLDDIR}signals.h"
test -n "$B_Makefile"  && echo "	$MAKEFILE"

cat <<foo

to make sure they are correct.	Or you may just want
to go ahead and try running $C_MAKE to see what happens.

foo
echo "Shall I execute \"$makeit\" now? " | tr -d '\012' 
read reply
echo

else
  # justmake
  reply=yep
fi

case "$reply" in
[yY]*) echo $makeit ; eval $makeit ; exit 0 ;;
esac
cat <<foo
In that case you will have to call the following yourself:

	$makeit

foo

fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  cat <<EOH | $PAGER
NAME

	buildzsh -- zsh configuration tool

SYNOPSIS

	buildzsh [parameters]

	buildzsh builds all or some of the files config.h, signals.h,
	and Makefile.  These files are necessary for building zsh.
	For more detailed explanation, see FILES below.

	By default it builds them all, this can be done by simply saying

		./buildzsh

	from the shell level while in the same directory with buildzsh.
	For not building all of the abovementioned files, see note 3)
	under BOOLEAN PARAMETERS.

	buildzsh supports building zsh for several architectures
	from the same, untouched, source tree.  See MULTIARCHITECTURE
	SUPPORT below.

PARAMETERS

	buildzsh knows about two kinds of parameters:

	CONFIGURABLE and BOOLEAN

CONFIGURABLE PARAMETERS

	configurable might also be called assignable: they can be
	assigned some value by using the form

		param=value

	For example

		./buildzsh LIBS=-ltermcap

	sets the configurable parameters "LIBS" to the value "-ltermcap"

	param		explanation			default
	-----		-----------			-------
	CC		C compiler			$DEFAULT_C_CC
	CFLAGS		C compiler flags    for example	$DEFAULT_C_CFLAGS
	CFLAGS_D	C preprocessor flags (-Dfoo)	$DEFAULT_C_CFLAGS_D
	CFLAGS_W	C warning flags	     (-ansi)	$DEFAULT_C_CFLAGS_W
	CFLAGS_X	C extra flags        (-m486)	$DEFAULT_C_CFLAGS_X
	CFLAGS_O	C optimizer flags    (-O)	$DEFAULT_C_CFLAGS_O
	CFLAGS_g	C debugger flags     (-g)	$DEFAULT_C_CFLAGS_g
	CFLAGS_z	zsh debugging flags  (-DQDEBUG)	$DEFAULT_C_CFLAGS_z
	LDFLAGS		linking flags	     (-x)	\$(CFLAGS)
	LIBS		libraries to link with	(-lnet)	$DEFAULT_C_LIBS
	SRCDIR		source directory		$DEFAULT_C_SRCDIR
	BLDDIR		building directory		$DEFAULT_C_BLDDIR
	ARCH		architecture			(zsh HOSTTYPE)
	ARCHPATT	ARCH pattern 2)			$DEFAULT_C_ARCHPATT
	INSTDIR		installation directory 3)	$DEFAULT_C_INSTDIR
	BINDIR		binary INSTDIR			$DEFAULT_C_BINDIR
	MANDIR		manual page INSTDIR		$DEFAULT_C_MANDIR
	ETCDIR		global init file directory	$DEFAULT_C_ETCDIR
	MAKE		the "make" to use		$DEFAULT_C_MAKE

	1) CFLAGS overrides all CFLAGS_... parameters, each CFLAGS_...
	   overrides any guesses done by buildzsh.

	2) For each instance of ARCHPATT in the parameters
	   $ARCH_PARMS,
	   ARCH will be substituted.

	3) If INSTDIR is set, it will be a prefix for BINDIR (=INSTDIR/bin)
	   and MANDIR (=INSTDIR/man/man1), BINDIR and MANDIR cannot then be
	   set on their own.

BOOLEAN PARAMETERS

	These parameters are either present or not.

	param		explanation			default
	-----		-----------			-------
	config.h	build config.h			$DEFAULT_B_config_h 1)
	signals.h	build signals.h			$DEFAULT_B_signals_h 1)
	hs		build config.h and signals.h	$DEFAULT_B_hs 1)
	Makefile	build Makefile			$DEFAULT_B_mf 1)
	mf		-"-				$DEFAULT_B_mf 1)
	gcc		use gcc instead of default cc	$DEFAULT_B_gcc
	mediumgcc	as "gcc" but with stricter	$DEFAULT_B_mediumgcc
			flags, requires ANSI clean
			zsh code _and_ system headers
	strictgcc	as "gcc" but with very, VERY,	$DEFAULT_B_strictgcc
			strict flags
	ksh		run builzsh with ksh		$DEFAULT_B_ksh 2)
			instead of default sh
	help		show this help			$DEFAULT_B_help
	query		ask configurer's judgement	$DEFAULT_B_query
	auto		do not ask the initial question	$DEFAULT_B_auto 3)
			about "query", start probing
			immediately
	noopt		no optimizing compilation (-O)	$DEFAULT_B_optimize 4)
	debug		debugging compilation (-g)	$DEFAULT_B_debug 4)
	zshdebug	zsh internal debugging used	$DEFAULT_B_zshdebug
	nomake		no make at the end of buildzsh	$DEFAULT_B_nomake

	For example

		./buildzsh gcc

	will customize Makefile so that gcc and the appropriate
	flags will be used.

	1) Normally all of config.h, signals.h, and Makefile
	   will be built.  If, however, only certain of these are
	   specified at the command line, only those specified will
           be built.  For example "buildzsh mf" will build only the
	   Makefile.

	2) The default is to use sh.  ksh is needed sometimes if sh
	   cannot for some reason handle buildzsh (e.g. Cray's UNICOS),
	   in such cases buildzsh normally runs itself automatically
	   with ksh and "ksh" option is not needed in the command line.

	3) Meant either for the extremely optimistic first-timers or
	   for the battle-scarred zsh hackers.
	
	4) These can cancel each other out: if both are present
	   but the C compiler cannot handle both of them, optimization
	   is turned off and debugging stays.  Only certain compilation
	   environments support optimization and debugging simultaneously.

MULTIARCHITECTURE SUPPORT

	*** CURRENTLY UNSUPPORTED (=SOMEWHAT BROKEN) FEATURE	***
	*** FOR DESPERATE USE ONLY				***
	*** IF IT WORKS FOR YOU, FINE, BUT DON'T RELY ON IT.	***
	*** IF IT DOESN'T WORK FOR YOU, TOUGH.			***
	*** IF YOU DO THE BUILDING HONOURING THE TRADITION      ***
	*** COMPILING AMONG THE SOURCES, EVERYTHING SHOULD GO	***
	*** JUST FINE, IGNORE THIS FEATURE.			***

	buildzsh understands using a common source code pool
	for building and installing zsh for several different
	architectures.   The configurable parameters

		$ARCH_PARMS

	are special: if these contain the pattern

		$DEFAULT_C_ARCHPATT

	this pattern will be replaced with a string describing
	the particular architecture.  By default this string is
	determined by buildzsh itself -- but all of these can be
	changed from the command line, see CONFIGURABLE PARAMETERS above.
	For example

		./buildzsh BLDDIR=/var/tmp/zsh/hp48sx

	will build Makefile so that by simply saying

		make -f /var/tmp/zsh/hp48sx/Makefile

	the whole zsh building process will happen in the directory
	"/var/tmp/zsh/hp48sx".

FILES

	buildzsh builds three files:

		config.h and signals.h are normal C source files:
		config.h contains the definitions that depend on
		the particular features of the operating system variant,
		signals.h contains the signal definitions.

		A makefile called Makefile customized for
		the particular architecture will be built to
		the building directory (by default the building directory
		is the current directory).

	There are fail-safe versions of config.h, signals.h and Makefile
	called config.h.sample, signals.h.sample and Makefile.sample
	that can be used either as-is or as raw material if buildzsh fails.

	buildzsh itself is just a top-level script that uses the bz.*
	scripts in the directory src/config.

ENVIRONMENT VARIABLES

	All of the configurable parameters (see above) (for example
	CFLAGS and LIBS) are taken intact from the environment.

BUGS

	Nothing is perfect and buildzsh is bound to have its
	share of bugs.  If and when modifying buildzsh becomes
	a necessity, please read the file src/config/config.README.
	It lists the role of each module of buildzsh and warns about
	the most common pitfalls.

WARNINGS

	buildzsh is quite large piece of serious shell scripting
	which is supposed to work under any Bourne shell (sh) AND
	Korn shell (ksh).  Achieving this goal requires sometimes
	dirty and/or obscure tricks to for example negotiate past
	some bugs that appear only in some vendors' environments.

	Fiddling with buildzsh is not for the faint at heart.
EOH
exit 1	
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             # --- (host type determination)

echo
echo '	determining host type...'

headerdir=/usr/include
arch=`(uname) 2>/dev/null`
motd=`(head -2 /etc/motd) 2>/dev/null`
case "$arch" in
"")	case "$motd" in
	*"HP-UX"*)	HPUX=yep; machid=hp9000;;
	*"Iris"*)	IRIX=yep; host=iris4d;;
	*"Ultrix"*)	ULTRIX=yep; host=vax;;
	*"RISC iX"*)	ARM=yep; host=arm;;
	*"Umax 4.2"*)	ENCORE=yep; host=encore;;
	*"Alliant Concentrix"*) ALLIANT=yep; host=alliant;;
	*"FPS Model 500"*) FPS=yep; host=fps500;;
	*"HCX/UX"*)	HARRIS=yep; host=harris;;
        "DYNIX/ptx"*)   SEQUENTPTX=yep; host=sequentptx;;
	*"nX Operating System"*)	BBN=yep; host=`arch`;;
	*"NEWS-OS"*)	NEWS=yep; host=news;;
	*)
		if test -d ${headerdir}/caif
		then AIX=yep; host=ibm032
		elif test -d /sys/node_data
		then APOLLO=yep; host=apollo-$ISP
		elif test -f /bin/pyr && /bin/pyr
		then PYR=yep; host=pyr
		elif test -d /NextApps
		then host=next
		      if test -d /NextDeveloper/Headers/bsd
		      then NEXT=3.x; headerdir=${headerdir}/bsd
		      else NEXT=2.x
		      fi
		elif test -f /etc/comply
		then SUNOS=yep; host=sun3
		elif test -f /bin/hinv
		then IRIX=yep; host=iris4d
		elif grep ULTRIX ${headerdir}/stdio.h >/dev/null 2>&1
		then ULTRIX=yep; host=vax
		elif grep 'Property of IBM' ${headerdir}/stdio.h >/dev/null 2>&1
		then AIX=yep
		else host=`(tcsh -fc 'echo $HOSTTYPE' || arch || machine || mach || echo $machine) 2>/dev/null`
		fi;;
	esac;;
HP-UX)	HPUX=`uname -r 2>/dev/null || echo yep`; machid=`uname -m`
	case "$machid" in
 	9000/7*)	host=hp9000s700;;
 	9000/8*)	host=hp9000s800;;
 	9000/[34]*)	host=hp9000s300;;
 	9000/2*)	host=hp9000s200;;
 	"")		host=hp9000;;
 	*)		host=hp-unknown;;
	esac;;
AIX*)	AIX=yep; machid=`uname -m`
	case "$machid" in
	00*) host=rs6000;;
	10*) host=ibm032;;
	20*) host=ibm032;;
	esac;;
A/UX)	MAC=yep; host=macII;;
dgux)	DGUX=yep; machid=`uname -m`
	case "$machid" in
	AViiON) host=aviion;;
	esac;;
SunOS)	machid=`uname -m`
	if test -n "`uname -r|egrep '^5'`"
	then
		SOLARIS=yep
	fi
	SUNOS=yep; case "$machid" in
	sun3*) host=sun3;;
	sun4*) host=sun4;;
	*) host=$machid;;
	esac;;
ULTRIX)	machid=`uname -m`
	ULTRIX=yep; case "$machid" in
	VAX) host=vax;;
	RISC) host=decstation ; MIPS_ULTRIX=yep;;
	*) host=$machid;;
	esac;;
IRIX)	IRIX=yep;
	host=iris4d
        osvers=`uname -r`
        case "$osvers" in
        5.*) IRIX5=yep;;
        esac
	;;
ConvexOS)CONVEX=yep; host=convex;;
OSF1)	OSF1=yep; 
	host=`uname -m`
	case "$host" in
	hp*) HPOSF=yep; host=hposf;;
	mips) MIPSOSF=yep; host=mipsosf;;
	esac
	;;
Linux)	LINUX=yep; host=`uname -m`;;
NetBSD)	NETBSD=yep; host=NetBSD;;
FreeBSD)FreeBSD=yep; host=`uname -m`;;
TitanOS)TITAN=yep; host=titan;;
*)	machid=`uname -m`
	case "$machid" in
	mips|IP6|IP7) MIPS=yep; host=mips;;
	CRAY*) UNICOS=yep; host=$machid;;
	i[34]86)
	    if test -f /etc/copyrights/01.sco
	    then SCO=yep host=`uname -m`
	    else
		# This doesn't work above because the PTX 1.4 and 2.0
		# return the hostname from uname which is deceptive.
		case "$motd" in
		"DYNIX/ptx"*)   SEQUENTPTX=yep; host=sequentptx;;
		esac
	    fi
	;;
	*) host=`(tcsh -fc 'echo $HOSTTYPE' || arch || machine || mach || echo $machine || echo $machid) 2>/dev/null`
	esac;;
esac
if test -n "$host"
then 
	# not foolproof but nice crome, though :-)
	a=a"`echo $host|egrep '^[aeiouy]' > /dev/null 2>&1 && echo n`"
	echo "	...looks like $a $host "
	case $host in
	mips) test -d /usr/include/bsd43 && headerdir=/usr/include/bsd43 ;;
	titan) test -d /usr/include/bsd && headerdir=/usr/include/bsd ;;
	esac
else
while test -z "$host"
do
	echo 1>&2 '

I cannot figure out what sort of host this is.	Please enter one
short alphanumeric string describing this host (e.g. sun, vax, hp)
(This will be used to set the $HOSTTYPE variable, so '"you don't
have to be very accurate if you're not in a multivendor environment.)
"
	 echo "? " | tr -d '\012' 1>&2
	 read host
	 echo ' ' 1>&2
done
fi

# --- we can deduce some things about ARCH

if test -n "$MIPS_ULTRIX" -o -n "$OSF1" -o -n "$IRIX" \
     -o -n "$MIPS" -o -n "$RISC" -o -n "$NEWS"
then
  CC_MIPS_STYLE=yep
fi

# --- (ARCH substitution)

test -n "$ARCH" && arch=$ARCH || arch=$host

if test -n "`echo $arch|egrep '[ /]'`"
then
   echo "Architecture name $ARCH contains either"
   echo "troublesome characters (' ') or"
   echo "illegal characters ('/')"
   echo "(considering using ARCH for pathnames)"
   echo "Will substitute them with '_' and '-'"
   arch="`echo $arch|tr ' ' '_'|tr '/' '-'|tr -s _- _-`"
   echo "yielding $arch (only for use in pathnames)"
   echo
fi

for ap in $ARCH_PARMS
do
  ape="`eval echo '$'$ap`"
  if test -n "`echo \"$ape\"|grep \"$C_ARCHPATT\"`"
  then
     eval "$ap=`echo \"$ape\"|sed \"s/$C_ARCHPATT/$arch/g\"`"
  fi
done

if test -n "$C_BLDDIR"
then
echo
echo Building directory is $C_BLDDIR
fi

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        . ./config/bz.config.h
. ./config/bz.signals.h
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 _tst_="$1"
_sym_="$2"
_val_="$3"
_yea_="$4"
_nay_="$5"
test -n "$6" && _fea_="$6" || _fea_="$4"
_yea_fea_="$7"
_nay_fea_="$8"
test -n "$F_define" -a -n "$_sym_" && echo "/* define this if you use $_fea_ */"

_auto=

if test -n "$B_query"
then
  _ans_=
  while test Z"$_ans_" != Zok
  do
    if test -n "$F_define" -a -z "$F_ifdef_warned"
    then 
      echo "	* 'Do you have' means 'Do you have _a working_ version of'" >&2
      F_ifdef_warned=yep
    fi
    if test -n "$B_query"
    then
      eval "$_tst_" && _dfl_='Y n' || _dfl_='N y'
      {
        echo
        test -n "$G_verb1_" && _verb1_="$G_verb1_" || _verb1_=Do
        test -n "$G_subj_"  && _subj_="$G_subj_"   || _subj_=you
        test -n "$G_verb2_" && _verb2_="$G_verb2_" || _verb2_=use
        echo "$_verb1_ $_subj_ $_verb2_ $_fea_? [${_dfl_}aq?] " | tr -d '\012'
      } >&2
    fi
    read _ans_
    case $_ans_ in
    [Yy]* )
      _tst_=true
      _ans_=ok
      _yea=yep
      _nay=
      ;;
    [Nn]* )
      _tst_=false
      _ans_=ok
      _yea=
      _nay=nope
      ;;
    [Aa]* )
      {
        echo
        echo "	OK, will autoproceed..."
	echo
      } >&2
      _ans_=ok
      _auto=yep
      ;;
   [?]*  )
      {
cat <<__eoh__
  
  The default will be selected by simply pressing Return/Newline/Enter.
  The default is probed out from the system by buildzsh, the probing
  can take sometimes couple of seconds.
  Inside the [brackets] the default is shown Capitalized, as the first
  option and separated from the other options by a space.
  
  y (or Y)  yep
  n (or N)  no
  a         auto: proceed until end without querying
  q         quit configuring this file, this file will be left unfinished;
            to quit altogether, use Ctrl-C or your respective
            interrupt key
__eoh__
      } >&2
      _ans_=
      ;;
    [Qq]* )
      exit 1
      ;;
    ''    )
      case "$_dfl_" in
      Y* ) _tst_=true  ;;
      N* ) _tst_=false ;;
      esac
      _ans_=ok
      ;;
    esac
  done
fi

test -n "$G_verb3a_" && _verb3a_="$G_verb3a_" || _verb3a_=using
test -n "$G_verb3b_" && _verb3b_="$G_verb3b_" || _verb3b_=using
  
if eval "$_tst_" && test -z "$_auto"
then
  if test -n "$F_define"
  then
    test -n "$_sym_" && echo "#define $_sym_ $_val_" || echo "$_yea_fea_"
  fi
  test -n "$F_using" && echo "	$_verb3a_ $_yea_..." >&2
  _yea=yep
  _nay=
else
  if test -n "$F_define"
  then
    test -n "$_sym_" && echo "/*#define $_sym_*/" || echo "$_nay_fea_"
  fi
  if test -n "$F_using"
  then
    test -n "$_nay_" && echo "	$_verb3b_ $_nay_..." >&2 || echo "	not $_verb3a_ $_yea_..." >&2
  fi
  _yea=
  _nay=nope
fi

_res="${_yea}${_nay}"
test -n "$F_define" && echo

G_verb1_=
G_subj_=
G_verb2_=
G_verb3a_=
G_verb3b_=
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         # bz.ifksh
#
# set the global flag F_must_ksh if we must refeed ourselves
# (for some reason or another) through ksh
#

F_cray="`(uname -m)2>/dev/null|grep -i cray`"

if test -n "$F_cray"
then
  F_must_ksh=yep
fi

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          . ./config/bz.saveargv
. ./config/bz.defaults
. ./config/bz.ifksh

trap "$TRAPN" $TRAPSIGS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # --- bz.makecc

# --- find out the C compiler

if test -z "$CC"
then
  if test -n "$C_CC"
  then
    CC="$C_CC"
  else
    set c89 c89 "/usr/bin /bin"
    . ./config/bz.walk
    if test -n "$c89"
    then CC=c89; C89=yep
    elif test -n "$MIPS"
    then CC='cc -systype bsd43'
    elif test -n "$TITAN"
    then CC='cc -43'
    else CC=$DEFAULT_CC	# the default CC
    fi
  fi
fi

test -z "$CC" && CC="$DEFAULT_C_CC"

set CC "$CC" "C compiler"
. ./config/bz.define

test -n "$C89" && echo "	(at least judging by name $CC does ANSI...)"

# --- GNU cc?

if test -n "$C89" -o -n "$B_gcc" -o -n "$B_strictgcc" -o -n "$B_mediumgcc"
then
  maybegcc="`$CC -v 2>&1|egrep '^gcc version '`"
  if test -n "$maybegcc"
  then
    echo "	($CC seems to be GNU...)"
    case "$CC" in
    *gcc*) echo "	(surprised?)" ;;
    esac
  fi
else
  test -n "$CC_MIPS_STYLE" && echo "	($CC might be MIPS style...)"
fi

makecc_done=yep
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 lif test -n "$OSF1" -o -n "$TITAN" -o -n "$HPUX"
  then LIBS='-ltermcap'
  elif test -n "$SEQUENTPTX"
  then LIBS='-ltermlib -lX11 -lseq'
  elif test -f /usr/lib/libcposix.a
  then LIBS='-lcposix -ltermcap'
  elif test -f /usr/lib/libBSD.a
  then LIBS='-ltermcap -lBSD'
  elif test -f /usr/lib/libtermcap.a -o -f /usr/ucblib/libtermcap.a
  then
    if test -n "$AIX"
    then LIBS='-lcurses'	# -lbsd should not be needed
    else LIBS='-ltermcap'
    fi
  fi
fi

test -z "$LIBS" -a -n "$C_LIBS" && LIBS="$C_LIBS"
test -z "$LIBS" && LIBS="$DEFAULT_C_LIBS"
set LIBS "$LIBS" "libraries to link with"
. ./config/bz.define

# -- modules

echo '	Working out modules (*.{[hco],pro})...'

modules="/tmp/modules$$"
modules_c="${modules}.c"
modules_h="${modules}.h"
modules_o="${modules}.o"
modules_p="${modules}.p"

trap "rm -f $modules $modules_c $modules_h $modules_o $modules_p;$TRAPN" $TRAPSIGS

(exec >$modules
# C source files and header files, one file per line,
# between "cat <<foo" and "foo"-lines
cat <<foo
builtin.c
cond.c
exec.c
glob.c
hist.c
init.c
jobs.c
lex.c
loop.c
math.c
mem.c
params.c
parse.c
subst.c
table.c
text.c
utils.c
watch.c
zle_bindings.c
zle_hist.c
zle_main.c
zle_misc.c
zle_move.c
zle_refresh.c
zle_tricky.c
zle_utils.c
zle_vi.c
zle_word.c
funcs.h
zle.h
zsh.h
ztype.h
foo
)

echo '	.c....'
egrep '\.c$' $modules > $modules_c
SRC=`cat $modules_c|tr '\012' ' '`

# as SRC but without .c 
BSRC=`cat $modules_c|sed 's/\.c$//'|tr '\012' ' '`

echo '	.h....'
egrep '\.h$' $modules > $modules_h
HEADER=`cat $modules_h | tr '\012' ' '`

test -n "$make_groks_VPATH" && c_blddir= || c_blddir="$C_BLDDIR"

echo '	.pro....'
sed 's/\.c$/.pro/' < $modules_c | sed "s%^%$c_blddir%" > $modules_p
PROTO=`cat $modules_p | tr '\012' ' '`

echo '	.o....'
sed 's/\.c$/.o/' < $modules_c | sed "s%^%$c_blddir%" > $modules_o
OBJS=`cat $modules_o | tr '\012' ' '`

rm -f $modules $modules_c $modules_h $modules_o $modules_p

{
  echo
  echo "	probed for Makefile..."
  echo
} >&2

fi

# -- find out how to build the .c.o rule

ccit='$(CC) $(CFLAGS) -c $(DFLAGS)'
ccdotc='$<'
ccseparate=
makeprecd=
makefflag=
ccinc=

if test -z "$F_bld_eq_src"
then
  test -n "$C_SRCDIR" && ccinc=" -I$C_SRCDIR"
  if test -z "$B_makeatbld"
  then
     makefflag="-f $MAKEFILE"
     ccinc=" -I$C_BLDDIR"
  else
     makeprecmd="cd $C_BLDDIR && "
     ccseparate=yep
  fi
  if test -n "$make_groks_VPATH"
  then
     if test -z "$B_makeatbld"
     then
       ccit="$ccit$ccinc -o ${C_BLDDIR}\$@ "
     fi
  else
     if test -n "$B_makeatbld"
     then
       ccit="$ccit$ccinc"' -o `basename ${C_SRCDIR}\$@`'
     else
       ccseparate=yep
     fi
  fi
fi

# all set

make_probe_done=yep

###
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               # --- bz.makevpath

# --- cc?

test -z "$makecc_done" && . ./config/bz.makecc

# --- does $MAKE grok VPATH?

test -z "$MAKE" && MAKE=make	# failsafe
echo "	checking whether $MAKE understands VPATH..." >&2

make_groks_VPATH=

oldwd=`pwd`
mkdir $VPATHTMP $VPATHTMPa $VPATHTMPb
if test -d "$VPATHTMP" -a -d "$VPATHTMPa" -a -d "$VPATHTMPb"
then
  cd $VPATHTMPa && echo 'static int foo = 42;' > foo.c
  if test -f $VPATHTMPa/foo.c
  then
    cd $VPATHTMPb && {
      cat > Makefile <<'foo'
foo.o:	foo.c
	@$(CC) -c $<
foo
      if test -f $VPATHTMPb/Makefile
      then
        $MAKE VPATH=$VPATHTMPa 2>/dev/null
        test -s $VPATHTMPb/foo.o && make_groks_VPATH=yep
        rm -f $VPATHTMPb/foo.o $VPATHTMPb/Makefile
      fi
    }
    rm -f $VPATHTMPa/foo.c
  fi
  (cd $VPATHTMP && \
   rmdir $VPATHTMPa && \
   rmdir $VPATHTMPb && \
   cd .. && rmdir $VPATHTMP)
fi
cd $oldwd

echo
echo "	($MAKE does "`test -z "$make_groks_VPATH" && echo "not "`"understand VPATH...)"
echo

make_groks_VPATH_done=yep

###
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   # --- bz.makeprobe

# --- make groks VPATH?

test -z "$make_groks_VPATH_done" && . ./config/bz.makevpath

# -- 

if test -z "$B_justmake"
then

cat <<foo
	probing for Makefile...

foo

# --- cc?

test -z "$makecc_done" && . ./config/bz.makecc

# --- CFLAGS

if test -z "$C_CFLAGS"
then

CFLAGS_D="$CFLAGS_D $C_CFLAGS_D"

CFLAGS_X="$CFLAGS_X $C_CFLAGS_X"

CFLAGS_W="$CFLAGS_W $C_CFLAGS_W"

if test -n "$B_debug"
then
  CFLAGS_g="`echo $CFLAGS_g $C_CFLAGS_g | sed 's/^ +$//'`"
  test -z "$CFLAGS_g" && CFLAGS_g="$DEFAULT_C_CFLAGS_g"
fi

if test -n "$B_zshdebug"
then
  CFLAGS_z="$CFLAGS_z $C_CFLAGS_z"
  test -z "$CFLAGS_z" && CFLAGS_z="$DEFAULT_C_CFLAGS_z"
fi

D_HP='-D_XOPEN_SOURCE -D_HPUX_SOURCE'

if test -n "$B_gcc" -o -n "$LINUX" -o -n "$NEXT"
then
  # NeXT 3.* has POSIX headers but no POSIX libs, sheesh
  # LINUX has no prototypes for non-ANSI stuff, sheesh
  if test -n "$LINUX" -o -n "$NEXT"
  then
    CFLAGS_W="$GCC_BASE0_W"	# no -ansi or -Wmissing-prototypes
  else
    CFLAGS_W="$GCC_BASE1_W"
  fi
  DEFAULT_C_CFLAGS_O=-O2
  test -n "$B_mediumgcc" && CFLAGS_W="$CFLAGS_W $GCC_MEDIUM_W"
  test -n "$B_strictgcc" && CFLAGS_W="$CFLAGS_W $GCC_STRICT_W"
  test -n "$NEXT" -o -n "$LINUX" && CFLAGS_X="$CFLAGS_X -pipe"
  test -z "$LINUX" -a -z "$NEXT" && CFLAGS_X="$CFLAGS_X -fpcc-struct-return"
  test Z"$host" = Z"i486"        && CFLAGS_M="$CFLAGS_M -m486"
  # if we have gcc, never mind that the native cc might be mips
  CC_MIPS_STYLE=
elif test -n "$APOLLO"
then CFLAGS_W="$CFLAGS_W -A nansi"
elif test -n "$HPUX"
then
  CFLAGS_D="$CFLAGS_D $D_HP -D_POSIX_SOURCE"
  if test -n "$C89"
  then CFLAGS_W="$CFLAGS_W +w1"
  else test Z"$HPUX" = Z"7.03" && CFLAGS_X="$CFLAGS_X -Wc,-Ns5000"
  fi
  C_LDFLAGS="$C_LDFLAGS -z"
elif test -n "$AIX"
then test -n "$C89" && CFLAGS_D="$CFLAGS_D -D_ALL_SOURCE"
elif test -n "$HPOSF"
# HPOSF must be tested before OSF1
then
  CFLAGS_D="$CFLAGS_D $D_HP -D_OSF_SOURCE"
  CFLAGS_W="$CFLAGS_W -q lang_level:ansi"
elif test -n "$OSF1"			# NOTE: the -Olimit N 
then CFLAGS_W="$CFLAGS_W -std1"	# is done later on
elif test -n "$NEWS"			# as it will be useful
then CFLAGS_W="$CFLAGS_W -std"	# only iff optimization
elif test -n "$MIPS"			# will be used.
then
  CFLAGS_W="$CFLAGS_W -std1"
  CFLAGS_X="$CFLAGS_X -Wf,-XNd5000 -Wf,-XNl4096"
elif test -n "$CONVEX"
then
CFLAGS_W="$CFLAGS_W -d arg_ptr_qual=w -d arg_ptr_ref=w -d bad_escape=w -d class_ignored=w -d const_not_init=w -d division_by_zero=w -d dollar_names=w -d escape_range_sequence=w -d float_suffix=w -d function_parameter=w -d hidden_arg=w -d hidden_extern=w -d hides_outer=w -d implicit_decl=w -d integer_overflow=w -d long_long_suffix=w -d no_arg_type=w -d no_external_declaration=w -d no_newline=w -d non_int_bit_field=w -d nothing_declared=w -d pp_argcount=w -d pp_argsended=w -d pp_badstr=w -d pp_badtp=w -d pp_badtp_cmdl=w -d pp_error_directive=w -d pp_extra=w -d pp_idexpected=w -d pp_line_range=w -d pp_macro_arg=w -d pp_macro_redefinition=w -d pp_macro_redefinition_cmdl=w -d pp_malformed_directive=w -d pp_old_dir=w -d pp_parse=w -d pp_undef=w -d pp_undef_cmdl=w -d pp_unrecognized_directive=w -d pp_unrecognized_pragma=w -d ptr_cvt_truncates=w -d qualified_cast=w -d record_fn_call=w -d record_fn_defn=w -d shift_too_large=w -d short_cvt_truncates=w -d strict_syntax=w -d unsigned_suffix"
elif test -n "$SOLARIS"
then
# -Xa would be nicer but it is strictish ANSI, while zsh
# needs K&R, so -Xs (s=sun) it is
# If you dream of -D_POSIX_SOURCE, quit dreaming.
  DEFAULT_C_CFLAGS_O="$DEFAULT_C_CFLAGS_O -xO2"
  CFLAGS_W="$CFLAGS_W -v -Xs"
elif test -n "$UNICOS"
then CFLAGS_W="$CFLAGS_W -h stdc"
elif test -f ${headerdir}/ndir.h -a ! -f /usr/lib/libBSD.a
then CFLAGS_W="$CFLAGS_W -Aa"
elif test -n "$IRIX"
then
  CFLAGS_W="$CFLAGS_W -prototypes -fullwarn"
  if test -n "$IRIX5"
  then CFLAGS_W="$CFLAGS_W -woff 799"
  else CFLAGS_W="$CFLAGS_W -woff 2,183,262,269,270,286,287,302,303,309"	# IRIX 4
  fi
fi

# optimization by default on
CFLAGS_O="`echo $CFLAGS_O $C_CFLAGS_O | sed 's/^ +$//'`"
test -z "$CFLAGS_O" && CFLAGS_O="$DEFAULT_C_CFLAGS_O"

if test -n "$B_noopt"
then
  CFLAGS_O=
fi

fi

# --- do -c and -o work simultaneously?

if test -z "$F_bld_eq_src"
then

cc_groks_c_o=
cc_groks_c_o_done=

if test -z "$cc_groks_c_o_done"
then

for co in $CC_GROK_c_o
do
 if test -n "`eval echo '$'$co`"
 then
   cc_groks_c_o=yep
   cc_groks_c_o_done=yep
   break
 fi
done

fi

if test -z "$cc_groks_c_o_done"
then

for co in $CC_LOSE_c_o
do
 if test -n "`eval echo '$'$co`"
 then
   cc_groks_c_o=
   cc_groks_c_o_done=yep
   break
 fi
done

fi

if test -z "$cc_groks_c_o_done"
then

# well, we must really test for it, then, mustn't we?

tmpc=/tmp/_tmp$$.c
tmpo=/tmp/_tmp$$.o

trap "rm -f $tmpc $tmpo;$TRAPN" $TRAPSIGS

echo 'int foo=42;' > $tmpc
# this C program *should* not elicit any other errors than just
# the complaint about simultaneous -c and -o
test -n "`($CC -c -o $tmpo $tmpc 2>&1)`" && cc_groks_c_o=

rm -f $tmpc $tmpo

cc_groks_c_o_done=yep

fi

if test -z "$cc_groks_c_o"
then
  if test -n "$F_bld_eq_src"
  then
    CC_JUST_C=yep
  else
    CC_LOSES_c_O=yep
  fi
fi

G_verb1_=Does
G_subj_=$CC
G_verb2_=understand
set 'test -z "$cc_groks_c_o"' cc_groks_c_o 1 "-c and -o simultaneously"
. ./config/bz.ifdef

fi

# --- do -g and -O work simultaneously?

if test -z "$B_noopt" -a -n "$B_debug" -a -n "$CFLAGS_O"
then

cc_groks_g_O=
cc_groks_g_O_done=

if test -z "$cc_groks_g_O_done"
then

for co in $CC_LOSE_g_O
do
 if test -n "`eval echo '$'$co`"
 then
   cc_groks_g_O=
   cc_groks_g_O_done=yep
   break
 fi
done

fi

if test -z "$cc_groks_g_O_done"
then

for co in $CC_GROK_g_O
do
 set Z `echo $co|tr -d "'" |tr ":" " "`
 if test -n "`eval echo '$'$1`"
 then
   test -n "$3" && CFLAGS_g="$3"
   test -n "$4" && CFLAGS_O="$4"
   cc_groks_g_O=yep
   cc_groks_g_O_done=yep
   break
 fi
done

fi

if test -z "$cc_groks_g_O_done"
then

# well, we must really test for it, then, mustn't we?

tmpc=/tmp/_tmp$$.c
tmpo=/tmp/_tmp$$.o

trap "rm -f $tmpc $tmpo;$TRAPN" $TRAPSIGS

echo 'int foo=42;' > $tmpc
# this C program *should* not elicit any other errors than just
# the complaint about simultaneous -g and -O
test -z "`($CC $CFLAGS_g $CFLAGS_O -o $tmpo -c $tmpc 2>&1)`" && cc_groks_g_O=yep

rm -f $tmpc $tmpo

cc_groks_g_O_done=yep

fi

G_verb1_=Does
G_subj_=$CC
G_verb2_=understand
set 'test -n "$cc_groks_g_O"' cc_groks_g_O 1 "-g and -O simultaneously"
. ./config/bz.ifdef

fi

# ---

if test -n "$CFLAGS_O" -a -n "$CFLAGS_g" -a -z "$cc_groks_g_O"
then
  echo "	($CC cannot simultaneously optimize (-O) and debug (-g),"
  if test -n "$B_debug"
  then
    echo "	turning off optimization...)"
    CFLAGS_O=
  elif test -z "$B_noopt"
  then
    echo "	turning off debug...)"
    CFLAGS_g=
  fi
fi

### Optimization complexity level
# for MIPS style compilers
if test -n "$CFLAGS_O" -a -n "$CC_MIPS_STYLE" -a -z "`echo $CFLAGS_O|grep Olimit`"
then
  CFLAGS_O="$CFLAGS_O -Olimit 1000"
fi

if test -n "$B_query"
then

set CFLAGS_O "$CFLAGS_O" "$CC optimizer flags (e.g. -O)"
. ./config/bz.define

set CFLAGS_g "$CFLAGS_g" "$CC debug flags (e.g. -g)"
. ./config/bz.define

set CFLAGS_X "$CFLAGS_X" "$CC additional flags (fancy -Defines, etc)"
. ./config/bz.define

fi

# the final joining of various CFLAGS_

# non-optimizing CFLAGS
CFLAGS_WO_O="`echo $CFLAGS_D $CFLAGS_W $CFLAGS_X $CFLAGS_g $CFLAGS_z $CFLAGS_M|sed 's/  */ /g'`"

CFLAGS_W_O="`echo $CFLAGS_WO_O $CFLAGS_O|sed 's/  */ /g'`"

if test -z "$CFLAGS" -a -n "$C_CFLAGS"
then
  CFLAGS="$C_CFLAGS"
else
  CFLAGS="$CFLAGS_W_O"
fi
set CFLAGS "$CFLAGS" "$CC flags"
. ./config/bz.define

# LD

LD="$CC"

test -z "$LD" -a -n "$C_LD" && LD="$C_LD"
test -z "$LD" && LD="$DEFAULT_C_LD"
set LD "$LD" "linker"
. ./config/bz.define

# LDFLAGS

LDFLAGS="`echo $CFLAGS_X $CFLAGS_M $CFLAGS_O $CFLAGS_g|sed 's/  */ /g'`"

test -n "$C_LDFLAGS" && LDFLAGS="$C_LDFLAGS"
set LDFLAGS "$LDFLAGS" "link flags"
. ./config/bz.define

# --- LIBS

if test -z "$LIBS"
then

  if test -n "$IRIX"
  then
    if grep '^\+' /etc/passwd >/dev/null 2>&1
    then LIBS='-lcurses -lmalloc -lbsd -lsun'
    else LIBS='-lcurses -lmalloc -lbsd'
    fi
  elif test -n "$SOLARIS"
  then LIBS='-ltermcap -lnsl'
  elif test -n "$BBN"
  then LIBS='-ltermcap -lposix'
  e# --- INSTDIR sanity checking
if test -n "$INSTDIR"
then
  if test -n "$BINDIR" -o -n "$MANDIR"
  then
    echo 'When INSTDIR is defined, neither BINDIR or MANDIR can be defined'
    echo 'Aborting.'
  else
    BINDIR="$INSTDIR/bin"
    MANDIR="$INSTDIR/man/man1"
  fi
fi
# --- default: do all the files
if test -z "$B_Makefile" -a -z "$B_signals_h" -a -z "$B_config_h"
then
  B_Makefile=1
  B_signals_h=1
  B_config_h=1
fi

# --- (defaults handling)

for cp in $CONFIG_PARMS
do
  if test -z "`eval echo '$'C_$cp`"
  then
    case "$cp" in
    INSTDIR)	;;
    BINDIR)	C_BINDIR=$DEFAULT_C_BINDIR ;;
    MANDIR)	C_MANDIR=$DEFAULT_C_MANDIR ;;
    ETCDIR)	C_ETCDIR=$DEFAULT_C_ETCDIR ;;
    CC)		;;
    CFLAGS)	;;
    CFLAGS_D)	;;
    CFLAGS_M)	;;
    CFLAGS_W)	;;
    CFLAGS_X)	;;
    CFLAGS_O)	;;
    CFLAGS_g)	;;
    CFLAGS_z)	;;
    LDFLAGS)	;;
    DFLAGS)	C_DFLAGS=$DEFAULT_C_DFLAGS ;;
    LIBS)	C_LIBS=$DEFAULT_C_LIBS;;
    SRCDIR)	C_SRCDIR=$DEFAULT_C_SRCDIR ;;
    BLDDIR)	C_BLDDIR=$DEFAULT_C_BLDDIR ;;
    ARCH)	;;
    ARCHPATT)	C_ARCHPATT="$DEFAULT_C_ARCHPATT" ;;
    MAKE)	C_MAKE=$DEFAULT_C_MAKE ;;
    *)	echo 'Unrecognized configurable parameter "'$cp'"'
	echo 'Recognized configurable paramaters : '$CONFIG_PARMS
	echo 'Aborting.'
	exit 1
	;;
    esac
  fi
done

for cp in $BOOL_PARMS
do
  if test -z "`eval echo '$B_'$cp`" -a -n "`eval echo '$DEFAULT_B_'$cp`"
  then
    eval "B_$cp=\"`eval echo '$DEFAULT_B_'$cp`\""
  fi
done

# *both* "auto" *and* "query" do not make sense
if test -n "$B_auto" -a -n "$B_query"
then
  echo
  echo 'Options "auto" and "query" simultaneously do not make sense.'
  echo 'Dropping option "auto".'
  B_auto=
fi

# add the debug / optimization flags if necessary
test -n "$B_debug"    && DEFAULT_C_CFLAGS="$DEFAULT_C_FLAGS "'$(CFLAGS_g)'
test -z "$B_noopt"    && DEFAULT_C_CFLAGS="$DEFAULT_C_FLAGS "'$(CFLAGS_O)'
test -n "$B_zshdebug" && DEFAULT_C_DFLAGS="$DEFAULT_C_FLAGS "'$(CFLAGS_D)'

# SRCDIR and BLDDIR sanity check
# (sanity = empty if just ".",_one_ trailing "/" if non-empty )

test Z"$C_SRCDIR" = Z"." && C_SRCDIR=
test -n "$C_SRCDIR" && SRCDIR="`echo $C_SRCDIR/ | sed 's%//*$%/%'`"
test Z"$C_BLDDIR" = Z"." && C_BLDDIR=
test -n "$C_BLDDIR" && BLDDIR="`echo $C_BLDDIR/ | sed 's%//*$%/%'`"

# whether the building and the source directory are the same
test Z"`(cd $C_BLDDIR;pwd)`" = Z"`(cd $C_SRCDIR;pwd)`" && F_bld_eq_src=yep

MAKEFILE=${C_BLDDIR}Makefile
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # --- (argument vector saving)

_argv=
for _argi in "$@"
do
  # @@@ ["'] should actually be escaped with \
  if test Z"`echo \"$_argi\"|egrep '[ 	]'`" != Z
  then
    _argv="$_argv \"$_argi\""
  else
    _argv="$_argv $_argi"
  fi
done
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    # --- (subroutine for PATH-like walking)

_var_=$1
_fil_=$2	# can actually be dirs too
_dir_=$3
_dfl_=$4
for _f_ in $_fil_
do
  for _d_ in $_dir_
  do
    _df="$_d_/$_f_"
    if test -f "$_df" -o -d "$_df"
    then
      eval $_var_="$_df"
      break
    fi
  done
  eval "test -n \"\$$_var_\" || $_var_=$_dfl_"
  eval "test -n \"\$$_var_\" && break"
done
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           # --- ${BLDDIR}signals.h

if test -n "$B_signals_h"
then

F_define=yep

echo
echo Building ${BLDDIR}signals.h... | tr -d '\012'
if test -n "$LINUX" -o -n "$UNICOS" -o -n "$AIX" -o -n "$SCO"
# Awk script taken from Larry Wall's perl Configure script
then 
if test -n "$LINUX"
then sigfile=/usr/include/linux/signal.h
else sigfile=/usr/include/sys/signal.h
fi
echo `cat $sigfile 2>&1 | awk '
$1 ~ /^#define$/ && $2 ~ /^SIG[A-Z0-9]*$/ && $3 ~ /^[1-9][0-9]*$/ {
	if (sig[$3] == "") {
	sig[$3] = substr($2,4,20)
    if (max < $3 && $3 < 60) {
	max = $3
	}
	}
}
# next case handles "# define SIGx y"
$1 ~ /^#$/ && $2 ~ /^define$/ && $3 ~ /^SIG[A-Z0-9]*$/ && $4 ~ /^[1-9][0-9]*$/ {
	if (sig[$4] == "") {
    sig[$4] = substr($3,4,20)
    if (max < $4 && $4 < 60) {
	max = $4
	}
    }
}
END {
    for (i=1; i<=max; i++) {
	if (sig[i] == "")
	    printf "%d", i
	else
	    printf "%s", sig[i]
	if (i < max)
	    printf " "
    }
    printf "\n"
}
'` | tr ' ' '\012' > ${BLDDIR}signals.h
else echo `csh -fc 'kill -l'` | tr ' ' '\012' >${BLDDIR}signals.h
fi
lct=`wc -l < ${BLDDIR}signals.h`
cp ${BLDDIR}signals.h ${BLDDIR}signams.h
(
cat <<foo
/* signals.h */
/* architecture-customized signals.h for $VERSION
 * for architecture "$arch",
 * automagically generated by buildzsh -- do not edit */
/* if all this is wrong, blame csh ;-) */

#define SIGCOUNT $lct

#ifdef GLOBALS

char *sigmsg[SIGCOUNT+2] = {
	"done",
foo

sed -e 's/^/SIG/' -e '/SIGHUP/s//hangup/
/SIGINT/s//interrupt/
/SIGQUIT/s//quit/
/SIGILL/s//illegal instruction/
/SIGTRAP/s//trace trap/
/SIGIOT/s//IOT instruction/
/SIGABRT/s//abort/
/SIGEMT/s//EMT instruction/
/SIGFPE/s//floating point exception/
/SIGKILL/s//killed/
/SIGBUS/s//bus error/
/SIGSEGV/s//segmentation fault/
/SIGSYS/s//bad system call/
/SIGPIPE/s//broken pipe/
/SIGTERM/s//terminated/
/SIGPWR/s//power fail/
/SIGVTALRM/s//virtual time alarm/
/SIGCONT/s//continued/
/SIGALRM/s//alarm/
/SIGUSR1/s//user signal 1/
/SIGUSR2/s//user signal 2/
/SIGCHLD/s//death of child/
/SIGIO/s//i\/o ready/
/SIGPROF/s//profile signal/
/SIGWINCH/s//window size changed/
/SIGXCPU/s//cpu limit exceeded/
/SIGXFSZ/s//filesize limit exceeded/' -e 's/.*/	"&",/' ${BLDDIR}signals.h
echo '	NULL
};

char *sigs[SIGCOUNT+4] = {
	"EXIT",' ) >${BLDDIR}sigtmp.h
mv ${BLDDIR}sigtmp.h ${BLDDIR}signals.h
if grep SIGSTOP ${BLDDIR}signals.h >/dev/null
then ed ${BLDDIR}signals.h <<'foo' >/dev/null 2>&1
/SIGSTOP/c
#ifdef USE_SUSPENDED
	"suspended (signal)",
#else
	"stopped (signal)",
#endif
.
/SIGTSTP/c
#ifdef USE_SUSPENDED
	"suspended",
#else
	"stopped",
#endif
.
/SIGTTIN/c
#ifdef USE_SUSPENDED
	"suspended (tty input)",
#else
	"stopped (tty input)",
#endif
.
/SIGTTOU/c
#ifdef USE_SUSPENDED
	"suspended (tty output)",
#else
	"stopped (tty output)",
#endif
.
w
q
foo
fi
(sed 's/.*/	"&",/' ${BLDDIR}signams.h
echo '	"ZERR",'
echo '	"DEBUG",
	NULL
};

#else

extern char *sigs[SIGCOUNT+4],*sigmsg[SIGCOUNT+2];

#endif') >>${BLDDIR}signals.h
rm ${BLDDIR}signams.h
echo done
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         --dont-format-comments
--dont-break-procedure-type
--no-parameter-indentation
--indent-level4
--line-comments-indentation4
--cuddle-else
--brace-indent0
--dont-star-comments
--blank-lines-after-declarations
--blank-lines-after-procedures
--no-blank-lines-after-block-comments
--no-blank-lines-after-commas
--comment-indentation33
--declaration-comment-column33
--no-comment-delimiters-on-blank-lines
--continuation-indentation4
--case-indentation0
--else-endif-column33
--no-space-after-casts
--no-blank-before-sizeof
--declaration-indentation0
--continue-at-parentheses
--no-space-after-function-call-names
--swallow-optional-blank-lines
--dont-space-special-semicolon
--tab-size8
--line-length132
--braces-on-if-line
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #! /bin/make -f
# Makefile for zsh
# generated by buildzsh

AUX=buildzsh

SRC=builtin.c cond.c exec.c glob.c hist.c init.c jobs.c lex.c loop.c \
math.c mem.c params.c parse.c subst.c table.c text.c utils.c watch.c \
zle_bindings.c zle_hist.c zle_main.c zle_misc.c zle_move.c zle_refresh.c \
zle_tricky.c zle_utils.c zle_vi.c zle_word.c

HEADER=funcs.h zle.h zsh.h ztype.h

PROTO=builtin.pro cond.pro exec.pro glob.pro hist.pro init.pro jobs.pro \
lex.pro loop.pro math.pro mem.pro params.pro parse.pro subst.pro table.pro \
text.pro utils.pro watch.pro zle_bindings.pro zle_hist.pro zle_main.pro \
zle_misc.pro zle_move.pro zle_refresh.pro zle_tricky.pro zle_utils.pro \
zle_vi.pro zle_word.pro

OBJS=builtin.o cond.o exec.o glob.o hist.o init.o jobs.o lex.o loop.o \
math.o mem.o params.o parse.o subst.o table.o text.o utils.o watch.o \
zle_bindings.o zle_hist.o zle_main.o zle_misc.o zle_move.o zle_refresh.o \
zle_tricky.o zle_utils.o zle_vi.o zle_word.o

BINDIR=/usr/local/bin
MANDIR=/usr/local/man/man1

# Debugging flags
DFLAGS = # -DQDEBUG

# For gcc 2.3.3
# CC=gcc -fpcc-struct-return
# CFLAGS= -O2 -g -Wall -Wno-implicit -Wno-parentheses -Wno-comment $(DFLAGS)

CC=cc
CFLAGS= -O
LIBS= -ltermcap

ZSHPATH=zsh

.SUFFIXES: .c .o .pro

.c.o:
	$(CC) $(CFLAGS) $(DFLAGS) -c $<

.c.pro:
	sed -n '/\/\*\*\/$$/{N;s/^\([^(]*\).*\/\*\*\/.\(.*\)/\1 DCLPROTO((\2))/p;}' $< | sed -e 's/;/,/g' -e 's/,))$$/));/' -e 's/(({))$$/((void));/' >$@

all: $(PROTO) $(ZSHPATH)

$(ZSHPATH): $(OBJS)
	$(CC) -o $(ZSHPATH) $(OBJS) $(LIBS) $(LFLAGS)
	
tags: /tmp
	ctags *.[cy]

# I hate this next line
$(OBJS): config.h zsh.h zle.h signals.h ztype.h funcs.h

params.o: version.h

clean:
	rm -f *.o *.pro zsh core 

cleanall:
	rm -f *.o *.pro zsh core Makefile signals.h config.h

install: zsh
	install -s -m 755 zsh $(BINDIR)
	install -m 444 ../man/man1/zsh.1 $(MANDIR)
                                                                                                                                                                                                     PURPOSE

	This directory contains shell scripts that are used by
	src/buildzsh.

FILES

	Hierarchical list	Function of
	of scripts called by	the particular
	buildzsh.		script.
	--------------------	--------------

	bz.init			Initialization...
		bz.saveargv		saving argv
		bz.defaults		for parameters
		bz.ifksh		for ksh-must
	bz.argh			Argument handling...
		bz.help			showing help
	bz.check		Argument checking...
		bz.doksh		do ksh if necessary
		bz.sanity		fix up some parameters
	bz.hs			Header building...
		bz.config.h		config.h
		bz.signals.h		signals.h
	bz.Makefile		Architecture-specific Makefile building...
	bz.finale		Shall we $MAKE?
	
NOTES

	The following notes are meant for buildzsh hackers,
	for others it will be a healthy example about the
	problems of writing large and portable shell scripts.

	The notes are indicated by a '*' in the left margin and
	they are are followed by (some of) the names of the bz.* files
	that are affected by the particular note.

* all the sh-constructs must be also "Korn-compliant"
  so that ksh also can munch this script.  This is normally not
  a big headache because ksh should be superset of Bourne sh.

  some miserable Bourne shells fail for some reason or another
  while executing buildzsh, we will try for those wrecthes whether
  ksh comes to rescue.

	bz.ifksh
	bz.doksh
	bz.Makefiles

* because the Makefiles are built by <<eof method *inside* buildzsh,
  they have to be BOTH "Bourne-compliant" AND "Korn-compliant".
  Therefore, certain measures have to be taken as certain
  constructs are understood differently amongst sh/ksh/make.
  These constructs are
        
        $@              (sh and make)
        $(foo)          (ksh and make)

  If these constructs are to be as "make" them understands, they MUST
  be escaped with a leading backlash as follows

        \$@
        \$(foo)

  All the "here-document" (<<EOF) situations cannot be handled with
  <<'quoted-eof' trick, which would cure both the above problems,
  because the expansion of $bar by sh/ksh is extensively used by
  for example

        CC=$CC

  where $CC has been resolved by sh/ksh.  Note, however, that when
  no $bar style expansions are needed during <<, the <<'quoted-eof'
  method is viable and the \ escaping is not needed.

	bz.Makefiles

* do NOT even think about using the <<trick as

  if test ...
  then
  exec >somefile
  cat <<eof
  ...
  eof
  fi
  
  thanks to Sun.  In ScumOS, you will get error messages like
  buildzsh: /tmp/sh1708429: No such file or directory
  after each 'cat' for each exec-cat pair.
  One must resort to the work-around: using subshells

  if test ...
  then
  (exec >somefile
  cat >>eof
  ...
  eof
  )
  fi
  
  Note that one must be careful about the closing (: it can come
  many lines after the initial cat <<'s eof, in buildzsh normally
  just before the 'fi' that closes down the building of some file

  if test ...doing-some-file
  then
  (exec >some-file
  ...
  )
  fi

	bz.Makefile
	bz.config.h

* do not use "test -x" because some braindead (but wide-spread)
  tests do not know such a flag, use "-f" instead, that *should* work
  everywhere.

	bz.Makefile
	bz.config.h
	bz.doksh
	bz.help
	bz.hosttype

* do not use "tr -s", either, use sed for that.

* the argument list of the buildzsh is saved by bz.init/bz.saveargv
  in to a variable called _argv that can be used in constructs like

  for i in $_argv
  do
    ...

  Whitespace is correctly saved in _argv.
  (but exotic quoting might get fatal?)

* there are a couple of subroutinish scripts that are used to automatize
  the chores of asking/looking for different kinds of questions.

  The calling sequence is as follows

	set arg1 arg2 arg3 arg4 ...
	. bz.foo
  
  Worrying about $@?  Saved in $_argv, see above.

  bz.define:

	Usage:

	set symbol_name default_value description [ empty_ok [ quote_it ] ]
	. bz.define

	Used to #define FOO, the definition is output to stdout.

	If empty answer is ok, the 4th argument should be non-empty.
	
	If the 5th argument is either " or ', the whole answer is
	quoted with that particular character (on both sides, of course).

  bz.ifdef:

	Usage:

	set test symbol_name default_value yea_feature \
            [ nay_feature [ feature_name ] ]

	Used to #define but only iff some condition holdsds,
	the definition is output to stdout.

	In query mode the question is normally paraphrased as
	"Do you have YEA_FEATURE?".  These can be (and are)
	customized: Do is G_verb1_, you is G_subj_, have is G_verb2_.
	See for example the "suspended"/"stopped" question in
	bz.config.h, there the "have" is changed into "prefer".

	This is the subroutine that says "using foo..." or
	"not using foo...".  Also the "using" can be customized,
	it is G_verb3a_ and G_verb3b_, corresponding to the positive
	and negative senses.

	All the G_{verb,subject}X customizations are temporary:
	each bz.ifdef call resets the defaults.

	You can test the variables _yea and _nay after the
	bz.ifdef call to know which alternative was chosen.

  bz.walk:

	set variable_name "file ..." "dir ..." default
	. bz.walk

  	Searches PATH-like for multiple files from multiple directories.
  	The first existing dir/file is set as the value of variable_name.
  	If no such exists, the default is used as the value.
  	The outer loop steps through files and the inner through directories.
  	For example:

	set gorp "cc gcc" "/usr/local/bin /usr/bin /bin" /bin/echo
	. bz.walk

  	This will try /usr/local/bin/cc, /usr/bin/cc, /bin/cc,
	/usr/local/bin/gcc, /usr/bin/gcc, and /bin/gcc, in that order.
	If none of these exist, gorp will have the value /bin/echo.

* As soon as you know for certain whether your C compiler groks -c and -o
  simultaneously or not, add the correct variable to test to
  either CC_GROK_c_o or CC_LOSE_c_o in bz.defaults, respectively.
  Neither matching means running $CC *each and every* time buildzsh is run.

	bz.Makefile
	bz.defaults

* As soon as you know for certain whether your C compiler groks -g and -O
  simultaneously or not, add the correct variable to test to
  either CC_GROK_g_O or CC_LOSE_g_O in bz.defaults, respectively.
  Neither matching means running $CC *each and every* time buildzsh is run.
  Variables like test:foo:bar mean testing for variable "test",
  if that succeeds, setting CC_gFLAGS to "foo" and CC_OFLAGS to "bar".

	For example: CC_GROK_g_O="AIX CC_MIPS_STYLE:-g3:-O GCC:-g:-O6"

  Use 'quotes' to protect whitespace.

	bz.Makefile
	bz.defaults

* if you want to display something to "stdin" while building
  Makefile, you must "1>&2" it

	bz.Makefile

* the naming of the various sh variables is a total mess.

---
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #! /bin/sh

if test "x$VERSION" != x
then
setopt shwordsplit
unsetopt cshjunkiequotes noclobber extendedglob noequals
fi

VERSION=`sed 's/.*"\(.*\)".*/\1/' version.h`

if test "Z$1" != "Zhelp"
then
cat <<foo
#
# buildzsh -- zsh configuration tool
#
# try "buildzsh help" for more information
#

Building $VERSION
foo
fi

# the real scripts are at src/config/

PATH=config:$PWD:$PATH;export PATH

. ./config/bz.init
. ./config/bz.argh
. ./config/bz.check
. ./config/bz.hosttype
. ./config/bz.hs
. ./config/bz.Makefile
. ./config/bz.finale

exit 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
/*
 *
 * cond.c - evaluate conditional expressions
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"

int evalcond(c)			/**/
Cond c;
{
    struct stat *st;

    switch (c->type) {
    case COND_NOT:
	return !evalcond(c->left);
    case COND_AND:
	return evalcond(c->left) && evalcond(c->right);
    case COND_OR:
	return evalcond(c->left) || evalcond(c->right);
    }
    singsub((char **)&c->left);
    untokenize(c->left);
    if (c->right) {
	singsub((char **)&c->right);
	if (c->type != COND_STREQ && c->type != COND_STRNEQ)
	    untokenize(c->right);
    }
    switch (c->type) {
    case COND_STREQ:
	return matchpat(c->left, c->right);
    case COND_STRNEQ:
	return !matchpat(c->left, c->right);
    case COND_STRLT:
	return strcmp(c->left, c->right) < 0;
    case COND_STRGTR:
	return strcmp(c->left, c->right) > 0;
    case 'e':
    case 'a':
	return (doaccess(c->left, F_OK));
    case 'b':
	return (S_ISBLK(dostat(c->left)));
    case 'c':
	return (S_ISCHR(dostat(c->left)));
    case 'd':
	return (S_ISDIR(dostat(c->left)));
    case 'f':
	return (S_ISREG(dostat(c->left)));
    case 'g':
	return (!!(dostat(c->left) & S_ISGID));
    case 'k':
	return (!!(dostat(c->left) & S_ISVTX));
    case 'n':
	return (!!strlen(c->left));
    case 'o':
	return (optison(c->left));
    case 'p':
	return (S_ISFIFO(dostat(c->left)));
    case 'r':
	return (doaccess(c->left, R_OK));
    case 's':
	return ((st = getstat(c->left)) && !!(st->st_size));
    case 'S':
	return (S_ISSOCK(dostat(c->left)));
    case 'u':
	return (!!(dostat(c->left) & S_ISUID));
    case 'w':
	return (doaccess(c->left, W_OK));
    case 'x':
	return (doaccess(c->left, X_OK));
    case 'z':
	return (!strlen(c->left));
    case 'h':
    case 'L':
	return (S_ISLNK(dolstat(c->left)));
    case 'O':
	return ((st = getstat(c->left)) && st->st_uid == geteuid());
    case 'G':
	return ((st = getstat(c->left)) && st->st_gid == getegid());
    case 't':
	return isatty(matheval(c->left));
    case COND_EQ:
	return matheval(c->left) == matheval(c->right);
    case COND_NE:
	return matheval(c->left) != matheval(c->right);
    case COND_LT:
	return matheval(c->left) < matheval(c->right);
    case COND_GT:
	return matheval(c->left) > matheval(c->right);
    case COND_LE:
	return matheval(c->left) <= matheval(c->right);
    case COND_GE:
	return matheval(c->left) >= matheval(c->right);
    case COND_NT:
    case COND_OT:
	{
	    time_t a;

	    if (!(st = getstat(c->left)))
		return 0;
	    a = st->st_mtime;
	    if (!(st = getstat(c->right)))
		return 0;
	    return (c->type == COND_NT) ? a > st->st_mtime : a < st->st_mtime;
	}
    case COND_EF:
	{
	    dev_t d;
	    ino_t i;

	    if (!(st = getstat(c->left)))
		return 0;
	    d = st->st_dev;
	    i = st->st_ino;
	    if (!(st = getstat(c->right)))
		return 0;
	    return d == st->st_dev && i == st->st_ino;
	}
    default:
	zerr("bad cond structure", NULL, 0);
    }
    return 0;
}

int doaccess(s, c)		/**/
char *s;
int c;
{
    return !access(s, c);
}

static struct stat st;

struct stat *getstat(s)		/**/
char *s;
{
    if (!strncmp(s, "/dev/fd/", 8)) {
	if (fstat(atoi(s + 8), &st))
	    return NULL;
    } else if (stat(s, &st))
	return NULL;
    return &st;
}

unsigned short dostat(s)	/**/
char *s;
{
    struct stat *statp;

    if (!(statp = getstat(s)))
	return 0;
    return statp->st_mode;
}

/* pem@aaii.oz; needed since dostat now uses "stat" */

unsigned short dolstat(s)	/**/
char *s;
{
    if (lstat(s, &st) < 0)
	return 0;
    return st.st_mode;
}

int optison(s)			/**/
char *s;
{
    int i;

    if (strlen(s) == 1)
	return opts[(int)*s];
    if ((i = optlookup(s)) != -1)
	return opts[i];
    zerr("no such option: %s", s, 0);
    return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 *
 * builtin.c - builtin commands
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"
#include <errno.h>

#define makecond() allocnode(N_COND)

/* builtin flags */

#define BINF_PLUSOPTS	1	/* +xyz legal */
#define BINF_R		2	/* this is r (fc -e -) */
#define BINF_PRINTOPTS	4
#define BINF_SETOPTS	8
#define BINF_FCOPTS	16
#define BINF_TYPEOPT	32
#define BINF_TYPEOPTS	(BINF_TYPEOPT|BINF_PLUSOPTS)
#define BINF_ECHOPTS	64

/* builtin funcs */

#define BIN_TYPESET 0
#define BIN_BG 1
#define BIN_FG 2
#define BIN_JOBS 3
#define BIN_WAIT 4
#define BIN_DISOWN 5
#define BIN_BREAK 6
#define BIN_CONTINUE 7
#define BIN_EXIT 8
#define BIN_RETURN 9
#define BIN_SHIFT 10
#define BIN_CD 11
#define BIN_POPD 12
#define BIN_PUSHD 13
#define BIN_PRINT 14
#define BIN_EVAL 15
#define BIN_SCHED 16
#define BIN_FC 17
#define BIN_PUSHLINE 18
#define BIN_LOGOUT 19
#define BIN_BUILTIN 20
#define BIN_TEST 21
#define BIN_BRACKET 22
#define BIN_EXPORT 23
#define BIN_TRUE 24
#define BIN_FALSE 25
#define BIN_ECHO 26

struct bincmd {
    char *name;
    int (*handlerfunc) DCLPROTO((char *, char **, char *, int));
    int minargs;		/* min # of args */
    int maxargs;		/* max # of args, or -1 for no limit */
    int flags;			/* BINF_flags (see above) */
    int funcid;			/* xbins (see above) for overloaded handlerfuncs */
    char *optstr;		/* string of legal options */
    char *defopts;		/* options set by default for overloaded handlerfuncs */
};

static char *auxdata;
static int auxlen;
static int showflag = 0, showflag2 = 0;

#define NULLBINCMD ((int (*) DCLPROTO((char *,char **,char *,int))) 0)

struct bincmd builtins[] =
{
    {"[", bin_test, 0, -1, 0, BIN_BRACKET, NULL, NULL},
    {".", bin_dot, 1, -1, 0, 0, NULL, NULL},
    {":", bin_colon, 0, -1, 0, BIN_TRUE, NULL, NULL},
    {"alias", bin_alias, 0, -1, 0, 0, "gamr", NULL},
    {"autoload", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "txv", "fu"},
    {"bg", bin_fg, 0, -1, 0, BIN_BG, NULL, NULL},
    {"bindkey", bin_bindkey, 0, -1, 0, 0, "asvemdr", NULL},
    {"break", bin_break, 0, 1, 0, BIN_BREAK, NULL, NULL},
    {"builtin", NULLBINCMD, 0, 0, 0, BIN_BUILTIN, NULL, NULL},
    {"bye", bin_break, 0, 1, 0, BIN_EXIT, NULL, NULL},
    {"cd", bin_cd, 0, 2, 0, BIN_CD, NULL, NULL},
    {"chdir", bin_cd, 0, 2, 0, BIN_CD, NULL, NULL},
    {"compctl", bin_compctl, 0, -1, 0, 0, NULL, NULL},
    {"continue", bin_break, 0, 1, 0, BIN_CONTINUE, NULL, NULL},
    {"declare", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "LRZfilrtux", NULL},
    {"dirs", bin_dirs, 0, -1, 0, 0, "v", NULL},
    {"disable", bin_disable, 0, -1, 0, 0, "-m", NULL},
    {"disown", bin_fg, 1, -1, 0, BIN_DISOWN, NULL, NULL},
    {"echo", bin_print, 0, -1, BINF_PRINTOPTS | BINF_ECHOPTS, BIN_ECHO, "n", "-"},
    {"echotc", bin_echotc, 1, -1, 0, 0, NULL, NULL},
    {"enable", bin_enable, 0, -1, 0, 0, "m", NULL},
    {"eval", bin_eval, 0, -1, 0, BIN_EVAL, NULL, NULL},
    {"exit", bin_break, 0, 1, 0, BIN_EXIT, NULL, NULL},
    {"export", bin_typeset, 0, -1, BINF_TYPEOPTS, BIN_EXPORT, "LRZfilrtu", "x"},
    {"false", bin_colon, 0, -1, 0, BIN_FALSE, NULL, NULL},
    {"fc", bin_fc, 0, -1, BINF_FCOPTS, BIN_FC, "nlreIRWAdDfEm", NULL},
    {"fg", bin_fg, 0, -1, 0, BIN_FG, NULL, NULL},
    {"functions", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "tum", "f"},
    {"getln", bin_read, 0, -1, 0, 0, "ecnAlE", "zr"},
    {"getopts", bin_getopts, 2, -1, 0, 0, NULL, NULL},
    {"hash", bin_hash, 2, 2, 0, 0, NULL, NULL},
    {"history", bin_fc, 0, -1, 0, BIN_FC, "nrdDfEm", "l"},
    {"integer", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "lrtux", "i"},
    {"jobs", bin_fg, 0, -1, 0, BIN_JOBS, "lpZrs", NULL},
    {"kill", bin_kill, 0, -1, 0, 0, NULL, NULL},
    {"let", bin_let, 1, -1, 0, 0, NULL, NULL},
    {"limit", bin_limit, 0, -1, 0, 0, "sh", NULL},
    {"local", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "LRZilrtu", NULL},
    {"log", bin_log, 0, 0, 0, 0, NULL, NULL},
    {"logout", bin_break, 0, 1, 0, BIN_LOGOUT, NULL, NULL},

#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
    {"mem", bin_mem, 0, 0, 0, 0, "v", NULL},
#endif

    {"popd", bin_cd, 0, 2, 0, BIN_POPD, NULL, NULL},
    {"print", bin_print, 0, -1, BINF_PRINTOPTS, BIN_PRINT, "RDPnrslzNu0123456789pioOc-", NULL},
    {"pushd", bin_cd, 0, 2, 0, BIN_PUSHD, NULL, NULL},
    {"pushln", bin_print, 0, -1, BINF_PRINTOPTS, BIN_PRINT, NULL, "-nz"},
    {"pwd", bin_pwd, 0, 0, 0, 0, NULL, NULL},
    {"r", bin_fc, 0, -1, BINF_R, BIN_FC, "nrl", NULL},
    {"read", bin_read, 0, -1, 0, 0, "rzu0123456789pkqecnAlE", NULL},
    {"readonly", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "LRZfiltux", "r"},
    {"rehash", bin_rehash, 0, 0, 0, 0, "f", NULL},
    {"return", bin_break, 0, 1, 0, BIN_RETURN, NULL, NULL},
    {"sched", bin_sched, 0, -1, 0, 0, NULL, NULL},
    {"set", bin_set, 0, -1, BINF_SETOPTS | BINF_PLUSOPTS, 0, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZaefghjklmnosuvwxy", NULL},
    {"setopt", bin_setopt, 0, -1, BINF_PLUSOPTS, 0, "0123456789BCDEFGHIJKLMNOPQRSTUVWXYZaefghjklmnosuvwxy", NULL},
    {"shift", bin_break, 0, -1, 0, BIN_SHIFT, NULL, NULL},
    {"source", bin_dot, 1, -1, 0, 0, NULL, NULL},
    {"suspend", bin_suspend, 0, 0, 0, 0, "f", NULL},
    {"test", bin_test, 0, -1, 0, BIN_TEST, NULL, NULL},
    {"ttyctl", bin_ttyctl, 0, 0, 0, 0, "fu", NULL},
    {"times", bin_times, 0, 0, 0, 0, NULL, NULL},
    {"trap", bin_trap, 0, -1, 0, 0, NULL, NULL},
    {"true", bin_colon, 0, -1, 0, BIN_TRUE, NULL, NULL},
    {"type", bin_whence, 0, -1, 0, 0, "pfam", "v"},
    {"typeset", bin_typeset, 0, -1, BINF_TYPEOPTS, 0, "LRZfilrtuxm", NULL},
    {"ulimit", bin_ulimit, 0, 1, 0, 0, "Hacdflmnopstv", NULL},
    {"umask", bin_umask, 0, 1, 0, 0, NULL, NULL},
    {"unalias", bin_unalias, 1, -1, 0, 0, "m", NULL},
    {"unfunction", bin_unhash, 1, -1, 0, 0, "m", NULL},
    {"unhash", bin_unhash, 1, -1, 0, 0, "m", NULL},
    {"unlimit", bin_unlimit, 0, -1, 0, 0, "h", NULL},
    {"unset", bin_unset, 1, -1, 0, 0, "m", NULL},
    {"unsetopt", bin_setopt, 0, -1, BINF_PLUSOPTS, 1, "0123456789BCDEFGHIJKLMNOPQRSTUWXYZabefghjklmnosuvwxy", NULL},
    {"vared", bin_vared, 1, 6, 0, 0, NULL, NULL},
    {"wait", bin_fg, 0, -1, 0, BIN_WAIT, NULL, NULL},
    {"whence", bin_whence, 0, -1, 0, 0, "pvcfam", NULL},
    {"which", bin_whence, 0, -1, 0, 0, "pam", "c"},
    {NULL, NULLBINCMD, 0, 0, 0, 0, NULL, NULL}
};

/* print options */

SPROTO(void prtopt, (int set));

static void prtopt(set)
int set;
{
    struct option *opp;

    if (isset(KSHOPTIONPRINT)) {
	printf("Current option settings\n");
	for (opp = optns; opp->name; opp++)
	    printf("%-20s%s\n", opp->name, isset(opp->id) ? "on" : "off");
    } else
	for (opp = optns; opp->name; opp++)
	    if ((!set) == (!isset(opp->id)))
		puts(opp->name);
}

/* add builtins to the command hash table */

void addbuiltins()
{				/**/
    struct cmdnam *c;
    struct bincmd *b;
    int t0;

    for (t0 = 0, b = builtins; b->name; b++, t0++) {
	c = (Cmdnam) zcalloc(sizeof *c);
	c->flags = BUILTIN;
	c->u.binnum = t0;
	addhnode(ztrdup(b->name), c, cmdnamtab, freecmdnam);
    }
}

/* enable */

int bin_enable(name, argv, ops, whocares)	/**/
char *name;
char **argv;
char *ops;
int whocares;
{
    struct cmdnam *c;
    struct bincmd *b;
    int t0, ret = 0;
    Comp com;

    if (!*argv) {
	listhtable(cmdnamtab, (HFunc) penabledcmd);
	return 0;
    }
    for (; *argv; argv++) {
	if (ops['m']) {
	    tokenize(*argv);
	    if (!(com = parsereg(*argv))) {
		ret = 1;
		untokenize(*argv);
		zwarnnam(name, "bad pattern : %s", *argv, 0);
		continue;
	    }
	    for (t0 = 0, b = builtins; b->name; b++, t0++)
		if (domatch(b->name, com, 0)) {
		    c = (Cmdnam) zcalloc(sizeof *c);
		    c->flags = BUILTIN;
		    c->u.binnum = t0;
		    addhnode(ztrdup(b->name), c, cmdnamtab, freecmdnam);
		}
	} else {
	    for (t0 = 0, b = builtins; b->name; b++, t0++)
		if (!strcmp(*argv, b->name))
		    break;
	    if (!b->name) {
		zerrnam(name, "no such builtin: %s", *argv, 0);
		ret = 1;
	    } else {
		c = (Cmdnam) zcalloc(sizeof *c);
		c->flags = BUILTIN;
		c->u.binnum = t0;
		addhnode(ztrdup(b->name), c, cmdnamtab, freecmdnam);
	    }
	}
    }
    return ret;
}

/* :, true, false */

int bin_colon(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    return (func == BIN_FALSE);
}

/* break, bye, continue, exit, logout, return, shift */

int bin_break(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    int num = lastval, nump = 0;

    if (*argv && (**argv == '-' || idigit(**argv))) {
	num = matheval(*argv++);
	nump = 1;
    }
    if ((func == BIN_BREAK || func == BIN_CONTINUE) && !loops) {
	if (func == BIN_CONTINUE)
	    zerrnam(name, "not in loop", NULL, 0);
	return 1;
    }
    switch (func) {
    case BIN_CONTINUE:
	contflag = 1;
    case BIN_BREAK:
	breaks = nump ? num : 1;
	if (breaks > loops)
	    breaks = loops;
	break;
    case BIN_RETURN:
	if (isset(INTERACTIVE) || locallevel || sourcelevel) {
	    retflag = 1;
	    breaks = loops;
	    lastval = num;
	    if (trapreturn)
		trapreturn = lastval;
	    return lastval;
	}			/* else fall through */
    case BIN_LOGOUT:
	if (func == BIN_LOGOUT && !islogin) {
	    zerrnam(name, "not login shell", NULL, 0);
	    return 1;
	}
    case BIN_EXIT:
	zexit(num);
	break;
    case BIN_SHIFT:
	{
	    char **s;
	    int l;

	    if (!nump)
		num = 1;
	    if (num < 0) {
		zerrnam(name, "bad number", NULL, 0);
		return 1;
	    }
	    if (*argv) {
		for (; *argv; argv++)
		    if ((s = getaparam(*argv))) {
			if (num < (l = arrlen(s)))
			    l = num;
			permalloc();
			s = arrdup(s + l);
			heapalloc();
			setaparam(*argv, s);
		    }
	    } else {
		if (num > arrlen(pparams))
		    num = arrlen(pparams);
		permalloc();
		s = arrdup(pparams + num);
		heapalloc();
		freearray(pparams);
		pparams = s;
	    }
	    break;
	}
    }
    return 0;
}

/* bg, disown, fg, jobs, wait */

int bin_fg(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    int job, lng, firstjob = -1, retval = 0;

    if (ops['Z']) {
	if (*argv)
	    strcpy(hackzero, *argv);
	return 0;
    }
    lng = (ops['l']) ? 1 : (ops['p']) ? 2 : 0;
    if ((func == BIN_FG || func == BIN_BG) && !jobbing) {
	zwarnnam(name, "no job control in this shell.", NULL, 0);
	return 1;
    }
    if (unset(NOTIFY))
	scanjobs();
    if (curjob != -1 && !(jobtab[curjob].stat & STAT_INUSE)) {
	curjob = prevjob;
	setprevjob();
	if (curjob != -1 && !(jobtab[curjob].stat & STAT_INUSE))
	    curjob = prevjob;
	setprevjob();
    }
    if (func == BIN_JOBS)
	stopmsg = 2;
    if (!*argv)
	if (func == BIN_FG || func == BIN_BG) {
	    if (curjob == -1 || curjob == thisjob) {
		zwarnnam(name, "no current job", NULL, 0);
		return 1;
	    }
	    firstjob = curjob;
	} else if (func == BIN_JOBS) {
	    for (job = 0; job != MAXJOB; job++)
		if (job != thisjob && jobtab[job].stat) {
		    if ((!ops['r'] && !ops['s']) ||
			(ops['r'] && ops['s']) ||
			(ops['r'] && !(jobtab[job].stat & STAT_STOPPED)) ||
			(ops['s'] && jobtab[job].stat & STAT_STOPPED))
			printjob(job + jobtab, lng);
		}
	    return 0;
	} else {
	    for (job = 0; job != MAXJOB; job++)
		if (job != thisjob && jobtab[job].stat)
		    waitjob(job, SIGINT);
	    return 0;
	}
    for (; (firstjob != -1) || *argv; (void)(*argv && argv++)) {
	int stopped, ocj = thisjob;

	if (func == BIN_WAIT && isanum(*argv)) {
	    waitforpid((long)atoi(*argv));
	    retval = lastval2;
	    thisjob = ocj;
	    continue;
	}
	job = (*argv) ? getjob(*argv, name) : firstjob;
	firstjob = -1;
	if (job == -1)
	    break;
	if (!(jobtab[job].stat & STAT_INUSE)) {
	    zwarnnam(name, "no such job: %d", 0, job);
	    return 1;
	}
	switch (func) {
	case BIN_FG:
	case BIN_BG:
	case BIN_WAIT:
	    if ((stopped = (jobtab[job].stat & STAT_STOPPED)))
		makerunning(jobtab + job);
	    else if (func == BIN_BG) {
		zwarnnam(name, "job already in background", NULL, 0);
		thisjob = ocj;
		return 1;
	    }
	    if (curjob == job) {
		curjob = prevjob;
		prevjob = (func == BIN_BG) ? -1 : job;
	    }
	    if (prevjob == job)
		prevjob = -1;
	    if (prevjob == -1)
		setprevjob();
	    if (curjob == -1) {
		curjob = prevjob;
		setprevjob();
	    }
	    if (func != BIN_WAIT)
		printjob(jobtab + job, (stopped) ? -1 : 0);
	    if (func != BIN_BG) {
		if (strcmp(jobtab[job].pwd, pwd)) {
		    printf("(pwd : ");
		    printdir(jobtab[job].pwd);
		    printf(")\n");
		}
		fflush(stdout);
		if (func != BIN_WAIT) {
		    thisjob = job;
		    attachtty(jobtab[job].gleader);
		}
	    }
	    if (stopped) {
		if (func != BIN_BG && jobtab[job].ty)
		    settyinfo(jobtab[job].ty);
		killpg(jobtab[job].gleader, SIGCONT);
	    }
	    if (func == BIN_WAIT)
	        waitjob(job, SIGINT);
	    if (func != BIN_BG) {
		waitjobs();
		retval = lastval2;
	    }
	    break;
	case BIN_JOBS:
	    printjob(job + jobtab, lng);
	    break;
	case BIN_DISOWN:
	    {
		static struct job zero;

		jobtab[job] = zero;
		break;
	    }
	}
	thisjob = ocj;
    }
    return retval;
}

/* let */

int bin_let(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    long val = 0;

    while (*argv)
	val = matheval(*argv++);
    return !val;
}

/* print the directory stack */

SPROTO(void pdstack, (void));

static void pdstack()
{
    Lknode node;

    printdir(pwd);
    for (node = firstnode(dirstack); node; incnode(node)) {
	putchar(' ');
	printdir(getdata(node));
    }
    putchar('\n');
}

/* exit the shell */

void zexit(val)			/**/
int val;
{
    if (isset(MONITOR))
	if (!stopmsg) {
	    checkjobs();
	    if (stopmsg) {
		stopmsg = 2;
		return;
	    }
	} else
	    killrunjobs();
    if (unset(NORCS) && interact) {
	if (isset(APPENDHISTORY))
	    savehistfile(getsparam("HISTFILE"), 1, 3);
	else
	    savehistfile(getsparam("HISTFILE"), 1, 0);
	if (islogin && !subsh)
	    sourcehome(".zlogout");
    }
    if (sigtrapped[SIGEXIT])
	dotrap(SIGEXIT);
    exit(val);
}

/* identify an option name */

int optlookup(s)		/**/
char *s;
{
    char *t;
    struct option *o;

    t = s = dupstring(s);
    while (*t)
	if (*t == '_')
	    chuck(t);
	else {
	    *t = tulower(*t);
	    t++;
	}
    for (o = optns; o->name; o++)
	if (!strcmp(o->name, s))
	    return (int)o->id;
    return -1;
}

/* setopt, unsetopt */

int bin_setopt(nam, args, ops, isun)	/**/
char *nam;
char **args;
char *ops;
int isun;
{
    struct option *opp;
    int c, match;

    match = ops[(int)'m'];
    ops['m'] = 0;
    if (!ops['@'] && !*args) {
	prtopt(!isun);
	return 0;
    }
    for (opp = optns; opp->name; opp++)
	if (ops[opp->id] == 1 + isun)
	    opts[(int)opp->id] = OPT_SET;
	else if (ops[(int)opp->id] == 2 - isun)
	    opts[(int)opp->id] = OPT_UNSET;
    if (!match)
	while (*args) {
	    c = optlookup(*args++);
	    if (c != -1) {
		if (c == INTERACTIVE)
		    zwarnnam(nam, "can't change option: %s", args[-1], 0);
		else
		    opts[c] = (isun) ? OPT_UNSET : OPT_SET;
	    } else {
		zwarnnam(nam, "no such option: %s", args[-1], 0);
		return 1;
	    }
    } else {
	Comp com;
	struct option *o;

	while (*args) {
	    tokenize(*args);
	    if (!(com = parsereg(*args))) {
		untokenize(*args);
		zwarnnam(nam, "bad pattern : %s", *args, 0);
		continue;
	    }
	    for (o = optns; o->name; o++)
		if (o->id != INTERACTIVE && o->id != MONITOR &&
		    domatch(o->name, com, 0))
		    opts[(int)o->id] = (isun) ? OPT_UNSET : OPT_SET;
	    args++;
	}
    }
    return 0;
}

/* execute func on each member of the hash table ht */

static hnamcmp DCLPROTO((struct hashnode ** a, struct hashnode ** b));
static int hnamcmp(a, b)
struct hashnode **a;
struct hashnode **b;
{
    return forstrcmp(&((*a)->nam), &((*b)->nam));
}

void listhtable(ht, func)	/**/
Hashtab ht;
HFunc func;
{
    int t0;
    struct hashnode *hn;

#ifndef HASHORDER

    int nhash;
    struct hashnode **hnsorttab, **htp;

    hnsorttab = (struct hashnode **)zalloc(ht->ct * sizeof(struct hashnode *));

    for (htp = hnsorttab, t0 = ht->hsize - 1; t0 >= 0; t0--)
	for (hn = ht->nodes[t0]; hn; hn = hn->next)
	    *htp++ = hn;

    qsort((vptr) & hnsorttab[0], ht->ct, sizeof(struct hashnode *),
	           (int (*)DCLPROTO((const void *, const void *)))hnamcmp);

    for (htp = hnsorttab, nhash = 0; nhash < ht->ct; nhash++, htp++)
	func((*htp)->nam, (char *)(*htp));

    free(hnsorttab);

#else

    for (t0 = ht->hsize - 1; t0 >= 0; t0--)
	for (hn = ht->nodes[t0]; hn; hn = hn->next)
	    func(hn->nam, (char *)hn);

#endif
}

/* print a shell function (used with listhtable) */

void pshfunc(s, cc)		/**/
char *s;
Cmdnam cc;
{
    char *t;

    if (!(cc->flags & SHFUNC))
	return;
    if (showflag && (cc->flags & showflag2) != showflag2)
	return;
    if (cc->flags & PMFLAG_u)
	printf("undefined ");
    if (cc->flags & PMFLAG_t)
	printf("traced ");
    if (!cc->u.list || !showflag) {
	printf("%s ()\n", s);
	return;
    }
    t = getpermtext((vptr) dupstruct((vptr) cc->u.list));
    printf("%s () {\n\t%s\n}\n", s, t);
    zsfree(t);
}

void penabledcmd(s, cc)		/**/
char *s;
Cmdnam cc;
{
    if (cc->flags & BUILTIN)
	printf("%s\n", s);
}

void pdisabledcmd(s, cc)	/**/
char *s;
Cmdnam cc;
{
    if (cc->flags & DISABLED)
	printf("%s\n", s);
}

void niceprintf(s, f)		/**/
char *s;
FILE *f;
{
    for (; *s; s++) {
	if (isprint(*s))
	    fputc(*s, f);
	else if (*s == '\n') {
	    putc('\\', f);
	    putc('n', f);
	} else {
	    putc('^', f);
	    fputc(*s | 0x40, f);
	}
    }
}

int bin_umask(nam, args, ops, func)	/**/
char *nam;
char **args;
char *ops;
int func;
{
    int um;
    char *s = *args;

    um = umask(0);
    umask(um);
    if (!s) {
	printf("%03o\n", (unsigned)um);
	return 0;
    }
    if (idigit(*s)) {
	um = zstrtol(s, &s, 8);
	if (*s) {
	    zwarnnam(nam, "bad umask", NULL, 0);
	    return 1;
	}
    } else {
	int whomask, umaskop, mask;

	for (;;) {
	    whomask = 0;
	    while (*s == 'u' || *s == 'g' || *s == 'o')
		if (*s == 'u')
		    s++, whomask |= 0100;
		else if (*s == 'g')
		    s++, whomask |= 0010;
		else if (*s == 'o')
		    s++, whomask |= 0001;
	    if (!whomask)
		whomask = 0111;
	    umaskop = (int)*s;
	    if (!(umaskop == '+' || umaskop == '-' || umaskop == '=')) {
		zwarnnam(nam, "bad symbolic mode operator: %c", NULL, umaskop);
		return 1;
	    }
	    mask = 0;
	    while (*++s && *s != ',')
		if (*s == 'r')
		    mask |= 04 * whomask;
		else if (*s == 'w')
		    mask |= 02 * whomask;
		else if (*s == 'x')
		    mask |= whomask;
		else {
		    zwarnnam(nam, "bad symbolic mode permission: %c",
			     NULL, *s);
		    return 1;
		}
	    if (umaskop == '+')
		um &= ~mask;
	    else if (umaskop == '-')
		um |= mask;
	    else		/* umaskop == '=' */
		um = (um | (whomask * 07)) & ~mask;
	    if (*s == ',')
		s++;
	    else
		break;
	}
	if (*s) {
	    zwarnnam(nam, "bad character in symbolic mode: %c", NULL, *s);
	    return 1;
	}
    }
    umask(um);
    return 0;
}

/* type, whence, which */

int bin_whence(nam, argv, ops, func)	/**/
char *nam;
char **argv;
char *ops;
int func;
{
    struct cmdnam *chn;
    struct alias *a;
    int retval = 0;
    int csh = ops[(int)'c'], all = ops[(int)'a'];
    int v = ops['v'] || csh;
    char *cnam;
    int informed;

    for (; *argv; argv++) {
	if (ops['m']) {
	    int i, n;
	    Comp com;

	    tokenize(*argv);
	    if (!(com = parsereg(*argv))) {
		retval = 1;
		untokenize(*argv);
		zwarnnam(nam, "bad pattern : %s", *argv, 0);
		continue;
	    }
	    if (!ops['p']) {
		n = aliastab->hsize;
		for (i = 0; i < n; i++) {
		    for (a = (struct alias *)aliastab->nodes[i]; a;
			 a = (struct alias *)a->next) {
			if (a->nam && domatch(a->nam, com, 0)) {
			    if (a->cmd < 0)
				printf((csh) ? "%s: shell reserved word\n" :
				       (v) ? "%s is a reserved word\n" : "%s\n", a->nam);
			    else if (!v)
				puts(a->text);
			    else if (a->cmd)
				printf((csh) ? "%s: aliased to %s\n" :
				       "%s is an alias for %s\n", a->nam, a->text);
			    else
				printf((csh) ? "%s: globally aliased to %s\n" :
				       "%s is a global alias for %s\n", a->nam, a->text);
			}
		    }
		}
		n = cmdnamtab->hsize;
		for (i = 0; i < n; i++) {
		    for (chn = (struct cmdnam *)cmdnamtab->nodes[i]; chn;
			 chn = (struct cmdnam *)chn->next) {
			if (chn->nam &&
			    (chn->flags & (SHFUNC | BUILTIN)) &&
			    !(chn->flags & EXCMD) &&
			    domatch(chn->nam, com, 0)) {
			    if (chn->flags & SHFUNC) {
				if (csh || ops['f']) {
				    showflag = 1;
				    showflag2 = 0;
				    pshfunc(chn->nam, chn);
				} else {
				    printf((v) ? "%s is a function\n" : "%s\n", chn->nam);
				}
			    } else
				printf((csh) ? "%s: shell built-in command\n" :
				       (v) ? "%s is a shell builtin\n" : "%s\n", chn->nam);
			}
		    }
		}
	    }
	    fullhash();
	    n = cmdnamtab->hsize;
	    for (i = 0; i < n; i++) {
		for (chn = (struct cmdnam *)cmdnamtab->nodes[i]; chn;
		     chn = (struct cmdnam *)chn->next) {
		    if (chn->nam && (chn->flags & EXCMD) &&
			domatch(chn->nam, com, 0)) {
			if (chn->flags & BUILTIN)
			    printf("%s is hashed to %s\n", chn->nam,
				   chn->u.cmd);
			else if (v && !csh)
			    printf("%s is %s/%s\n", chn->nam,
				   chn->u.name ? *(chn->u.name) : "",
				   chn->nam);
			else
			    printf("%s/%s\n", chn->u.name ? *(chn->u.name) : "",
				   chn->nam);
		    }
		}
	    }

	} else {
	    informed = 0;
	    if (!ops['p'] && (a = (Alias) gethnode(*argv, aliastab))) {
		if (a->cmd < 0)
		    printf((csh) ? "%s: shell reserved word\n" :
			   (v) ? "%s is a reserved word\n" : "%s\n", *argv);
		else if (!v)
		    puts(a->text);
		else if (a->cmd)
		    printf((csh) ? "%s: aliased to %s\n" :
			   "%s is an alias for %s\n", *argv, a->text);
		else
		    printf((csh) ? "%s: globally aliased to %s\n" :
			   "%s is a global alias for %s\n", *argv, a->text);
		if (!all)
		    continue;
		informed = 1;
	    }
	    if (!ops['p'] && (chn = (Cmdnam) gethnode(*argv, cmdnamtab)) &&
		(chn->flags & (SHFUNC | BUILTIN))) {
		if (chn->flags & EXCMD)
		    printf("%s is hashed to %s\n", chn->nam, chn->u.cmd);
		else if (chn->flags & SHFUNC) {
		    if (csh || ops['f']) {
			showflag = 1;
			showflag2 = 0;
			pshfunc(*argv, chn);
		    } else {
			printf((v) ? "%s is a function\n" : "%s\n", *argv);
		    }
		} else
		    printf((csh) ? "%s: shell built-in command\n" :
			   (v) ? "%s is a shell builtin\n" : "%s\n", *argv);
		if (!all)
		    continue;
		informed = 1;
	    }
	    if (all) {
		char **pp, buf[MAXPATHLEN], *z;

		for (pp = path; *pp; pp++) {
		    z = buf;
		    strucpy(&z, *pp);
		    *z++ = '/';
		    strcpy(z, *argv);
		    if (iscom(buf)) {
			if (v && !csh)
			    printf("%s is %s\n", *argv, buf);
			else
			    puts(buf);
			informed = 1;
		    }
		}
		if (!informed && v) {
		    printf("%s not found\n", *argv);
		    retval = 1;
		}
	    } else if (!(cnam = findcmd(*argv))) {
		if (v)
		    printf("%s not found\n", *argv);
		retval = 1;
	    } else {
		if (v && !csh)
		    printf("%s is %s\n", *argv, cnam);
		else
		    puts(cnam);
		zsfree(cnam);
	    }
	}
    }
    return retval;
}

/* cd, chdir, pushd, popd */

int doprintdir = 0;		/* set in exec.c (for autocd) */

int bin_cd(nam, argv, ops, func)/**/
char *nam;
char **argv;
char *ops;
int func;
{
    char *dest, *dir;
    struct stat st1, st2;

    doprintdir = (doprintdir == -1);

    if (func == BIN_CD && isset(AUTOPUSHD))
	func = BIN_PUSHD;
    dir = dest = cd_get_dest(nam, argv, ops, func);
    if (!dest)
	return 1;
    dest = cd_do_chdir(nam, dest);
    if (dest != dir)
	zsfree(dir);
    if (!dest)
	return 1;
    cd_new_pwd(func, dest);
    zsfree(dest);

    if (stat(pwd, &st1) < 0) {
	zsfree(pwd);
	pwd = zgetwd();
    } else if (stat(".", &st2) < 0)
	chdir(pwd);
    else if (st1.st_ino != st2.st_ino || st1.st_dev != st2.st_dev)
	if (isset(CHASELINKS)) {
	    zsfree(pwd);
	    pwd = zgetwd();
	} else {
	    chdir(pwd);
	}
    return 0;
}

char *cd_get_dest(nam, argv, ops, func)	/**/
char *nam;
char **argv;
char *ops;
int func;
{
    char *dest = NULL;

    if (!argv[0])
	if (func == BIN_CD || ((func == BIN_PUSHD && isset(PUSHDTOHOME))
			       || empty(dirstack)))
	    dest = ztrdup(home);
	else
	    dest = ztrdup(getnode(dirstack));
    else if (!argv[1]) {
	Lknode n;
	int dd;
	char *end;

	doprintdir++;
	if (argv[0][1] && argv[0][0] == (isset(PUSHDMINUS) ? '-' : '+')) {
	    dd = zstrtol(argv[0] + 1, &end, 10) - 1;
	    if (dd >= 0 && *end == '\0') {
		for (n = firstnode(dirstack); n && dd; dd--, incnode(n));
		if (!n) {
		    zwarnnam(nam, "no such entry in dir stack", NULL, 0);
		    return NULL;
		}
		dest = (char *)remnode(dirstack, n);
	    }
	} else if (argv[0][1] && argv[0][0] == (isset(PUSHDMINUS) ? '+' : '-')) {
	    dd = zstrtol(argv[0] + 1, &end, 10);
	    if (*end == '\0') {
		for (n = lastnode(dirstack); n != (Lknode) dirstack && dd;
		     dd--, n = prevnode(n));
		if (n == (Lknode) dirstack) {
		    zwarnnam(nam, "no such entry in dir stack", NULL, 0);
		    return NULL;
		}
		dest = (char *)remnode(dirstack, n);
	    }
	}
	if (!dest)
	    dest = ztrdup(strcmp(argv[0], "-") ? (doprintdir--, argv[0]) :
			  oldpwd);
    } else {
	char *u;
	int len1, len2, len3;

	if (!(u = ztrstr(pwd, argv[0]))) {
	    zwarnnam(nam, "string not in pwd: %s", argv[0], 0);
	    return NULL;
	}
	len1 = strlen(argv[0]);
	len2 = strlen(argv[1]);
	len3 = u - pwd;
	dest = (char *)zalloc(len3 + len2 + strlen(u + len1) + 1);
	strncpy(dest, pwd, len3);
	strcpy(dest + len3, argv[1]);
	strcat(dest, u + len1);
	doprintdir++;
    }
    return dest;
}

char *cd_do_chdir(cnam, dest)	/**/
char *cnam;
char *dest;
{
    int hasdot = 0, eno = ENOENT;
    int nocdpath = dest[0] == '.' &&
    (dest[1] == '/' || !dest[1] || (dest[1] == '.' &&
				    (dest[2] == '/' || !dest[1])));
    char **pp, *ret;

    if (*dest == '/') {
	if ((ret = cd_try_chdir(NULL, dest)))
	    return ret;
	zwarnnam(cnam, "%e: %s", dest, errno);
	return NULL;
    }
    if (!nocdpath)
	for (pp = cdpath; *pp; pp++)
	    if ((*pp)[0] == '.' && (*pp)[1] == '\0')
		hasdot = 1;
    if (!hasdot || nocdpath) {
	if ((ret = cd_try_chdir(NULL, dest)))
	    return ret;
	if (errno != ENOENT)
	    eno = errno;
    }
    if (!nocdpath)
	for (pp = cdpath; *pp; pp++) {
	    if ((ret = cd_try_chdir(*pp, dest))) {
		if (strcmp(*pp, ".")) {
		    doprintdir++;
		}
		return ret;
	    }
	    if (errno != ENOENT)
		eno = errno;
	}
    if ((ret = cd_able_vars(dest))) {
	if ((ret = cd_try_chdir(NULL, ret))) {
	    doprintdir++;
	    return ret;
	}
	if (errno != ENOENT)
	    eno = errno;
    }
    zwarnnam(cnam, "%e: %s", dest, eno);
    return NULL;
}

char *cd_able_vars(s)		/**/
char *s;
{
    char *rest;

    if (isset(CDABLEVARS)) {
	for (rest = s; *rest && *rest != '/'; rest++);
	s = getnamedir(s, rest - s);

	if (s && *rest)
	    s = dyncat(s, rest);

	return s;
    }
    return NULL;
}

char *cd_try_chdir(pfix, dest)	/**/
char *pfix;
char *dest;
{
    char buf[MAXPATHLEN], buf2[MAXPATHLEN];
    char *s;
    int dotsct;

    if (pfix)
	sprintf(buf, "%s/%s", (!strcmp("/", pfix)) ? "" : pfix, dest);
    else
	strcpy(buf, dest);
    dotsct = fixdir(buf2, buf);
    if (buf2[0] == '/')
	return (chdir(buf) == -1) ? NULL : ztrdup(buf2);
    if (!dotsct) {
	if (chdir(buf) == -1)
	    return NULL;
	if (*buf2)
	    sprintf(buf, "%s/%s", (!strcmp("/", pwd)) ? "" : pwd, buf2);
	else
	    strcpy(buf, pwd);
	return ztrdup(buf);
    }
    strcpy(buf, pwd);
    s = buf + strlen(buf) - 1;
    while (dotsct--)
	while (s != buf)
	    if (*--s == '/')
		break;
    if (s == buf || *buf2)
	s++;
    strcpy(s, buf2);
    if (chdir(buf) != -1 || chdir(dest) != -1)
	return ztrdup(buf);
    return NULL;
}

int fixdir(d, s)		/**/
char *d;
char *s;
{
    int ct = 0;
    char *d0 = d;

#ifdef HAS_RFS
    while (*s == '/' && s[1] == '.' && s[2] == '.') {
	*d++ = '/';
	*d++ = '.';
	*d++ = '.';
	s += 3;
    }
#endif
#ifdef apollo
    if (*s == '/')
	*d++ = *s++;		/*added RBC 18/05/92 */
#endif
    for (;;) {
	if (*s == '/') {
	    *d++ = *s++;
	    while (*s == '/')
		s++;
	}
	if (!*s) {
	    while (d > d0 + 1 && d[-1] == '/')
		d--;
	    *d = '\0';
	    return ct;
	}
	if (s[0] == '.' && s[1] == '.' && (s[2] == '\0' || s[2] == '/')) {
	    if (d > d0 + 1) {
		for (d--; d > d0 + 1 && d[-1] != '/'; d--);
		if (d[-1] != '/')
		    d--;
	    } else
		ct++;
	    s++;
	    while (*++s == '/');
	} else if (s[0] == '.' && (s[1] == '/' || s[1] == '\0')) {
	    while (*++s == '/');
	} else {
	    while (*s != '/' && *s != '\0')
		*d++ = *s++;
	}
    }
}

void cd_new_pwd(func, s)	/**/
int func;
char *s;
{
    Param pm;
    List l;
    char *new_pwd;

    if (isset(CHASELINKS))
	new_pwd = findpwd(s);
    else
	new_pwd = ztrdup(s);
    if (!strcmp(new_pwd, pwd) &&
	(func != BIN_PUSHD || isset(PUSHDIGNOREDUPS))) {
	zsfree(new_pwd);
#ifdef ALWAYS_DO_CD_PROCESSING
	if (unset(PUSHDSILENT) && func != BIN_CD && isset(INTERACTIVE))
	    pdstack();
	if (l = getshfunc("chpwd")) {
	    fflush(stdout);
	    fflush(stderr);
	    doshfuncnoval(dupstruct(l), NULL, 0);
	}
#endif
	return;
    }
    zsfree(oldpwd);
    oldpwd = pwd;
    pwd = new_pwd;
    if ((pm = (Param) gethnode("PWD", paramtab)) &&
	(pm->flags & PMFLAG_x) && pm->env)
	pm->env = replenv(pm->env, pwd);
    if ((pm = (Param) gethnode("OLDPWD", paramtab)) &&
	(pm->flags & PMFLAG_x) && pm->env)
	pm->env = replenv(pm->env, oldpwd);
    if (func == BIN_PUSHD) {
	permalloc();
	if (isset(PUSHDIGNOREDUPS)) {
	    Lknode n;
	    char *nodedata;

	    for (n = firstnode(dirstack); n; incnode(n)) {
		nodedata = (char *)getdata(n);
		if (!strcmp(oldpwd, nodedata) || !strcmp(pwd, nodedata)) {
		    free(remnode(dirstack, n));
		    break;
		}
	    }
	}
	pushnode(dirstack, ztrdup(oldpwd));
	heapalloc();
    }
    if (unset(PUSHDSILENT) && func != BIN_CD && isset(INTERACTIVE))
	pdstack();
    else if (doprintdir)
	printdircr(pwd);
    if ((l = getshfunc("chpwd"))) {
	fflush(stdout);
	fflush(stderr);
	doshfuncnoval(dupstruct(l), NULL, 0);
    }
    if (dirstacksize != -1 && countnodes(dirstack) >= dirstacksize) {
	if (dirstacksize < 2)
	    dirstacksize = 2;
	else
	    free(remnode(dirstack, lastnode(dirstack)));
    }
}

int bin_rehash(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    newcmdnamtab();
    if (ops['f'])
	fullhash();
    return 0;
}

int bin_hash(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    struct cmdnam *chn;

    chn = (Cmdnam) zcalloc(sizeof *chn);
    chn->flags = HASHCMD;
    chn->u.cmd = ztrdup(argv[1]);
    addhnode(ztrdup(argv[0]), chn, cmdnamtab, freecmdnam);
    return 0;
}

/* convert %%, %1, %foo, %?bar? to a job number */

int getjob(s, prog)		/**/
char *s;
char *prog;
{
    int t0, retval;

    if (*s != '%')
	goto jump;
    s++;
    if (*s == '%' || *s == '+' || !*s) {
	if (curjob == -1) {
	    zwarnnam(prog, "no current job", NULL, 0);
	    retval = -1;
	    goto done;
	}
	retval = curjob;
	goto done;
    }
    if (*s == '-') {
	if (prevjob == -1) {
	    zwarnnam(prog, "no previous job", NULL, 0);
	    retval = -1;
	    goto done;
	}
	retval = prevjob;
	goto done;
    }
    if (idigit(*s)) {
	t0 = atoi(s);
	if (t0 && t0 < MAXJOB && jobtab[t0].stat && t0 != thisjob) {
	    retval = t0;
	    goto done;
	}
	zwarnnam(prog, "no such job", NULL, 0);
	retval = -1;
	goto done;
    }
    if (*s == '?') {
	struct process *pn;

	for (t0 = MAXJOB - 1; t0 >= 0; t0--)
	    if (jobtab[t0].stat && t0 != thisjob)
		for (pn = jobtab[t0].procs; pn; pn = pn->next)
		    if (ztrstr(pn->text, s + 1)) {
			retval = t0;
			goto done;
		    }
	zwarnnam(prog, "job not found: %s", s, 0);
	retval = -1;
	goto done;
    }
  jump:
    if ((t0 = findjobnam(s)) != -1) {
	retval = t0;
	goto done;
    }
    zwarnnam(prog, "job not found: %s", s, 0);
    retval = -1;
  done:
    return retval;
}

/* find a job named s */

int findjobnam(s)		/**/
char *s;
{
    int t0;

    for (t0 = MAXJOB - 1; t0 >= 0; t0--)
	if (jobtab[t0].stat && jobtab[t0].procs && t0 != thisjob &&
	    jobtab[t0].procs->text && strpfx(s, jobtab[t0].procs->text))
	    return t0;
    return -1;
}

int isanum(s)			/**/
char *s;
{
    while (*s == '-' || idigit(*s))
	s++;
    return *s == '\0';
}

int bin_kill(nam, argv, ops, func)	/**/
char *nam;
char **argv;
char *ops;
int func;
{
    int sig = SIGTERM;
    int retval = 0;

    if (*argv && **argv == '-') {
	if (idigit((*argv)[1]))
	    sig = atoi(*argv + 1);
	else {
	    if ((*argv)[1] == 'l' && (*argv)[2] == '\0') {
		printf("%s", sigs[1]);
		for (sig = 2; sig <= SIGCOUNT; sig++)
		    printf(" %s", sigs[sig]);
		putchar('\n');
		return 0;
	    }
	    for (sig = 1; sig <= SIGCOUNT; sig++)
		if (!strcmp(sigs[sig], *argv + 1))
		    break;
	    if (sig > SIGCOUNT) {
		zwarnnam(nam, "unknown signal: SIG%s", *argv + 1, 0);
		zwarnnam(nam, "type kill -l for a List of signals", NULL, 0);
		return 1;
	    }
	}
	argv++;
    }
    for (; *argv; argv++) {
	if (**argv == '%') {
	    int p = getjob(*argv, "kill");

	    if (p == -1) {
		retval = 1;
		continue;
	    }
	    if (killjb(jobtab + p, sig) == -1) {
		zwarnnam("kill", "kill failed: %e", NULL, errno);
		retval = 1;
		continue;
	    }
	    if (jobtab[p].stat & STAT_STOPPED) {
		if (sig == SIGCONT)
		    jobtab[p].stat &= ~STAT_STOPPED;
		if (sig != SIGKILL && sig != SIGCONT && sig != SIGTSTP
		    && sig != SIGTTOU && sig != SIGTTIN && sig != SIGSTOP)
		    killjb(jobtab + p, SIGCONT);
	    }
	} else if (!isanum(*argv)) {
	    zwarnnam("kill", "illegal pid: %s", *argv, 0);
	    retval = 1;
	} else if (kill(atoi(*argv), sig) == -1) {
	    zwarnnam("kill", "kill failed: %e", NULL, errno);
	    retval = 1;
	}
    }
    return retval;
}

#ifdef RLIM_INFINITY
static char *recs[] =
{
    "cputime", "filesize", "datasize", "stacksize", "coredumpsize",
#ifdef RLIMIT_RSS
#ifdef RLIMIT_MEMLOCK
    "memoryuse",
#else
    "resident",
#endif				/* RLIMIT_MEMLOCK */
#endif				/* RLIMIT_RSS */
#ifdef RLIMIT_MEMLOCK
    "memorylocked",
#endif
#ifdef RLIMIT_NPROC
    "maxproc",
#endif
#ifdef RLIMIT_OFILE
    "openfiles",
#endif
#ifdef RLIMIT_NOFILE
    "descriptors",
#endif
#ifdef RLIMIT_VMEM
    "vmemorysize"
#endif
};
#endif

int bin_limit(nam, argv, ops, func)	/**/
char *nam;
char **argv;
char *ops;
int func;
{
#ifndef RLIM_INFINITY
    zwarnnam(nam, "not available on this system", NULL, 0);
    return 1;
#else
    char *s;
    int hard = ops['h'], t0, lim;
    long val;

    if (ops['s']) {
	if (*argv)
	    zwarnnam(nam, "arguments after -s ignored", NULL, 0);
	for (t0 = 0; t0 != RLIM_NLIMITS; t0++)
	    if (setrlimit(t0, limits + t0) < 0)
		zwarnnam(nam, "setrlimit failed: %e", NULL, errno);
	return 0;
    }
    if (!*argv) {
	showlimits(hard, -1);
	return 0;
    }
    while ((s = *argv++)) {
	for (lim = -1, t0 = 0; t0 != RLIM_NLIMITS; t0++)
	    if (!strncmp(recs[t0], s, strlen(s))) {
		if (lim != -1)
		    lim = -2;
		else
		    lim = t0;
	    }
	if (lim < 0) {
	    zwarnnam("limit",
		     (lim == -2) ? "ambiguous resource specification: %s"
		     : "no such resource: %s", s, 0);
	    return 1;
	}
	if (!(s = *argv++)) {
	    showlimits(hard, lim);
	    return 0;
	}
	if (!lim) {
	    val = zstrtol(s, &s, 10);
	    if (*s)
		if ((*s == 'h' || *s == 'H') && !s[1])
		    val *= 3600L;
		else if ((*s == 'm' || *s == 'M') && !s[1])
		    val *= 60L;
		else if (*s == ':')
		    val = val * 60 + zstrtol(s + 1, &s, 10);
		else {
		    zwarnnam("limit", "unknown scaling factor: %s", s, 0);
		    return 1;
		}
	}
#ifdef RLIMIT_NPROC
	else if (lim == RLIMIT_NPROC)
	    val = zstrtol(s, &s, 10);
#endif
#ifdef RLIMIT_OFILE
	else if (lim == RLIMIT_OFILE)
	    val = zstrtol(s, &s, 10);
#endif
#ifdef RLIMIT_NOFILE
	else if (lim == RLIMIT_NOFILE)
	    val = zstrtol(s, &s, 10);
#endif
	else {
	    val = zstrtol(s, &s, 10);
	    if (!*s || ((*s == 'k' || *s == 'K') && !s[1]))
		val *= 1024L;
	    else if ((*s == 'M' || *s == 'm') && !s[1])
		val *= 1024L * 1024;
	    else {
		zwarnnam("limit", "unknown scaling factor: %s", s, 0);
		return 1;
	    }
	}
	if (hard)
	    if (val > limits[lim].rlim_max && geteuid()) {
		zwarnnam("limit", "can't raise hard limits", NULL, 0);
		return 1;
	    } else {
		limits[lim].rlim_max = val;
		if (limits[lim].rlim_max < limits[lim].rlim_cur)
		    limits[lim].rlim_cur = limits[lim].rlim_max;
	} else if (val > limits[lim].rlim_max) {
	    zwarnnam("limit", "limit exceeds hard limit", NULL, 0);
	    return 1;
	} else
	    limits[lim].rlim_cur = val;
    }
    return 0;
#endif
}

int bin_unlimit(nam, argv, ops, func)	/**/
char *nam;
char **argv;
char *ops;
int func;
{
#ifndef RLIM_INFINITY
    zwarnnam(nam, "not available on this system", NULL, 0);
    return 1;
#else
    int hard = ops['h'], t0, lim;

    if (hard && geteuid()) {
	zwarnnam(nam, "can't remove hard limits", NULL, 0);
	return 1;
    }
    if (!*argv) {
	for (t0 = 0; t0 != RLIM_NLIMITS; t0++) {
	    if (hard)
		limits[t0].rlim_max = RLIM_INFINITY;
	    else
		limits[t0].rlim_cur = limits[t0].rlim_max;
	}
	return 0;
    }
    for (; *argv; argv++) {
	for (lim = -1, t0 = 0; t0 != RLIM_NLIMITS; t0++)
	    if (!strncmp(recs[t0], *argv, strlen(*argv))) {
		if (lim != -1)
		    lim = -2;
		else
		    lim = t0;
	    }
	if (lim < 0) {
	    zwarnnam(nam,
		     (lim == -2) ? "ambiguous resource specification: %s"
		     : "no such resource: %s", *argv, 0);
	    return 1;
	}
	if (hard)
	    limits[lim].rlim_max = RLIM_INFINITY;
	else
	    limits[lim].rlim_cur = limits[lim].rlim_max;
    }
    return 0;
#endif
}

#ifdef RLIM_INFINITY
void showlimits(hard, lim)	/**/
int hard;
int lim;
{
    int t0;
    RLIM_TYPE val;

    for (t0 = 0; t0 != RLIM_NLIMITS; t0++)
	if (t0 == lim || lim == -1) {
	    printf("%-16s", recs[t0]);
	    val = (hard) ? limits[t0].rlim_max : limits[t0].rlim_cur;
	    if (val == RLIM_INFINITY)
		printf("unlimited\n");
	    else if (!t0)
		printf("%d:%02d:%02d\n", (int)(val / 3600),
		       (int)(val / 60) % 60, (int)(val % 60));
#ifdef RLIMIT_NPROC
	    else if (t0 == RLIMIT_NPROC)
		printf("%d\n", (int)val);
#endif
#ifdef RLIMIT_OFILE
	    else if (t0 == RLIMIT_OFILE)
		printf("%d\n", (int)val);
#endif
#ifdef RLIMIT_NOFILE
	    else if (t0 == RLIMIT_NOFILE)
		printf("%d\n", (int)val);
#endif
	    else if (val >= 1024L * 1024L)
		printf("%ldMb\n", val / (1024L * 1024L));
	    else
		printf("%ldKb\n", val / 1024L);
	}
}
#endif

int bin_sched(nam, argv, ops, func)	/**/
char *nam;
char **argv;
char *ops;
int func;
{
    char *s = *argv++;
    time_t t;
    long h, m;
    struct tm *tm;
    struct schedcmd *sch, *sch2, *schl;
    int t0;

    if (s && *s == '-') {
	t0 = atoi(s + 1);

	if (!t0) {
	    zwarnnam("sched", "usage for delete: sched -<item#>.", NULL, 0);
	    return 1;
	}
	for (schl = (struct schedcmd *)&schedcmds, sch = schedcmds, t0--;
	     sch && t0; sch = (schl = sch)->next, t0--);
	if (!sch) {
	    zwarnnam("sched", "not that many entries", NULL, 0);
	    return 1;
	}
	schl->next = sch->next;
	zsfree(sch->cmd);
	zfree(sch, sizeof(struct schedcmd));

	return 0;
    }
    if (!s) {
	char tbuf[40];

	for (t0 = 1, sch = schedcmds; sch; sch = sch->next, t0++) {
	    t = sch->time;
	    tm = localtime(&t);
	    ztrftime(tbuf, 20, "%a %b %e %k:%M:%S", tm);
	    printf("%3d %s %s\n", t0, tbuf, sch->cmd);
	}
	return 0;
    } else if (!*argv) {
	zwarnnam("sched", "not enough arguments", NULL, 0);
	return 1;
    }
    if (*s == '+') {
	h = zstrtol(s + 1, &s, 10);
	if (*s != ':') {
	    zwarnnam("sched", "bad time specifier", NULL, 0);
	    return 1;
	}
	m = zstrtol(s + 1, &s, 10);
	if (*s) {
	    zwarnnam("sched", "bad time specifier", NULL, 0);
	    return 1;
	}
	t = time(NULL) + h * 3600 + m * 60;
    } else {
	h = zstrtol(s, &s, 10);
	if (*s != ':') {
	    zwarnnam("sched", "bad time specifier", NULL, 0);
	    return 1;
	}
	m = zstrtol(s + 1, &s, 10);
	if (*s && *s != 'a' && *s != 'p') {
	    zwarnnam("sched", "bad time specifier", NULL, 0);
	    return 1;
	}
	t = time(NULL);
	tm = localtime(&t);
	t -= tm->tm_sec + tm->tm_min * 60 + tm->tm_hour * 3600;
	if (*s == 'p')
	    h += 12;
	t += h * 3600 + m * 60;
	if (t < time(NULL))
	    t += 3600 * 24;
    }
    sch = (struct schedcmd *)zcalloc(sizeof *sch);
    sch->time = t;
    sch->cmd = ztrdup(spacejoin(argv));
    sch->next = NULL;
    for (sch2 = (struct schedcmd *)&schedcmds; sch2->next; sch2 = sch2->next);
    sch2->next = sch;
    return 0;
}

int bin_eval(nam, argv, ops, func)	/**/
char *nam;
char **argv;
char *ops;
int func;
{
    char *s = ztrdup(spacejoin(argv));
    List list;

    hungets(s);
    zsfree(s);
    strinbeg();
    if (!(list = parse_list())) {
	hflush();
	strinend();
	return 1;
    }
    strinend();
    runlist(list);
    return lastval;
}

/* get the history event associated with s */

int fcgetcomm(s)		/**/
char *s;
{
    int cmd;

    if ((cmd = atoi(s))) {
	if (cmd < 0)
	    cmd = curhist + cmd;
	if (cmd >= curhist) {
	    zwarnnam("fc", "bad history number: %d", 0, cmd);
	    return -1;
	}
	return cmd;
    }
    cmd = hcomsearch(s);
    if (cmd == -1)
	zwarnnam("fc", "event not found: %s", s, 0);
    return cmd;
}

/* perform old=new substituion */

int fcsubs(sp, sub)		/**/
char **sp;
struct asgment *sub;
{
    char *s1, *s2, *s3, *s4, *s = *sp, *s5;
    int subbed = 0;

    while (sub) {
	s1 = sub->name;
	s2 = sub->value;
	sub = sub->next;
	s5 = s;
	while ((s3 = (char *)ztrstr(s5, s1))) {
	    s4 = (char *)
		alloc(1 + (s3 - s) + strlen(s2) + strlen(s3 + strlen(s1)));
	    ztrncpy(s4, s, s3 - s);
	    strcat(s4, s2);
	    s5 = s4 + strlen(s4);
	    strcat(s4, s3 + strlen(s1));
	    s = s4;
	    subbed = 1;
	}
    }
    *sp = s;
    return subbed;
}

/* print a series of history events to a file */

int fclist(f, n, r, D, d, first, last, subs, com)	/**/
FILE *f;
int n;
int r;
int D;
int d;
int first;
int last;
struct asgment *subs;
Comp com;
{
    int fclistdone = 0;
    char *s, *hs;
    Histent ent;

    if (r) {
	r = last;
	last = first;
	first = r;
    }
    if (!subs)
	fclistdone = 1;
    for (;;) {
	hs = quietgetevent(first);
	if (!hs) {
	    zwarnnam("fc", "no such event: %d", NULL, first);
	    return 1;
	}
	s = makehstr(hs);
	if (!com || domatch(s, com, 0)) {
	    fclistdone |= fcsubs(&s, subs);
	    if (n)
		fprintf(f, "%5d  ", first);
	    ent = NULL;
	    if (d) {
		struct tm *ltm;

		if (!ent)
		    ent = gethistent(first);
		ltm = localtime(&ent->stim);
		if (d >= 2) {
		    if (d >= 4) {
			fprintf(f, "%d.%d.%d ",
				ltm->tm_mday, ltm->tm_mon + 1,
				ltm->tm_year + 1900);
		    } else {
			fprintf(f, "%d/%d/%d ",
				ltm->tm_mon + 1,
				ltm->tm_mday,
				ltm->tm_year + 1900);
		    }
		}
		fprintf(f, "%02d:%02d  ", ltm->tm_hour, ltm->tm_min);
	    }
	    if (D) {
		long diff;

		if (!ent)
		    ent = gethistent(first);
		diff = (ent->ftim) ? ent->ftim - ent->stim : 0;
		fprintf(f, "%ld:%02ld  ", diff / 60, diff % 60);
	    }
	    if (f == stdout) {
		niceprintf(s, f);
		putc('\n', f);
	    } else
		fprintf(f, "%s\n", s);
	}
	if (first == last)
	    break;
	else if (first > last)
	    first--;
	else
	    first++;
    }
    if (f != stdout)
	fclose(f);
    if (!fclistdone) {
	zwarnnam("fc", "no substitutions performed", NULL, 0);
	return 1;
    }
    return 0;
}

int fcedit(ename, fn)		/**/
char *ename;
char *fn;
{
    if (!strcmp(ename, "-"))
	return 1;
    return !zyztem(ename, fn);
}

/* fc, history, r */

int bin_fc(nam, argv, ops, func)/**/
char *nam;
char **argv;
char *ops;
int func;
{
    int first = -1, last = -1, retval, delayrem, minflag = 0;
    char *s;
    struct asgment *asgf = NULL, *asgl = NULL;
    Comp com = NULL;

    if (!interact) {
	zwarnnam(nam, "not interactive shell", NULL, 0);
	return 1;
    }
    if (*argv && ops['m']) {
	tokenize(*argv);
	if (!(com = parsereg(*argv++))) {
	    zwarnnam(nam, "invalid match pattern", NULL, 0);
	    return 1;
	}
    }
    delayrem = !strcmp(nam, "r");
    if (!delayrem && !(ops['l'] && unset(HISTNOSTORE)) &&
	(ops['R'] || ops['W'] || ops['A']))
	remhist();
    if (ops['R']) {
	readhistfile(*argv ? *argv : getsparam("HISTFILE"), 1);
	return 0;
    }
    if (ops['W']) {
	savehistfile(*argv ? *argv : getsparam("HISTFILE"), 1,
		     (ops['I'] ? 2 : 0));
	return 0;
    }
    if (ops['A']) {
	savehistfile(*argv ? *argv : getsparam("HISTFILE"), 1,
		     (ops['I'] ? 3 : 1));
	return 0;
    }
    while (*argv && equalsplit(*argv, &s)) {
	struct asgment *a = (struct asgment *)alloc(sizeof *a);

	if (!asgf)
	    asgf = asgl = a;
	else {
	    asgl->next = a;
	    asgl = a;
	}
	a->name = *argv;
	a->value = s;
	argv++;
    }
    if (*argv) {
	minflag = **argv == '-';
	first = fcgetcomm(*argv);
	if (first == -1)
	    return 1;
	argv++;
    }
    if (*argv) {
	last = fcgetcomm(*argv);
	if (last == -1)
	    return 1;
	argv++;
    }
    if (*argv) {
	zwarnnam("fc", "too many arguments", NULL, 0);
	return 1;
    }
    if (first == -1)
	first = (ops['l']) ? curhist - 16 : curhist - 1;
    if (last == -1)
	last = (ops['l']) ? curhist : first;
    if (first < firsthist())
	first = firsthist();
    if (last == -1)
	last = (minflag) ? curhist : first;
    if (ops['l'])
	retval = fclist(stdout, !ops['n'], ops['r'], ops['D'],
			ops['d'] + ops['f'] * 2 + ops['E'] * 4,
			first, last, asgf, com);
    else {
	FILE *out;
	char *fil = gettemp();

	retval = 1;
	out = fopen(fil, "w");
	if (!out)
	    zwarnnam("fc", "can't open temp file: %e", NULL, errno);
	else {
	    if (!fclist(out, 0, ops['r'], 0, 0, first, last, asgf, com))
		if (fcedit(auxdata ? auxdata : fceditparam, fil))
		    if (stuff(fil))
			zwarnnam("fc", "%e: %s", s, errno);
		    else
			retval = 0;
	}
	unlink(fil);
    }
    if (delayrem)
	remhist();
    return retval;
}

int bin_suspend(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    if (islogin && !ops['f']) {
	zerrnam(name, "can't suspend login shell", NULL, 0);
	return 1;
    }
    if (jobbing) {
	sig_default(SIGPIPE);
	sig_default(SIGTTIN);
	sig_default(SIGTSTP);
	sig_default(SIGTTOU);
    }
    kill(0, SIGTSTP);
    if (jobbing) {
	while (gettygrp() != mypgrp) {
	    sleep(1);
	    if (gettygrp() != mypgrp)
		kill(0, SIGTTIN);
	}
	sig_ignore(SIGTTOU);
	sig_ignore(SIGTSTP);
	sig_ignore(SIGTTIN);
	sig_ignore(SIGPIPE);
    }
    return 0;
}

int bin_alias(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    struct alias *an;
    struct asgment *asg;
    int incm = !(ops['a'] || ops['g']), ret = 0;

    if (ops['r'])
	showflag = 2;
    else
	showflag = !incm;
    if (!*argv)
	listhtable(aliastab, (HFunc) printalias);
    else
	while ((asg = getasg(*argv++))) {
	    if (asg->value)
		addhnode(ztrdup(asg->name), mkanode(ztrdup(asg->value), incm),
			 aliastab, freeanode);
	    else if (ops['m']) {
		int n, i;
		struct alias *a;
		Comp com;

		tokenize(argv[-1]);
		if (!(com = parsereg(argv[-1]))) {
		    ret = 1;
		    untokenize(argv[-1]);
		    zerrnam(name, "bad pattern : %s", argv[-1], 0);
		    continue;
		}
		n = aliastab->hsize;
		for (i = 0; i < n; i++) {
		    for (a = (struct alias *)aliastab->nodes[i]; a;
			 a = (struct alias *)a->next) {
			if (a->nam && domatch(a->nam, com, 0))
			    printalias(a->nam, a), ret = 0;
		    }
		}
	    } else if ((an = (Alias) gethnode(asg->name, aliastab))) {
		if ((!ops['r'] || an->cmd == 1) &&
		    (!ops['g'] || !an->cmd))
		    printalias(asg->name, an);
	    } else
		ret = 1;
	}
    return ret;
}

/* print an alias; used with listhtable */

void printalias(s, a)		/**/
char *s;
struct alias *a;
{
    char *ptr;
    int special = 0;

    if (a->cmd >= 0 && (!showflag ||
			(showflag == 1 && !a->cmd) ||
			(showflag == 2 && a->cmd)))
	/*!(showflag && a->cmd))*/  {
	for (ptr = a->text; *ptr; ptr++)
	    if (ispecial(*ptr))
		special++;
	if (special) {
	    printf("%s=\'", s);
	    for (ptr = a->text; *ptr; ptr++)
		if (*ptr == '\'')
		    printf("\'\\\'\'");
		else
		    putchar(*ptr);
	    printf("\'\n");
	} else
	    printf("%s=%s\n", s, a->text);
	}
}

/* print a param; used with listhtable */

void printparam(s, p)		/**/
char *s;
Param p;
{
    if ((showflag > 0 && !(p->flags & showflag)) || (p->flags & PMFLAG_UNSET))
	return;
    if (!showflag) {
	int fgs = p->flags;

	if (fgs & PMFLAG_i)
	    printf("integer ");
	if (fgs & PMFLAG_A)
	    printf("array ");
	if (fgs & PMFLAG_L)
	    printf("left justified %d ", p->ct);
	if (fgs & PMFLAG_R)
	    printf("right justified %d ", p->ct);
	if (fgs & PMFLAG_Z)
	    printf("zero filled %d ", p->ct);
	if (fgs & PMFLAG_l)
	    printf("lowercase ");
	if (fgs & PMFLAG_u)
	    printf("uppercase ");
	if (fgs & PMFLAG_r)
	    printf("readonly ");
	if (fgs & PMFLAG_t)
	    printf("tagged ");
	if (fgs & PMFLAG_x)
	    printf("exported ");
    }
    if (showflag2)
	printf("%s\n", s);
    else {
	char *t, **u;

	printf("%s=", s);
	switch (p->flags & PMTYPE) {
	case PMFLAG_s:
	    if (p->gets.cfn && (t = p->gets.cfn(p)))
		puts(t);
	    else
		putchar('\n');
	    break;
	case PMFLAG_i:
	    printf("%ld\n", p->gets.ifn(p));
	    break;
	case PMFLAG_A:
	    putchar('(');
	    u = p->gets.afn(p);
	    if (!*u)
		printf(")\n");
	    else {
		while (u[1])
		    printf("%s ", *u++);
		printf("%s)\n", *u);
	    }
	    break;
	}
    }
}

/* autoload, declare, export, functions, integer, local, readonly, typeset */

int bin_typeset(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    int on = 0, off = 0, roff, bit = 1, retcode = 0, initon, initoff;
    char *optstr = "LRZilurtx";
    struct param *pm;
    struct asgment *asg;

    for (; *optstr; optstr++, bit <<= 1)
	if (ops[*optstr] == 1)
	    on |= bit;
	else if (ops[*optstr] == 2)
	    off |= bit;
    roff = off;
    if (ops['f']) {
	on &= PMFLAG_t | PMFLAG_u;
	off &= PMFLAG_t | PMFLAG_u;
	showflag = (ops['f'] == 1);
	if (ops['@'] && ((off & ~PMFLAG_t) || (on & ~(PMFLAG_u | PMFLAG_t)))) {
	    zerrnam(name, "invalid option(s)", NULL, 0);
	    return 1;
	}
	showflag2 = 0;
	if (!*argv) {
	    showflag2 = off | on;
	    listhtable(cmdnamtab, (HFunc) pshfunc);
	} else if (ops['m']) {
	    Comp com;
	    int i, n;
	    struct cmdnam *chn;

	    on &= ~512;
	    for (; *argv; argv++) {
		tokenize(*argv);
		if (!(com = parsereg(*argv))) {
		    retcode = 1;
		    untokenize(*argv);
		    zerrnam(name, "bad pattern : %s", *argv, 0);
		    continue;
		}
		n = cmdnamtab->hsize;
		for (i = 0; i < n; i++)
		    for (chn = (struct cmdnam *)cmdnamtab->nodes[i]; chn;
			 chn = (struct cmdnam *)chn->next)
			if ((chn->flags & SHFUNC) &&
			    domatch(chn->nam, com, 0)) {
			    if (on | off)
				chn->flags = (chn->flags | on) & (~off);
			    else
				pshfunc(chn->nam, chn);
			}
	    }
	} else
	    for (; *argv; argv++) {
		Cmdnam cc;

		if ((cc = (Cmdnam) gethnode(*argv, cmdnamtab)) &&
		    (cc->flags & SHFUNC))
		    if (on | off)
			cc->flags = (cc->flags | on) & (~off);
		    else
			pshfunc(*argv, cc);
		else if (on & PMFLAG_u) {
		    cc = (Cmdnam) zcalloc(sizeof *cc);
		    cc->flags = SHFUNC | on;
		    addhnode(ztrdup(*argv), cc, cmdnamtab, freecmdnam);
		} else
		    retcode = 1;
	    }
	return retcode;
    }
    if ((on | off) & PMFLAG_x)
	func = BIN_EXPORT;
    if (on & PMFLAG_i)
	off |= PMFLAG_R | PMFLAG_L | PMFLAG_Z | PMFLAG_u | PMFLAG_A;
    if (on & PMFLAG_L)
	off |= PMFLAG_R | PMFLAG_i;
    if (on & PMFLAG_R)
	off |= PMFLAG_L | PMFLAG_i;
    if (on & PMFLAG_Z)
	off |= PMFLAG_i;
    if (on & PMFLAG_u)
	off |= PMFLAG_l;
    if (on & PMFLAG_l)
	off |= PMFLAG_u;
    on &= ~off;
    showflag = showflag2 = 0;
    initon = on;
    initoff = off;
    if (!*argv) {
	showflag = on | roff;
	showflag2 = roff || ops['+'];
	listhtable(paramtab, (HFunc) printparam);
    } else
	while ((asg = getasg(*argv++))) {
	    on = initon;
	    off = initoff;
	    if (ops['m']) {
		Comp com;
		int i, n;

		on &= ~512;
		tokenize(asg->name);
		if (!(com = parsereg(asg->name))) {
		    untokenize(asg->name);
		    zerrnam(name, "bad pattern : %s", argv[-1], 0);
		    continue;
		}
		n = paramtab->hsize;
		for (i = 0; i < n; i++)
		    for (pm = (struct param *)paramtab->nodes[i]; pm;
			 pm = (struct param *)pm->next)
			if (domatch(pm->nam, com, 0)) {
			    if (!on && !roff && !asg->value) {
				printparam(pm->nam, pm);
				continue;
			    }
			    pm->flags = (pm->flags | on) & ~off;
			    if ((on & (PMFLAG_L | PMFLAG_R | PMFLAG_Z | PMFLAG_i))
				&& (pmtype(pm) != PMFLAG_A))
				pm->ct = auxlen;
			    if (pmtype(pm) != PMFLAG_A) {
				if (pm->flags & PMFLAG_x) {
				    if (!pm->env)
					pm->env = addenv(pm->nam,
							 (asg->value) ? asg->value : getsparam(pm->nam));
				} else if (pm->env) {
				    delenv(pm->env);
				    zsfree(pm->env);
				    pm->env = NULL;
				}
				if (asg->value)
				    setsparam(pm->nam, ztrdup(asg->value));
			    }
			}
	    } else {
		if (!isident(asg->name)) {
		    zerr("not an identifier: %s", asg->name, 0);
		    continue;
		}
		pm = (Param) gethnode(asg->name, paramtab);
		if (pm && (pm->flags & PMFLAG_SPECIAL)) {
		    func = 0;
		    on = (pmtype(pm) == PMFLAG_i) ?
			(on &= ~(PMFLAG_L | PMFLAG_R | PMFLAG_Z | PMFLAG_u)) :
			(on & ~PMFLAG_i);
		    off &= ~PMFLAG_i;
		}
		if (pm && pm->level)
		    on &= ~PMFLAG_x;
		bit = 0;	/* flag for switching int<->not-int */
		if (pm && !(pm->flags & PMFLAG_UNSET) &&
		    ((((locallevel == pm->level) || func == BIN_EXPORT)
		      && !(bit = ((off & pm->flags) | (on & ~pm->flags)) & PMFLAG_i)) ||
		     (pm->flags & PMFLAG_SPECIAL))) {
		    if (!on && !roff && !asg->value) {
			printparam(asg->name, pm);
			continue;
		    }
		    pm->flags = (pm->flags | on) & ~off;
		    if (on & (PMFLAG_L | PMFLAG_R | PMFLAG_Z | PMFLAG_i))
			pm->ct = auxlen;
		    if (pmtype(pm) != PMFLAG_A) {
			if (pm->flags & PMFLAG_x) {
			    if (!pm->env)
				pm->env = addenv(asg->name,
						 (asg->value) ? asg->value : getsparam(asg->name));
			} else if (pm->env) {
			    delenv(pm->env);
			    zsfree(pm->env);
			    pm->env = NULL;
			}
			if (asg->value)
			    setsparam(asg->name, ztrdup(asg->value));
		    }
		} else {
		    int readonly = on & PMFLAG_r;

		    if (bit) {
			if (!asg->value)
			    asg->value = dupstring(getsparam(asg->name));
			unsetparam(asg->name);
		    } else if (locallist && func != BIN_EXPORT) {
			permalloc();
			addnode(locallist, ztrdup(asg->name));
			heapalloc();
		    }
		    pm = createparam(ztrdup(asg->name), on & ~PMFLAG_r);
		    pm->ct = auxlen;
		    if (func != BIN_EXPORT)
			pm->level = locallevel;
		    if (asg->value)
			setsparam(asg->name, ztrdup(asg->value));
		    pm->flags |= readonly;
		}
	    }
	}
    return 0;
}

/* Check whether a command is a bin_typeset. */

int istypeset(c, nam)		/**/
Cmdnam c;
char *nam;
{
    struct bincmd *b;

    if (c)
	if ((c->flags & BUILTIN) && !(c->flags & EXCMD))
	    return (builtins[c->u.binnum].handlerfunc == bin_typeset);
	else
	    nam = c->nam;
    if (nam)
	for (b = builtins; b->name; b++)
	    if (!strcmp(nam, b->name) && b->handlerfunc == bin_typeset)
		return 1;
    return 0;
}

/* echo, print, pushln */

int bin_print(name, args, ops, func)	/**/
char *name;
char **args;
char *ops;
int func;
{
    int nnl = 0, fd;
    Histent ent;
    FILE *fout = stdout;

    if (ops['z']) {
	permalloc();
	pushnode(bufstack, ztrdup(spacejoin(args)));
	heapalloc();
	return 0;
    }
    if (ops['s']) {
	permalloc();
	ent = gethistent(++curhist);
	zsfree(ent->lex);
	zsfree(ent->lit);
	ent->lex = ztrdup(join(args, HISTSPACE));
	ent->lit = ztrdup(join(args, ' '));
	ent->stim = ent->ftim = time(NULL);
	ent->flags = 0;
	heapalloc();
	return 0;
    }
    if (ops['R'])
	ops['r'] = 1;
    if (ops['u'] || ops['p']) {
	if (ops['u']) {
	    for (fd = 0; fd < 10; fd++)
		if (ops[fd + '0'])
		    break;
	    if (fd == 10)
		fd = 0;
	} else
	    fd = coprocout;
	if ((fd = dup(fd)) < 0) {
	    zwarnnam(name, "bad file number", NULL, 0);
	    return 1;
	}
	if ((fout = fdopen(fd, "w")) == 0) {
	    zwarnnam(name, "bad mode on fd", NULL, 0);
	    return 1;
	}
    }
    if (ops['o']) {
	if (ops['i'])
	    qsort(args, arrlen(args), sizeof(char *), cstrpcmp);

	else
	    qsort(args, arrlen(args), sizeof(char *), strpcmp);
    } else if (ops['O']) {
	if (ops['i'])
	    qsort(args, arrlen(args), sizeof(char *), invcstrpcmp);

	else
	    qsort(args, arrlen(args), sizeof(char *), invstrpcmp);
    }
    if (ops['c']) {
	int l, nc, nr, sc, n, t, i;
	char **ap;

	for (n = l = 0, ap = args; *ap; ap++, n++)
	    if (l < (t = strlen(*ap)))
		l = t;

	nc = (columns - 1) / (l + 2);
	sc = 0;
	if (nc)
	    sc = (columns - 1) / nc;
	else
	    nc = 1;
	nr = (n + nc - 1) / nc;

	for (i = 0; i < nr; i++) {
	    ap = args + i;
	    do {
		l = strlen(*ap);
		fprintf(fout, "%s", *ap);
		for (; l < sc; l++)
		    fputc(' ', fout);
		for (t = nr; t && *ap; t--, ap++);
	    }
	    while (*ap);
	    fputc(ops['N'] ? '\0' : '\n', fout);
	}
	if (fout != stdout)
	    fclose(fout);
	return 0;
    }
    for (; *args; args++) {
	char *arg = *args;
	int len = -1;

	if (!ops['r'])
	    arg = getkeystring(arg, &len, func != BIN_ECHO, &nnl);
	if (ops['D'])
	    fprintdir(arg, fout);
	else {
	    if (ops['P'])
		arg = putprompt(arg, &len, -1);
	    fwrite(arg, 1, len == -1 ? strlen(arg) : len, fout);
	}

	if (args[1])
	    fputc(ops['l'] ? '\n' : ops['0'] ? '\0' : ' ', fout);
    }
    if (!(ops['n'] || nnl))
	fputc(ops['N'] ? '\0' : '\n', fout);
    if (fout != stdout)
	fclose(fout);
    return 0;
}

int bin_dirs(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    Lklist l;

    if (ops['v']) {
	Lknode node;
	int t0 = 1;

	printf("0\t");
	printdir(pwd);
	for (node = firstnode(dirstack); node; incnode(node)) {
	    printf("\n%d\t", t0++);
	    printdir(getdata(node));
	}
	putchar('\n');
	return 0;
    }
    if (!*argv) {
	pdstack();
	return 0;
    }
    permalloc();
    l = newlist();
    if (!*argv) {
	heapalloc();
	return 0;
    }
    while (*argv)
	addnode(l, ztrdup(*argv++));
    freetable(dirstack, freestr);
    dirstack = l;
    heapalloc();
    return 0;
}

int bin_unalias(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    int ret = 0;
    Alias dat;

    while (*argv)
	if (ops['m']) {
	    int n, i, match = 0;
	    Alias a;
	    Comp com;

	    tokenize(*argv++);
	    if (!(com = parsereg(argv[-1]))) {
		ret = 1;
		untokenize(argv[-1]);
		zwarnnam(name, "bad pattern : %s", argv[-1], 0);
		continue;
	    }
	    n = aliastab->hsize;
	    for (i = 0; i < n; i++) {
		for (a = (Alias) aliastab->nodes[i]; a; a = dat) {
		    dat = (Alias) a->next;
		    if (a->nam && a->cmd >= 0 && domatch(a->nam, com, 0))
			freeanode(remhnode(a->nam, aliastab)), match++;
		}
	    }
	    if (!ret)
		ret = !match;
	} else {
	    if ((dat = (Alias) gethnode(*argv++, aliastab)) && dat->cmd >= 0)
		freeanode(remhnode(dat->nam, aliastab));
	    else
		ret = 1;
	}
    return ret;
}

int bin_disable(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    Cmdnam chn, chn2, nchn;
    Comp com;

    if (!*argv) {
	listhtable(cmdnamtab, (HFunc) pdisabledcmd);
	return 0;
    }
    if (ops['m']) {
	for (; *argv; argv++) {
	    tokenize(*argv);
	    if (!(com = parsereg(*argv))) {
		untokenize(*argv);
		zwarnnam(name, "bad pattern : %s", *argv, 0);
		continue;
	    }
	    if (!strncmp(*argv, "TRAP", 4)) {
		char trapname[20];
		int t;

		strncpy(trapname, "TRAP", sizeof(trapname));
		for (t = 0; t < VSIGCOUNT; t++) {
		    strncpy(trapname + 4, sigs[t], sizeof(trapname) - 5);
		    if (domatch(trapname, com, 0)) {
			unsettrap(t);
			chn = (Cmdnam) zcalloc(sizeof *chn);
			chn->flags |= DISABLED;
			addhnode(ztrdup(trapname), chn, cmdnamtab, freecmdnam);
		    }
		}
	    } else {
		int t, n;

		n = cmdnamtab->hsize;
		for (t = 0; t < n; t++)
		    for (chn = (Cmdnam) cmdnamtab->nodes[t]; chn; chn = nchn) {
			nchn = (Cmdnam) chn->next;
			if (domatch(chn->nam, com, 0)) {
			    chn2 = (Cmdnam) zcalloc(sizeof *chn2);
			    chn2->flags |= DISABLED;
			    addhnode(ztrdup(chn->nam), chn2, cmdnamtab,
				     freecmdnam);
			}
		    }
	    }
	}
    } else {
	char **p, buf[MAXPATHLEN];

	while (*argv) {
	    if (!strncmp(*argv, "TRAP", 4))
		unsettrap(getsignum(*argv + 4));
	    chn = (Cmdnam) zcalloc(sizeof *chn);
	    for (p = path; *p; p++) {
		strcpy(buf, *path);
		strcat(buf, "/");
		strcat(buf, *argv);
		if (iscom(buf)) {
		    chn->u.name = path;
		    break;
		}
	    }
	    chn->flags |= *p ? EXCMD : DISABLED;
	    addhnode(ztrdup(*argv++), chn, cmdnamtab, freecmdnam);
	}
    }
    return 0;
}

int bin_unhash(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    vptr dat;
    Comp com;

    if (ops['m']) {
	for (; *argv; argv++) {
	    tokenize(*argv);
	    if (!(com = parsereg(*argv))) {
		untokenize(*argv);
		zwarnnam(name, "bad pattern : %s", *argv, 0);
		continue;
	    }
	    if (!strncmp(*argv, "TRAP", 4)) {
		char trapname[20];
		int t;

		strncpy(trapname, "TRAP", sizeof(trapname));
		for (t = 0; t < VSIGCOUNT; t++) {
		    strncpy(trapname + 4, sigs[t], sizeof(trapname) - 5);
		    if (domatch(trapname, com, 0))
			unsettrap(t);
		}
	    } else {
		Cmdnam chn, nchn;
		int t, n;

		n = cmdnamtab->hsize;
		for (t = 0; t < n; t++)
		    for (chn = (Cmdnam) cmdnamtab->nodes[t]; chn; chn = nchn) {
			nchn = (Cmdnam) chn->next;
			if (domatch(chn->nam, com, 0))
			    freecmdnam(remhnode(chn->nam, cmdnamtab));
		    }
	    }
	}
    } else {
	while (*argv) {
	    if (!strncmp(*argv, "TRAP", 4))
		unsettrap(getsignum(*argv + 4));
	    if ((dat = remhnode(*argv++, cmdnamtab)))
		freecmdnam(dat);
	}
    }
    return 0;
}

int bin_unset(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    int retval = 0;
    char *s;

    while ((s = *argv++))
	if (ops['m']) {
	    int i, n;
	    Comp com;
	    struct param *par, *next;

	    tokenize(s);
	    if (!(com = parsereg(s))) {
		retval = 1;
		untokenize(s);
		zwarnnam(name, "bad pattern : %s", s, 0);
		continue;
	    }
	    n = paramtab->hsize;
	    for (i = 0; i < n; i++)
		for (par = (struct param *)paramtab->nodes[i]; par;
		     par = next) {
		    next = (struct param *)par->next;
		    if (domatch(par->nam, com, 0))
			unsetparam(par->nam);
		}
	} else {
	    if (gethnode(s, paramtab))
		unsetparam(s);
	    else
		retval = 1;
	}
    return retval;
}

static char *zbuf;
static int readfd;

int zread()
{				/**/
    char cc;

    if (zbuf)
	return (*zbuf) ? *zbuf++ : EOF;
    if (read(readfd, &cc, 1) != 1)
	return EOF;
    return (int)cc;
}

extern int cs;

int bin_read(name, args, ops, func)	/**/
char *name;
char **args;
char *ops;
int func;
{
    char *reply = "REPLY", *readpmpt;
    int bsiz, c = 0, gotnl = 0, al = 0;
    char *buf, *bptr, *firstarg = *args, *zbuforig;
    Lklist readll = newlist();

    if (ops['k']) {
	int nchars, val;
	char cc, d;
	int haso = 0, isem = !strcmp(term, "emacs");

	if (SHTTY == -1) {
	    SHTTY = open("/dev/tty", O_RDWR);
	    haso = 1;
	}
	if (SHTTY == -1) {
	    fprintf(stderr, "not interactive and can't open terminal\n");
	    fflush(stderr);
	    return 1;
	}
	if (*args && idigit(**args)) {
	    if (!(nchars = atoi(*args)))
		nchars = 1;
	    args++;
	} else
	    nchars = 1;

	if (*args && **args == '/') {
	    fprintf(stderr, "%s", putprompt(*args + 1, &c, 0));
	    fflush(stderr);
	    args++;
	}
	if (*args)
	    reply = *args++;

	bptr = buf = (char *)zalloc(nchars + 1);
	buf[nchars] = '\0';

	attachtty(mypgrp);
	if (!isem)
	    setcbreak();

	for (bptr = buf; nchars;) {
#ifdef FIONREAD
	    ioctl(SHTTY, FIONREAD, (char *)&val);
	    if (val) {
		if (!isem)
		    settyinfo(&shttyinfo);
		if (ops['e'] || ops['E']) {
		    printf("%s\n", buf);
		    if (ops['e'])
			zsfree(buf);
		}
		if (!ops['e'])
		    setsparam(reply, buf);

		if (haso) {
		    close(SHTTY);
		    SHTTY = -1;
		}
		return 1;
	    }
#endif
	    if (read(SHTTY, &cc, 1) == 1)
		nchars--, *bptr++ = cc;
	}
	if (isem)
	    while (read(SHTTY, &d, 1) == 1 && d != '\n');
	else
	    settyinfo(&shttyinfo);

	if (haso) {
	    close(SHTTY);
	    SHTTY = -1;
	}
	if (ops['e'] || ops['E']) {
	    printf("%s\n", buf);
	    if (ops['e'])
		zsfree(buf);
	}
	if (!ops['e'])
	    setsparam(reply, buf);
	return 0;
    }
    if (ops['l']) {
	if (!inzlefunc) {
	    zwarnnam(name, "option valid only in functions called from zle",
		     NULL, 0);
	    errflag = 0;
	    return 1;
	}
	if (ops['n']) {
	    char nbuf[14];

	    if (ops['e'] || ops['E'])
		printf("%d\n", cs + 1);
	    if (!ops['e']) {
		sprintf(nbuf, "%d", cs + 1);
		setsparam(*args ? *args : "REPLY", ztrdup(nbuf));
	    }
	    return 0;
	}
	if (ops['e'] || ops['E'])
	    printf("%s\n", (char *)line);
	if (!ops['e'])
	    setsparam(*args ? *args : "REPLY", ztrdup((char *)line));
	return 0;
    }
    if (ops['c']) {
	if (!inzlefunc) {
	    zwarnnam(name, "option valid only in functions called from zle",
		     NULL, 0);
	    errflag = 0;
	    return 1;
	}
	if (ops['n']) {
	    char nbuf[14];

	    if (ops['e'] || ops['E'])
		printf("%d\n", clwpos + 1);
	    if (!ops['e']) {
		sprintf(nbuf, "%d", clwpos + 1);
		setsparam(*args ? *args : "REPLY", ztrdup(nbuf));
	    }
	    return 0;
	}
	if (ops['A'] && !ops['e']) {
	    char **p, **b = (char **)zcalloc((clwnum + 1) * sizeof(char *));
	    int i;

	    for (i = 0, p = b; i < clwnum; p++, i++)
		*p = ztrdup(clwords[i]);

	    setaparam(*args ? *args : "reply", b);
	    return 0;
	}
	if (ops['e'] || ops['E']) {
	    int i;

	    for (i = 0; i < clwnum; i++)
		printf("%s\n", clwords[i]);

	    if (ops['e'])
		return 0;
	}
	if (*args) {
	    int i = 0;

	    for (; i < clwnum && *args; args++, i++)
		setsparam(*args, ztrdup(clwords[i]));
	} else
	    setsparam("REPLY", ztrdup(clwords[clwpos]));

	return 0;
    }
    if (ops['q']) {
	char *readbuf;
	int haso = 0;

	if (SHTTY == -1)
	    SHTTY = open("/dev/tty", O_RDWR), haso = 1;

	if (SHTTY == -1) {
	    fprintf(stderr, "not interactive and can't open terminal\n");
	    fflush(stderr);
	    return 1;
	}
	readbuf = (char *)zalloc(2);
	readbuf[1] = '\0';

	if (*args && **args == '/') {
	    fprintf(stderr, "%s", putprompt(*args + 1, &c, 0));
	    fflush(stderr);
	    args++;
	}
	reply = (*args) ? *args++ : "REPLY";

	readbuf[0] = ((char)getquery()) == 'y' ? 'y' : 'n';

	if (haso) {
	    close(SHTTY);
	    SHTTY = -1;
	}
	if (ops['e'] || ops['E']) {
	    printf("%s\n", readbuf);
	    if (ops['e'])
		free(readbuf);
	}
	if (!ops['e'])
	    setsparam(reply, readbuf);

	return readbuf[0] == 'n';
    }
    if (*args && **args == '?')
	args++;
    reply = *args ? *args++ : ops['A'] ? "reply" : "REPLY";
    if (ops['A'] && *args) {
	zwarnnam(name, "only one array argument allowed", NULL, 0);
	return 1;
    }
    if (ops['u'] && !ops['p']) {
	for (readfd = 0; readfd < 10; ++readfd)
	    if (ops[readfd + '0'])
		break;
	if (readfd == 10)
	    readfd = 0;
    } else if (ops['p'])
	readfd = coprocin;
    else {
	attachtty((jobtab[thisjob].gleader) ? jobtab[thisjob].gleader : mypgrp);
	readfd = 0;
	if (firstarg) {
	    for (readpmpt = firstarg;
		 *readpmpt && *readpmpt != '?'; readpmpt++);
	    if (*readpmpt++) {
		if (isatty(0))
		    write(2, readpmpt, strlen(readpmpt));
		readpmpt[-1] = '\0';
	    }
	}
#if 0
	else if (isset(SHINSTDIN) && unset(INTERACTIVE)) {
	    if (isatty(1))
		readfd = 1;
	    else if (isatty(2))
		readfd = 2;
	}
#endif
    }

    zbuforig = zbuf = (!ops['z']) ? NULL :
	(full(bufstack)) ? (char *)getnode(bufstack) : ztrdup("");
    while (*args || (ops['A'] && !gotnl)) {
	buf = bptr = (char *)zalloc(bsiz = 64);
	for (;;) {
	    if (gotnl)
		break;
	    c = zread();
	    if (!ops['r'] && c == '\n' && bptr != buf && bptr[-1] == '\\') {
		bptr--;
		continue;
	    }
	    if (c == EOF || (isep(c) && bptr != buf) || c == '\n')
		break;
	    if (isep(c))
		continue;
	    *bptr++ = c;
	    if (bptr == buf + bsiz) {
		buf = realloc(buf, bsiz *= 2);
		bptr = buf + (bsiz / 2);
	    }
	}
	if (c == EOF) {
	    if (readfd == coprocin) {
		close(coprocin);
		close(coprocout);
		coprocin = coprocout = -1;
	    }
	    return 1;
	}
	if (c == '\n')
	    gotnl = 1;
	*bptr = '\0';
	if (ops['e'] || ops['E']) {
	    printf("%s\n", buf);
	    if (ops['e'])
		free(buf);
	}
	if (!ops['e']) {
	    if (ops['A']) {
		addnode(readll, buf);
		al++;
	    } else
		setsparam(reply, buf);
	}
	if (!ops['A'])
	    reply = *args++;
    }
    if (ops['A']) {
	char **pp, **p = NULL;
	Lknode n;

	p = (ops['e'] ? (char **)NULL
	     : (char **)zcalloc((al + 1) * sizeof(char *)));

	for (pp = p, n = firstnode(readll); n; incnode(n)) {
	    if (ops['e'] || ops['E']) {
		printf("%s\n", (char *)getdata(n));
		if (p)
		    zsfree(getdata(n));
	    } else
		*pp++ = (char *)getdata(n);
	}
	if (p)
	    setaparam(reply, p);
	return 0;
    }
    buf = bptr = (char *)zalloc(bsiz = 64);
    if (!gotnl)
	for (;;) {
	    c = zread();
	    if (!ops['r'] && c == '\n' && bptr != buf && bptr[-1] == '\\') {
		bptr--;
		continue;
	    }
	    if (c == EOF || (c == '\n' && !zbuf))
		break;
	    if (isep(c) && bptr == buf)
		continue;
	    *bptr++ = c;
	    if (bptr == buf + bsiz) {
		buf = realloc(buf, bsiz *= 2);
		bptr = buf + (bsiz / 2);
	    }
	}
    while (bptr > buf && isep(bptr[-1]))
	bptr--;
    *bptr = '\0';
    if (ops['e'] || ops['E']) {
	printf("%s\n", buf);
	if (ops['e'])
	    zsfree(buf);
    }
    if (!ops['e'])
	setsparam(reply, buf);
    if (zbuforig) {
	char first = *zbuforig;

	zsfree(zbuforig);
	if (!first)
	    return 1;
    } else if (c == EOF) {
	if (readfd == coprocin) {
	    close(coprocin);
	    close(coprocout);
	    coprocin = coprocout = -1;
	}
	return 1;
    }
    return 0;
}

int bin_vared(name, args, ops, func)	/**/
char *name;
char **args;
char *ops;
int func;
{
    char *s;
    char *t;
    struct param *pm;
    int create = 0, pl1, pl2;
    char *p1 = NULL, *p2 = NULL;

    while (*args && **args == '-') {
	while (*++(*args))
	    switch (**args) {
	    case 'c':
		create = 1;
		break;
	    case 'p':
		if ((*args)[1])
		    p1 = *args + 1, *args = "" - 1;
		else if (args[1])
		    p1 = *(++args), *args = "" - 1;
		else {
		    zwarnnam(name, "prompt string expected after -p", NULL, 0);
		    return 1;
		}
		break;
	    case 'r':
		if ((*args)[1])
		    p2 = *args + 1, *args = "" - 1;
		else if (args[1])
		    p2 = *(++args), *args = "" - 1;
		else {
		    zwarnnam(name, "prompt string expected after -r", NULL, 0);
		    return 1;
		}
		break;
	    default:
		zwarnnam(name, "unknown option: %s", *args, 0);
		return 1;
	    }
	args++;
    }

    if (!*args) {
	zwarnnam(name, "missing variable", NULL, 0);
	return 1;
    }
    if (!(s = getsparam(args[0]))) {
	if (create)
	    createparam(args[0], PMFLAG_s);
	else {
	    zwarnnam(name, "no such variable: %s", args[0], 0);
	    return 1;
	}
    }
    permalloc();
    pushnode(bufstack, ztrdup(s));
    heapalloc();
    if (p1)
	p1 = putprompt(p1, &pl1, 0);
    else
	pl1 = 0;
    if (p2)
	p2 = putprompt(p2, &pl2, 0);
    else
	pl2 = 0;
    t = (char *)zleread((unsigned char *)p1, (unsigned char *)p2, pl1, pl2);
    if (!t || errflag)
	return 1;
    if (t[strlen(t) - 1] == '\n')
	t[strlen(t) - 1] = '\0';
    pm = (struct param *)gethnode(args[0], paramtab);
    if (pmtype(pm) == PMFLAG_A)
	setaparam(args[0], spacesplit(t));
    else
	setsparam(args[0], t);
    return 0;
}

#define fset(X) (flags & X)

/* execute a builtin handler function after parsing the arguments */

int execbin(args, cnode)	/**/
Lklist args;
Cmdnam cnode;
{
    struct bincmd *b;
    char ops[128], *arg, *pp, *name, **argv, **oargv, *optstr;
    int t0, flags, sense, argc = 0, execop;
    Lknode n;
    char *oxarg, *xarg = NULL;

    auxdata = NULL;
    auxlen = 0;
    for (t0 = 0; t0 != 128; t0++)
	ops[t0] = 0;
    name = (char *)ugetnode(args);
    b = builtins + cnode->u.binnum;

/* the 'builtin' builtin is handled specially */

    if (b->funcid == BIN_BUILTIN) {
	Cmdnam cname;

	if (!(name = (char *)ugetnode(args))) {
	    zerrnam("builtin", "command name expected", NULL, 0);
	    return 1;
	}
	if ((cname = (Cmdnam) gethnode(name, cmdnamtab)) &&
	    (cname->flags & BUILTIN) &&
	    !(cname->flags & EXCMD))
	    b = builtins + cname->u.binnum;
	else
	    for (b = builtins; b->name; b++)
		if (!strcmp(name, b->name))
		    break;
	if (!b->name) {
	    zerrnam("builtin", "no such builtin: %s", name, 0);
	    return 1;
	}
    }
    flags = b->flags;
    arg = (char *)ugetnode(args);
    optstr = b->optstr;
    if (flags & BINF_ECHOPTS && arg && strcmp(arg, "-n"))
	optstr = NULL;
    if (optstr)
	while (arg &&
	       ((sense = *arg == '-') || (fset(BINF_PLUSOPTS) && *arg == '+')) &&
	       (fset(BINF_PLUSOPTS) || !atoi(arg))) {
	    if (xarg) {
		oxarg = tricat(xarg, " ", arg);
		zsfree(xarg);
		xarg = oxarg;
	    } else
		xarg = ztrdup(arg);
	    if (arg[1] == '-')
		arg++;
	    if (!arg[1]) {
		ops['-'] = 1;
		if (!sense)
		    ops['+'] = 1;
	    } else
		ops['@'] = 1;
	    execop = -1;
	    while (*++arg)
		if (strchr(b->optstr, execop = (int)*arg))
		    ops[(int)*arg] = (sense) ? 1 : 2;
		else
		    break;
	    if (*arg) {
		zerr("bad option: %c", NULL, *arg);
		zsfree(xarg);
		return 1;
	    }
	    arg = (char *)ugetnode(args);
	    if (fset(BINF_SETOPTS) && execop == 'o') {
		int c;

		if (!arg)
		    prtopt(sense);
		else {
		    c = optlookup(arg);
		    if (c == -1) {
			zerr("bad option: %s", arg, 0);
			zsfree(xarg);
			return 1;
		    } else {
			if (c == INTERACTIVE)
			    zerr("can't change option: %s", arg, 0);
			else
			    ops[c] = ops['o'];
			arg = (char *)ugetnode(args);
		    }
		}
	    }
	    if ((fset(BINF_PRINTOPTS) && ops['R']) || ops['-'])
		break;
	    if (fset(BINF_SETOPTS) && ops['A']) {
		auxdata = arg;
		arg = (char *)ugetnode(args);
		break;
	    }
	    if (fset(BINF_FCOPTS) && execop == 'e') {
		auxdata = arg;
		arg = (char *)ugetnode(args);
	    }
	    if (fset(BINF_TYPEOPT) && (execop == 'L' || execop == 'R' ||
				       execop == 'Z' || execop == 'i') && arg && idigit(*arg)) {
		auxlen = atoi(arg);
		arg = (char *)ugetnode(args);
	    }
	}
    if (fset(BINF_R))
	auxdata = "-";
    if ((pp = b->defopts))
	while (*pp)
	    ops[(int)*pp++] = 1;
    if (arg) {
	argc = 1;
	n = firstnode(args);
	while (n)
	    argc++, incnode(n);
    }
    oargv = argv = (char **)ncalloc(sizeof(char **) * (argc + 1));

    if ((*argv++ = arg))
	while ((*argv++ = (char *)ugetnode(args)));
    argv = oargv;
    if (errflag) {
	zsfree(xarg);
	return 1;
    }
    if (argc < b->minargs || (argc > b->maxargs && b->maxargs != -1)) {
	zerrnam(name, (argc < b->minargs)
		? "not enough arguments" : "too many arguments", NULL, 0);
	zsfree(xarg);
	return 1;
    }
    if (isset(XTRACE)) {
	char **execpp = argv;

	fprintf(stderr, "%s%s", (prompt4) ? prompt4 : "", name);
	if (xarg)
	    fprintf(stderr, " %s", xarg);
	while (*execpp)
	    fprintf(stderr, " %s", *execpp++);
	fputc('\n', stderr);
	fflush(stderr);
    }
    zsfree(xarg);
    return (*(b->handlerfunc)) (name, argv, ops, b->funcid);
}

struct asgment *getasg(s)	/**/
char *s;
{
    static struct asgment asg;

    if (!s)
	return NULL;
    if (*s == '=') {
	zerr("bad assignment", NULL, 0);
	return NULL;
    }
    asg.name = s;
    for (; *s && *s != '='; s++);
    if (*s) {
	*s = '\0';
	asg.value = s + 1;
    } else
	asg.value = NULL;
    return &asg;
}

/* ., source */

int bin_dot(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    char **old, *old0;
    int ret, diddot = 0, dotdot = 0;
    char buf[MAXPATHLEN];
    char *s, **t, *enam;

    if (!*argv)
	return 0;
    old = pparams;
    old0 = argzero;
    if (argv[1]) {
	permalloc();
	pparams = arrdup(argv + 1);
	heapalloc();
    }
    enam = argzero = ztrdup(*argv);
    errno = ENOENT;
    ret = 1;
    if (*name != '.' && access(argzero, F_OK) == 0) {
	diddot = 1;
	ret = source(enam = argzero);
    }
    if (ret) {
	for (s = argzero; *s; s++)
	    if (*s == '/') {
		if (*argzero == '.') {
		    if (argzero + 1 == s)
			++diddot;
		    else if (argzero[1] == '.' && argzero + 2 == s)
			++dotdot;
		}
		ret = source(argzero);
		break;
	    }
	if (!*s || (ret && isset(PATHDIRS) && diddot < 2 && dotdot == 0)) {
	    for (t = path; *t; t++) {
		if ((*t)[0] == '.' && !(*t)[1]) {
		    if (diddot)
			continue;
		    diddot = 1;
		    strcpy(buf, argzero);
		} else
		    sprintf(buf, "%s/%s", *t, argzero);
		if (access(buf, F_OK) == 0) {
		    ret = source(enam = buf);
		    break;
		}
	    }
	}
    }
    if (argv[1]) {
	freearray(pparams);
	pparams = old;
    }
    if (ret)
	zerrnam(name, "%e: %s", enam, errno);
    zsfree(argzero);
    argzero = old0;
    return ret ? ret : lastval;
}

int bin_set(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    struct option *opp;
    char **x;

    if (((ops['+'] && ops['-']) || !ops['-']) && !ops['@'] && !*argv) {
	showflag = ~0;
	showflag2 = ops[(int)'+'];
	listhtable(paramtab, (HFunc) printparam);
    }
    for (opp = optns; opp->name; opp++)
	if (ops[(int)opp->id] == 1)
	    opts[(int)opp->id] = OPT_SET;
	else if (ops[(int)opp->id] == 2)
	    opts[(int)opp->id] = OPT_UNSET;
    if (ops['A'] && !auxdata) {
	showflag = PMFLAG_A;
	showflag2 = ops[(int)'+'];
	listhtable(paramtab, (HFunc) printparam);
    }
    if (!*argv && !ops['-'])
	return 0;
    permalloc();
    x = arrdup(argv);
    heapalloc();
    if (ops['A'])
	setaparam(auxdata, x);
    else {
	freearray(pparams);
	pparams = x;
    }
    return 0;
}

#define pttime(X) printf("%ldm%lds",((long) (X))/3600,((long) (X))/60%60)

int bin_times(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    struct tms buf;

    if (times(&buf) == -1)
	return 1;
    pttime(buf.tms_utime);
    putchar(' ');
    pttime(buf.tms_stime);
    putchar('\n');
    pttime(buf.tms_cutime);
    putchar(' ');
    pttime(buf.tms_cstime);
    putchar('\n');
    return 0;
}

int bin_getopts(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    char *optstr = *argv++, *var = *argv++;
    char **args = (*argv) ? argv : pparams;
    static int optcind = 1, quiet;
    char *str, optbuf[3], *opch = optbuf + 1;
    int oldzoptind = zoptind;

    if (zoptind < 1)
	zoptind = 1;
    if (zoptind == 1)
	quiet = 0;
    optbuf[0] = '+';
    optbuf[1] = optbuf[2] = '\0';
    zsfree(zoptarg);
    zoptarg = ztrdup("");
    setsparam(var, ztrdup(""));
    if (*optstr == ':') {
	quiet = 1;
	optstr++;
    }
    if (zoptind > arrlen(args))
	return 1;
    str = args[zoptind - 1];
    if ((*str != '+' && *str != '-') || optcind >= (int)strlen(str) ||
	!strcmp("--", str)) {
	if (*str == '+' || *str == '-')
	    zoptind++;
	optcind = 0;
	return 1;
    }
    if (!optcind)
	optcind = 1;
    *opch = str[optcind++];
    if (!args[zoptind - 1][optcind]) {
	zoptind++;
	optcind = 0;
    }
    for (; *optstr; optstr++)
	if (*opch == *optstr)
	    break;
    if (!*optstr) {
	setsparam(var, ztrdup("?"));
	zoptind = oldzoptind;
	if (quiet) {
	    zsfree(zoptarg);
	    zoptarg = ztrdup(opch);
	    return 0;
	}
	zerr("bad option: %c", NULL, *opch);
	errflag = 0;
	return 0;
    }
    setsparam(var, ztrdup(opch - (*str == '+')));
    if (optstr[1] == ':') {
	if (!args[zoptind - 1]) {
	    if (quiet) {
		zsfree(zoptarg);
		zoptarg = ztrdup(opch);
		setsparam(var, ztrdup(":"));
		return 0;
	    }
	    setsparam(var, ztrdup("?"));
	    zerr("argument expected after %c option", NULL, *opch);
	    errflag = 0;
	    return 0;
	}
	zsfree(zoptarg);
	zoptarg = ztrdup(args[zoptind - 1] + optcind);
	zoptind++;
	optcind = 0;
    }
    return 0;
}

/* get a signal number from a string */

int getsignum(s)		/**/
char *s;
{
    int x = atoi(s), t0;

    if (idigit(*s) && x >= 0 && x < VSIGCOUNT)
	return x;
    for (t0 = 0; t0 != VSIGCOUNT; t0++)
	if (!strcmp(s, sigs[t0]))
	    return t0;
    return -1;
}

int bin_trap(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    List l;
    char *arg;

    if (!*argv) {
	int t0;

	for (t0 = 0; t0 != VSIGCOUNT; t0++)
	    if (sigtrapped[t0])
		if (!sigfuncs[t0])
		    printf("TRAP%s () {}\n", sigs[t0]);
		else {
		    char *s =
		    getpermtext((vptr) dupstruct((vptr) sigfuncs[t0]));

		    printf("TRAP%s () {\n\t%s\n}\n", sigs[t0], s);
		    zsfree(s);
		}
	return 0;
    }
    if ((getsignum(*argv) != -1) || (!strcmp(*argv, "-") && argv++)) {
	int t0;

	if (!*argv)
	    for (t0 = 0; t0 != VSIGCOUNT; t0++)
		unsettrap(t0);
	else
	    while (*argv)
		unsettrap(getsignum(*argv++));
	return 0;
    }
    arg = *argv++;
    if (!*arg)
	l = NULL;
    else if (!(l = parselstring(arg))) {
	zerrnam(name, "couldn't parse trap command", NULL, 0);
	return 1;
    }
    for (; *argv; argv++) {
	int sg = getsignum(*argv);

	if (sg == -1) {
	    zerrnam(name, "undefined signal: %s", *argv, 0);
	    break;
	}
	settrap(sg, l);
    }
    if (l)
	popheap();
    return errflag;
}

#ifdef RLIM_INFINITY
void printulimit(lim, hard)	/**/
int lim;
int hard;
{
    RLIM_TYPE t0;

    t0 = (hard) ? limits[lim].rlim_max : limits[lim].rlim_cur;
    switch (lim) {
    case RLIMIT_CPU:
	printf("cpu time (seconds)         ");
	break;
    case RLIMIT_FSIZE:
	printf("file size (blocks)         ");
	t0 /= 512;
	break;
    case RLIMIT_DATA:
	printf("data seg size (kbytes)     ");
	t0 /= 1024;
	break;
    case RLIMIT_STACK:
	printf("stack size (kbytes)        ");
	t0 /= 1024;
	break;
    case RLIMIT_CORE:
	printf("core file size (blocks)    ");
	t0 /= 512;
	break;
#ifdef RLIMIT_RSS
    case RLIMIT_RSS:
	printf("resident set size (kbytes) ");
	t0 /= 1024;
	break;
#endif
#ifdef RLIMIT_MEMLOCK
    case RLIMIT_MEMLOCK:
	printf("locked-in-memory size (kb) ");
	t0 /= 1024;
	break;
#endif
#ifdef RLIMIT_NPROC
    case RLIMIT_NPROC:
	printf("processes                  ");
	break;
#endif
#ifdef RLIMIT_OFILE
    case RLIMIT_OFILE:
	printf("open files                 ");
	break;
#endif
#ifdef RLIMIT_NOFILE
    case RLIMIT_NOFILE:
	printf("file descriptors           ");
	break;
#endif
#ifdef RLIMIT_VMEM
    case RLIMIT_VMEM:
	printf("virtual memory size (kb)   ");
	t0 /= 1024;
	break;
#endif
    }
    if (t0 == RLIM_INFINITY)
	printf("unlimited\n");
    else
	printf("%ld\n", (long)t0);
}
#endif

int bin_ulimit(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
#ifndef RLIM_INFINITY
    zwarnnam(name, "not available on this system", NULL, 0);
    return 1;
#else
    int res, hard;

    hard = ops['H'];
    if (ops['a'] || !ops['@'])
	res = -1;
    else if (ops['t'])
	res = RLIMIT_CPU;
    else if (ops['f'])
	res = RLIMIT_FSIZE;
    else if (ops['d'])
	res = RLIMIT_DATA;
    else if (ops['s'])
	res = RLIMIT_STACK;
    else if (ops['c'])
	res = RLIMIT_CORE;
#ifdef RLIMIT_MEMLOCK
    else if (ops['l'])
	res = RLIMIT_MEMLOCK;
#endif
#ifdef RLIMIT_RSS
    else if (ops['m'])
	res = RLIMIT_RSS;
#endif
#ifdef RLIMIT_NOFILE
    else if (ops['n'])
	res = RLIMIT_NOFILE;
#endif
#ifdef RLIMIT_OFILE
    else if (ops['o'])
	res = RLIMIT_OFILE;
#endif
#ifdef RLIMIT_NPROC
    else if (ops['p'])
	res = RLIMIT_NPROC;
#endif
#ifdef RLIMIT_VMEM
    else if (ops['v'])
	res = RLIMIT_VMEM;
#endif
    else {
	zwarnnam(name, "no such limit", NULL, 0);
	return 1;
    }
    if (res == -1)
	if (*argv) {
	    zwarnnam(name, "no arguments required after -a", NULL, 0);
	    return 1;
	} else {
	    int t0;

	    for (t0 = 0; t0 != RLIM_NLIMITS; t0++)
		printulimit(t0, hard);
	    return 0;
	}
    if (!*argv)
	printulimit(res, hard);
    else if (strcmp(*argv, "unlimited")) {
	RLIM_TYPE t0;

	t0 = (RLIM_TYPE) atol(*argv);
	switch (res) {
	case RLIMIT_FSIZE:
	case RLIMIT_CORE:
	    t0 *= 512;
	    break;
	case RLIMIT_DATA:
	case RLIMIT_STACK:
#ifdef RLIMIT_RSS
	case RLIMIT_RSS:
#endif
#ifdef RLIMIT_MEMLOCK
	case RLIMIT_MEMLOCK:
#endif
#ifdef RLIMIT_VMEM
	case RLIMIT_VMEM:
#endif
	    t0 *= 1024;
	    break;
	}
	if (hard) {
	    if (t0 > limits[res].rlim_max && geteuid()) {
		zwarnnam(name, "can't raise hard limits", NULL, 0);
		return 1;
	    }
	    limits[res].rlim_max = t0;
	} else {
	    if (t0 > limits[res].rlim_max) {
		if (geteuid()) {
		    zwarnnam(name, "value exceeds hard limit", NULL, 0);
		    return 1;
		}
		limits[res].rlim_max = limits[res].rlim_cur = t0;
	    } else
		limits[res].rlim_cur = t0;
	}
    } else {
	if (hard) {
	    if (geteuid()) {
		zwarnnam(name, "can't remove hard limits", NULL, 0);
		return 1;
	    }
	    limits[res].rlim_max = RLIM_INFINITY;
	} else
	    limits[res].rlim_cur = limits[res].rlim_max;
    }
    return 0;
#endif
}

int putraw(c)			/**/
int c;
{
    putchar(c);
    return 0;
}

int bin_echotc(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    char *s, buf[2048], *t, *u;
    int num, argct, t0;

    s = *argv++;
    if (!termok)
	return 1;
    if ((num = tgetnum(s)) != -1) {
	printf("%d\n", num);
	return 0;
    }
    if (tgetflag(s)) {
	puts("yes");
	return (0);
    }
    u = buf;
    t = tgetstr(s, &u);
    if (!t || !*t) {
	zwarnnam(name, "no such capability: %s", s, 0);
	return 1;
    }
    for (argct = 0, u = t; *u; u++)
	if (*u == '%') {
	    if (u++, (*u == 'd' || *u == '2' || *u == '3' || *u == '.' ||
		      *u == '+'))
		argct++;
	}
    if (arrlen(argv) != argct) {
	zwarnnam(name, (arrlen(argv) < argct) ? "not enough arguments" :
		 "too many arguments", NULL, 0);
	return 1;
    }
    if (!argct)
	tputs(t, 1, putraw);
    else {
	t0 = (argv[1]) ? atoi(argv[1]) : atoi(*argv);
	tputs(tgoto(t, atoi(*argv), t0), t0, putraw);
    }
    return 0;
}

int bin_pwd(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    printf("%s\n", pwd);
    return 0;
}

#define TEST_END 0
#define TEST_INPAR 1
#define TEST_OUTPAR 2
#define TEST_STR 3
#define TEST_AND 4
#define TEST_OR 5
#define TEST_NOT 6

static char **tsp;
static int *tip;

int bin_test(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    char **s;
    int cnt, *arr, *ap, last_expr = 0;
    Cond c;

    if (func == BIN_BRACKET) {
	for (s = argv; *s; s++);
	if (s == argv || strcmp(s[-1], "]")) {
	    zerrnam(name, "']' expected", NULL, 0);
	    return 1;
	}
	s[-1] = NULL;
    }
    if (!*argv)
	return 1;
    for (s = argv, cnt = 0; *s; s++, cnt++);
    ap = arr = (int *)alloc((cnt + 1) * sizeof *arr);
    for (s = argv; *s; s++, ap++)
	if (!strcmp(*s, "(")) {
	    *ap = TEST_INPAR;
	    last_expr = 0;
	} else if (!strcmp(*s, ")")) {
	    *ap = TEST_OUTPAR;
	    last_expr = 1;
	} else if (!strcmp(*s, "=") || !strcmp(*s, "!=")) {
	    zerrnam(name, "argument expected", NULL, 0);
	    return 1;
	} else if (s[1] && (!strcmp(s[1], "=") || !strcmp(s[1], "!=")
			    || (s[1][0] == '-' &&
				get_cond_num(s[1] + 1) > -1))) {
	    if (!s[2] || (!strcmp(s[2], "(") || !strcmp(s[2], ")"))) {
		zerrnam(name, "argument expected", NULL, 0);
		return 1;
	    }
	    ap[0] = ap[1] = ap[2] = TEST_STR;
	    ap += 2;
	    s += 2;
	    last_expr = 1;
	} else if (!strcmp(*s, "-a") && last_expr) {
	    *ap = TEST_AND;
	    last_expr = 0;
	} else if (!strcmp(*s, "-o") && last_expr) {
	    *ap = TEST_OR;
	    last_expr = 0;
	} else if (!strcmp(*s, "!") && !last_expr) {
	    *ap = TEST_NOT;
	    last_expr = 0;
	} else {
	    *ap = TEST_STR;
	    last_expr = 1;
	    if (s[1] && strcmp(s[1], "(") && strcmp(s[1], ")") &&
		**s == '-') {
		*++ap = TEST_STR;
		++s;
	    }
	}
    *ap = TEST_END;
    tsp = argv;
    tip = arr;
    c = partest(0);
    if (*tip != TEST_END || errflag) {
	zerrnam(name, "parse error", NULL, 0);
	return 1;
    }
    return (c) ? !evalcond(c) : 1;
}

Cond partest(level)		/**/
int level;
{
    Cond a, b;

    switch (level) {
    case 0:
	a = partest(1);
	if (*tip == TEST_OR) {
	    tip++, tsp++;
	    b = (Cond) makecond();
	    b->left = (vptr) a;
	    b->right = (vptr) partest(0);
	    b->type = COND_OR;
	    return b;
	}
	return a;
    case 1:
	a = partest(2);
	if (*tip == TEST_AND) {
	    tip++, tsp++;
	    b = (Cond) makecond();
	    b->left = (vptr) a;
	    b->right = (vptr) partest(1);
	    b->type = COND_AND;
	    return b;
	}
	return a;
    case 2:
	if (*tip == TEST_NOT) {
	    tip++, tsp++;
	    b = (Cond) makecond();
	    b->left = (vptr) partest(2);
	    b->type = COND_NOT;
	    return b;
	}
    case 3:
	if (*tip == TEST_INPAR) {
	    tip++, tsp++;
	    b = partest(0);
	    if (*tip != TEST_OUTPAR) {
		zerrnam("test", "parse error", NULL, 0);
		return NULL;
	    }
	    tip++, tsp++;
	    return b;
	}
	if (tip[0] != TEST_STR) {
	    zerrnam("test", "parse error", NULL, 0);
	    return NULL;
	} else if (tip[1] != TEST_STR) {
	    b = (Cond) makecond();
	    if (!strcmp(*tsp, "-t")) {
		b->left = (vptr) dupstring("1");
		b->type = 't';
	    } else {
		b->left = (vptr) tsp[0];
		b->type = 'n';
	    }
	    tip++, tsp++;
	    return b;
	} else if (tip[2] != TEST_STR) {
	    b = par_cond_double(tsp[0], tsp[1]);
	    tip += 2, tsp += 2;
	    return b;
	} else {
	    b = par_cond_triple(tsp[0], tsp[1], tsp[2]);
	    tip += 3, tsp += 3;
	    return b;
	}
    }
    return NULL;
}

int get_xcompctl(name, av, cc, isdef)	/**/
char *name;
char ***av;
Compctl cc;
int isdef;
{
    char **argv = *av, *t, *tt, sav;
    int n, l = 0, ready = 0, dummy;
    Compcond m, c, o;
    Compctl *next = &(cc->ext);

    while (!ready) {
	o = m = c = (Compcond) zcalloc(sizeof(*c));
	for (t = *argv; *t;) {
	    while (*t == ' ')
		t++;
	    switch (*t) {
	    case 's':
		c->type = CCT_CURSUF;
		break;
	    case 'S':
		c->type = CCT_CURPRE;
		break;
	    case 'p':
		c->type = CCT_POS;
		break;
	    case 'c':
		c->type = CCT_CURSTR;
		break;
	    case 'C':
		c->type = CCT_CURPAT;
		break;
	    case 'w':
		c->type = CCT_WORDSTR;
		break;
	    case 'W':
		c->type = CCT_WORDPAT;
		break;
	    case 'n':
		c->type = CCT_CURSUB;
		break;
	    case 'N':
		c->type = CCT_CURSUBC;
		break;
	    case 'm':
		c->type = CCT_NUMWORDS;
		break;
	    case 'r':
		c->type = CCT_RANGESTR;
		break;
	    case 'R':
		c->type = CCT_RANGEPAT;
		break;
	    default:
		t[1] = '\0';
		zerrnam(name, "unknown condition code: %s", t, 0);
		freecompctl(cc);
		zfree(m, sizeof(struct compcond));

		return 1;
	    }
	    if (t[1] != '[') {
		t[1] = '\0';
		zerrnam(name, "expected condition after condition code: %s", t, 0);
		freecompctl(cc);
		zfree(m, sizeof(struct compcond));

		return 1;
	    }
	    t++;
	    for (n = 0, tt = t; *tt == '['; n++) {
		for (l = 1, tt++; *tt && l; tt++)
		    if (*tt == '\\' && tt[1])
			tt++;
		    else if (*tt == '[')
			l++;
		    else if (*tt == ']')
			l--;
		    else if (l == 1 && *tt == ',')
			*tt = '\201';
		if (tt[-1] == ']')
		    tt[-1] = '\200';
	    }

	    if (l) {
		t[1] = '\0';
		zerrnam(name, "error after condition code: %s", t, 0);
		freecompctl(cc);
		zfree(m, sizeof(struct compcond));

		return 1;
	    }
	    c->n = n;

	    if (c->type == CCT_POS ||
		c->type == CCT_NUMWORDS) {
		c->u.r.a = (int *)zcalloc(n * sizeof(int));
		c->u.r.b = (int *)zcalloc(n * sizeof(int));
	    } else if (c->type == CCT_CURSUF ||
		       c->type == CCT_CURPRE)
		c->u.s.s = (char **)zcalloc(n * sizeof(char *));

	    else if (c->type == CCT_RANGESTR ||
		     c->type == CCT_RANGEPAT) {
		c->u.l.a = (char **)zcalloc(n * sizeof(char *));
		c->u.l.b = (char **)zcalloc(n * sizeof(char *));
	    } else {
		c->u.s.p = (int *)zcalloc(n * sizeof(int));
		c->u.s.s = (char **)zcalloc(n * sizeof(char *));
	    }
	    for (l = 0; *t == '['; l++, t++) {
		for (t++; *t && *t == ' '; t++);
		tt = t;
		if (c->type == CCT_POS ||
		    c->type == CCT_NUMWORDS) {
		    for (; *t && *t != '\201' && *t != '\200'; t++);
		    if (!(sav = *t)) {
			zerrnam(name, "error in condition", NULL, 0);
			freecompctl(cc);
			freecompcond(m);
			return 1;
		    }
		    *t = '\0';
		    c->u.r.a[l] = atoi(tt);
		    if (sav == '\200')
			c->u.r.b[l] = c->u.r.a[l];
		    else {
			tt = ++t;
			for (; *t && *t != '\200'; t++);
			if (!*t) {
			    zerrnam(name, "error in condition", NULL, 0);
			    freecompctl(cc);
			    freecompcond(m);
			    return 1;
			}
			*t = '\0';
			c->u.r.b[l] = atoi(tt);
		    }
		} else if (c->type == CCT_CURSUF ||
			   c->type == CCT_CURPRE) {
		    for (; *t && *t != '\200'; t++)
			if (*t == '\201')
			    *t = ',';
		    if (!*t) {
			zerrnam(name, "error in condition", NULL, 0);
			freecompctl(cc);
			freecompcond(m);
			return 1;
		    }
		    *t = '\0';
		    c->u.s.s[l] = ztrdup(tt);
		} else if (c->type == CCT_RANGESTR ||
			   c->type == CCT_RANGEPAT) {
		    for (; *t && *t != '\201'; t++);
		    if (!*t) {
			zerrnam(name, "error in condition", NULL, 0);
			freecompctl(cc);
			freecompcond(m);
			return 1;
		    }
		    *t = '\0';
		    c->u.l.a[l] = ztrdup(tt);
		    tt = ++t;
		    for (; *t && *t != '\200'; t++)
			if (*t == '\201')
			    *t = ',';
		    if (!*t) {
			zerrnam(name, "error in condition", NULL, 0);
			freecompctl(cc);
			freecompcond(m);
			return 1;
		    }
		    *t = '\0';
		    c->u.l.b[l] = ztrdup(tt);
		} else {
		    for (; *t && *t != '\201'; t++);
		    if (!*t) {
			zerrnam(name, "error in condition", NULL, 0);
			freecompctl(cc);
			freecompcond(m);
			return 1;
		    }
		    *t = '\0';
		    c->u.s.p[l] = atoi(tt);
		    tt = ++t;
		    for (; *t && *t != '\200'; t++)
			if (*t == '\201')
			    *t = ',';
		    if (!*t) {
			zerrnam(name, "error in condition", NULL, 0);
			freecompctl(cc);
			freecompcond(m);
			return 1;
		    }
		    *t = '\0';
		    c->u.s.s[l] = ztrdup(tt);
		}
	    }
	    while (*t == ' ')
		t++;
	    if (*t == ',') {
		o->or = c = (Compcond) zcalloc(sizeof(*c));
		o = c;
		t++;
	    } else if (*t) {
		c->and = (Compcond) zcalloc(sizeof(*c));
		c = c->and;
	    }
	}
	*next = (Compctl) zcalloc(sizeof(*cc));
	(*next)->cond = m;
	argv++;
	if (get_compctl(name, &argv, *next, &dummy, 0, isdef)) {
	    freecompctl(cc);
	    return 1;
	}
	if ((!argv || !*argv) &&
	    (cc == &cc_default || cc == &cc_compos))
	    ready = 1;
	else {
	    if (!argv || !*argv || **argv != '-' ||
		((!argv[0][1] || argv[0][1] == '+') && !argv[1])) {
		zerrnam(name, "missing command names", NULL, 0);
		freecompctl(cc);
		return 1;
	    }
	    if (!strcmp(*argv, "--"))
		ready = 1;
	    else if (!strcmp(*argv, "-+") && argv[1] && !strcmp(argv[1], "--")) {
		ready = 1;
		argv++;
	    }
	    argv++;
	    next = &((*next)->next);
	}
    }
    *av = argv - 1;
    return 0;
}

int get_compctl(name, av, cc, t, first, isdef)	/**/
char *name;
char ***av;
Compctl cc;
int *t;
int first;
int isdef;
{
    unsigned long flags = 0;
    Compctl cc2 = NULL;
    char **argv = *av, *usrkeys = NULL, *compglob = NULL, *str = NULL;
    char *funcn = NULL, *explain = NULL, *compprefix = NULL, *suffix = NULL;
    char *subcmd = NULL, *hpat = NULL;
    int ready = 0, hnum = 0, hx = 0;

    for (; !ready && *argv && **argv == '-';) {
	if (**argv == '-' && !(*argv)[1])
	    *argv = "-+";
	while (!ready && *++(*argv))
	    switch (**argv) {
	    case 'f':
		flags |= CC_FILES;
		break;
	    case 'c':
		flags |= CC_COMMPATH;
		break;
	    case 'o':
		flags |= CC_OPTIONS;
		break;
	    case 'v':
		flags |= CC_VARS;
		break;
	    case 'b':
		flags |= CC_BINDINGS;
		break;
	    case 'A':
		flags |= CC_ARRAYS;
		break;
	    case 'I':
		flags |= CC_INTVARS;
		break;
	    case 'F':
		flags |= CC_FUNCS;
		break;
	    case 'p':
		flags |= CC_PARAMS;
		break;
	    case 'E':
		flags |= CC_ENVVARS;
		break;
	    case 'j':
		flags |= CC_JOBS;
		break;
	    case 'r':
		flags |= CC_RUNNING;
		break;
	    case 'z':
		flags |= CC_STOPPED;
		break;
	    case 'B':
		flags |= CC_BUILTINS;
		break;
	    case 'a':
		flags |= CC_ALREG | CC_ALGLOB;
		break;
	    case 'R':
		flags |= CC_ALREG;
		break;
	    case 'G':
		flags |= CC_ALGLOB;
		break;
	    case 'u':
		flags |= CC_USERS;
		break;
	    case 'd':
		flags |= CC_DISCMDS;
		break;
	    case 'e':
		flags |= CC_EXCMDS;
		break;
	    case 'N':
		flags |= CC_SCALARS;
		break;
	    case 'O':
		flags |= CC_READONLYS;
		break;
	    case 'Z':
		flags |= CC_SPECIALS;
		break;
	    case 'q':
		flags |= CC_REMOVE;
		break;
	    case 'U':
		flags |= CC_DELETE;
		break;
	    case 'n':
		flags |= CC_NAMED;
		break;
	    case 'k':
		if ((*argv)[1]) {
		    usrkeys = (*argv) + 1;
		    *argv = "" - 1;
		} else if (!argv[1]) {
		    zerrnam(name, "variable name expected after -k", NULL, 0);
		    return 1;
		} else {
		    usrkeys = *++argv;
		    *argv = "" - 1;
		}
		break;
	    case 'K':
		if ((*argv)[1]) {
		    funcn = (*argv) + 1;
		    *argv = "" - 1;
		} else if (!argv[1]) {
		    zerrnam(name, "function name expected after -K", NULL, 0);
		    return 1;
		} else {
		    funcn = *++argv;
		    *argv = "" - 1;
		}
		break;
	    case 'X':
		if ((*argv)[1]) {
		    explain = (*argv) + 1;
		    *argv = "" - 1;
		} else if (!argv[1]) {
		    zerrnam(name, "string expected after -X", NULL, 0);
		    return 1;
		} else {
		    explain = *++argv;
		    *argv = "" - 1;
		}
		break;
	    case 'P':
		if (hx) {
		    zerrnam(name, "prefix definition in xor'd completion not allowed",
			    NULL, 0);
		    return 1;
		}
		if ((*argv)[1]) {
		    compprefix = (*argv) + 1;
		    *argv = "" - 1;
		} else if (!argv[1]) {
		    zerrnam(name, "string expected after -P", NULL, 0);
		    return 1;
		} else {
		    compprefix = *++argv;
		    *argv = "" - 1;
		}
		break;
	    case 'S':
		if (hx) {
		    zerrnam(name, "suffix definition in xor'd completion not allowed",
			    NULL, 0);
		    return 1;
		}
		if ((*argv)[1]) {
		    suffix = (*argv) + 1;
		    *argv = "" - 1;
		} else if (!argv[1]) {
		    zerrnam(name, "string expected after -S", NULL, 0);
		    return 1;
		} else {
		    suffix = *++argv;
		    *argv = "" - 1;
		}
		break;
	    case 'g':
		if ((*argv)[1]) {
		    compglob = (*argv) + 1;
		    *argv = "" - 1;
		} else if (!argv[1]) {
		    zerrnam(name, "glob pattern expected after -g", NULL, 0);
		    return 1;
		} else {
		    compglob = *++argv;
		    *argv = "" - 1;
		}
		break;
	    case 's':
		if ((*argv)[1]) {
		    str = (*argv) + 1;
		    *argv = "" - 1;
		} else if (!argv[1]) {
		    zerrnam(name, "command string expected after -s", NULL, 0);
		    return 1;
		} else {
		    str = *++argv;
		        $                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *argv = "" - 1;
		}
		break;
	    case 'l':
		if ((*argv)[1]) {
		    subcmd = (*argv) + 1;
		    *argv = "" - 1;
		} else if (!argv[1]) {
		    zerrnam(name, "command name expected after -s", NULL, 0);
		    return 1;
		} else {
		    subcmd = *++argv;
		    *argv = "" - 1;
		}
		break;
	    case 'H':
		if ((*argv)[1])
		    hnum = atoi((*argv) + 1);
		else if (argv[1])
		    hnum = atoi(*++argv);
		else {
		    zerrnam(name, "number expected after -H", NULL, 0);
		    return 1;
		}
		if (!argv[1]) {
		    zerrnam(name, "missing pattern after -H", NULL, 0);
		    return 1;
		}
		hpat = *++argv;
		if (hnum < 1)
		    hnum = 0;
		if (*hpat == '*' && !hpat[1])
		    hpat = "";
		*argv = "" - 1;
		break;
	    case 'C':
		if (first && !hx) {
		    Compctl c2;

		    cc = cc2 = &cc_compos;

		    c2 = (Compctl) zcalloc(sizeof *cc2);
		    c2->xor = cc2->xor;
		    c2->ext = cc2->ext;
		    c2->refc = 1;

		    freecompctl(c2);

		    cc2->ext = cc2->xor = NULL;
		} else {
		    zerrnam(name, "misplaced command completion (-C) flag", NULL, 0);
		    return 1;
		}
		break;
	    case 'D':
		if (first && !hx) {
		    Compctl c2;

		    cc = cc2 = &cc_default, isdef = 1;
		    c2 = (Compctl) zcalloc(sizeof *cc2);
		    c2->xor = cc2->xor;
		    c2->ext = cc2->ext;
		    c2->refc = 1;

		    freecompctl(c2);

		    cc2->ext = cc2->xor = NULL;
		} else {
		    zerrnam(name, "misplaced default completion (-D) flag", NULL, 0);
		    return 1;
		}
		break;
	    case 'x':
		if (!argv[1]) {
		    zerrnam(name, "condition expected after -x", NULL, 0);
		    return 1;
		}
		if (first) {
		    argv++;
		    if (get_xcompctl(name, &argv, cc, isdef))
			return 2;
		    ready = 2;
		} else {
		    zerrnam(name, "recursive extended completion not allowed",
			    NULL, 0);
		    return 1;
		}
		break;
	    default:
		if (!first && (**argv == '-' || **argv == '+'))
		    (*argv)--, argv--, ready = 1;
		else {
		    zerrnam(name, "bad option: %c", NULL, **argv);
		    return 1;
		}
	    }

	if (*++argv && (!ready || ready == 2) && **argv == '+' && !argv[0][1]) {
	    hx = 1;
	    ready = 0;

	    if (subcmd &&
		(usrkeys || compglob || str || funcn || explain || compprefix ||
		 suffix || hpat || flags)) {
		zerrnam(name, "illegal combination of options", NULL, 0);
		return 1;
	    }
	    cc->mask = flags;
	    zsfree(cc->keyvar);
	    zsfree(cc->glob);
	    zsfree(cc->str);
	    zsfree(cc->func);
	    zsfree(cc->explain);
	    zsfree(cc->prefix);
	    zsfree(cc->suffix);
	    zsfree(cc->subcmd);
	    zsfree(cc->hpat);

	    cc->mask = flags;
	    cc->keyvar = ztrdup(usrkeys);
	    cc->glob = ztrdup(compglob);
	    cc->str = ztrdup(str);
	    cc->func = ztrdup(funcn);
	    cc->explain = ztrdup(explain);
	    cc->prefix = ztrdup(compprefix);
	    cc->suffix = ztrdup(suffix);
	    cc->subcmd = ztrdup(subcmd);
	    cc->hpat = ztrdup(hpat);
	    cc->hnum = hnum;

	    if (!*++argv || **argv != '-' ||
		(**argv == '-' && (!argv[0][1] ||
				   (argv[0][1] == '-' && !argv[0][2])))) {
		if (isdef) {
		    zerrnam(name, "recursive xor'd default completions not allowed",
			    NULL, 0);
		    return 1;
		}
		cc->xor = &cc_default;
		if (!*argv || **argv == '-') {
		    if (*argv)
			(*argv)--;
		    argv--;
		    ready = 1;
		}
	    } else {
		cc->xor = (Compctl) zcalloc(sizeof(*cc));
		cc = cc->xor;
		flags = 0;
		usrkeys = NULL;
		compglob = NULL;
		str = NULL;
		funcn = NULL;
		explain = NULL;
		compprefix = NULL;
		suffix = NULL;
		subcmd = NULL;
		hpat = NULL;
		hnum = 0;
	    }
	}
    }

    if (subcmd &&
	(usrkeys || compglob || str || funcn || explain || compprefix || suffix ||
	 hpat || flags)) {
	zerrnam(name, "illegal combination of options", NULL, 0);
	return 1;
    }
    if (cc2)
	*t = 1;

    cc->mask = flags;
    zsfree(cc->keyvar);
    zsfree(cc->glob);
    zsfree(cc->str);
    zsfree(cc->func);
    zsfree(cc->explain);
    zsfree(cc->prefix);
    zsfree(cc->suffix);
    zsfree(cc->subcmd);
    zsfree(cc->hpat);

    cc->mask = flags;
    cc->keyvar = ztrdup(usrkeys);
    cc->glob = ztrdup(compglob);
    cc->str = ztrdup(str);
    cc->func = ztrdup(funcn);
    cc->explain = ztrdup(explain);
    cc->prefix = ztrdup(compprefix);
    cc->suffix = ztrdup(suffix);
    cc->subcmd = ztrdup(subcmd);
    cc->hpat = ztrdup(hpat);
    cc->hnum = hnum;
    *av = argv;

    return 0;
}

int bin_compctl(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    Compctl cc = NULL;
    int t = 0, t2;
    unsigned long flags = 0;

    if (*argv) {
	cc = (Compctl) zcalloc(sizeof(*cc));

	if ((t2 = get_compctl(name, &argv, cc, &t, 1, 0))) {
	    if (t2 == 1)
		freecompctl(cc);
	    return 1;
	}
	if (*argv)
	    compctl_process_cc(argv, cc);

	flags = cc->mask;

	if (!*argv)
	    freecompctl(cc);
    }
    if (!*argv && !t) {
	showflag = flags;
	listhtable(compctltab, (HFunc) printcompctlp);
	printcompctl("COMMAND", &cc_compos);
	printcompctl("DEFAULT", &cc_default);
    }
    return 0;
}

void printif(str, c)		/**/
char *str;
int c;
{
    if (str)
	printf("-%c \"%s\" ", c, str);
}

void printcompctlp(s, ccp)	/**/
char *s;
Compctlp ccp;
{
    printcompctl(s, ccp->cc);
}

void printcompctl(s, cc)	/**/
char *s;
Compctl cc;
{
    char *css = "fcqovbAIFpEjrzBRGudeNOZUn";
    char *mss = " pcCwWsSnNmrR";
    unsigned long t = 0x7fffffff;

    if (cc->mask & showflag) {
	if (s)
	    puts(s);
    } else if (!showflag) {
	unsigned long flags = cc->mask;

	if (s)
	    printf("%s ", s);
	if (flags & t) {
	    putchar('-');
	    if ((flags & (CC_ALREG | CC_ALGLOB)) == (CC_ALREG | CC_ALGLOB))
		putchar('a'), flags &= ~(CC_ALREG | CC_ALGLOB);
	    while (*css) {
		if ((flags & 1) && (t & 1))
		    putchar(*css);
		css++;
		flags >>= 1;
		t >>= 1;
	    }
	    putchar(' ');
	}
	flags = cc->mask;
	if (cc->keyvar)
	    printf(*cc->keyvar == '(' ? "-k \"%s\" " : "-k %s ", cc->keyvar);
	printif(cc->func, 'K');
	printif(cc->explain, 'X');
	printif(cc->prefix, 'P');
	printif(cc->suffix, 'S');
	printif(cc->glob, 'g');
	printif(cc->str, 's');
	printif(cc->subcmd, 'l');
	if (cc->hpat)
	    printf("-H %d \"%s\" ", cc->hnum, cc->hpat);
	if (cc->ext) {
	    Compcond c, o;
	    int i;

	    cc = cc->ext;
	    printf("-x ");

	    while (cc) {
		c = cc->cond;

		putchar('\"');
		for (c = cc->cond; c;) {
		    o = c->or;
		    while (c) {
			putchar(mss[c->type]);

			for (i = 0; i < c->n; i++)
			    switch (c->type) {
			    case CCT_POS:
			    case CCT_NUMWORDS:
				printf("[%d,%d]", c->u.r.a[i], c->u.r.b[i]);
				break;
			    case CCT_CURSUF:
			    case CCT_CURPRE:
				printf("[%s]", c->u.s.s[i]);
				break;
			    case CCT_RANGESTR:
			    case CCT_RANGEPAT:
				printf("[%s,%s]", c->u.l.a[i], c->u.l.b[i]);
				break;
			    default:
				printf("[%d,%s]", c->u.s.p[i], c->u.s.s[i]);
			    }
			if ((c = c->and))
			    putchar(' ');
		    }
		    if ((c = o))
			printf(" , ");
		}
		printf("\" ");
		c = cc->cond;
		cc->cond = NULL;
		printcompctl(NULL, cc);
		cc->cond = c;
		if ((cc = (Compctl) (cc->next)))
		    printf("- ");
	    }
	}
	if (cc && cc->xor) {
	    printf("+ ");
	    if (cc->xor != &cc_default)
		printcompctl(NULL, cc->xor);
	}
	if (s)
	    putchar('\n');
    }
}

void compctl_process(s, mask, uk, gl, st, fu, ex, pr, su, sc, hp, hn)	/**/
char **s;
int mask;
char *uk;
char *gl;
char *st;
char *fu;
char *ex;
char *pr;
char *su;
char *sc;
char *hp;
int hn;
{
    Compctl cc;

    cc = (Compctl) zcalloc(sizeof *cc);
    cc->mask = mask;
    cc->keyvar = ztrdup(uk);
    cc->glob = ztrdup(gl);
    cc->str = ztrdup(st);
    cc->func = ztrdup(fu);
    cc->explain = ztrdup(ex);
    cc->prefix = ztrdup(pr);
    cc->suffix = ztrdup(su);
    cc->subcmd = ztrdup(sc);
    cc->hpat = ztrdup(hp);
    cc->hnum = hn;

    compctl_process_cc(s, cc);
}

void compctl_process_cc(s, cc)	/**/
char **s;
Compctl cc;
{
    Compctlp ccp;

    cc->refc = 0;
    for (; *s; s++) {
	cc->refc++;
	ccp = (Compctlp) zalloc(sizeof *ccp);
	ccp->cc = cc;
	addhnode(ztrdup(*s), ccp, compctltab, freecompctlp);
    }
}

int bin_ttyctl(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    if (!ops['@'])
	printf("tty is %sfrozen\n", ttyfrozen ? "" : "not ");
    else if (ops['f'])
	ttyfrozen = 1;
    else
	ttyfrozen = 0;
    return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /* this file is created automatically by buildzsh */

/* define this if you are sysvish */
/* #define SYSV */

#define TERMIOS
/* #define TTY_NEEDS_DRAINING */
/* #define CLOBBERS_TYPEAHEAD */

#define HAS_DIRENT

#define HAS_UNISTD

#define HAS_STDLIB

#define HAS_STRING

#define HAS_MEMORY

#define HAS_LOCALE

/*#define HAS_UTMPX*/

#define UTMP_HOST

/*#define HAS_TIME*/

/*#define HAS_WAIT*/

/* define this if you have WAITPID */
#define WAITPID

/* define this if you have SELECT */
#define HAS_SELECT

/* define this if you have <sys/select.h> */
/* #define HAS_SYS_SELECT */

/* we can't just test for S_IFIFO or check to see if the mknod worked,
   because the NeXTs sold by a vendor which will remain nameless will
   happily create the FIFO for you, and then panic when you try to do
	something weird with them, because they aren't supported by the OS. */

/* #define NO_FIFOS */

/* define this if you have strftime() */
#define HAS_STRFTIME

#define HAS_TCSETPGRP

#define HAS_TCCRAP

#define HAS_SETPGID

/* #define HAS_SIGRELSE */

/* define this if you have RFS */
/* #define HAS_RFS */

/* define this if you have a working getrusage and wait3 */
#define HAS_RUSAGE
/* define this if you use NIS for your passwd map */
#define HAS_NIS_PASSWD

/* define this if your signal handlers return void */
#define SIGVOID
#ifdef sgi
#undef SIGVOID
#endif

/* define this if signal handlers need to be reset each time */
/* #define RESETHANDNEEDED */

#ifdef SIGVOID
#define HANDTYPE void
#else
#define HANDTYPE int
#define INTHANDTYPE
#endif

/* a string corresponding to the host type */
#define HOSTTYPE "sun4"

/* the default editor for the fc builtin */
#define DEFFCEDIT "vi"

/* the path of wtmp */
#define WTMP_FILE "/var/adm/wtmp"

/* the path of utmp */
#define UTMP_FILE "/etc/utmp"

/* default prefix for temporary files */
#define DEFTMPPREFIX "/tmp/zsh"

/* define if you prefer "suspended" to "stopped" */
#define USE_SUSPENDED

/* the file to source absolutely first whenever zsh is run; if undefined,
      don't source anything */
#define GLOBALZSHENV "/etc/zshenv"

/* the file to source whenever zsh is run; if undefined, don't source
	anything */
#define GLOBALZSHRC "/etc/zshrc"

/* the file to source whenever zsh is run as a login shell; if
	undefined, don't source anything */
#define GLOBALZLOGIN "/etc/zlogin"

/* the file to source whenever zsh is run as a login shell, before
	zshrc is read; if undefined, don't source anything */
#define GLOBALZPROFILE "/etc/zprofile"

/* the default HISTSIZE */
#define DEFAULT_HISTSIZE 30

#define _BSD_SIGNALS   /* this could be an iris, you never know */
#define _BSD           /* this could be HP-UX, you never know */
#define _BSD_INCLUDES  /* this could be AIX, you never know */
#define _BBN_POSIX_SUPPORT	/* this could be nX, you never know */

/* if your compiler doesn't like void *, change this to char *
	and ignore all the warnings.
*/

typedef void *vptr;

#define JOB_CONTROL

/* define this if you want to use zsh's own allocator */

/* #define USE_ZSH_MALLOC */

/* define this if you want the allocator to store information */

/* #define MEM_DEBUG */

/* define this if you want to get error messages from the allocator */

/* #define MEM_WARNING */

/* define this if you want free() to be really save */

/* #define SECURE_FREE */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 void doshfunc(list, doshargs, flags)	/**/
List list;
Lklist doshargs;
int flags;
{
    char **tab, **x, *oargv0;
    int oxtr = opts[XTRACE], opev = opts[PRINTEXITVALUE], xexittr;
    int oldzoptind;
    Lklist olist;
    char *s;
    List xexitfn;

    pushheap();
    xexittr = sigtrapped[SIGEXIT];
    xexitfn = sigfuncs[SIGEXIT];
    tab = pparams;
    oargv0 = argzero;
    oldzoptind = zoptind;
    zoptind = 1;
    if (flags & PMFLAG_t)
	opts[XTRACE] = OPT_SET;
    opts[PRINTEXITVALUE] = OPT_UNSET;
    if (doshargs) {
	pparams = x =
	    (char **)zcalloc(((sizeof *x) * (1 + countnodes(doshargs))));
	argzero = ztrdup(ugetnode(doshargs));
	while ((*x = (char *)ugetnode(doshargs)))
	    *x = ztrdup(*x), x++;
    } else {
	pparams = (char **)zcalloc(sizeof *pparams);
	argzero = ztrdup(argzero);
    }
    permalloc();
    olist = locallist;
    locallist = newlist();
    locallevel++;
    heapalloc();
    runlist(dupstruct(list));
    locallevel--;
    while ((s = (char *)getnode(locallist))) {
	Param pm = (Param) gethnode(s, paramtab);

	if (pm && pm->level > locallevel)
	    unsetparam(s);
	zsfree(s);
    }
    zfree(locallist, sizeof(struct lklist));

    locallist = olist;
    breaks = retflag = 0;
    freearray(pparams);
    zsfree(argzero);
    zoptind = oldzoptind;
    argzero = oargv0;
    pparams = tab;
    if (sigfuncs[SIGEXIT] && sigfuncs[SIGEXIT] != xexitfn) {
	dotrap(SIGEXIT);
	freestruct(sigfuncs[SIGEXIT]);
    }
    sigtrapped[SIGEXIT] = xexittr;
    sigfuncs[SIGEXIT] = xexitfn;
    opts[XTRACE] = oxtr;
    opts[PRINTEXITVALUE] = opev;
    popheap();
}

/* search fpath for an undefined function */

List getfpfunc(s)		/**/
char *s;
{
    char **pp = fpath, buf[MAXPATHLEN];
    int fd;

    for (; *pp; pp++) {
	sprintf(buf, "%s/%s", *pp, s);
	if (!access(buf, R_OK) && (fd = open(buf, O_RDONLY)) != -1) {
	    int len = lseek(fd, 0, 2);

	    if (len == -1)
		close(fd);
	    else {
		char *d;
		List r;

		lseek(fd, 0, 0);
		d = (char *)zcalloc(len + 1);
		if (read(fd, d, len) != len) {
		    zfree(d, len + 1);
		    close(fd);
		} else {
		    close(fd);
		    r = parselstring(d);
		    zfree(d, len + 1);

		    return r;
		}
	    }
	}
    }
    return NULL;
}

/* check to see if AUTOCD applies here */

extern int doprintdir;

char *cancd(s)			/**/
char *s;
{
    int nocdpath = s[0] == '.' &&
    (s[1] == '/' || !s[1] || (s[1] == '.' && (s[2] == '/' || !s[1])));
    char *t;

    if (*s != '/') {
	char sbuf[MAXPATHLEN], **cp;

	if (cancd2(s))
	    return s;
	if (access(s, X_OK) == 0)
	    return NULL;
	if (!nocdpath)
	    for (cp = cdpath; *cp; cp++) {
		sprintf(sbuf, "%s/%s", *cp, s);
		if (cancd2(sbuf)) {
		    doprintdir = -1;
		    return dupstring(sbuf);
		}
	    }
	if ((t = cd_able_vars(s))) {
	    if (cancd2(t)) {
		doprintdir = -1;
		return t;
	    }
	}
	return NULL;
    }
    return cancd2(s) ? s : NULL;
}

int cancd2(s)			/**/
char *s;
{
    struct stat buf;

    return !(access(s, X_OK) || stat(s, &buf) || !S_ISDIR(buf.st_mode));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*
 *
 * exec.c - command execution
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"
#include <errno.h>

#define execerr() { if (forked) _exit(1); \
	closemnodes(mfds); lastval = 1; return; }

static Lklist args;

/* parse list in a string */

List parselstring(s)		/**/
char *s;
{
    List l;

    hungets(s);
    strinbeg();
    pushheap();
    if (!(l = parse_list())) {
	strinend();
	hflush();
	popheap();
	return NULL;
    }
    strinend();
    return l;
}

/* execute a string */

void execstring(s)		/**/
char *s;
{
    List l;

    if ((l = parselstring(s))) {
	execlist(l);
	popheap();
    }
}

/* fork and set limits */

int phork()
{				/**/
    int pid;

#ifdef RLIM_INFINITY
    int t0;

#endif

    if (thisjob >= MAXJOB - 1) {
	zerr("job table full", NULL, 0);
	return -1;
    }
    pid = fork();
    if (pid == -1) {
	zerr("fork failed: %e", NULL, errno);
	return -1;
    }
#ifdef RLIM_INFINITY
    if (!pid)
	for (t0 = 0; t0 != RLIM_NLIMITS; t0++)
	    setrlimit(t0, limits + t0);
#endif
    return pid;
}

/* execute a current shell command */

int execcursh(cmd)		/**/
Cmd cmd;
{
    runlist(cmd->u.list);
    cmd->u.list = NULL;
    return lastval;
}

/* execve after handling $_ and #! */

#define POUNDBANGLIMIT 64

int zexecve(pth, argv)		/**/
char *pth;
char **argv;
{
    int eno;
    static char buf[MAXPATHLEN * 2];
    char **eep;

    for (eep = environ; *eep; eep++)
	if (**eep == '_' && (*eep)[1] == '=')
	    break;
    buf[0] = '_';
    buf[1] = '=';
    if (*pth == '/')
	strcpy(buf + 2, pth);
    else
	sprintf(buf + 2, "%s/%s", pwd, pth);
    if (!*eep)
	eep[1] = NULL;
    *eep = buf;
    execve(pth, argv, environ);
    if ((eno = errno) == ENOEXEC) {
	char execvebuf[POUNDBANGLIMIT + 1], *ptr, *ptr2, *argv0;
	int fd, ct, t0;

	if ((fd = open(pth, O_RDONLY)) >= 0) {
	    argv0 = *argv;
	    *argv = pth;
	    ct = read(fd, execvebuf, POUNDBANGLIMIT);
	    close(fd);
	    if (ct > 0) {
		if (execvebuf[0] == '#')
		    if (execvebuf[1] == '!') {
			for (t0 = 0; t0 != ct; t0++)
			    if (execvebuf[t0] == '\n')
				execvebuf[t0] = '\0';
			execvebuf[POUNDBANGLIMIT] = '\0';
			for (ptr = execvebuf + 2; *ptr && *ptr == ' '; ptr++);
			for (ptr2 = ptr; *ptr && *ptr != ' '; ptr++);
			if (*ptr) {
			    *ptr = '\0';
			    argv[-2] = ptr2;
			    argv[-1] = ptr + 1;
			    execve(ptr2, argv - 2, environ);
			} else {
			    argv[-1] = ptr2;
			    execve(ptr2, argv - 1, environ);
			}
		    } else {
			argv[-1] = "sh";
			execve("/bin/sh", argv - 1, environ);
		} else {
		    for (t0 = 0; t0 != ct; t0++)
			if (!execvebuf[t0])
			    break;
		    if (t0 == ct) {
			argv[-1] = "sh";
			execve("/bin/sh", argv - 1, environ);
		    }
		}
	    } else
		eno = errno;
	    *argv = argv0;
	} else
	    eno = errno;
    }
    return eno;
}

#define MAXCMDLEN (MAXPATHLEN*4)

/* execute an external command */

void execute(dash)		/**/
int dash;
{
    static Lklist exargs;
    char **argv, *arg0, **pp;
    char *z, *s, buf[MAXCMDLEN], buf2[MAXCMDLEN];
    int ee, eno = 0;
    Cmdnam cn;

    if (empty(args)) {
	zerr("no command", NULL, 0);
	_exit(1);
    }
    if (!exargs && (s = zgetenv("STTY"))) {
	exargs = args;
	args = NULL;
	zyztem("stty", s);
	args = exargs;
	exargs = NULL;
    }
    arg0 = (char *)peekfirst(args);
    cn = (Cmdnam) gethnode(arg0, cmdnamtab);
    if (cn && (cn->flags & DISABLED))
	cn = NULL;
    if ((z = zgetenv("ARGV0"))) {
	setdata(firstnode(args), (vptr) ztrdup(z));
	delenv(z - 6);
    } else if (dash) {
	sprintf(buf2, "-%s", arg0);
	setdata(firstnode(args), (vptr) ztrdup(buf2));
    }
    argv = makecline(args);
    unblockchld();
    if ((int)strlen(arg0) > MAXPATHLEN) {
	zerr("command too long: %s", arg0, 0);
	_exit(1);
    }
    for (s = arg0; *s; s++)
	if (*s == '/') {
	    errno = zexecve(arg0, argv);
	    if (arg0 == s || unset(PATHDIRS) ||
		(arg0[0] == '.' && (arg0 + 1 == s ||
				    (arg0[1] == '.' && arg0 + 2 == s)))) {
		zerr("%e: %s", arg0, errno);
		_exit(1);
	    }
	    break;
	}
    if (cn && ISEXCMD(cn->flags)) {
	char nn[MAXPATHLEN];

	if (cn->flags & BUILTIN)
	    strcpy(nn, cn->u.cmd);
	else {
	    for (pp = path; pp < cn->u.name; pp++)
		if (**pp == '.' && (*pp)[1] == '\0') {
		    ee = zexecve(arg0, argv);
		    if (ee != ENOENT)
			eno = ee;
		} else if (**pp != '/') {
		    z = buf;
		    strucpy(&z, *pp);
		    *z++ = '/';
		    strcpy(z, arg0);
		    ee = zexecve(buf, argv);
		    if (ee != ENOENT)
			eno = ee;
		}
	    strcpy(nn, cn->u.name ? *(cn->u.name) : "");
	    strcat(nn, "/");
	    strcat(nn, cn->nam);
	}
	ee = zexecve(nn, argv);

	if (ee != ENOENT)
	    eno = ee;
    }
    for (pp = path; *pp; pp++)
	if ((*pp)[0] == '.' && !(*pp)[1]) {
	    ee = zexecve(arg0, argv);
	    if (ee != ENOENT)
		eno = ee;
	} else {
	    z = buf;
	    strucpy(&z, *pp);
	    *z++ = '/';
	    strcpy(z, arg0);
	    ee = zexecve(buf, argv);
	    if (ee != ENOENT)
		eno = ee;
	}
    if (eno)
	zerr("%e: %s", arg0, eno);
    else
	zerr("command not found: %s", arg0, 0);
    _exit(1);
}

#define try(X) { if (iscom(X)) return ztrdup(X); }

/* get the full pathname of an external command */

char *findcmd(arg0)		/**/
char *arg0;
{
    char **pp;
    char *z, *s, buf[MAXCMDLEN];
    Cmdnam cn;

    cn = (Cmdnam) gethnode(arg0, cmdnamtab);
    if (!cn && isset(HASHCMDS))
	cn = hashcmd(arg0, path);
    if (cn && cn->flags & DISABLED)
	cn = NULL;
    if ((int)strlen(arg0) > MAXPATHLEN)
	return NULL;
    for (s = arg0; *s; s++)
	if (*s == '/') {
	    try(arg0);
	    if (arg0 == s || unset(PATHDIRS)) {
		return NULL;
	    }
	    break;
	}
    if (cn && ISEXCMD(cn->flags)) {
	char nn[MAXPATHLEN];

	if (cn->flags & BUILTIN)
	    strcpy(nn, cn->u.cmd);
	else {
	    for (pp = path; pp < cn->u.name; pp++)
		if (**pp != '/') {
		    z = buf;
		    strucpy(&z, *pp);
		    *z++ = '/';
		    strcpy(z, arg0);
		    try(buf);
		}
	    strcpy(nn, cn->u.name ? *(cn->u.name) : "");
	    strcat(nn, "/");
	    strcat(nn, cn->nam);
	}
	try(nn);
    }
    for (pp = path; *pp; pp++) {
	z = buf;
	strucpy(&z, *pp);
	*z++ = '/';
	strcpy(z, arg0);
	try(buf);
    }
    return NULL;
}

int iscom(s)			/**/
char *s;
{
    struct stat statbuf;

    return (access(s, X_OK) == 0 && stat(s, &statbuf) >= 0 &&
	    S_ISREG(statbuf.st_mode));
}

int isrelative(s)		/**/
char *s;
{
    if (*s != '/')
	return 1;
    for (; *s; s++)
	if (*s == '.' && s[-1] == '/' &&
	    (s[1] == '/' || s[1] == '\0' ||
	     (s[1] == '.' && (s[2] == '/' || s[2] == '\0'))))
	    return 1;
    return 0;
}

Cmdnam hashcmd(arg0, pp)	/**/
char *arg0;
char **pp;
{
    char *s, buf[MAXPATHLEN];
    char **pq;
    DIR *dir;
    struct dirent *de;
    Cmdnam cn;

    for (; *pp; pp++)
	if (**pp == '/') {
	    s = buf;
	    strucpy(&s, *pp);
	    *s++ = '/';
	    strcpy(s, arg0);
	    if (iscom(buf))
		break;
	}
    if (!*pp || isrelative(*pp))
	return NULL;
    cn = (Cmdnam) zcalloc(sizeof *cn);
    cn->flags = EXCMD;
    cn->u.name = pp;
    addhnode(ztrdup(arg0), cn, cmdnamtab, freecmdnam);
    if (unset(HASHDIRS))
	return cn;
    for (pq = pathchecked; pq <= pp; pq++) {
	if (isrelative(*pq) || !(dir = opendir(*pq)))
	    continue;
	readdir(dir);
	readdir(dir);
	while ((de = readdir(dir)))
	    addhcmdnode(de->d_name, pq);
	closedir(dir);
    }
    pathchecked = pp + 1;
    return cn;
}

void fullhash()
{				/**/
    char **pq;
    DIR *dir;
    struct dirent *de;

    for (pq = pathchecked; *pq; pq++) {
	if (isrelative(*pq) || !(dir = opendir(*pq)))
	    continue;
	readdir(dir);
	readdir(dir);
	while ((de = readdir(dir)))
	    addhcmdnode(de->d_name, pq);
	closedir(dir);
    }
    pathchecked = pq;
}

void execlist(list)		/**/
List list;
{
    static int donetrap;

    if (breaks)
	return;
    if (!list || list == &dummy_list)
	return;
    donetrap = 0;
    simplifyright(list);
    switch (list->type) {
    case SYNC:
    case ASYNC:
	execlist2(list->left, list->type, !list->right);
	if (sigtrapped[SIGDEBUG])
	    dotrap(SIGDEBUG);
	if (sourcelevel < 32768 && !donetrap) {
	    if (sigtrapped[SIGZERR] && lastval) {
		dotrap(SIGZERR);
		donetrap = 1;
	    }
	    if (lastval && isset(ERREXIT)) {
		if (sigtrapped[SIGEXIT])
		    dotrap(SIGEXIT);
		exit(lastval);
	    }
	}
	if (list->right && !retflag) {
	/* errflag = 0; */
	    execlist(list->right);
	}
	break;
    }
}

void execlist2(list, type, last1)	/**/
Sublist list;
int type;
int last1;
{
    if (!list)
	return;
    switch (list->type) {
    case END:
	execpline(list, type, last1);
	break;
    case ORNEXT:
	if (!execpline(list, SYNC, 0))
	    execlist2(list->right, type, last1);
	else
	    while ((list = list->right))
		if (list->type == ANDNEXT) {
		    execlist2(list->right, type, last1);
		    return;
		}
	break;
    case ANDNEXT:
	if (execpline(list, SYNC, 0))
	    execlist2(list->right, type, last1);
	else
	    while ((list = list->right))
		if (list->type == ORNEXT) {
		    execlist2(list->right, type, last1);
		    return;
		}
	break;
    }
}

static int in_pipe;

int execpline(l, how, last1)	/**/
Sublist l;
int how;
int last1;
{
    int ipipe[2], opipe[2];

    if (!l)
	return 0;
    ipipe[0] = ipipe[1] = opipe[0] = opipe[1] = 0;
    if (in_pipe) {
	execpline2(l->left, how, opipe[0], ipipe[1], last1);
	return lastval;		/* if we're in a pipe don't change lastval; it'll be */
    }				/* done by the first instance of execpline */
    blockchld();
    if ((thisjob = getfreejob()) == -1)
	return 1;
    initjob();
    if (how == TIMED) {
	jobtab[thisjob].stat |= STAT_TIMED;
	how = SYNC;
    }
    if (l->flags & PFLAG_COPROC) {
	how = ASYNC;
	if (coprocin >= 0) {
	    close(coprocin);
	    close(coprocout);
	}
	mpipe(ipipe);
	mpipe(opipe);
	coprocin = ipipe[0];
	coprocout = opipe[1];
    }
    execpline2(l->left, how, opipe[0], ipipe[1], last1);
    if (how == ASYNC) {
	if (l->flags & PFLAG_COPROC)
	    close(ipipe[1]);
	spawnjob();
	unblockchld();
	return 1;
    } else {
	waitjobs();
	unblockchld();
	if (l->flags & PFLAG_NOT)
	    lastval = !lastval;
	return !lastval;
    }
}

void execpline2(pline, how, input, output, last1)	/**/
Pline pline;
int how;
int input;
int output;
int last1;
{
    int pid;
    int pipes[2];
    int oldlineno = lineno;

    if (breaks)
	return;
    if (!pline)
	return;
    lineno = pline->left->lineno;
    if (pline->type == END) {
	in_pipe = 0;
	execcmd(pline->left, input, output, how == ASYNC, last1);
	pline->left = NULL;
    } else {
	int old_pipe = in_pipe;

	in_pipe = 0;
	mpipe(pipes);
	if (pline->left->type >= CURSH && how == SYNC) {

	/* if we are doing "foo | bar" where foo is a current
				shell command, do foo in a subshell and do
				the rest of the pipeline in the current shell. */

	    int synch[2];

	    pipe(synch);
	    if (!(pid = fork())) {
		close(pipes[0]);
		close(synch[0]);
		entersubsh(how == ASYNC);
		close(synch[1]);
		exiting = 1;
		execcmd(pline->left, input, pipes[1], how == ASYNC, 0);
		_exit(lastval);
	    } else if (pid == -1) {
		close(synch[0]);
		close(synch[1]);
		zerr("fork failed: %e", NULL, errno);
	    } else {
		char dummy, *text = getjobtext((vptr) pline->left);

		addproc(pid, text);
		close(synch[1]);
		read(synch[0], &dummy, 1);
		close(synch[0]);
	    }
	} else {
	/* otherwise just do the pipeline normally. */
	    execcmd(pline->left, input, pipes[1], how == ASYNC, 0);
	}
	in_pipe = old_pipe;
	pline->left = NULL;
	close(pipes[1]);
	if (pline->right) {
	/* if another execpline() is invoked because the command is a list it
	   must know that we're already in a pipeline */
	    in_pipe = 1;
	    execpline2(pline->right, how, pipes[0], output, last1);
	    close(pipes[0]);
	}
    }

    lineno = oldlineno;
}

/* make the argv array */

char **makecline(list)		/**/
struct lklist *list;
{
    int ct = 0;
    Lknode node;
    char **argv, **ptr;

    if (isset(XTRACE)) {
	fprintf(stderr, "%s", (prompt4) ? prompt4 : "");
	for (node = firstnode(list); node; incnode(node), ct++);
	ptr = argv = 2 + (char **)ncalloc((ct + 4) * sizeof(char *));

	for (node = firstnode(list); node; incnode(node))
	    if (*(char *)getdata(node)) {
		*ptr++ = (char *)getdata(node);
		untokenize(getdata(node));
		fputs(getdata(node), stderr);
		if (nextnode(node))
		    fputc(' ', stderr);
	    }
	*ptr = NULL;
	fputc('\n', stderr);
	fflush(stderr);
	return (argv);
    } else {
	for (node = firstnode(list); node; incnode(node), ct++);
	ptr = argv = 2 + (char **)ncalloc((ct + 4) * sizeof(char *));

	for (node = firstnode(list); node; incnode(node))
	    if (*(char *)getdata(node)) {
		*ptr++ = (char *)getdata(node);
		untokenize(getdata(node));
	    }
	*ptr = NULL;
	return (argv);
    }
}

/* untokenize the command line and remove null arguments */

void fixcline(l)		/**/
Lklist l;
{
    Lknode node, next;

    for (node = firstnode(l); node; node = next) {
	next = nextnode(node);
	if (!*(char *)getdata(node))
	    uremnode(l, node);
	else
	    untokenize(getdata(node));
    }
}

void untokenize(s)		/**/
char *s;
{
    for (; *s; s++)
	if (itok(*s))
	    if (*s == Nularg)
		chuck(s--);
	    else
		*s = ztokens[*s - Pound];
}

/* nonzero if we shouldn't clobber a file */

int dontclob(f)			/**/
struct redir *f;
{
    struct stat buf;

    if (unset(NOCLOBBER) || f->type & 1)
	return 0;
    if (stat(f->name, &buf) == -1)
	return 1;
    return S_ISREG(buf.st_mode);
}

/* close an multio (success) */

void closemn(mfds, fd)		/**/
struct multio **mfds;
int fd;
{
    if (mfds[fd]) {
	if (mfds[fd]->ct > 1)
	    if (mfds[fd]->rflag == 0)
		catproc(mfds[fd]);
	    else
		teeproc(mfds[fd]);
	mfds[fd] = NULL;
    }
}

/* close all the mnodes (failure) */

void closemnodes(mfds)		/**/
struct multio **mfds;
{
    int t0, t1;

    for (t0 = 0; t0 != 10; t0++)
	if (mfds[t0]) {
	    for (t1 = 0; t1 != mfds[t0]->ct; t1++)
		close(mfds[t0]->fds[t1]);
	    mfds[t0] = NULL;
	}
}

/* add a fd to an multio */
/* an multio is a list of fds associated with a certain fd.
	thus if you do "foo >bar >ble", the multio for fd 1 will have
	two fds, the result of open("bar",...), and the result of
	open("ble",....). */

void addfd(forked, save, mfds, fd1, fd2, rflag)	/**/
int forked;
int *save;
struct multio **mfds;
int fd1;
int fd2;
int rflag;
{
    int pipes[2];

    if (!mfds[fd1]) {		/* starting a new multio */
	mfds[fd1] = (struct multio *)alloc(sizeof(struct multio));

	if (!forked && fd1 != fd2 && fd1 < 10)
	    save[fd1] = movefd(fd1);
	redup(fd2, fd1);
	mfds[fd1]->ct = 1;
	mfds[fd1]->fds[0] = fd1;
	mfds[fd1]->rflag = rflag;
    } else {
	if (mfds[fd1]->rflag != rflag) {
	    zerr("file mode mismatch on fd %d", NULL, fd1);
	    return;
	}
	if (mfds[fd1]->ct == 1) {	/* split the stream */
	    mfds[fd1]->fds[0] = movefd(fd1);
	    mfds[fd1]->fds[1] = movefd(fd2);
	    mpipe(pipes);
	    mfds[fd1]->pipe = pipes[1 - rflag];
	    redup(pipes[rflag], fd1);
	    mfds[fd1]->ct = 2;
	} else			/* add another fd to an already split stream */
	    mfds[fd1]->fds[mfds[fd1]->ct++] = movefd(fd2);
    }
}

void addvars(l, export)		/**/
Lklist l;
int export;
{
    struct varasg *v;
    Lklist vl;

    while (full(l)) {
	char **arr, **ptr;

	v = (struct varasg *)ugetnode(l);
	singsub(&v->name);
	if (errflag)
	    return;
	untokenize(v->name);
	if (v->type == PMFLAG_s) {
	    vl = newlist();
	    addnode(vl, v->str);
	} else
	    vl = v->arr;
	prefork(vl, v->type ? 3 : 013);
	if (errflag)
	    return;
	postfork(vl, v->type ? 1 : 011);
	if (errflag)
	    return;
	if (v->type == PMFLAG_s && (empty(vl) || !nextnode(firstnode(vl)))) {
	    Param pm;
	    char *val;

	    if (empty(vl))
		val = ztrdup("");
	    else {
		untokenize(peekfirst(vl));
		val = ztrdup(ugetnode(vl));
	    }
	    pm = setsparam(v->name, ztrdup(val));
	    if (errflag)
		return;
	    if (export && !(pm->flags & PMFLAG_x))
		addenv(v->name, val);
	    zsfree(val);
	    continue;
	}
	ptr = arr = (char **)zalloc(sizeof(char **) * (countnodes(vl) + 1));

	while (full(vl)) {
	    char *pp;

	    pp = (char *)ugetnode(vl);
	    if (*pp) {
		*ptr = ztrdup(pp);
		untokenize(*ptr++);
	    }
	}
	*ptr = NULL;
	setaparam(v->name, arr);
	if (errflag)
	    return;
    }
}

void execcmd(cmd, input, output, bkg, last1)	/**/
Cmd cmd;
int input;
int output;
int bkg;
int last1;
{
    int type;
    long pid;
    int save[10], t0;
    struct redir *fn;
    struct multio *mfds[10];
    int fil, forked = 0, iscursh, nullexec = 0, assign = 0;
    char *text, dummy;
    Cmdnam cn1 = NULL;

    args = cmd->args;
    for (t0 = 0; t0 != 10; t0++) {
	save[t0] = -1;
	mfds[t0] = NULL;
    }
    if ((type = cmd->type) == SIMPLE && empty(args))
	if (full(cmd->redir))
	    if (cmd->flags & CFLAG_EXEC) {
		nullexec = 1;
	    } else if (!*nullcmd) {
		zerr("redirection with no command", NULL, 0);
		errflag = lastval = 1;
		return;
	    } else if (*readnullcmd &&
		       ((Redir) peekfirst(cmd->redir))->type == READ &&
		       !nextnode(firstnode(cmd->redir))) {
		addnode(args, dupstring(readnullcmd));
	    } else
		addnode(args, dupstring(nullcmd));
	else {
	    addvars(cmd->vars, 0);
	    if (errflag)
		lastval = 1;
	    return;
	}
    if (full(args) && *(char *)peekfirst(args) == '%') {
	insnode(args, (Lknode) args, dupstring((bkg) ? "bg" : "fg"));
	bkg = 0;
    }
    if (isset(AUTORESUME) && !bkg && empty(cmd->redir) && full(args) &&
	!input && type == SIMPLE && !nextnode(firstnode(args))) {
	if (unset(NOTIFY))
	    scanjobs();
	if (findjobnam(peekfirst(args)) != -1)
	    pushnode(args, dupstring("fg"));
    }
    if (jobbing) {		/* get the text associated with this command */
	text = getjobtext((vptr) cmd);
    } else
	text = NULL;
    if (full(args) && !(cmd->flags & CFLAG_COMMAND) && type == SIMPLE) {
	char *cmdarg = (char *)peekfirst(args);
	Cmdnam cn2 = NULL;
	int builtin = 0;

	if (!strcmp(cmdarg, "builtin") && args->first->next &&
	    (cn2 = (Cmdnam) gethnode(cmdarg, cmdnamtab)) &&
	    (cn2->flags & BUILTIN) &&
	    !(cn2->flags & EXCMD)) {
	    builtin = 1;
	    cmdarg = (char *)args->first->next->dat;
	}
	cn1 = (Cmdnam) gethnode(cmdarg, cmdnamtab);
	if (cn1 && (cn1->flags & BUILTIN) && !(cn1->flags & EXCMD))
	    assign = istypeset(cn1, NULL);
	else if (builtin)
	    assign = istypeset(NULL, cmdarg);
	if (builtin)
	    cn1 = cn2;
    }
 /* do prefork substitutions */
    prefork(args, (((type == CCASE) ? 010 : 0)
		   | (assign ? 02 : isset(MAGICEQUALSUBST))));

 /* warn about "rm *" */
    if (unset(RMSTARSILENT) && interact && isset(SHINSTDIN) &&
	type == SIMPLE && full(args) && nextnode(firstnode(args)) &&
	!strcmp(peekfirst(args), "rm") &&
	!(cmd->flags & CFLAG_NOGLOB)) {
	Lknode node, next;

	for (node = nextnode(firstnode(args)); node && !errflag; node = next) {
	    char *s = (char *)getdata(node);
	    int l = strlen(s);

	    next = nextnode(node);
	    if (s[0] == Star && !s[1]) {
		if (!checkrmall(pwd))
		    uremnode(args, node);
	    } else if (l > 2 && s[l - 2] == '/' && s[l - 1] == Star) {
		char t = s[l - 2];

		s[l - 2] = 0;
		if (!checkrmall(s))
		    uremnode(args, node);
		s[l - 2] = t;
	    }
	}
	if (!nextnode(firstnode(args)))
	    errflag = 1;
    }
    if (errflag) {
	lastval = 1;
	return;
    }
    if (!cn1) {
	char *s, *t;

	if (full(args) && ((char *)peekfirst(args))[0] == Inbrack &&
	    ((char *)peekfirst(args))[1] == '\0')
	    ((char *)peekfirst(args))[0] = '[';
	if (type == SIMPLE && full(args) && !(cmd->flags & CFLAG_COMMAND)) {
	    cn1 = (Cmdnam) gethnode(t = s = (char *)peekfirst(args), cmdnamtab);
	    if (!cn1 && isset(HASHCMDS) && strcmp(t, "..")) {
		while (*t && *t != '/')
		    t++;
		if (!*t)
		    cn1 = hashcmd(s, pathchecked);
	    }
	}
	if (type == SIMPLE && !cn1 && isset(AUTOCD) && isset(SHINSTDIN) &&
	    full(args) && empty(cmd->redir) &&
	    !nextnode(firstnode(args)) && (s = cancd(peekfirst(args)))) {
	    peekfirst(args) = (vptr) s;
	    pushnode(args, dupstring("cd"));
	    cn1 = (Cmdnam) gethnode("cd", cmdnamtab);
	}
    }
/* this is nonzero if cmd is a current shell procedure */

    iscursh = (type >= CURSH) || (type == SIMPLE && cn1 &&
				  (cn1->flags & (BUILTIN | SHFUNC)) &&
				  !(cn1->flags & EXCMD));

/* if this command is backgrounded or (this is an external
		command and we are not exec'ing it) or this is a builtin
		with output piped somewhere, then fork.  If this is the
		last stage in a subshell pipeline, don't fork, but make
		the rest of the function think we forked. */

    if (bkg || !(iscursh || (cmd->flags & CFLAG_EXEC)) ||
	(cn1 && (cn1->flags & (BUILTIN | SHFUNC)) &&
	 !(cn1->flags & EXCMD) && output)) {
	int synch[2];

	blockchld();
	pipe(synch);
	pid = (last1 && execok())? 0 : phork();
	if (pid == -1) {
	    close(synch[0]);
	    close(synch[1]);
	    return;
	}
	if (pid) {
	    close(synch[1]);
	    read(synch[0], &dummy, 1);
	    close(synch[0]);
	    if (pid == -1)
		zerr("%e", NULL, errno);
	    else {
		if (bkg)
		    lastpid = pid;
		else if (!jobtab[thisjob].stty_in_env && full(cmd->vars))
		    while (full(cmd->vars))	/* search for STTY=... */
			if (!strcmp(((Varasg) ugetnode(cmd->vars))->name,
				    "STTY")) {
			    jobtab[thisjob].stty_in_env = 1;
			    break;
			}
		addproc(pid, text);
	    }
	    return;
	}
	close(synch[0]);
	entersubsh(bkg);
	close(synch[1]);
	forked = 1;

	if (sigtrapped[SIGINT] == 2)
	    holdintr();
    } else if ((cmd->flags & CFLAG_EXEC) && !nullexec)
	entersubsh(bkg);

    if (bkg && isset(BGNICE))
	nice(5);

/* perform postfork substitutions */
    postfork(args, !(cmd->flags & CFLAG_NOGLOB));
    if (errflag) {
	lastval = 1;
	goto err;
    } else {
	char *s;

	while (full(args) && (s = (char *)peekfirst(args)) && !*s)
	    ugetnode(args);
    }

    if (input)			/* add pipeline input/output to mnodes */
	addfd(forked, save, mfds, 0, input, 0);
    if (output)
	addfd(forked, save, mfds, 1, output, 1);
    spawnpipes(cmd->redir);	/* do process substitutions */
    while (full(cmd->redir))
	if ((fn = (struct redir *)ugetnode(cmd->redir))->type == INPIPE) {
	    if (fn->fd2 == -1) {
		fixfds(save);
		execerr();
	    }
	    addfd(forked, save, mfds, fn->fd1, fn->fd2, 0);
	} else if (fn->type == OUTPIPE) {
	    if (fn->fd2 == -1) {
		fixfds(save);
		execerr();
	    }
	    addfd(forked, save, mfds, fn->fd1, fn->fd2, 1);
	} else {
	    if (!(fn->type == HERESTR || fn->type == CLOSE || fn->type ==
		  MERGE || fn->type == MERGEOUT))
		if (xpandredir(fn, cmd->redir))
		    continue;
	    if (errflag) {
		fixfds(save);
		execerr();
	    }
	    if (fn->type == HERESTR) {
		fil = getherestr(fn);
		if (fil == -1) {
		    fixfds(save);
		    if (errno != EINTR)
			zerr("%e", NULL, errno);
		    execerr();
		}
		addfd(forked, save, mfds, fn->fd1, fil, 0);
	    } else if (fn->type == READ) {
		fil = open(fn->name, O_RDONLY);
		if (fil == -1) {
		    fixfds(save);
		    if (errno != EINTR)
			zerr("%e: %s", fn->name, errno);
		    execerr();
		}
		addfd(forked, save, mfds, fn->fd1, fil, 0);
	    } else if (fn->type == CLOSE) {
		if (!forked && fn->fd1 < 10)
		    save[fn->fd1] = movefd(fn->fd1);
		closemn(mfds, fn->fd1);
		close(fn->fd1);
	    } else if (fn->type == MERGE || fn->type == MERGEOUT) {
		if (fn->fd2 == FD_COPROC)
		    fn->fd2 = (fn->type == MERGEOUT) ? coprocout : coprocin;
		closemn(mfds, fn->fd1);
		fil = dup(fn->fd2);
		if (fil == -1) {
		    char fdstr[4];

		    fixfds(save);
		    sprintf(fdstr, "%d", fn->fd2);
		    zerr("%s: %e", fdstr, errno);
		    execerr();
		}
		addfd(forked, save, mfds, fn->fd1, fil, fn->type == MERGEOUT);
	    } else {
		if (fn->type >= APP)
		    fil = open(fn->name,
			       (isset(NOCLOBBER) && !(fn->type & 1)) ?
			       O_WRONLY | O_APPEND : O_WRONLY | O_APPEND | O_CREAT, 0666);
		else
		    fil = open(fn->name, dontclob(fn) ?
			       O_WRONLY | O_CREAT | O_EXCL : O_WRONLY | O_CREAT | O_TRUNC, 0666);
		if (fil == -1) {
		    fixfds(save);
		    if (errno != EINTR)
			zerr("%e: %s", fn->name, errno);
		    execerr();
		}
		addfd(forked, save, mfds, fn->fd1, fil, 1);
	    }
	}

/* we are done with redirection.  close the mnodes, spawning
		tee/cat processes as necessary. */
    for (t0 = 0; t0 != 10; t0++)
	closemn(mfds, t0);

    if (nullexec) {
	for (t0 = 0; t0 != 10; t0++)
	    if (save[t0] != -1)
		close(save[t0]);
	return;
    }
    if (unset(NOEXEC))
	if (type >= CURSH) {
	    static int (*func[]) DCLPROTO((Cmd)) =
	    {
		execcursh, exectime, execfuncdef, execfor, execwhile,
		execrepeat, execif, execcase, execselect, execcond};

	    fixcline(args);
	    lastval = (func[type - CURSH]) (cmd);
	} else if (iscursh) {	/* builtin or shell function */
	    if (!cn1) {
		lastval = 1;
		return;
	    }
	    if (cmd->vars) {
		addvars(cmd->vars, 0);
		if (errflag) {
		    lastval = 1;
		    return;
		}
	    }
	    fixcline(args);
	    if (cn1->flags & SHFUNC)
		execshfunc(cmd, cn1);
	    else {
		if (forked)
		    closem();
		lastval = execbin(args, cn1);
		if (isset(PRINTEXITVALUE) && isset(SHINSTDIN) &&
		    lastval && !subsh) {
		    fprintf(stderr, "zsh: exit %ld\n", (long)lastval);
		}
		fflush(stdout);
		if (save[1] == -1) {
		    if (ferror(stdout)) {
			zerr("write error: %e", NULL, errno);
			clearerr(stdout);
			errflag = 0;
		    }
		} else
		    clearerr(stdout);
	    }
	} else {
	    if (cmd->flags & CFLAG_EXEC)
		setiparam("SHLVL", --shlvl);
	    if (cmd->vars) {
		addvars(cmd->vars, 1);
		if (errflag) {
		    lastval = 1;
		    return;
		}
	    }
	    if (type == SIMPLE) {
		closem();
		execute(cmd->flags & CFLAG_DASH);
	    } else		/* ( ... ) */
		execlist(cmd->u.list);
	}
  err:
    if (forked)
	_exit(lastval);
    fixfds(save);
}

/* restore fds after redirecting a builtin */

void fixfds(save)		/**/
int *save;
{
    int old_errno = errno;
    int t0;

    for (t0 = 0; t0 != 10; t0++)
	if (save[t0] != -1)
	    redup(save[t0], t0);
    errno = old_errno;
}

void entersubsh(bkg)		/**/
int bkg;
{
    if (!jobbing) {
	if (bkg) {
	    sigtrapped[SIGINT] = 2;
	    sig_ignore(SIGINT);
	    sigtrapped[SIGQUIT] = 2;
	    sig_ignore(SIGQUIT);
	    if (isatty(0)) {
		close(0);
		if (open("/dev/null", O_RDWR)) {
		    zerr("can't open /dev/null: %e", NULL, errno);
		    _exit(1);
		}
	    }
	}
    } else if (thisjob != -1) {
	if (!jobtab[thisjob].gleader) {
	    jobtab[thisjob].gleader = getpid();
	    setpgrp(0L, jobtab[thisjob].gleader);
	    if (!bkg)
		attachtty(jobtab[thisjob].gleader);
	} else
	    setpgrp(0L, jobtab[thisjob].gleader);
    }
    subsh = 1;
    if (SHTTY != -1) {
	close(SHTTY);
	SHTTY = -1;
    }
    if (jobbing) {
	sig_default(SIGTTOU);
	sig_default(SIGTTIN);
	sig_default(SIGTSTP);
	sig_default(SIGPIPE);
    }
    if (interact) {
	sig_default(SIGTERM);
	if (sigtrapped[SIGINT] != 2)
	    sig_default(SIGINT);
    }
    if (sigtrapped[SIGQUIT] != 2)
	sig_default(SIGQUIT);
    opts[MONITOR] = OPT_UNSET;
    opts[USEZLE] = OPT_UNSET;
    clearjobtab();
}

/* close all internal shell fds */

void closem()
{				/**/
    int t0;

    for (t0 = 10; t0 != NOFILE; t0++)
	close(t0);
}

/* convert here document into a here string */

char *gethere(str, typ)		/**/
char *str;
int typ;
{
    char pbuf[256];
    int qt = 0, siz = 0, l, strip = 0;
    char *s, *t, *bptr;

    for (s = str; *s; s++)
	if (INULL(*s)) {
	    *s = Nularg;
	    qt = 1;
	}
    untokenize(str);
    if (typ == HEREDOCDASH) {
	strip = 1;
	while (*str == '\t')
	    str++;
    }
    t = ztrdup("");
    for (;;) {
	char *u, *v;

	if (!hgets(pbuf, sizeof(pbuf)))
	    break;
	bptr = pbuf;
	if (strip)
	    while (*bptr == '\t')
		bptr++;
	for (u = bptr, v = str; *u != '\n' && *v; u++, v++)
	    if (*u != *v)
		break;
	if (!(*u == '\n' && !*v)) {
	    l = strlen(bptr);
	    if (!qt && l > 1 && bptr[l - 1] == '\n' && bptr[l - 2] == '\\')
		bptr[l -= 2] = '\0';
	    t = realloc(t, siz + l + 1);
	    strncpy(t + siz, bptr, l);
	    siz += l;
	} else
	    break;
    }
    t[siz] = '\0';
    if (siz && t[siz - 1] == '\n')
	t[siz - 1] = '\0';
    if (!qt)
	for (s = t; *s; s++)
	    if (*s == '$') {
		*s = Qstring;
	    } else if (*s == '`') {
		*s = Qtick;
	    } else if (*s == '(') {
		*s = Inpar;
	    } else if (*s == ')') {
		*s = Outpar;
	    } else if (*s == '\\' &&
		       (s[1] == '$' || s[1] == '`'))
		chuck(s);
    s = dupstring(t);
    zsfree(t);
    return s;
}

/* open here string fd */

int getherestr(fn)		/**/
struct redir *fn;
{
    Lklist fake;
    char *s = gettemp(), *t;
    int fd;

    fake = newlist();
    addnode(fake, fn->name);
    prefork(fake, 010);
    if (!errflag)
	postfork(fake, 011);
    if (errflag)
	return -1;
    if ((fd = open(s, O_CREAT | O_WRONLY, 0600)) == -1)
	return -1;
    while ((t = (char *)ugetnode(fake))) {
	untokenize(t);
	write(fd, t, strlen(t));
	if (full(fake))
	    write(fd, " ", 1);
    }
    write(fd, "\n", 1);
    close(fd);
    fd = open(s, O_RDONLY);
    unlink(s);
    return fd;
}

void catproc(mn)		/**/
struct multio *mn;
{
    int len, t0;
    char *buf;

    if (phork()) {
	for (t0 = 0; t0 != mn->ct; t0++)
	    close(mn->fds[t0]);
	close(mn->pipe);
	return;
    }
    closeallelse(mn);
    buf = (char *)zalloc(4092);
    for (t0 = 0; t0 != mn->ct; t0++)
	while ((len = read(mn->fds[t0], buf, 4092)))
	    write(mn->pipe, buf, len);
    _exit(0);
}

void teeproc(mn)		/**/
struct multio *mn;
{
    int len, t0;
    char *buf;

    if (phork()) {
	for (t0 = 0; t0 != mn->ct; t0++)
	    close(mn->fds[t0]);
	close(mn->pipe);
	return;
    }
    buf = (char *)zalloc(4092);
    closeallelse(mn);
    while ((len = read(mn->pipe, buf, 4092)) > 0)
	for (t0 = 0; t0 != mn->ct; t0++)
	    write(mn->fds[t0], buf, len);
    _exit(0);
}

void closeallelse(mn)		/**/
struct multio *mn;
{
    int t0, t1;

    for (t0 = 0; t0 != NOFILE; t0++)
	if (mn->pipe != t0) {
	    for (t1 = 0; t1 != mn->ct; t1++)
		if (mn->fds[t1] == t0)
		    break;
	    if (t1 == mn->ct)
		close(t0);
	}
}

long int zstrtol(s, t, base)	/**/
char *s;
char **t;
int base;
{
    int ret = 0;

    if (base <= 10)
	for (; *s >= '0' && *s < ('0' + base); s++)
	    ret = ret * base + *s - '0';
    else
	for (; idigit(*s) || (*s >= 'a' && *s < ('a' + base - 10))
	     || (*s >= 'A' && *s < ('A' + base - 10)); s++)
	    ret = ret * base + (idigit(*s) ? (*s - '0') : (*s & 0x1f) + 9);
    if (t)
	*t = (char *)s;
    return ret;
}

/* $(...) */

Lklist getoutput(cmd, qt)	/**/
char *cmd;
int qt;
{
    List list;
    int pipes[2];
    int pid;

    if (*cmd == '<') {
	int stream;
	char *fi, *s, x;

	for (cmd++; *cmd == ' '; cmd++);
	for (s = cmd; *s && *s != ' '; s++)
	    if (*s == '\\')
		s++;
	    else if (*s == '$')
		*s = String;
	x = *s;
	*s = '\0';
	fi = dupstring(cmd);
	*s = x;
	if (*fi == '~')
	    *fi = Tilde;
	else if (*fi == '=')
	    *fi = Equals;
	singsub(&fi);
	if (errflag)
	    return NULL;
	stream = open(fi, O_RDONLY);
	if (stream == -1) {
	    zerr("%e: %s", fi, errno);
	    return NULL;
	}
	return readoutput(stream, qt);
    }
    if (!(list = parselstring(cmd)))
	return NULL;
    mpipe(pipes);
    blockchld();
    if ((cmdoutpid = pid = phork()) > 0) {
	Lklist retval;

	popheap();
	close(pipes[1]);
	retval = readoutput(pipes[0], qt);
	chldsuspend(0);		/* unblocks */
	lastval = cmdoutval;
	cmdoutval = 0;
	return retval;
    } else if (pid == -1) {
	popheap();
	close(pipes[0]);
	close(pipes[1]);
	errflag = 1;
	cmdoutpid = 0;
	unblockchld();
	return NULL;
    }
    unblockchld();
    subsh = 1;
    close(pipes[0]);
    redup(pipes[1], 1);
    entersubsh(0);
    sig_ignore(SIGTSTP);
    exiting = 1;
    execlist(list);
    close(1);
    _exit(lastval);
    zerr("exit returned in child!!", NULL, 0);
    kill(getpid(), SIGKILL);
    return NULL;		/* redundant but shuts up Convex cc */
}

/* read output of command substitution */

Lklist readoutput(in, qt)	/**/
int in;
int qt;
{
    Lklist ret;
    char *buf, *ptr;
    int bsiz, c, cnt = 0;
    FILE *fin;

    fin = fdopen(in, "r");
    ret = newlist();
    ptr = buf = (char *)ncalloc(bsiz = 64);
    if (qt) {
	*ptr++ = Nularg;
	cnt++;
    }
    while ((c = fgetc(fin)) != EOF)
	if (!qt && isep(c)) {
	    if (cnt) {
		*ptr = '\0';
		if (isset(GLOBSUBST))
		    tokenize(buf);
		addnode(ret, buf);
		ptr = buf = (char *)ncalloc(bsiz = 64);
		cnt = 0;
	    }
	} else {
	    *ptr++ = c;
	    if (++cnt == bsiz) {
		char *pp = (char *)ncalloc(bsiz *= 2);

		memcpy(pp, buf, cnt);
		ptr = (buf = pp) + cnt;
	    }
	}
    if (ptr != buf && ptr[-1] == '\n')
	ptr[-1] = '\0';
    else
	*ptr = '\0';
    if (!qt && isset(GLOBSUBST))
	tokenize(buf);
    if (cnt)
	addnode(ret, buf);
    fclose(fin);
    return ret;
}

/* =(...) */

char *getoutputfile(cmd)	/**/
char *cmd;
{
    int pid;
    char *nam = gettemp(), *str;
    List list;

    if (thisjob == -1)
	return NULL;
    for (str = cmd; *str && *str != Outpar; str++);
    if (!*str)
	zerr("oops.", NULL, 0);
    *str = '\0';
    if (!(list = parselstring(cmd)))
	return NULL;
    permalloc();
    if (!jobtab[thisjob].filelist)
	jobtab[thisjob].filelist = newlist();
    addnode(jobtab[thisjob].filelist, ztrdup(nam));
    heapalloc();
    blockchld();
    if ((pid = cmdoutpid = phork())) {
	popheap();
	if (pid < 0)
	    unblockchld();
	else {
	    int os = jobtab[thisjob].stat;

	    waitforpid(pid);
	    cmdoutval = 0;
	    jobtab[thisjob].stat = os;
	}
	return nam;
    }
    subsh = 1;
    close(1);
    entersubsh(0);
    (void)creat(nam, 0666);
    exiting = 1;
    execlist(list);
    close(1);
    _exit(lastval);
    zerr("exit returned in child!!", NULL, 0);
    kill(getpid(), SIGKILL);
    return NULL;		/* redundant but shuts up Convex cc */
}

/* get a temporary named pipe */

char *namedpipe()
{				/**/
#ifdef HAS_FIFOS
    char *tnam = gettemp();

    if (mknod(tnam, 0010666, 0) < 0)
	return NULL;
    return tnam;
#else
         return NULL;
#endif
}

/* <(...) */

char *getoutproc(cmd)		/**/
char *cmd;
{
#ifndef HAS_FIFOS
    zerr("doesn't look like your system supports FIFOs.", NULL, 0);
    return NULL;
#else
    List list;
    int fd;
    char *pnam, *str;

    if (thisjob == -1)
	return NULL;
    for (str = cmd; *str && *str != Outpar; str++);
    if (!*str)
	zerr("oops.", NULL, 0);
    *str = '\0';
    pnam = namedpipe();
    if (!pnam)
	return NULL;
    permalloc();
    if (!jobtab[thisjob].filelist)
	jobtab[thisjob].filelist = newlist();
    addnode(jobtab[thisjob].filelist, ztrdup(pnam));
    heapalloc();
    if (!(list = parselstring(cmd)))
	return NULL;
    if (phork()) {
	popheap();
	return pnam;
    }
    entersubsh(1);
    closem();
    fd = open(pnam, O_WRONLY);
    if (fd == -1) {
	zerr("can't open %s: %e", pnam, errno);
	_exit(1);
    }
    redup(fd, 1);
    fd = open("/dev/null", O_RDONLY);
    redup(fd, 0);
    exiting = 1;
    execlist(list);
    close(1);
    _exit(lastval);
    return NULL;
#endif
}

/* >(...) */

char *getinproc(cmd)		/**/
char *cmd;
{
#ifndef HAS_FIFOS
    zerr("doesn't look like your system supports FIFOs.", NULL, 0);
    return NULL;
#else
    List list;
    int pid, fd;
    char *pnam, *str;

    if (thisjob == -1)
	return NULL;
    for (str = cmd; *str && *str != Outpar; str++);
    if (!*str)
	zerr("oops.", NULL, 0);
    *str = '\0';
    pnam = namedpipe();
    if (!pnam)
	return NULL;
    permalloc();
    if (!jobtab[thisjob].filelist)
	jobtab[thisjob].filelist = newlist();
    addnode(jobtab[thisjob].filelist, ztrdup(pnam));
    heapalloc();
    if (!(list = parselstring(cmd)))
	return NULL;
    if ((pid = phork())) {
	popheap();
	return pnam;
    }
    entersubsh(1);
    closem();
    fd = open(pnam, O_RDONLY);
    redup(fd, 0);
    exiting = 1;
    execlist(list);
    _exit(lastval);
    return NULL;
#endif
}

/* > >(...) (does not use named pipes) */

int getinpipe(cmd)		/**/
char *cmd;
{
    List list;
    int pipes[2];
    char *str;

    for (str = cmd; *str && *str != Outpar; str++);
    if (!*str)
	zerr("oops.", NULL, 0);
    *str = '\0';
    if (!(list = parselstring(cmd + 2)))
	return -1;
    mpipe(pipes);
    if (phork()) {
	popheap();
	close(pipes[1]);
	return pipes[0];
    }
    close(pipes[0]);
    closem();
    entersubsh(1);
    redup(pipes[1], 1);
    exiting = 1;
    execlist(list);
    _exit(lastval);
    return 0;
}

/* < <(...) */

int getoutpipe(cmd)		/**/
char *cmd;
{
    List list;
    int pipes[2];
    char *str;

    for (str = cmd; *str && *str != Outpar; str++);
    if (!*str)
	zerr("oops.", NULL, 0);
    *str = '\0';
    if (!(list = parselstring(cmd + 2)))
	return -1;
    strinend();
    mpipe(pipes);
    if (phork()) {
	popheap();
	close(pipes[0]);
	return pipes[1];
    }
    close(pipes[1]);
    entersubsh(1);
    redup(pipes[0], 0);
    closem();
    exiting = 1;
    execlist(list);
    _exit(lastval);
    return 0;
}

/* run a list, saving the current job num */

void runlist(l)			/**/
List l;
{
    int cj = thisjob;

    execlist(l);
    thisjob = cj;
}

char *gettemp()
{				/**/
    return mktemp(dyncat((tmpprefix ? tmpprefix : DEFTMPPREFIX), "XXXXXX"));
}

/* my getwd */

char *zgetwd()
{				/**/
    static char buf0[MAXPATHLEN];
    char buf3[MAXPATHLEN];

#ifdef apollo
    char *buf2 = buf0 + 2;	/* changed +1 to +2  RBC 17.11.91 */

#else
    char *buf2 = buf0 + 1;

#endif
    struct stat sbuf;
    struct dirent *de;
    DIR *dir;
    ino_t ino, rootino = (ino_t) ~ 0;
    dev_t dev, rootdev = (dev_t) ~ 0;

    holdintr();
    buf2[0] = '\0';
    buf0[0] = '/';
#ifdef apollo
    buf0[1] = '/';		/* added RBC 17.11.91 */
#endif
    if (stat(buf0, &sbuf) >= 0) {
	rootino = sbuf.st_ino;
	rootdev = sbuf.st_dev;
    }
    for (;;) {
	if (stat(".", &sbuf) < 0) {
	    chdir(buf0);
	    noholdintr();
	    return ztrdup(".");
	}
	ino = sbuf.st_ino;
	dev = sbuf.st_dev;
	if (stat("..", &sbuf) < 0) {
	    chdir(buf0);
	    noholdintr();
	    return ztrdup(".");
	}
	if ((sbuf.st_ino == ino && sbuf.st_dev == dev) ||
	    (ino == rootino && dev == rootdev)) {
	    chdir(buf0);
	    noholdintr();
	    return ztrdup(buf0);
	}
	dir = opendir("..");
	if (!dir) {
	    chdir(buf0);
	    noholdintr();
	    return ztrdup(".");
	}
	chdir("..");
	readdir(dir);
	readdir(dir);
	while ((de = readdir(dir)))
	    if (de->d_ino == ino) {
		lstat(de->d_name, &sbuf);
		if (sbuf.st_dev == dev)
		    goto match;
	    }
	closedir(dir);
	dir = opendir(".");
	readdir(dir);
	readdir(dir);
	while ((de = readdir(dir))) {
	    lstat(de->d_name, &sbuf);
	    if (sbuf.st_dev == dev)
		goto match;
	}
	noholdintr();
	closedir(dir);
	return ztrdup(".");
      match:
	strcpy(buf3, de->d_name);
	if (*buf2)
	    strcat(buf3, "/");
	strcat(buf3, buf2);
	strcpy(buf2, buf3);
	closedir(dir);
    }
}

/* open pipes with fds >= 10 */

void mpipe(pp)			/**/
int *pp;
{
    pipe(pp);
    pp[0] = movefd(pp[0]);
    pp[1] = movefd(pp[1]);
}

/* do process substitution with redirection */

void spawnpipes(l)		/**/
Lklist l;
{
    Lknode n = firstnode(l);
    Redir f;

    for (; n; incnode(n)) {
	f = (Redir) getdata(n);
	if (f->type == OUTPIPE) {
	    char *str = f->name;

	    f->fd2 = getoutpipe(str);
	}
	if (f->type == INPIPE) {
	    char *str = f->name;

	    f->fd2 = getinpipe(str);
	}
    }
}

/* perform time ... command */

int exectime(cmd)		/**/
Cmd cmd;
{
    int jb = thisjob;

    if (!cmd->u.pline) {
	shelltime();
	return 0;
    }
    execpline(cmd->u.pline, TIMED, 0);
    thisjob = jb;
    return lastval;
}

/* define a function */

int execfuncdef(cmd)		/**/
Cmd cmd;
{
    Cmdnam cc;
    char *s;

    permalloc();
    while ((s = (char *)ugetnode(cmd->args))) {
	cc = (Cmdnam) zalloc(sizeof *cc);
	cc->flags = SHFUNC;
	if (!cmd->u.list)
	    cc->u.list = NULL;
	else
	    cc->u.list = (List) dupstruct(cmd->u.list);
	addhnode(ztrdup(s), cc, cmdnamtab, freecmdnam);
	if (!strncmp(s, "TRAP", 4)) {
	    int t0 = getsignum(s + 4);

	    if (t0 != -1) {
		settrap(t0, cmd->u.list);
		permalloc();
	    }
	}
    }
    heapalloc();
    return 0;
}

/* evaluate a [[ ... ]] */

int execcond(cmd)		/**/
Cmd cmd;
{
    return !evalcond(cmd->u.cond);
}

void execshfunc(cmd, cn)	/**/
Cmd cmd;
Cmdnam cn;
{
    List l;

    if (errflag)
	return;
    if (!cn->u.list) {
	char *nam;

	if (!(cn->flags & PMFLAG_u))
	    return;
	if (!(l = getfpfunc(nam = (char *)peekfirst(cmd->args)))) {
	    zerr("function not found: %s", nam, 0);
	    lastval = 1;
	    return;
	}
	cn->flags &= ~PMFLAG_u;
	permalloc();
	cn->u.list = (List) dupstruct(l);
	heapalloc();
	popheap();
    }
    doshfunc(cn->u.list, cmd->args, cn->flags);
}

void doshfuncnoval(list, doshargs, flags)	/**/
List list;
Lklist doshargs;
int flags;
{
    int val = lastval;

    doshfunc(list, doshargs, flags);
    lastval = val;
}

/* structure for foo=bar assignments */
struct asgment {
    struct asgment *next;
    char *name, *value;
};

#include "builtin.pro"
#include "cond.pro"
#include "exec.pro"
#include "glob.pro"
#include "hist.pro"
#include "init.pro"
#include "jobs.pro"
#include "lex.pro"
#include "loop.pro"
#include "math.pro"
#include "mem.pro"
#include "params.pro"
#include "parse.pro"
#include "subst.pro"
#include "table.pro"
#include "text.pro"
#include "utils.pro"
#include "watch.pro"
#include "zle_hist.pro"
#include "zle_main.pro"
#include "zle_misc.pro"
#include "zle_move.pro"
#include "zle_refresh.pro"
#include "zle_tricky.pro"
#include "zle_utils.pro"
#include "zle_vi.pro"
#include "zle_word.pro"

char *mktemp DCLPROTO((char *));

#ifndef HAS_STDLIB
char *malloc DCLPROTO((int));
char *realloc DCLPROTO((char *, int));
char *calloc DCLPROTO((int, int));

#endif
char *ttyname DCLPROTO((int));

extern char PC, *BC, *UP;
extern short ospeed;
extern int tgetent DCLPROTO((char *bp, char *name));
extern int tgetnum DCLPROTO((char *id));
extern int tgetflag DCLPROTO((char *id));
extern char *tgetstr DCLPROTO((char *id, char **area));
extern char *tgoto DCLPROTO((char *cm, int destcol, int destline));
extern int tputs DCLPROTO((char *cp, int affcnt, int (*outc) (int)));

/* missing prototypes for various C compilers */

#if defined(SOLARIS)
#include <setjmp.h>
/* Solaris does not seem to have prototype for these under /usr/include */
extern char *getdomainname DCLPROTO((char *name, int namelen));
extern FILE *fdopen(int, const char *);
extern int kill(pid_t, int);
extern int sigaction(int, const struct sigaction *, struct sigaction *);
extern int sighold(int);
extern int sigrelse(int);
extern int sigpause(int);
extern int gettimeofday(struct timeval *tp, struct timezone *tzp);

#endif

#if defined(__convexc__)
/* ConvexOS does not seem to have prototypes for these under /usr/include */
extern int bzero(char *b, int length);
extern int gethostname(char *name, int namelen);
extern int getrlimit(int resource, struct rlimit *rlp);
extern int getrusage(int, struct rusage *);
extern int gettimeofday(struct timeval *tp, struct timezone *tzp);
extern int mknod(char *path, int mode, int dev);
extern int nice(int incr);
extern int readlink(char *path, char *buf, int bufsize);
extern int select(int nfds, fd_set * readfds, fd_set * writefds, fd_set * expectfds, struct timeval *timeout);
extern int setrlimit(int resource, struct rlimit *rlp);
extern int sigblock(int mask);
extern int sigpause(int sigmask);
extern int sigsetmask(int mask);
extern int sigvec(int sig, struct sigvec *vec, struct sigvec *ovec);
extern int wait3(int *status, int options, struct rusage *rusage);

#endif

/* HP/UX 9 c89 */
#if defined(__hpux) && defined(_XPG3) && !defined(_POSIX1_1988)
#define WRITE_ARG_2_T void *
#else
#define WRITE_ARG_2_T char *
#endif

#if defined(__hpux) && defined(_HPUX_SOURCE)
#define SELECT_ARG_2_T int *
#else
#define SELECT_ARG_2_T fd_set *
#endif

#if defined(__sgi)
#if defined(_POSIX_SOURCE)
/* cc -ansiposix pretends not to see these, maybe too BSDish? */
extern void setpwent(void);
extern void endpwent(void);
extern struct passwd *getpwent(void);

#endif
/* cc -ansi/-ansiposix pretends not to see these, maybe too BSDish/SYSVish? */
#if defined(__STDC__)
#ifdef IRIX5
#ifdef _POSIX_SOURCE
extern int BSDgettimeofday(struct timeval *tp, struct timezone *tzp);
extern int getrusage(int rwho, struct rusage *rusage);
extern int lstat(const char *path, struct stat *buf);
extern int readlink(const char *path, void *buf, size_t bufsiz);

#endif
extern int wait3(union wait *statptr, int options, struct rusage *rusage);

#else
extern int (*BSDsignal(int, int (*)())) ();
extern int kill(pid_t pid, int sig);
extern int readlink(const char *pathname, char *buf, int bufsiz);

#endif
extern void bzero(void *b, int length);
extern int gethostname(char *name, int namelen);
extern int ioctl(int fildes, int request,...);
extern int mknod(const char *pathname, mode_t mode, dev_t dev);
extern int nice(int incr);
extern void seekdir(DIR * dirp, long loc);
extern int select(int nfds, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval *timeout);
extern int sighold(int sig);
extern int sigrelse(int sig);
extern int sigpause(int sig);

#endif
#endif

#if defined(_CRAY) && defined(__STDC__)
extern FILE *fdopen(int fildes, char *type);

#include <setjmp.h>
typedef int sigjmp_buf[_SJBLEN];
extern int _Sigsetjmp __((sigjmp_buf _Env, int _Savemask));

#define sigsetjmp(_Env, _Savemask)  _Sigsetjmp(_Env, _Savemask)
extern void siglongjmp __((sigjmp_buf _Env, int _Val));

#endif

#if defined(__NeXT__)
#if defined(__STRICT_ANSI__)	/* -ansi does not see these */
#define bzero(b,len) memset(b,0,len)
extern FILE *fdopen(int filedes, const char *mode);

#endif
/* NeXT has almost everything in
 * /usr/include/bsd/libc.h == <libc.h>
 * (sort of <unistd.h>), except the following */
extern int getppid(void);

#endif

#if defined(__osf__) && defined(__alpha)
/* Digital cc does not need these prototypes, gcc does need them */
void bzero(char *string, int length);
int gethostname(char *address, int address_len);
int ioctl(int d, unsigned long request, char *argp);
int mknod(const char *pathname, int mode, dev_t device);
int nice(int increment);
int select(int nfds, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval *timeout);

#endif

#if defined(DGUX) && defined(__STDC__)
/* Just plain missing. */
extern int getrlimit(int resource, struct rlimit *rlp);
extern int setrlimit(int resource, const struct rlimit *rlp);
extern int getrusage(int who, struct rusage *rusage);
extern int gettimeofday(struct timeval *time_value,
			struct timezone *time_zone);
extern int wait3(union wait *wait_status, int options, struct rusage *rusage);
extern int gethostname(char *nameptr, int maxlength);
extern int getdomainname(char *name, int maxlength);
extern int bzero(char *ptr, int length);
extern int select(int nfds, fd_set * readfds, fd_set * writefds,
		  fd_set * exceptfds, struct timeval *timeout);

#endif

#if defined(SCO)
struct timezone {
    short minutes;
};
extern void gettimeofday(struct timeval *tv, struct timezone *tz);
extern int nice(int incr);
extern int mknod(char *path, int mode, int dev);
extern int ioctl(int fildes, int request,...);

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*
 *
 * glob.c - filename generation
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"

#include <errno.h>
#include <pwd.h>
#include <grp.h>

#define exists(X) (access(X,0) == 0 || readlink(X,NULL,0) == 0)

static int mode;		/* != 0 if we are parsing glob patterns */
static int pathpos;		/* position in pathbuf */
static int matchsz;		/* size of matchbuf */
static int matchct;		/* number of matches found */
static char pathbuf[MAXPATHLEN];/* pathname buffer */
static char **matchbuf;		/* array of matches */
static char **matchptr;		/* &matchbuf[matchct] */
static char *colonmod;		/* colon modifiers in qualifier list */
static ino_t old_ino;
static dev_t old_dev;
static int old_pos;

#ifdef ULTRIX
typedef struct stat *Statptr;	/* This makes the Ultrix compiler happy.  Go figure. */

#endif

#define TT_DAYS 0
#define TT_HOURS 1
#define TT_MINS 2
#define TT_WEEKS 3
#define TT_MONTHS 4

/* max # of qualifiers */

struct qual {
    struct qual *next, *or;
    int (*func) DCLPROTO((struct stat *, long));
    long data;
    int sense;
    int amc;
    int range;
    int timef;
};

static struct qual *quals;

static int qualct, qualorct;
static int range, amc, timef;
static int gf_nullglob, gf_markdirs, gf_noglobdots, gf_listtypes;

char *glob_pre, *glob_suf;

/* pathname component in filename patterns */

struct complist {
    Complist next;
    Comp comp;
    int closure;		/* 1 if this is a (foo/)# */
};
struct comp {
    Comp left, right, next, exclude;
    char *str;
    int stat;
};

#define C_ONEHASH	1
#define C_TWOHASH	2
#define C_CLOSURE	(C_ONEHASH|C_TWOHASH)
#define C_LAST		4
#define C_PATHADD	8

#define CLOSUREP(c)	(c->stat & C_CLOSURE)
#define ONEHASHP(c)	(c->stat & C_ONEHASH)
#define TWOHASHP(c)	(c->stat & C_TWOHASH)
#define LASTP(c)	(c->stat & C_LAST)
#define PATHADDP(c)	(c->stat & C_PATHADD)

void glob(list, np)		/**/
Lklist list;
Lknode *np;
{
    struct qual *qo, *qn, *ql;
    Lknode node = prevnode(*np);
    Lknode next = nextnode(*np);
    int luh = useheap;
    char *str;			/* the pattern */
    int sl;			/* length of the pattern */
    Complist q;			/* pattern after parsing */
    char *ostr = (char *)getdata(*np);	/* the pattern before the parser chops it up */

    heapalloc();
    str = dupstring(ostr);
    if (!luh)
	permalloc();
    sl = strlen(str);
    uremnode(list, *np);
    qo = qn = quals = ql = NULL;
    qualct = qualorct = 0;
    colonmod = NULL;
    gf_nullglob = isset(NULLGLOB);
    gf_markdirs = isset(MARKDIRS);
    gf_listtypes = 0;
    gf_noglobdots = unset(GLOBDOTS);
    if (str[sl - 1] == Outpar) {/* check for qualifiers */
	char *s;
	int sense = 0;
	long data = 0;

#ifdef ULTRIX
	int (*func) DCLPROTO((Statptr, long));

#else
	int (*func) DCLPROTO((struct stat *, long));

#endif

	for (s = str + sl - 2; s != str; s--)
	    if (*s == Bar || *s == Outpar || *s == Inpar
		|| (isset(EXTENDEDGLOB) && *s == Tilde))
		break;
	if (*s == Inpar) {
	    *s++ = '\0';
	    while (*s != Outpar && !colonmod) {
#ifdef ULTRIX
		func = (int (*)DCLPROTO((Statptr, long)))0;
#else
		func = (int (*)DCLPROTO((struct stat *, long)))0;
#endif
		if (idigit(*s)) {
		    func = qualflags;
		    data = 0;
		    while (idigit(*s))
			data = data * 010 + (*s++ - '0');
		} else if (*s == ',' || *s == Comma) {
		    s++;
		    if (qualct) {
			qn = (struct qual *)hcalloc(sizeof *qn);
			qo->or = qn;
			qo = qn;
			qualorct++;
			qualct = 0;
			ql = NULL;
		    }
		} else
		    switch ((int)(unsigned char)(*s++)) {
		    case ':':
			colonmod = s - 1;
			break;
		    case (int)STOUC(Hat):
		    case '^':
			sense ^= 1;
			break;
		    case '-':
			sense ^= 2;
			break;
#ifdef S_IFLNK
		    case '@':
			func = qualmode;
			data = S_IFLNK;
			break;
#endif
#ifdef S_IFSOCK
		    case (int)STOUC(Equals):
		    case '=':
			func = qualmode;
			data = S_IFSOCK;
			break;
#endif
#ifdef S_IFIFO
		    case 'p':
			func = qualmode;
			data = S_IFIFO;
			break;
#endif
		    case '/':
			func = qualmode;
			data = S_IFDIR;
			break;
		    case '.':
			func = qualmode;
			data = S_IFREG;
			break;
		    case '%':
			if (*s == 'b')
			    s++, func = qualisblk;
			else if (*s == 'c')
			    s++, func = qualischar;
			else
			    func = qualisdev;
			break;
		    case (int)STOUC(Star):
			func = qualiscom;
			break;
		    case 'R':
			func = qualflags;
			data = 0004;
			break;
		    case 'W':
			func = qualflags;
			data = 0002;
			break;
		    case 'X':
			func = qualflags;
			data = 0001;
			break;
		    case 'r':
			func = qualflags;
			data = 0400;
			break;
		    case 'w':
			func = qualflags;
			data = 0200;
			break;
		    case 'x':
			func = qualflags;
			data = 0100;
			break;
		    case 's':
			func = qualflags;
			data = 04000;
			break;
		    case 'S':
			func = qualflags;
			data = 02000;
			break;
		    case 'd':
			func = qualdev;
			data = qgetnum(&s);
			break;
		    case 'l':
			func = qualnlink;
			amc = -1;
			goto getrange;
		    case 'U':
			func = qualuid;
			data = geteuid();
			break;
		    case 'G':
			func = qualgid;
			data = getegid();
			break;
		    case 'u':
			func = qualuid;
			if (idigit(*s))
			    data = qgetnum(&s);
			else {
			    struct passwd *pw;
			    char sav, *tt;

			    tt = get_strarg(s);
			    if (!*tt) {
				zerr("missing end of name",
				     NULL, 0);
				data = 0;
			    } else {
				sav = *tt;
				*tt = '\0';

				if ((pw = getpwnam(s + 1)))
				    data = pw->pw_uid;
				else {
				    zerr("unknown user", NULL, 0);
				    data = 0;
				}
				if ((*tt = sav) != Outpar)
				    s = tt + 1;
				else
				    s = tt;
			    }
			}
			break;
		    case 'g':
			func = qualgid;
			if (idigit(*s))
			    data = qgetnum(&s);
			else {
			    struct group *gr;
			    char sav, *tt;

			    tt = get_strarg(s);
			    if (!*tt) {
				zerr("missing end of name",
				     NULL, 0);
				data = 0;
			    } else {
				sav = *tt;
				*tt = '\0';

				if ((gr = getgrnam(s + 1)))
				    data = gr->gr_gid;
				else {
				    zerr("unknown group", NULL, 0);
				    data = 0;
				}
				if ((*tt = sav) != Outpar)
				    s = tt + 1;
				else
				    s = tt;
			    }
			}
			break;
		    case 'o':
			func = qualeqflags;
			data = qgetoctnum(&s);
			break;
		    case 'M':
			gf_markdirs = !(sense & 1);
			break;
		    case 'T':
			gf_listtypes = !(sense & 1);
			break;
		    case 'N':
			gf_nullglob = !(sense & 1);
			break;
		    case 'D':
			gf_noglobdots = sense & 1;
			break;
		    case 'a':
			amc = 0;
			func = qualtime;
			goto getrange;
		    case 'm':
			amc = 1;
			func = qualtime;
			goto getrange;
		    case 'c':
			amc = 2;
			func = qualtime;
			goto getrange;
		    case 'L':
			func = qualsize;
			amc = -1;
		      getrange:
			timef = TT_DAYS;
			if (amc >= 0)
			    if (*s == 'h')
				timef = TT_HOURS, ++s;
			    else if (*s == 'm')
				timef = TT_MINS, ++s;
			    else if (*s == 'w')
				timef = TT_WEEKS, ++s;
			    else if (*s == 'M')
				timef = TT_MONTHS, ++s;
			if ((range = *s == '+' ? 1 : *s == '-' ? -1 : 0))
			    ++s;
			data = qgetnum(&s);
			break;

		    default:
			zerr("unknown file attribute", NULL, 0);
			return;
		    }
		if (func) {
		    if (!qn)
			qn = (struct qual *)hcalloc(sizeof *qn);
		    if (ql)
			ql->next = qn;
		    ql = qn;
		    if (!quals)
			quals = qo = qn;
		    qn->func = func;
		    qn->sense = sense;
		    qn->data = data;
		    qn->range = range;
		    qn->timef = timef;
		    qn->amc = amc;
		    qn = NULL;
		    qualct++;
		}
		if (errflag)
		    return;
	    }
	}
    } else if ((str[sl - 1] == '/') &&
	       !((str[sl - 2] == Star) &&
		 (str[sl - 3] == Star))) {	/* foo/ == foo(/) */
	str[sl - 1] = '\0';
	quals = (struct qual *)hcalloc(sizeof *quals);
	quals->func = qualmode;
	quals->data = S_IFDIR;
	quals->sense = 0;
	qualct = 1;
    }
    if (*str == '/') {		/* pattern has absolute path */
	str++;
	pathbuf[0] = '/';
	pathbuf[pathpos = 1] = '\0';
    } else			/* pattern is relative to pwd */
	pathbuf[pathpos = 0] = '\0';
    q = parsepat(str);
    if (!q || errflag) {	/* if parsing failed */
	if (isset(NOBADPATTERN)) {
	    insnode(list, node, ostr);
	    return;
	}
	errflag = 0;
	zerr("bad pattern: %s", ostr, 0);
	return;
    }
    matchptr = matchbuf = (char **)zalloc((matchsz = 16) * sizeof(char *));

    matchct = 0;
    old_ino = (ino_t) 0;
    old_dev = (dev_t) 0;
    old_pos = -1;
    scanner(q);			/* do the globbing */
    if (matchct)
	badcshglob |= 2;
    else if (!gf_nullglob)
	if (isset(CSHNULLGLOB)) {
	    badcshglob |= 1;
	} else if (unset(NONOMATCH)) {
	    zerr("no matches found: %s", ostr, 0);
	    free(matchbuf);
	    return;
	} else {
	    *matchptr++ = dupstring(ostr);
	    matchct = 1;
	}
    qsort((vptr) & matchbuf[0], matchct, sizeof(char *),
	       (int (*)DCLPROTO((const void *, const void *)))notstrcmp);

    matchptr = matchbuf;
    while (matchct--)		/* insert matches in the arg list */
	insnode(list, node, *matchptr++);
    free(matchbuf);
    *np = (next) ? prevnode(next) : lastnode(list);
}

/* get number after qualifier */

long qgetnum(s)			/**/
char **s;
{
    long v = 0;

    if (!idigit(**s)) {
	zerr("number expected", NULL, 0);
	return 0;
    }
    while (idigit(**s))
	v = v * 10 + *(*s)++ - '0';
    return v;
}

/* get octal number after qualifier */

long qgetoctnum(s)		/**/
char **s;
{
    long v = 0;

    if (!idigit(**s)) {
	zerr("octal number expected", NULL, 0);
	return 0;
    }
    while (**s >= '0' && **s <= '7')
	v = v * 010 + *(*s)++ - '0';
    return v;
}

int notstrcmp(a, b)		/**/
char **a;
char **b;
{
    char *c = *b, *d = *a;
    int x1, x2, cmp;

    for (; *c == *d && *c; c++, d++);
    cmp = (int)(unsigned char)*c - (int)(unsigned char)*d;
    if (isset(NUMERICGLOBSORT)) {
	for (; c > *b && idigit(c[-1]); c--, d--);
	if (idigit(*c) && idigit(*d)) {
	    x1 = atoi(c);
	    x2 = atoi(d);
	    if (x1 != x2)
		return x1 - x2;
	}
    }
    return cmp;
}

int forstrcmp(a, b)		/**/
char **a;
char **b;
{
    char *c = *b, *d = *a;

    for (; *c == *d && *c; c++, d++);
    return ((int)(unsigned char)*d - (int)(unsigned char)*c);
}

/* add a match to the list */

void insert(s)			/**/
char *s;
{
    struct stat buf, buf2, *bp;
    int statted = 0;

    if (gf_listtypes || gf_markdirs) {
	statted = 1;
	if (!lstat(s, &buf) && (gf_listtypes || S_ISDIR(buf.st_mode))) {
	    char *t;
	    int ll = strlen(s);

	    t = (char *)ncalloc(ll + 2);
	    strcpy(t, s);
	    t[ll] = file_type(buf.st_mode);
	    t[ll + 1] = '\0';
	    s = t;
	}
    }
    if (qualct || qualorct) {	/* do the (X) (^X) stuff */
	struct qual *qo, *qn;
	int t = 0;

	if (statted || lstat(s, &buf) >= 0) {
	    statted = 0;
	    for (qo = quals; qo && !t; qo = qo->or) {

		t = 1;
		for (qn = qo; t && qn && qn->func; qn = qn->next) {
		    range = qn->range;
		    amc = qn->amc;
		    timef = qn->timef;
		    if ((qn->sense & 2) && !statted) {
			statted = 1;
			stat(s, &buf2);
		    }
		    bp = (qn->sense & 2) ? &buf2 : &buf;
		    if (!(!!((qn->func) (bp, qn->data)) ^
			  (qn->sense & 1))) {
			t = 0;
			break;
		    }
		}
	    }
	}
	if (!t)
	    return;
    }
    if (colonmod) {
	char *cm2 = colonmod;

	modify(&s, &cm2);
    }
    *matchptr++ = s;
    if (++matchct == matchsz) {
	matchbuf = (char **)realloc((char *)matchbuf,
				    sizeof(char **) * (matchsz *= 2));

	matchptr = matchbuf + matchct;
    }
}

#ifdef __STDC__
char file_type(mode_t filemode)
{
#else
char file_type(filemode)	/**/
mode_t filemode;
{
#endif
    switch (filemode & S_IFMT) {/* screw POSIX */
    case S_IFDIR:
	return '/';
#ifdef S_IFIFO
    case S_IFIFO:
	return '|';
#endif
    case S_IFCHR:
	return '%';
    case S_IFBLK:
	return '#';
#ifdef S_IFLNK
    case S_IFLNK:
	return /* (access(pbuf, F_OK) == -1) ? '&' :*/ '@';
#endif
#ifdef S_IFSOCK
    case S_IFSOCK:
	return '=';
#endif
    default:
	if (filemode & 0111)
	    return '*';
	else
	    return ' ';
    }
}

/* check to see if str is eligible for filename generation */

int haswilds(str)		/**/
char *str;
{
    if ((*str == Inbrack || *str == Outbrack) && !str[1])
	return 0;
    if (str[0] == '%')
	return 0;
    for (; *str; str++)
	if (*str == Pound || *str == Hat || *str == Star ||
	    *str == Bar || *str == Inbrack || *str == Inang ||
	    *str == Quest || (*str == Inpar && str[1] == ':'))
	    return 1;
    return 0;
}

/* check to see if str is eligible for brace expansion */

int hasbraces(str)		/**/
char *str;
{
    int mb, bc, cmct1, cmct2;
    char *lbr = NULL;

    if (str[0] == Inbrace && str[1] == Outbrace)
	return 0;
    if (isset(BRACECCL)) {
	for (mb = bc = 0; *str; ++str)
	    if (*str == Inbrace) {
		if (++bc > mb)
		    mb = bc;
	    } else if (*str == Outbrace)
		if (--bc < 0)
		    return (0);
	return (mb && bc == 0);
    }
    for (mb = bc = cmct1 = cmct2 = 0; *str; str++) {
	if (*str == Inbrace) {
	    if (!bc)
		lbr = str;
	    bc++;
	    if (str[4] == Outbrace && str[2] == '-') {	/* {a-z} */
		cmct1++;
		if (bc == 1)
		    cmct2++;
	    }
	} else if (*str == Outbrace) {
	    bc--;
	    if (!bc) {
		if (!cmct2) {
		    *lbr = '{';
		    *str = '}';
		}
		cmct2 = 0;
	    }
	} else if (*str == Comma && bc) {
	    cmct1++;
	    if (bc == 1)
		cmct2++;
	}
	if (bc > mb)
	    mb = bc;
	if (bc < 0)
	    return 0;
    }
    return (mb && bc == 0 && cmct1);
}

/* expand stuff like >>*.c */

int xpandredir(fn, tab)		/**/
struct redir *fn;
Lklist tab;
{
    Lklist fake;
    char *nam;
    struct redir *ff;
    int ret = 0;

    fake = newlist();
    addnode(fake, fn->name);
    prefork(fake, 0);
    if (!errflag)
	postfork(fake, 1);
    if (errflag)
	return 0;
    if (full(fake) && !nextnode(firstnode(fake))) {
	fn->name = (char *)peekfirst(fake);
	untokenize(fn->name);
    } else
	while ((nam = (char *)ugetnode(fake))) {
	    ff = (struct redir *)alloc(sizeof *ff);
	    *ff = *fn;
	    ff->name = nam;
	    addnode(tab, ff);
	    ret = 1;
	}
    return ret;
}

/* concatenate s1 and s2 in dynamically allocated buffer */

char *dyncat(s1, s2)		/**/
char *s1;
char *s2;
{
    char *ptr;

    ptr = (char *)ncalloc(strlen(s1) + strlen(s2) + 1);
    strcpy(ptr, s1);
    strcat(ptr, s2);
    return ptr;
}

/* concatenate s1, s2, and s3 in dynamically allocated buffer */

char *tricat(s1, s2, s3)	/**/
char *s1;
char *s2;
char *s3;
{
    char *ptr;

    ptr = (char *)zalloc(strlen(s1) + strlen(s2) + strlen(s3) + 1);
    strcpy(ptr, s1);
    strcat(ptr, s2);
    strcat(ptr, s3);
    return ptr;
}

/* brace expansion */

void xpandbraces(list, np)	/**/
Lklist list;
Lknode *np;
{
    Lknode node = (*np), last = prevnode(node);
    char *str = (char *)getdata(node), *str3 = str, *str2;
    int prev, bc, comma;

    for (; *str != Inbrace; str++);
    for (str2 = str, bc = comma = 0; *str2; ++str2)
	if (*str2 == Inbrace)
	    ++bc;
	else if (*str2 == Outbrace) {
	    if (--bc == 0)
		break;
	} else if (bc == 1 && *str2 == Comma)
	    ++comma;
    if (!comma && !bc && isset(BRACECCL)) {	/* {a-mnop} */
	char ccl[256], *p;
	unsigned char c1, c2, lastch;

	uremnode(list, node);
	memset(ccl, 0, sizeof(ccl) / sizeof(ccl[0]));
	for (p = str + 1, lastch = 0; p < str2;) {
	    if (itok(c1 = *p++))
		c1 = ztokens[c1 - STOUC(Pound)];
	    if (itok(c2 = *p))
		c2 = ztokens[c2 - STOUC(Pound)];
	    if (c1 == '-' && lastch && p < str2 && (int)lastch <= (int)c2) {
		while ((int)lastch < (int)c2)
		    ccl[lastch++] = 1;
		lastch = 0;
	    } else
		ccl[lastch = c1] = 1;
	}
	strcpy(str + 1, str2 + 1);
	for (p = ccl + 255; p-- > ccl;)
	    if (*p) {
		*str = p - ccl;
		insnode(list, last, dupstring(str3));
	    }
	*np = nextnode(last);
	return;
    }
    if (str[2] == '-' && str[4] == Outbrace) {	/* {a-z} */
	char c1, c2;

	uremnode(list, node);
	chuck(str);
	c1 = *str;
	chuck(str);
	chuck(str);
	c2 = *str;
	chuck(str);
	if (itok(c1))
	    c1 = ztokens[c1 - Pound];
	if (itok(c2))
	    c2 = ztokens[c2 - Pound];
	if (c1 < c2)
	    for (; c2 >= c1; c2--) {	/* {a-z} */
		*str = c2;
		insnode(list, last, dupstring(str3));
	} else
	    for (; c2 <= c1; c2++) {	/* {z-a} */
		*str = c2;
		insnode(list, last, dupstring(str3));
	    }
	*np = nextnode(last);
	return;
    }
    prev = str - str3;
    str2 = getparen(str++);
    if (!str2) {
	zerr("how did you get this error?", NULL, 0);
	return;
    }
    uremnode(list, node);
    node = last;
    for (;;) {
	char *zz, *str4;
	int cnt;

	for (str4 = str, cnt = 0; cnt || (*str != Comma && *str !=
					  Outbrace); str++)
	    if (*str == Inbrace)
		cnt++;
	    else if (*str == Outbrace)
		cnt--;
	    else if (!*str)
		exit(10);
	zz = (char *)zalloc(prev + (str - str4) + strlen(str2) + 1);
	ztrncpy(zz, str3, prev);
	strncat(zz, str4, str - str4);
	strcat(zz, str2);
	insnode(list, node, zz);
	incnode(node);
	if (*str != Outbrace)
	    str++;
	else
	    break;
    }
    *np = nextnode(last);
}

/* get closing paren, given pointer to opening paren */

char *getparen(str)		/**/
char *str;
{
    int cnt = 1;
    char typein = *str++, typeout = typein + 1;

    for (; *str && cnt; str++)
	if (*str == typein)
	    cnt++;
	else if (*str == typeout)
	    cnt--;
    if (!str && cnt)
	return NULL;
    return str;
}

/* check to see if a matches b (b is not a filename pattern) */

int matchpat(a, b)		/**/
char *a;
char *b;
{
    Comp c;
    int val, len;
    char *b2;

    remnulargs(b);
    len = strlen(b);
    b2 = (char *)alloc(len + 3);
    strcpy(b2 + 1, b);
    b2[0] = Inpar;
    b2[len + 1] = Outpar;
    b2[len + 2] = '\0';
    c = parsereg(b2);
    if (!c) {
	zerr("bad pattern: %s", b, 0);
	return 0;
    }
    val = domatch(a, c, 0);
    return val;
}

/* do the ${foo%%bar}, ${foo#bar} stuff */
/* please do not laugh at this code. */

char *get_match_ret(s, b, e, fl)/**/
char *s;
int b;
int e;
int fl;
{
    char buf[80], *r, *p, *rr;
    int ll = 0, l = strlen(s), bl = 0, t = 0, i;

    if (fl & 8)
	ll += 1 + (e - b);
    if (fl & 16)
	ll += 1 + (l - (e - b));
    if (fl & 32) {
	sprintf(buf, "%d ", b + 1);
	ll += (bl = strlen(buf));
    }
    if (fl & 64) {
	sprintf(buf + bl, "%d ", e + 1);
	ll += (bl = strlen(buf));
    }
    if (fl & 128) {
	sprintf(buf + bl, "%d ", e - b);
	ll += (bl = strlen(buf));
    }
    if (bl)
	buf[bl - 1] = '\0';

    rr = r = (char *)ncalloc(ll);

    if (fl & 8) {
	for (i = b, p = s + b; i < e; i++)
	    *rr++ = *p++;
	t = 1;
    }
    if (fl & 16) {
	if (t)
	    *rr++ = ' ';
	for (i = 0, p = s; i < b; i++)
	    *rr++ = *p++;
	for (i = e, p = s + e; i < l; i++)
	    *rr++ = *p++;
	t = 1;
    }
    *rr = '\0';
    if (bl) {
	if (t)
	    *rr++ = ' ';
	strcpy(rr, buf);
    }
    return r;
}

void getmatch(sp, pat, fl, n)	/**/
char **sp;
char *pat;
int fl;
int n;
{
    Comp c;
    char *s = *sp, *t, sav;
    int i, j, l = strlen(*sp);

    remnulargs(pat);
    c = parsereg(pat);
    if (!c) {
	zerr("bad pattern: %s", pat, 0);
	return;
    }
    switch (fl & 7) {
    case 0:
	for (i = 1, t = s + 1; i <= l; i++, t++) {
	    sav = *t;
	    *t = '\0';
	    if (domatch(s, c, 0) && !--n) {
		*t = sav;
		*sp = get_match_ret(*sp, 0, i, fl);
		return;
	    }
	    *t = sav;
	}
	break;

    case 1:
	for (t = s + l - 1; t >= s; t--) {
	    if (domatch(t, c, 0) && !--n) {
		*sp = get_match_ret(*sp, t - s, l, fl);
		return;
	    }
	}
	break;

    case 2:
	for (t = s + l; t > s; t--) {
	    sav = *t;
	    *t = '\0';
	    if (domatch(s, c, 0) && !--n) {
		*t = sav;
		*sp = get_match_ret(*sp, 0, t - s, fl);
		return;
	    }
	    *t = sav;
	}
	break;

    case 3:
	for (i = 0, t = s; i < l; i++, t++) {
	    if (domatch(t, c, 0) && !--n) {
		*sp = get_match_ret(*sp, i, l, fl);
		return;
	    }
	}
	break;

    case 4:
	for (i = 1; i <= l; i++) {
	    for (t = s + i, j = i; j <= l; j++, t++) {
		sav = *t;
		*t = '\0';
		if (domatch(s + i - 1, c, 0) && !--n) {
		    *t = sav;
		    *sp = get_match_ret(*sp, i - 1, j, fl);
		    return;
		}
		*t = sav;
	    }
	}
	break;

    case 5:
	for (i = 1; i <= l; i++) {
	    for (t = s + l, j = i; j <= l; j++, t--) {
		sav = *t;
		*t = '\0';
		if (domatch(t - i, c, 0) && !--n) {
		    *t = sav;
		    *sp = get_match_ret(*sp, l - j, t - s, fl);
		    return;
		}
		*t = sav;
	    }
	}
	break;

    case 6:
	for (i = l; i; i--) {
	    for (t = s, j = i; j <= l; j++, t++) {
		sav = t[i];
		t[i] = '\0';
		if (domatch(t, c, 0) && !--n) {
		    t[i] = sav;
		    *sp = get_match_ret(*sp, t - s, t - s + i, fl);
		    return;
		}
		t[i] = sav;
	    }
	}
	break;

    case 7:
	for (i = l; i; i--) {
	    for (t = s + l, j = i; j <= l; j++, t--) {
		sav = *t;
		*t = '\0';
		if (domatch(t - i, c, 0) && !--n) {
		    *t = sav;
		    *sp = get_match_ret(*sp, l - j, t - s, fl);
		    return;
		}
		*t = sav;
	    }
	}
	break;
    }
    *sp = get_match_ret(*sp, 0, 0, fl);
}

/* add a component to pathbuf */

SPROTO(int addpath, (char *s));

static int addpath(s)
char *s;
{
    if ((int)strlen(s) + pathpos >= MAXPATHLEN)
	return 0;
    while ((pathbuf[pathpos++] = *s++));
    pathbuf[pathpos - 1] = '/';
    pathbuf[pathpos] = '\0';
    return 1;
}

char *getfullpath(s)		/**/
char *s;
{
    static char buf[MAXPATHLEN];

    strcpy(buf, pathbuf);
    strcat(buf, s);
    return buf;
}

/* do the globbing */

void scanner(q)			/**/
Complist q;
{
    Comp c;
    int closure;
    struct stat st;

    if (!q)
	return;

    if (q->closure && old_pos != pathpos &&
	stat((*pathbuf) ? pathbuf : ".", &st) != -1)
	if (st.st_ino == old_ino && st.st_dev == old_dev)
	    return;
	else {
	    old_pos = pathpos;
	    old_ino = st.st_ino;
	    old_dev = st.st_dev;
	}
    if ((closure = q->closure))	/* (foo/)# */
	if (q->closure == 2)	/* (foo/)## */
	    q->closure = 1;
	else
	    scanner(q->next);
    if ((c = q->comp)) {
	if (!(c->next || c->left) && !haswilds(c->str)) {
	    if (q->next) {
		int oppos = pathpos;

		if (errflag)
		    return;
		if (q->closure && !strcmp(c->str, "."))
		    return;
		if (!addpath(c->str))
		    return;
		if (!closure || exists(pathbuf))
		    scanner((q->closure) ? q : q->next);
		pathbuf[pathpos = oppos] = '\0';
	    } else {
		char *s;

		if (exists(s = getfullpath(c->str)))
		    insert(dupstring(s));
	    }
	} else {
	    char *fn;
	    int dirs = !!q->next;
	    struct dirent *de;
	    DIR *lock = opendir((*pathbuf) ? pathbuf : ".");

	    if (lock == NULL)
		return;
	    while ((de = readdir(lock))) {
		if (errflag)
		    break;
		fn = &de->d_name[0];
		if (fn[0] == '.'
		    && (fn[1] == '\0'
			|| (fn[1] == '.' && fn[2] == '\0')))
		    continue;
		if (!dirs && !colonmod &&
		    ((glob_pre && !strpfx(glob_pre, fn))
		     || (glob_suf && !strsfx(glob_suf, fn))))
		    continue;
		if (domatch(fn, c, gf_noglobdots)) {
		    int oppos = pathpos;

		    if (dirs) {
			if (closure) {
			    int type3;
			    struct stat buf;

			    if (lstat(getfullpath(fn), &buf) == -1) {
				if (errno != ENOENT && errno != EINTR &&
				    errno != ENOTDIR) {
				    zerr("%e: %s", fn, errno);
				    errflag = 0;
				}
				continue;
			    }
			    type3 = buf.st_mode & S_IFMT;
			    if (type3 != S_IFDIR)
				continue;
			}
			if (addpath(fn))
			    scanner((q->closure) ? q : q->next);	/* scan next level */
			pathbuf[pathpos = oppos] = '\0';
		    } else
			insert(dyncat(pathbuf, fn));
		}
	    }
	    closedir(lock);
	}
    } else
	zerr("no idea how you got this error message.", NULL, 0);
}

/* do the [..(foo)..] business */

int minimatch(pat, str)		/**/
char **pat;
char **str;
{
    char *pt = *pat + 1, *s = *str;

    for (; *pt != Outpar; s++, pt++)
	if ((*pt != Quest || !*s) && *pt != *s) {
	    *pat = getparen(*pat) - 1;
	    return 0;
	}
    *str = s - 1;
    return 1;
}

static char *pptr;
static Comp tail = 0;
static int first;

int domatch(str, c, fist)	/**/
char *str;
Comp c;
int fist;
{
    pptr = str;
    first = fist;
    return doesmatch(c);
}

#define untok(C)  (itok(C) ? ztokens[(C) - Pound] : (C))

/* See if pattern has a matching exclusion (~...) part */

int excluded(c, eptr, efst)	/**/
Comp c;
char *eptr;
int efst;
{
    char *saves = pptr;
    int savei = first, ret;

    first = efst;
    pptr = (PATHADDP(c) && pathpos) ? getfullpath(eptr) : eptr;

    ret = doesmatch(c->exclude);

    pptr = saves;
    first = savei;

    return ret;
}

/* see if current pattern matches c */

int doesmatch(c)		/**/
Comp c;
{
    char *pat = c->str;
    int done = 0;

  tailrec:
    if (ONEHASHP(c) || (done && TWOHASHP(c))) {
	char *saves = pptr;

	if (first && *pptr == '.')
	    return 0;
	if (doesmatch(c->next))
	    return 1;
	pptr = saves;
	first = 0;
    }
    done++;
    for (;;) {
	if (!pat || !*pat) {
	    char *saves;
	    int savei;

	    if (errflag)
		return 0;
	    saves = pptr;
	    savei = first;
	    if (c->left || c->right)
		if (!doesmatch(c->left) ||
		    (c->exclude && excluded(c, saves, savei)))
		    if (c->right) {
			pptr = saves;
			first = savei;
			if (!doesmatch(c->right))
			    return 0;
		    } else
			return 0;
	    if (*pptr && CLOSUREP(c)) {
		pat = c->str;
		goto tailrec;
	    }
	    if (!c->next)
		return (!LASTP(c) || !*pptr);
	    c = c->next;
	    done = 0;
	    pat = c->str;
	    goto tailrec;
	}
	if (first && *pptr == '.' && *pat != '.')
	    return 0;
	if (*pat == Star) {	/* final * is not expanded to ?#; returns success */
	    while (*pptr)
		pptr++;
	    return 1;
	}
	first = 0;
	if (*pat == Quest && *pptr) {
	    pptr++;
	    pat++;
	    continue;
	}
	if (*pat == Hat)
	    return 1 - doesmatch(c->next);
	if (*pat == Inbrack) {
	    if (!*pptr)
		break;
	    if (pat[1] == Hat || pat[1] == '^' || pat[1] == '!') {
		pat[1] = Hat;
		for (pat += 2; *pat != Outbrack && *pat; pat++)
		    if (*pat == '-' && pat[-1] != Hat && pat[1] != Outbrack) {
			if (untok(pat[-1]) <= *pptr && untok(pat[1]) >= *pptr)
			    break;
		    } else if (*pptr == untok(*pat))
			break;
		if (!*pat) {
		    zerr("something is very wrong.", NULL, 0);
		    return 0;
		}
		if (*pat != Outbrack)
		    break;
		pat++;
		pptr++;
		continue;
	    } else {
		for (pat++; *pat != Outbrack && *pat; pat++)
		    if (*pat == Inpar) {
			if (minimatch(&pat, &pptr))
			    break;
		    } else if (*pat == '-' && pat[-1] != Inbrack &&
			       pat[1] != Outbrack) {
			if (untok(pat[-1]) <= *pptr && untok(pat[1]) >= *pptr)
			    break;
		    } else if (*pptr == untok(*pat))
			break;
		if (!pat || !*pat) {
		    zerr("oh dear.  that CAN'T be right.", NULL, 0);
		    return 0;
		}
		if (*pat == Outbrack)
		    break;
		for (pptr++; *pat != Outbrack; pat++);
		pat++;
		continue;
	    }
	}
	if (*pat == Inang) {
	    int t1, t2, t3;
	    char *ptr;

	    if (*++pat == Outang) {	/* handle <> case */
		(void)zstrtol(pptr, &ptr, 10);
		if (ptr == pptr)
		    break;
		pptr = ptr;
		pat++;
	    } else {
		t1 = zstrtol(pptr, &ptr, 10);
		if (ptr == pptr)
		    break;
		pptr = ptr;
		t2 = zstrtol(pat, &ptr, 10);
		if (*ptr != '-')
		    t3 = t2, pat = ptr;
		else
		    t3 = zstrtol(ptr + 1, &pat, 10);
		if (!t3)
		    t3 = -1;
		if (*pat++ != Outang)
		    exit(21);
		if (t1 < t2 || (t3 != -1 && t1 > t3))
		    break;
	    }
	    continue;
	}
	if (*pptr == *pat) {
	    pptr++;
	    pat++;
	    continue;
	}
	break;
    }
    return 0;
}

Complist parsepat(str)		/**/
char *str;
{
    mode = 0;
    pptr = str;
    return parsecomplist();
}

Comp parsereg(str)		/**/
char *str;
{
    mode = 1;
    pptr = str;
    return parsecompsw(0);
}

Complist parsecomplist()
{				/**/
    Comp c1;
    Complist p1;

    if (pptr[0] == Star && pptr[1] == Star &&
	(pptr[2] == '/' ||
	 (pptr[2] == Star && pptr[3] == Star && pptr[4] == '/'))) {
	pptr += 3;
	if (pptr[-1] == Star)
	    pptr += 2;
	p1 = (Complist) alloc(sizeof *p1);
	if ((p1->next = parsecomplist()) == NULL) {
	    errflag = 1;
	    return NULL;
	}
	p1->comp = (Comp) alloc(sizeof *p1->comp);
	p1->comp->stat |= C_LAST;
	p1->comp->str = dupstring("*");
	*p1->comp->str = Star;
	p1->closure = 1;
	return p1;
    }
    if (*pptr == Inpar) {
	char *str;
	int pars = 1;

	for (str = pptr + 1; *str && pars; str++)
	    if (*str == Inpar)
		pars++;
	    else if (*str == Outpar)
		pars--;
	if (str[0] != Pound || str[-1] != Outpar || str[-2] != '/')
	    goto kludge;
	pptr++;
	if (!(c1 = parsecompsw(0)))
	    return NULL;
	if (pptr[0] == '/' && pptr[1] == Outpar && pptr[2] == Pound) {
	    int pdflag = 0;

	    pptr += 3;
	    if (*pptr == Pound) {
		pdflag = 1;
		pptr++;
	    }
	    p1 = (Complist) alloc(sizeof *p1);
	    p1->comp = c1;
	    p1->closure = 1 + pdflag;
	    p1->next = parsecomplist();
	    return (p1->comp) ? p1 : NULL;
	}
    } else {
      kludge:
	if (!(c1 = parsecompsw(1)))
	    return NULL;
	if (*pptr == '/' || !*pptr) {
	    int ef = *pptr == '/';

	    p1 = (Complist) alloc(sizeof *p1);
	    p1->comp = c1;
	    p1->closure = 0;
	    p1->next = ef ? (pptr++, parsecomplist()) : NULL;
	    return (ef && !p1->next) ? NULL : p1;
	}
    }
    errflag = 1;
    return NULL;
}

Comp parsecomp()
{				/**/
    Comp c = (Comp) alloc(sizeof *c), c1, c2;
    char *s = c->str = (char *)alloc(MAXPATHLEN * 2), *ls = NULL;

    c->next = tail;

    while (*pptr && (mode || *pptr != '/') && *pptr != Bar &&
	   (!isset(EXTENDEDGLOB) || *pptr != Tilde ||
	    !pptr[1] || pptr[1] == Outpar || pptr[1] == Bar) &&
	   *pptr != Outpar) {
	if (*pptr == Hat) {
	    *s++ = Hat;
	    *s++ = '\0';
	    pptr++;
	    if (!(c->next = parsecomp()))
		return NULL;
	    return c;
	}
	if (*pptr == Star && pptr[1] &&
	    (!isset(EXTENDEDGLOB) || pptr[1] != Tilde || !pptr[2] ||
	     pptr[2] == Bar ||
	     pptr[2] == Outpar) && (mode || pptr[1] != '/')) {
	    *s++ = '\0';
	    pptr++;
	    c1 = (Comp) alloc(sizeof *c1);
	    *(c1->str = dupstring("?")) = Quest;
	    c1->stat |= C_ONEHASH;
	    if (!(c2 = parsecomp()))
		return NULL;
	    c1->next = c2;
	    c->next = c1;
	    return c;
	}
	if (*pptr == Inpar) {
	    int pars = 1;
	    char *startp = pptr, *endp;
	    Comp stail = tail;
	    int dpnd = 0;

	    for (pptr = pptr + 1; *pptr && pars; pptr++)
		if (*pptr == Inpar)
		    pars++;
		else if (*pptr == Outpar)
		    pars--;
	    if (pptr[-1] != Outpar) {
		errflag = 1;
		return NULL;
	    }
	    if (*pptr == Pound) {
		dpnd = 1;
		pptr++;
		if (*pptr == Pound) {
		    pptr++;
		    dpnd = 2;
		}
	    }
	    if (!(c1 = parsecomp()))
		return NULL;
	    tail = dpnd ? NULL : c1;
	    endp = pptr;
	    pptr = startp;
	    pptr++;
	    *s++ = '\0';
	    c->next = (Comp) alloc(sizeof *c);
	    c->next->left = parsecompsw(0);
	    if (dpnd)
		c->next->stat |= (dpnd == 2) ? C_TWOHASH : C_ONEHASH;
	    c->next->next = dpnd ? c1 : (Comp) alloc(sizeof *c);
	    pptr = endp;
	    tail = stail;
	    return c;
	}
	if (*pptr == Pound) {
	    *s = '\0';
	    pptr++;
	    if (!ls)
		return NULL;
	    if (*pptr == Pound) {
		pptr++;
		c->next = c1 = (Comp) alloc(sizeof *c);
		c1->str = dupstring(ls);
	    } else
		c1 = c;
	    c1->next = c2 = (Comp) alloc(sizeof *c);
	    c2->str = dupstring(ls);
	    c2->stat |= C_ONEHASH;
	    c2->next = parsecomp();
	    if (!c2->next)
		return NULL;
	    *ls++ = '\0';
	    return c;
	}
	ls = s;
	if (*pptr == Inang) {
	    int dshct;

	    dshct = (pptr[1] == Outang);
	    *s++ = *pptr++;
	    while (*pptr && (*s++ = *pptr++) != Outang)
		if (s[-1] == '-')
		    dshct++;
		else if (!idigit(s[-1]))
		    break;
	    if (s[-1] != Outang)
		return NULL;
	} else if (*pptr == Inbrack) {
	    while (*pptr && (*s++ = *pptr++) != Outbrack);
	    if (s[-1] != Outbrack)
		return NULL;
	} else if (itok(*pptr) && *pptr != Star && *pptr != Quest)
	    *s++ = ztokens[*pptr++ - Pound];
	else
	    *s++ = *pptr++;
    }
    if (*pptr == '/' || !*pptr)
	c->stat |= C_LAST;
    *s++ = '\0';
    return c;
}

Comp parsecompsw(pathadd)	/**/
int pathadd;
{
    Comp c1, c2, c3, excl = NULL;

    c1 = parsecomp();
    if (!c1)
	return NULL;
    if (isset(EXTENDEDGLOB) && *pptr == Tilde) {
	int oldmode = mode;

	mode = 1;
	pptr++;
	excl = parsecomp();
	mode = oldmode;
	if (!excl)
	    return NULL;
    }
    if (*pptr == Bar || excl) {
	c2 = (Comp) alloc(sizeof *c2);
	if (*pptr == Bar) {
	    pptr++;
	    c3 = parsecompsw(pathadd);
	    if (!c3)
		return NULL;
	} else {
	    if (!*pptr || *pptr == '/')
		c2->stat |= C_LAST;
	    c3 = NULL;
	}
	c2->str = dupstring("");
	c2->left = c1;
	c2->right = c3;
	c2->exclude = excl;
	if (pathadd)
	    c2->stat |= C_PATHADD;
	return c2;
    }
    return c1;
}

void tokenize(s)		/**/
char *s;
{
    char *t;

    for (; *s; s++)
	if (*s == '\\')
	    chuck(s);
	else
	    for (t = ztokens; *t; t++)
		if (*t == *s) {
		    *s = (t - ztokens) + Pound;
		    break;
		}
}

/* remove unnecessary Nulargs */

void remnulargs(s)		/**/
char *s;
{
    int nl = *s;
    char *t = s;

    while (*s)
	if (INULL(*s))
	    chuck(s);
	else
	    s++;
    if (!*t && nl) {
	t[0] = Nularg;
	t[1] = '\0';
    }
}

/* qualifier functions */

int qualdev(buf, dv)		/**/
struct stat *buf;
long dv;
{
    return buf->st_dev == dv;
}

int qualnlink(buf, ct)		/**/
struct stat *buf;
long ct;
{
    return (range < 0 ? buf->st_nlink < ct :
	    range > 0 ? buf->st_nlink > ct :
	    buf->st_nlink == ct);
}

int qualuid(buf, uid)		/**/
struct stat *buf;
long uid;
{
    return buf->st_uid == uid;
}

int qualgid(buf, gid)		/**/
struct stat *buf;
long gid;
{
    return buf->st_gid == gid;
}

int qualisdev(buf, junk)	/**/
struct stat *buf;
long junk;
{
    junk = buf->st_mode & S_IFMT;
    return junk == S_IFBLK || junk == S_IFCHR;
}

int qualisblk(buf, junk)	/**/
struct stat *buf;
long junk;
{
    junk = buf->st_mode & S_IFMT;
    return junk == S_IFBLK;
}

int qualischar(buf, junk)	/**/
struct stat *buf;
long junk;
{
    junk = buf->st_mode & S_IFMT;
    return junk == S_IFCHR;
}

int qualmode(buf, mod)		/**/
struct stat *buf;
long mod;
{
    return (buf->st_mode & S_IFMT) == mod;
}

int qualflags(buf, mod)		/**/
struct stat *buf;
long mod;
{
    return buf->st_mode & mod;
}

int qualeqflags(buf, mod)	/**/
struct stat *buf;
long mod;
{
    return (buf->st_mode & 07777) == mod;
}

int qualiscom(buf, mod)		/**/
struct stat *buf;
long mod;
{
    return (buf->st_mode & (S_IFMT | S_IEXEC)) == (S_IFREG | S_IEXEC);
}

int qualsize(buf, size)		/**/
struct stat *buf;
long size;
{
    return (range < 0 ? buf->st_size < size :
	    range > 0 ? buf->st_size > size :
	    buf->st_size == size);
}

int qualtime(buf, days)		/**/
struct stat *buf;
long days;
{
    time_t now, diff;

    time(&now);
    diff = now - (amc == 0 ? buf->st_atime : amc == 1 ? buf->st_mtime :
		  buf->st_ctime);
    switch (timef) {
    case TT_DAYS:
	diff /= 86400l;
	break;
    case TT_HOURS:
	diff /= 3600l;
	break;
    case TT_MINS:
	diff /= 60l;
	break;
    case TT_WEEKS:
	diff /= 604800l;
	break;
    case TT_MONTHS:
	diff /= 2592000l;
	break;
    }

    return (range < 0 ? diff < days :
	    range > 0 ? diff > days :
	    diff == days);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        im;
		}
		if (ent->stim == 0)
		    ent->stim = tim;
		if (ent->ftim == 0)
		    ent->ftim = tim;
	    } else {
		ent->ftim = ent->stim = tim;
	    }
	    zsfree(ent->lex);
	    zsfree(ent->lit);
	    ent->lex = ztrdup(pt);
	    ent->lit = ztrdup(pt);
	    ent->flags = HIST_OLD;
	}
	fclose(in);
    } else if (err)
	zerr("can't read history file", s, 0);
}

void savehistfile(s, err, app)	/**/
char *s;
int err;
int app;
{
    char *t;
    FILE *out;
    int ev;
    Histent ent;

    if (!s || !interact || savehist == 0)
	return;
    ev = curhist - savehist + 1;
    if (ev < firsthist())
	ev = firsthist();
    if (app & 1)
	out = fdopen(open(s, O_CREAT | O_WRONLY | O_APPEND, 0600), "a");
    else
	out = fdopen(open(s, O_CREAT | O_WRONLY | O_TRUNC, 0600), "w");
    if (out) {
	for (; ev <= curhist; ev++) {
	    ent = gethistent(ev);
	    if (app & 2) {
		if (ent->flags & HIST_OLD)
		    continue;
		ent->flags |= HIST_OLD;
	    }
	    t = ((lithist) ? ent->lit : ent->lex);
	    if (isset(EXTENDEDHISTORY)) {
		fprintf(out, ": %ld:%ld;",
			(long)ent->stim,
			(long)ent->ftim);
	    } else if (*t == ':')
		fputc('\\', out);

	    for (; *t; t++)
		if (*t == HISTSPACE)
		    fputc(' ', out);
		else {
		    if (*t == '\n')
			fputc('\\', out);
		    fputc(*t, out);
		}
	    fputc('\n', out);
	}
	fclose(out);

	if (app & 2 && (out = fopen(s, "r"))) {
	    char **store, buf[1024], **ptr;
	    int i, l, histnum = 0;

	    store = (char **)zcalloc((savehist + 1) * sizeof *store);
	    while (fgets(buf, sizeof(buf), out)) {
		l = strlen(buf);
		if (l > 1)
		    while (l < sizeof(buf) - 1 && buf[l - 2] == '\\') {
			fgets(buf + l, sizeof buf - l, out);
			l = strlen(buf);
		    }
		if (store[i = histnum % savehist])
		    free(store[i]);
		store[i] = (char *)zalloc(l + 1);
		strcpy(store[i], buf);
		histnum++;
	    }
	    fclose(out);
	    if ((out = fdopen(open(s, O_WRONLY | O_TRUNC, 0600), "w"))) {
		if (histnum < savehist)
		    for (i = 0; i < histnum; i++)
			fprintf(out, "%s", store[i]);
		else
		    for (i = histnum; i < histnum + savehist; i++)
			fprintf(out, "%s", store[i % savehist]);
		fclose(out);
	    }
	    for (ptr = store; *ptr; ptr++)
		zsfree(*ptr);
	    free(store);
	}
    } else if (err)
	zerr("can't write history file %s", s, 0);
}

int firsthist()
{				/**/
    int ev;
    Histent ent;

    ev = curhist - histentct + 1;
    if (ev < 1)
	ev = 1;
    do {
	ent = gethistent(ev);
	if ((lithist) ? ent->lit : ent->lex)
	    break;
	ev++;
    }
    while (ev < curhist);
    return ev;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 *
 * hist.c - history expansion
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"

static Histent curhistent;

static int lastc;

/* add a character to the current history word */

void hwaddc(c)			/**/
int c;
{
    if (hlastw && chline && (!(errflag || lexstop) || c == HISTSPACE)) {
	if (c == '!' && unset(NOBANGHIST))
	    hwaddc('\\');
	*hptr++ = c;
	if (hptr - chline >= hlinesz) {
	    int ll, flag = 0, oldsiz = hlinesz;

	    ll = hptr - hlastw;
	    if (curhistent->lex == chline)
		flag = 1;
	    chline = realloc(chline, hlinesz = oldsiz + 16);
	    if (flag)
		curhistent->lex = chline;
	    hptr = chline + oldsiz;
	    hlastw = hptr - ll;
	}
    }
}

#define habort() { errflag = lexstop = 1; return ' '; }

/* get a character after performing history substitution */

int hgetc()
{				/**/
    int c, ev, farg, evset = -1, larg, argc, cflag = 0, bflag = 0;
    static int mev = -1, marg = -1;
    char buf[256], *ptr;
    char *sline, *eline;

  tailrec:
    c = hgetch();
    if (stophist || alstackind) {
	hwaddc(c);
	return c;
    }
    if (isfirstch && c == hatchar) {
	isfirstch = 0;
	hungetch(hatchar);
	hungets(":s");
	goto hatskip;
    }
    if (c != ' ')
	isfirstch = 0;
    if (c == '\\') {
	int g = hgetch();

	if (g != bangchar)
	    hungetch(g);
	else {
	    hwaddc(bangchar);
	    return bangchar;
	}
    }
    if (c != bangchar) {
	hwaddc(c);
	return c;
    }
  hatskip:
    *hptr = '\0';
    if ((c = hgetch()) == '{') {
	bflag = cflag = 1;
	c = hgetch();
    }
    if (c == '\"') {
	stophist = 1;
	goto tailrec;
    }
    if ((!cflag && inblank(c)) || c == '=' || c == '(' || lexstop) {
	if (lexstop)
	    lexstop = 0;
	else
	    hungetch(c);
	hwaddc(bangchar);
	return bangchar;
    }
    cflag = 0;
    ptr = buf;

/* get event number */

    if (c == '?') {
	for (;;) {
	    c = hgetch();
	    if (c == '?' || c == '\n' || lexstop)
		break;
	    else
		*ptr++ = c;
	}
	if (c != '\n' && !lexstop)
	    c = hgetch();
	*ptr = '\0';
	mev = ev = hconsearch(hsubl = ztrdup(buf), &marg);
	evset = 0;
	if (ev == -1) {
	    herrflush();
	    zerr("no such event: %s", buf, 0);
	    habort();
	}
    } else {
	int t0;

	for (;;) {
	    if (inblank(c) || c == ';' || c == ':' || c == '^' || c == '$' ||
		c == '*' || c == '%' || c == '}' ||
		c == '\'' || c == '"' || c == '`' || lexstop)
		break;
	    if (ptr != buf) {
		if (c == '-')
		    break;
		if ((idigit(buf[0]) || buf[0] == '-') && !idigit(c))
		    break;
	    }
	    *ptr++ = c;
	    if (c == '#' || c == bangchar) {
		c = hgetch();
		break;
	    }
	    c = hgetch();
	}
	*ptr = 0;
	if (!*buf)
	    if (c != '%') {
		if (isset(CSHJUNKIEHISTORY))
		    ev = curhist - 1;
		else
		    ev = defev;
		if (c == ':' && evset == -1)
		    evset = 0;
		else
		    evset = 1;
	    } else {
		if (marg != -1)
		    ev = mev;
		else
		    ev = defev;
		evset = 0;
	} else if ((t0 = atoi(buf))) {
	    ev = (t0 < 0) ? curhist + t0 : t0;
	    evset = 1;
	} else if ((unsigned)*buf == bangchar) {
	    ev = curhist - 1;
	    evset = 1;
	} else if (*buf == '#') {
	    ev = curhist;
	    evset = 1;
	} else if ((ev = hcomsearch(buf)) == -1) {
	    zerr("event not found: %s", buf, 0);
	    while (c != '\n' && !lexstop)
		c = hgetch();
	    habort();
	} else
	    evset = 1;
    }

/* get the event */

    if (!(eline = getevent(defev = ev)))
	habort();

/* extract the relevant arguments */

    argc = getargc(eline);
    if (c == ':') {
	cflag = 1;
	c = hgetch();
	if (c == '%' && marg != -1) {
	    if (!evset) {
		eline = getevent(defev = mev);
		argc = getargc(eline);
	    } else {
		zerr("Ambiguous history reference", NULL, 0);
		while (c != '\n' && !lexstop)
		    c = hgetch();
		habort();
	    }

	}
    }
    if (c == '*') {
	farg = 1;
	larg = argc;
	cflag = 0;
    } else {
	hungetch(c);
	larg = farg = getargspec(argc, marg, evset);
	if (larg == -2)
	    habort();
	if (farg != -1)
	    cflag = 0;
	c = hgetch();
	if (c == '*') {
	    cflag = 0;
	    larg = argc;
	} else if (c == '-') {
	    cflag = 0;
	    larg = getargspec(argc, marg, evset);
	    if (larg == -2)
		habort();
	    if (larg == -1)
		larg = argc - 1;
	} else
	    hungetch(c);
    }
    if (farg == -1)
	farg = 0;
    if (larg == -1)
	larg = argc;
    if (!(sline = getargs(eline, farg, larg)))
	habort();

/* do the modifiers */

    for (;;) {
	c = (cflag) ? ':' : hgetch();
	cflag = 0;
	if (c == ':') {
	    int gbal = 0;

	    if ((c = hgetch()) == 'g') {
		gbal = 1;
		c = hgetch();
	    }
	    switch (c) {
	    case 'p':
		histdone = HISTFLAG_DONE | HISTFLAG_NOEXEC;
		break;
	    case 'h':
		if (!remtpath(&sline)) {
		    herrflush();
		    zerr("modifier failed: h", NULL, 0);
		    habort();
		}
		break;
	    case 'e':
		if (!rembutext(&sline)) {
		    herrflush();
		    zerr("modifier failed: e", NULL, 0);
		    habort();
		}
		break;
	    case 'r':
		if (!remtext(&sline)) {
		    herrflush();
		    zerr("modifier failed: r", NULL, 0);
		    habort();
		}
		break;
	    case 't':
		if (!remlpaths(&sline)) {
		    herrflush();
		    zerr("modifier failed: t", NULL, 0);
		    habort();
		}
		break;
	    case 's':
		{
		    int del;
		    char *ptr1, *ptr2;

		    del = hgetch();
		    ptr1 = hdynread2(del);
		    if (!ptr1)
			habort();
		    ptr2 = hdynread2(del);
		    if (strlen(ptr1)) {
			zsfree(hsubl);
			hsubl = ptr1;
		    }
		    zsfree(hsubr);
		    hsubr = ptr2;
		    if (hsubl && !ztrstr(sline, hsubl)) {
			herrflush();
			zerr("substitution failed", NULL, 0);
			habort();
		    }
		}
	    case '&':
		if (hsubl && hsubr)
		    subst(&sline, hsubl, hsubr, gbal);
		else {
		    herrflush();
		    zerr("no previous substitution with &", NULL, 0);
		    habort();
		}
		break;
	    case 'q':
		quote(&sline);
		break;
	    case 'x':
		quotebreak(&sline);
		break;
	    case 'l':
		downcase(&sline);
		break;
	    case 'u':
		upcase(&sline);
		break;
	    default:
		herrflush();
		zerr("illegal modifier: %c", NULL, c);
		habort();
	    }
	} else {
	    if (c != '}' || !bflag)
		hungetch(c);
	    if (c != '}' && bflag) {
		zerr("'}' expected", NULL, 0);
		habort();
	    }
	    break;
	}
    }

/* stuff the resulting string in the input queue and start over */

    lexstop = 0;
    if (alstackind != MAXAL) {
	hungets(HISTMARK);
	alstack[alstackind++] = NULL;
    }
    for (ptr = sline; *ptr; ptr++) {
	if (ptr[0] == '\\' && ptr[1] == '!')
	    chuck(ptr);
    }
    hungets(sline);
    histdone |= HISTFLAG_DONE;
    if (isset(HISTVERIFY))
	histdone |= HISTFLAG_NOEXEC | HISTFLAG_RECALL;
    goto tailrec;
}

/* reset the alias stack for lexrestore () */

void clearalstack()
{				/**/
    Alias ix;

    while (alstackind) {
	ix = alstack[--alstackind];
	ix->inuse = 0;
    }
}

/* get a character without history expansion */

int hgetch()
{				/**/
    unsigned char *hgetchline, *hgetchpmpt = NULL, *hgetchpmpt2 = NULL;
    int plen, p2len = 0;

  start:
    if (inbufct) {
	inbufct--;
	if ((lastc = *inbufptr++) == ALPOP && alstackind > 0) {
	    Alias ix;
	    char *t;

	    ix = alstack[--alstackind];
	    if (ix) {
		ix->inuse = 0;
		t = ix->text;
		if (*t && t[strlen(t) - 1] == ' ')
		    alstat = ALSTAT_MORE;
		else
		    alstat = ALSTAT_JUNK;
	    }
	    goto start;
	}
	if (itok(lastc))
	    goto start;
	return lastc;
    }
    if (strin || errflag) {
	lexstop = 1;
	return lastc = ' ';
    }
    if (interact && isset(SHINSTDIN))
	if (!isfirstln)
	    hgetchpmpt = (unsigned char *)putprompt(prompt2, &plen, 0);
	else {
	    hgetchpmpt = (unsigned char *)putprompt(prompt, &plen, 0);
	    if (rprompt)
		hgetchpmpt2 = (unsigned char *)putprompt(rprompt, &p2len, 0);
	    else
		hgetchpmpt2 = NULL, p2len = 0;
	}
    if (!(interact && isset(SHINSTDIN) && SHTTY != -1 && isset(USEZLE))) {
	char *lbuf;

	if (interact && isset(SHINSTDIN))
	    write(2, (WRITE_ARG_2_T) hgetchpmpt, strlen((char *)hgetchpmpt));
	hgetchline = (unsigned char *)fgets(lbuf = (char *)zalloc(256), 256, bshin);
	if (!hgetchline)
	    zfree(lbuf, 256);
    } else
	hgetchline = zleread(hgetchpmpt, hgetchpmpt2, plen, p2len);
    if (!hgetchline) {
	lexstop = 1;
	return lastc = ' ';
    }
    if (errflag) {
	free(hgetchline);
	lexstop = errflag = 1;
	return lastc = ' ';
    }
    if (interact && isset(SHINSTDIN)) {
	char *s = curhistent->lit;

	curhistent->lit = tricat("", s, (char *)hgetchline);
	zsfree(s);
    }
    if (isfirstln)
	spaceflag = *hgetchline == ' ';
    if (isset(VERBOSE)) {
	fputs((char *)hgetchline, stderr);
	fflush(stderr);
    }
    if (*hgetchline && hgetchline[strlen((char *)hgetchline) - 1] == '\n') {
	lineno++;
	if (interact && isset(SUNKEYBOARDHACK) && isset(SHINSTDIN) &&
	    SHTTY != -1 && *hgetchline && hgetchline[1] &&
	    hgetchline[strlen((char *)hgetchline) - 2] == '`') {
	    int ct;
	    unsigned char *ptr;

	    for (ct = 0, ptr = hgetchline; *ptr; ptr++)
		if (*ptr == '`')
		    ct++;
	    if (ct & 1) {
		ptr[-2] = '\n';
		ptr[-1] = '\0';
	    }
	}
    }
    isfirstch = 1;
    hungets((char *)hgetchline);
    free(hgetchline);
    goto start;
}

/* Read one line of at most n-1 chars from the input queue */

char *hgets(buf, n)		/**/
char *buf;
int n;
{
    int l;

    for (l = 0; l < n - 1; l++)
	if ((buf[l] = hgetch()) == '\n' || lexstop)
	    break;
    buf[l + (lexstop ? 0 : 1)] = 0;

    return (!lexstop || l) ? buf : NULL;
}

/* put a string in the input queue */

void hungets(str)		/**/
char *str;
{
    int slen = strlen(str);

/* shrink inbuf if it gets too big */

    if (!inbufct && inbufsz > 65536) {
	free(inbuf);
	inbuf = (char *)zalloc(inbufsz = 256);
	inbufptr = inbuf + inbufsz;
	inbufct = 0;
    }
    if (slen + inbufct > inbufsz) {
	char *x;

	while (slen + inbufct > inbufsz)
	    inbufsz *= 4;
	x = (char *)zalloc(inbufsz);
	memcpy(x + inbufsz - inbufct, inbufptr, inbufct);
	inbufptr = x + inbufsz - inbufct;
	free(inbuf);
	inbuf = x;
    }
    memcpy(inbufptr -= slen, str, slen);
    inbufct += slen;
}

/* unget a char and remove it from chline */

void hungetc(c)			/**/
int c;
{
    if (lexstop)
	return;
    if (hlastw) {
	if (hlastw == hptr)
	    zerr("hungetc attempted at buffer start", NULL, 0);
	else {
	    hptr--;
	    if (*hptr == '!' && unset(NOBANGHIST))
		hptr--;
	}
    }
    hungetch(c);
}

void hungetch(c)		/**/
int c;
{
    if (lexstop)
	return;
    if (inbufct == inbufsz) {
	hungets(" ");
	*inbufptr = c;
    } else {
	*--inbufptr = c;
	inbufct++;
    }
}

/* begin reading a string */

void strinbeg()
{				/**/
    strin = 1;
    hbegin();
    lexinit();
}

/* done reading a string */

void strinend()
{				/**/
    hend();
    strin = 0;
    isfirstch = 1;
    histdone = 0;
}

/* stuff a whole file into the input queue and print it */

int stuff(fn)			/**/
char *fn;
{
    FILE *in;
    char *buf;
    int len;

    if (!(in = fopen(fn, "r"))) {
	zerr("can't open %s", fn, 0);
	return 1;
    }
    fseek(in, 0, 2);
    len = ftell(in);
    fseek(in, 0, 0);
    buf = (char *)alloc(len + 1);
    if (!(fread(buf, len, 1, in))) {
	zerr("read error on %s", fn, 0);
	fclose(in);
	zfree(buf, len + 1);
	return 1;
    }
    fclose(in);
    buf[len] = '\0';
    fwrite(buf, len, 1, stdout);
    hungets(buf);
    return 0;
}

/* flush input queue */

void hflush()
{				/**/
    inbufptr += inbufct;
    inbufct = 0;
}

/* initialize the history mechanism */

void hbegin()
{				/**/
    isfirstln = isfirstch = 1;
    histremmed = errflag = histdone = spaceflag = 0;
    stophist = !interact || isset(NOBANGHIST) || unset(SHINSTDIN);
    lithist = isset(HISTLIT);
    chline = hptr = zcalloc(hlinesz = 16);
    curhistent = gethistent(curhist);
    if (!curhistent->ftim)
	curhistent->ftim = time(NULL);
    if (interact && isset(SHINSTDIN) && !strin) {
	attachtty(mypgrp);
	defev = curhist++;
	if (curhist - histsiz >= 0)
	    if (gethistent(curhist - histsiz)->lex) {
		zsfree(gethistent(curhist - histsiz)->lex);
		gethistent(curhist - histsiz)->lex = NULL;
	    }
	if (curhist - lithistsiz >= 0)
	    if (gethistent(curhist - lithistsiz)->lit) {
		zsfree(gethistent(curhist - lithistsiz)->lit);
		gethistent(curhist - lithistsiz)->lit = NULL;
	    }
	curhistent = gethistent(curhist);
	curhistent->lex = chline;
	*(curhistent->lit = zalloc(1)) = '\0';
    } else
	histremmed = 1;
}

/* say we're done using the history mechanism */

int hend()
{				/**/
    int flag, save = 1;
    Histent he;

    if (!chline)
	return 1;
    if (!interact || strin || unset(SHINSTDIN)) {
	zfree(chline, hlinesz);
	return 1;
    }
    flag = histdone;
    histdone = 0;
    if (hptr < chline + 2)
	save = 0;
    else {
	char *s, *t;

	s = curhistent->lit;
	if (*s && (*(t = s + strlen(s) - 1) == HISTSPACE || *t == '\n'))
	    *t = '\0';
	hptr[-1] = '\0';
	if (hptr[-2] == '\n')
	    if (chline[1]) {
		if (hptr[-3] == HISTSPACE)
		    hptr[-3] = '\0';
		else
		    hptr[-2] = '\0';
	    } else
		save = 0;
	he = gethistent(curhist - 1);
	if (!*chline || !strcmp(chline, "\n") ||
	    (isset(HISTIGNOREDUPS) && he->lex && !strcmp(he->lex, chline)) ||
	    (isset(HISTIGNORESPACE) && spaceflag))
	    save = 0;
    }
    if (flag & (HISTFLAG_DONE | HISTFLAG_RECALL)) {
	char *ptr, *p;

	p = ptr = ztrdup(chline);
	for (; *p; p++)
	    if (*p == HISTSPACE)
		*p = ' ';
	if ((flag & (HISTFLAG_DONE | HISTFLAG_RECALL)) == HISTFLAG_DONE) {
	    fprintf(stderr, "%s\n", ptr);
	    fflush(stderr);
	}
	if (flag & HISTFLAG_RECALL) {
	    permalloc();
	    pushnode(bufstack, ptr);
	    lastalloc();
	    save = 0;
	} else
	    zsfree(ptr);
    }
    curhistent->stim = time(NULL);
    curhistent->ftim = 0L;
    curhistent->flags = 0;
    if (!save)
	remhist();
    if (chline && !curhistent->lex)
	zfree(chline, hlinesz);
    if (curhistent->lex) {
	char *s = ztrdup(curhistent->lex);

	zfree(curhistent->lex, hlinesz);
	curhistent->lex = s;
    }
    chline = NULL;
    return !(flag & HISTFLAG_NOEXEC || errflag);
}

/* remove the current line from the history List */

void remhist()
{				/**/
    if (!histremmed) {
	histremmed = 1;
	curhist--;
    }
}

/* begin a word */

void hwbegin()
{				/**/
    hlastw = hptr;
}

/* add a word to the history List */

char *hwadd()
{				/**/
    if (hlastw && chline) {
	hwaddc(HISTSPACE);
	if (alstackind || strin)
	    if (!(alstackind == 1 && !alstack[0]))
		hptr = hlastw;
    }
    if (alstat == ALSTAT_JUNK)
	alstat = 0;
    return hlastw;
}

/* get an argument specification */

int getargspec(argc, marg, evset)	/**/
int argc;
int marg;
int evset;
{
    int c, ret = -1;

    if ((c = hgetch()) == '0')
	return 0;
    if (idigit(c)) {
	ret = 0;
	while (idigit(c)) {
	    ret = ret * 10 + c - '0';
	    c = hgetch();
	}
	hungetch(c);
    } else if (c == '^')
	ret = 1;
    else if (c == '$')
	ret = argc;
    else if (c == '%') {
	if (evset) {
	    herrflush();
	    zerr("Ambiguous history reference", NULL, 0);
	    return -2;
	}
	if (marg == -1) {
	    herrflush();
	    zerr("%% with no previous word matched", NULL, 0);
	    return -2;
	}
	ret = marg;
    } else
	hungetch(c);
    return ret;
}

/* do ?foo? search */

int hconsearch(str, marg)	/**/
char *str;
int *marg;
{
    int t0, t1 = 0;
    char *s, *hs;

    for (t0 = curhist - 1; (hs = quietgetevent(t0)); t0--)
	if ((s = ztrstr(hs, str))) {
	    while (s != hs)
		if (*s-- == HISTSPACE)
		    t1++;
	    *marg = t1;
	    return t0;
	}
    return -1;
}

/* do !foo search */

int hcomsearch(str)		/**/
char *str;
{
    int t0;
    char *hs;

    for (t0 = curhist - 1; (hs = quietgetevent(t0)); t0--)
	if (!strncmp(hs, str, strlen(str)))
	    return t0;
    return -1;
}

/* various utilities for : modifiers */

int remtpath(junkptr)		/**/
char **junkptr;
{
    char *str = *junkptr, *remcut;

    if ((remcut = strrchr(str, '/'))) {
	if (str != remcut)
	    *remcut = '\0';
	else
	    str[1] = '\0';
	return 1;
    }
    return 0;
}

int remtext(junkptr)		/**/
char **junkptr;
{
    char *str = *junkptr, *remcut;

    if ((remcut = strrchr(str, '.')) && remcut != str) {
	*remcut = '\0';
	return 1;
    }
    return 0;
}

int rembutext(junkptr)		/**/
char **junkptr;
{
    char *str = *junkptr, *remcut;

    if ((remcut = strrchr(str, '.')) && remcut != str) {
	*junkptr = dupstring(remcut + 1);	/* .xx or xx? */
	return 1;
    }
    return 0;
}

int remlpaths(junkptr)		/**/
char **junkptr;
{
    char *str = *junkptr, *remcut;

    if ((remcut = strrchr(str, '/'))) {
	*remcut = '\0';
	*junkptr = dupstring(remcut + 1);
	return 1;
    }
    return 0;
}

int makeuppercase(junkptr)	/**/
char **junkptr;
{
    char *str = *junkptr;

    for (; *str; str++)
	*str = tuupper(*str);
    return 1;
}

int makelowercase(junkptr)	/**/
char **junkptr;
{
    char *str = *junkptr;

    for (; *str; str++)
	*str = tulower(*str);
    return 1;
}

int makecapitals(junkptr)	/**/
char **junkptr;
{
    char *str = *junkptr;

    for (; *str;) {
	for (; *str && !ialnum(*str); str++);
	if (*str)
	    *str = tuupper(*str), str++;
	for (; *str && ialnum(*str); str++)
	    *str = tulower(*str);
    }
    return 1;
}

void subst(strptr, in, out, gbal)	/**/
char **strptr;
char *in;
char *out;
int gbal;
{
    char *str = *strptr, *instr = *strptr, *substcut, *sptr, *oldstr;
    int off, inlen, outlen;

    if (!(substcut = (char *)ztrstr(str, in)))
	return;
    inlen = strlen(in);
    sptr = convamps(out, in, inlen);
    outlen = strlen(sptr);

    do {
	*substcut = '\0';
	off = substcut - *strptr + outlen;
	substcut += inlen;
	*strptr = tricat(oldstr = *strptr, sptr, substcut);
	if (oldstr != instr)
	    zsfree(oldstr);
	str = (char *)*strptr + off;
    } while (gbal && (substcut = (char *)ztrstr(str, in)));
}

char *convamps(out, in, inlen)	/**/
char *out;
char *in;
int inlen;
{
    char *ptr, *ret, *pp;
    int slen, sdup = 0;

    for (ptr = out, slen = 0; *ptr; ptr++, slen++)
	if (*ptr == '\\')
	    ptr++, sdup = 1;
	else if (*ptr == '&')
	    slen += inlen - 1, sdup = 1;
    if (!sdup)
	return out;
    ret = pp = (char *)alloc(slen + 1);
    for (ptr = out; *ptr; ptr++)
	if (*ptr == '\\')
	    *pp++ = *++ptr;
	else if (*ptr == '&') {
	    strcpy(pp, in);
	    pp += inlen;
	} else
	    *pp++ = *ptr;
    *pp = '\0';
    return ret;
}

char *makehstr(s)		/**/
char *s;
{
    char *t;

    t = s = dupstring(s);
    for (; *t; t++)
	if (*t == HISTSPACE)
	    *t = ' ';
    return s;
}

char *quietgetevent(ev)		/**/
int ev;
{
    Histent ent;

    if (ev < firsthist() || ev > curhist)
	return NULL;
    ent = gethistent(ev);
    return (lithist) ? ent->lit : ent->lex;
}

char *getevent(ev)		/**/
int ev;
{
    char *ret;

    ret = quietgetevent(ev);
    if (!ret) {
	herrflush();
	zerr("no such event: %d", NULL, ev);
    }
    return ret;
}

int getargc(list)		/**/
char *list;
{
    int argc = 0;

    for (; *list; list++)
	if (*list == HISTSPACE)
	    argc++;
    return argc;
}

char *getargs(elist, arg1, arg2)/**/
char *elist;
int arg1;
int arg2;
{
    char *ret = elist, *retn;
    int acnt = arg2 - arg1 + 1;

    while (arg1--)
	while (*ret && *ret++ != HISTSPACE);
    if (!*ret)
	if (arg1 == -1 && arg2 == 0) {
	    herrflush();
	    zerr("no words available from current command", NULL, 0);
	    return NULL;
	} else {
	    herrflush();
	    zerr("no such word in event", NULL, 0);
	    return NULL;
	}
    retn = ret = dupstring(ret);
    while (acnt > 0) {
	while (*ret && *ret != HISTSPACE)
	    ret++;
	if (*ret == HISTSPACE)
	    *ret = ' ';
	else
	    break;
	acnt--;
    }
    if (acnt > 1 && !*ret) {
	herrflush();
	zerr("no such word in event", NULL, 0);
	return NULL;
    }
    *ret = '\0';
    return retn;
}

void upcase(x)			/**/
char **x;
{
    char *pp = *(char **)x;

    for (; *pp; pp++)
	*pp = tuupper(*pp);
}

void downcase(x)		/**/
char **x;
{
    char *pp = *(char **)x;

    for (; *pp; pp++)
	*pp = tulower(*pp);
}

int quote(tr)			/**/
char **tr;
{
    char *ptr, *rptr, **str = (char **)tr;
    int len = 3;
    int inquotes = 0;

    for (ptr = *str; *ptr; ptr++, len++)
	if (*ptr == '\'') {
	    len += 3;
	    if (!inquotes)
		inquotes = 1;
	    else
		inquotes = 0;
	} else if (inblank(*ptr) && !inquotes && ptr[-1] != '\\')
	    len += 2;
    ptr = *str;
    *str = rptr = (char *)alloc(len);
    *rptr++ = '\'';
    for (; *ptr; ptr++)
	if (*ptr == '\'') {
	    if (!inquotes)
		inquotes = 1;
	    else
		inquotes = 0;
	    *rptr++ = '\'';
	    *rptr++ = '\\';
	    *rptr++ = '\'';
	    *rptr++ = '\'';
	} else if (inblank(*ptr) && !inquotes && ptr[-1] != '\\') {
	    *rptr++ = '\'';
	    *rptr++ = *ptr;
	    *rptr++ = '\'';
	} else
	    *rptr++ = *ptr;
    *rptr++ = '\'';
    *rptr++ = 0;
    str[1] = NULL;
    return 0;
}

int quotebreak(tr)		/**/
char **tr;
{
    char *ptr, *rptr, **str = (char **)tr;
    int len = 3;

    for (ptr = *str; *ptr; ptr++, len++)
	if (*ptr == '\'')
	    len += 3;
	else if (inblank(*ptr))
	    len += 2;
    ptr = *str;
    *str = rptr = (char *)alloc(len);
    *rptr++ = '\'';
    for (; *ptr;)
	if (*ptr == '\'') {
	    *rptr++ = '\'';
	    *rptr++ = '\\';
	    *rptr++ = '\'';
	    *rptr++ = '\'';
	    ptr++;
	} else if (inblank(*ptr)) {
	    *rptr++ = '\'';
	    *rptr++ = *ptr++;
	    *rptr++ = '\'';
	} else
	    *rptr++ = *ptr++;
    *rptr++ = '\'';
    *rptr++ = '\0';
    return 0;
}

void herrflush()
{				/**/
    if (strin)
	hflush();
    else
	while (lastc != '\n' && !lexstop)
	    hgetch();
}

/* read an arbitrary amount of data into a buffer until stop is found */

char *hdynread(stop)		/**/
int stop;
{
    int bsiz = 256, ct = 0, c;
    char *buf = (char *)zalloc(bsiz), *ptr;

    ptr = buf;
    while ((c = hgetch()) != stop && c != '\n' && !lexstop) {
	if (c == '\\')
	    c = hgetch();
	*ptr++ = c;
	if (++ct == bsiz) {
	    buf = realloc(buf, bsiz *= 2);
	    ptr = buf + ct;
	}
    }
    *ptr = 0;
    if (c == '\n') {
	hungetch('\n');
	zerr("delimiter expected", NULL, 0);
	zfree(buf, bsiz);
	return NULL;
    }
    return buf;
}

char *hdynread2(stop)		/**/
int stop;
{
    int bsiz = 256, ct = 0, c;
    char *buf = (char *)zalloc(bsiz), *ptr;

    ptr = buf;
    while ((c = hgetch()) != stop && c != '\n' && !lexstop) {
	if (c == '\n') {
	    hungetch(c);
	    break;
	}
	if (c == '\\')
	    c = hgetch();
	*ptr++ = c;
	if (++ct == bsiz) {
	    buf = realloc(buf, bsiz *= 2);
	    ptr = buf + ct;
	}
    }
    *ptr = 0;
    if (c == '\n')
	hungetch('\n');
    return buf;
}

void inithist()
{				/**/
    histentct = (lithistsiz > histsiz) ? lithistsiz : histsiz;
    histentarr = (Histent) zcalloc(histentct * sizeof *histentarr);
}

void resizehistents()
{				/**/
    int newentct, t0, t1, firstlit, firstlex;
    Histent newarr;

    newentct = (lithistsiz > histsiz) ? lithistsiz : histsiz;
    newarr = (Histent) zcalloc(newentct * sizeof *newarr);
    firstlex = curhist - histsiz + 1;
    firstlit = curhist - lithistsiz + 1;
    t0 = firsthist();
    if (t0 < curhist - newentct)
	t0 = curhist - newentct;
    t1 = t0 % newentct;
    for (; t0 <= curhist; t0++) {
	newarr[t1] = *gethistent(t0);
	if (t0 < firstlex) {
	    zsfree(newarr[t1].lex);
	    newarr[t1].lex = NULL;
	}
	if (t0 < firstlit) {
	    zsfree(newarr[t1].lit);
	    newarr[t1].lit = NULL;
	}
	t1++;
	if (t1 == newentct)
	    t1 = 0;
    }
    free(histentarr);
    histentarr = newarr;
    histentct = newentct;
}

void readhistfile(s, err)	/**/
char *s;
int err;
{
    char buf[1024];
    FILE *in;
    Histent ent;
    time_t tim = time(NULL);

    if (!s)
	return;
    if ((in = fopen(s, "r"))) {
	while (fgets(buf, sizeof(buf), in)) {
	    int l = strlen(buf);
	    char *pt = buf;

	    while (l && buf[l - 1] == '\n') {
		buf[l - 1] = '\0';
		if (l > 1 && buf[l - 2] == '\\') {
		    buf[l - 2] = '\n';
		    fgets(buf + l - 1, sizeof(buf) - (l - 1), in);
		    l = strlen(buf);
		} else
		    break;
	    }
	    for (; *pt; pt++)
		if (*pt == ' ')
		    *pt = HISTSPACE;

	    ent = gethistent(++curhist);
	    pt = buf;
	    if (*pt == ':') {
		pt++;
		ent->stim = atol(pt);
		for (; *pt != ':' && *pt; pt++);
		if (*pt) {
		    pt++;
		    ent->ftim = atol(pt);
		    for (; *pt != ';' && *pt; pt++);
		    if (*pt)
			pt++;
		} else {
		    ent->ftim = t/*
 *
 * init.c - main loop and initialization routines
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define GLOBALS
#include "zsh.h"
#include <pwd.h>

static int noexitct = 0;

void main(argc, argv, envp)	/**/
int argc;
char **argv;
char **envp;
{
    char *zshname;

#ifdef LC_ALL
    setlocale(LC_ALL, "");
#endif
    environ = envp;
    permalloc();
    if (!(zshname = strrchr(argv[0], '/')))
	zshname = argv[0];
    else
	zshname++;
    if (*zshname == '-')
	zshname++;
    setflags(zshname);
    parseargs(argv);
    setmoreflags();
    setupvals(zshname);
    initialize();
    heapalloc();
    runscripts(zshname);
    for (;;) {
	do
	    loop(1);
	while (tok != ENDINPUT);
	if (!(isset(IGNOREEOF) && interact)) {
#if 0
	    if (interact)
		fputs(islogin ? "logout\n" : "exit\n", stderr);
#endif
	    zexit(lastval);
	    continue;
	}
	noexitct++;
	if (noexitct >= 10) {
	    stopmsg = 1;
	    zexit(lastval);
	}
	zerrnam("zsh", (!islogin) ? "use 'exit' to exit."
		: "use 'logout' to logout.", NULL, 0);
    }
}

/* keep executing lists until EOF found */

void loop(toplevel)		/**/
int toplevel;
{
    List list;

    pushheap();
    for (;;) {
	freeheap();
	errflag = 0;
	if (interact && isset(SHINSTDIN))
	    preprompt();
	hbegin();		/* init history mech */
	intr();			/* interrupts on */
	ainit();		/* init alias mech */
	lexinit();
	if (!(list = parse_event())) {	/* if we couldn't parse a list */
	    hend();
	    if (tok == ENDINPUT && !errflag)
		break;
	    continue;
	}
	if (hend()) {
	    if (stopmsg)	/* unset 'you have stopped jobs' flag */
		stopmsg--;
	    execlist(list);
	    if (toplevel)
		noexitct = 0;
	}
	if (ferror(stderr)) {
	    zerr("write error", NULL, 0);
	    clearerr(stderr);
	}
	if (subsh)		/* how'd we get this far in a subshell? */
	    exit(lastval);
	if (((!interact || sourcelevel) && errflag) || retflag)
	    break;
	if (trapreturn) {
	    lastval = trapreturn;
	    trapreturn = 0;
	}
	if (isset('t') && toplevel) {
	    if (sigtrapped[SIGEXIT])
		dotrap(SIGEXIT);
	    exit(lastval);
	}
    }
    popheap();
}

void setflags(zshname)		/**/
const char *zshname;
{
    int c;

    for (c = 0; c != 43; c++)
	opts[c] = OPT_UNSET;
    for (c = 43; c != 128; c++)
	opts[c] = OPT_INVALID;
    for (c = 'a'; c <= 'z'; c++)
	opts[c] = opts[c - 'a' + 'A'] = OPT_UNSET;
    for (c = '0'; c <= '9'; c++)
	opts[c] = OPT_UNSET;
    opts['A'] = OPT_INVALID;
    opts['i'] = (isatty(0)) ? OPT_SET : OPT_UNSET;
    opts[BGNICE] = opts[NOTIFY] = OPT_SET;
    opts[USEZLE] = (interact && SHTTY != -1) ? OPT_SET : OPT_UNSET;
    opts[HASHCMDS] = opts[HASHLISTALL] = opts[HASHDIRS] = OPT_SET;

/* Bourne/Korn mode:
		The following seven options cause zsh to behave more like
		Bourne and Korn shells when invoked as "sh" or "ksh".
		K - don't recognize csh-style history subst
		k - allow interactive comments
		I - don't perform brace expansion
		3 - don't print error for unmatched wildcards
		H - don't query 'rm *'
		y - split parameters using IFS
		KSHOPTIONPRINT - print options ksh-like
		 -- wnp@rcvie.co.at, 1992-05-14
	*/

    if (strcmp(zshname, "sh") == 0 || strcmp(zshname, "ksh") == 0) {
	opts['K'] = opts['k'] = opts['I'] = opts['3'] = OPT_SET;
	opts['H'] = opts['y'] = opts[KSHOPTIONPRINT] = OPT_SET;
	opts[GLOBSUBST] = OPT_SET;
    }
}

static char *cmd;
static int opti = OPT_UNSET;

void parseargs(argv)		/**/
char **argv;
{
    char **x;
    int bk = 0, action;
    Lklist paramlist;

    hackzero = argzero = *argv;
    opts[LOGINSHELL] = (**(argv++) == '-') ? OPT_SET : OPT_UNSET;
    SHIN = 0;
    while (!bk && *argv && (**argv == '-' || **argv == '+')) {
	action = (**argv == '-') ? OPT_SET : OPT_UNSET;
	while (*++*argv) {
	    if ((bk = (**argv == 'b' || **argv == '-')))
		break;
	    if (opts[(int)**argv] == OPT_INVALID) {
		zerr("bad option: -%c", NULL, **argv);
		exit(1);
	    }
	    if (**argv == 'c') {/* -c command */
		argv++;
		if (!*argv) {
		    zerr("string expected after -c", NULL, 0);
		    exit(1);
		}
		cmd = *argv;
		opts[INTERACTIVE] = opti;
		opts['c'] = OPT_SET;
		bk = 1;
		break;
	    } else if (**argv == 'o') {
		int c;

		if (!*++*argv)
		    argv++;
		if (!*argv) {
		    zerr("string expected after -o", NULL, 0);
		    exit(1);
		}
		c = optlookup(*argv);
		if (c == -1)
		    zerr("no such option: %s", *argv, 0);
		else {
		    if (c == 'i')
			opti = action;
		    opts[c] = action;
		}
		break;
	    } else {
		if (**argv == 'i')
		    opti = action;
		opts[(int)**argv] = action;
	    }
	}
	argv++;
    }
    paramlist = newlist();
    if (*argv) {
	if (opts[SHINSTDIN] == OPT_UNSET) {
	    argzero = *argv;
	    if (opts['c'] == OPT_UNSET)
		SHIN = movefd(open(argzero, O_RDONLY));
	    if (SHIN == -1) {
		zerr("can't open input file: %s", argzero, 0);
		exit(1);
	    }
	    opts[INTERACTIVE] = opti;
	    argv++;
	}
	while (*argv)
	    addnode(paramlist, ztrdup(*argv++));
    } else
	opts[SHINSTDIN] = OPT_SET;
    pparams = x = (char **)zcalloc((countnodes(paramlist) + 1) * sizeof(char *));

    while ((*x++ = (char *)getnode(paramlist)));
    free(paramlist);
    argzero = ztrdup(argzero);
}

void setmoreflags()
{				/**/
#ifndef NOCLOSEFUNNYFDS
    int t0;

#endif
    long ttpgrp;

/* stdout,stderr fully buffered */
#ifdef _IOFBF
    setvbuf(stdout, malloc(BUFSIZ), _IOFBF, BUFSIZ);
    setvbuf(stderr, malloc(BUFSIZ), _IOFBF, BUFSIZ);
#else
    setbuffer(stdout, malloc(BUFSIZ), BUFSIZ);
    setbuffer(stderr, malloc(BUFSIZ), BUFSIZ);
#endif
    subsh = 0;
#ifndef NOCLOSEFUNNYFDS
/* this works around a bug in some versions of in.rshd */
    if (isset('c'))
	for (t0 = 3; t0 != 10; t0++)
	    close(t0);
#endif
#ifdef JOB_CONTROL
    opts[MONITOR] = (interact) ? OPT_SET : OPT_UNSET;
    if (jobbing) {
	SHTTY = movefd((isatty(0)) ? dup(0) : open("/dev/tty", O_RDWR));
	if (SHTTY == -1)
	    opts[MONITOR] = OPT_UNSET;
	else {
#if defined(TIOCSETD) && defined(NTTYDISC)
	    int ldisc = NTTYDISC;

	    ioctl(SHTTY, TIOCSETD, (char *)&ldisc);
#endif
	    gettyinfo(&shttyinfo);	/* get tty state */
#if defined(__sgi)
	    if (shttyinfo.tio.c_cc[VSWTCH] <= 0)	/* hack for irises */
		shttyinfo.tio.c_cc[VSWTCH] = CSWTCH;
#endif
	}
#if defined(__sgi) || defined(__386BSD__) || defined(__NetBSD__) || defined(__FreeBSD__)
	attachtty(GETPGRP());
#endif
	if ((mypgrp = GETPGRP()) <= 0)
	    opts[MONITOR] = OPT_UNSET;
	else
	    while ((ttpgrp = gettygrp()) != -1 && ttpgrp != mypgrp) {
		sleep(1);
		mypgrp = GETPGRP();
		if (mypgrp == gettygrp())
		    break;
		killpg(mypgrp, SIGTTIN);
		mypgrp = GETPGRP();
	    }
    } else
	SHTTY = -1;
#else
    opts[MONITOR] = OPT_UNSET;
    SHTTY = movefd((isatty(0)) ? dup(0) : open("/dev/tty", O_RDWR));
    if (SHTTY != -1)
	gettyinfo(&shttyinfo);
#endif
}

SPROTO(long get_baudrate, (int speedcode));

static long get_baudrate(speedcode)
int speedcode;
{
    switch (speedcode) {
    case B0:
	return (0L);
    case B50:
	return (50L);
    case B75:
	return (75L);
    case B110:
	return (110L);
    case B134:
	return (134L);
    case B150:
	return (150L);
    case B200:
	return (200L);
    case B300:
	return (300L);
    case B600:
	return (600L);
#ifdef _B900
    case _B900:
	return (900L);
#endif
    case B1200:
	return (1200L);
    case B1800:
	return (1800L);
    case B2400:
	return (2400L);
#ifdef _B3600
    case _B3600:
	return (3600L);
#endif
    case B4800:
	return (4800L);
#ifdef _B7200
    case _B7200:
	return (7200L);
#endif
    case B9600:
	return (9600L);
#ifdef B19200
    case B19200:
	return (19200L);
#else
#ifdef EXTA
    case EXTA:
	return (19200L);
#endif
#endif
#ifdef B38400
    case B38400:
	return (38400L);
#else
#ifdef EXTB
    case EXTB:
	return (38400L);
#endif
#endif
    default:
	break;
    }
    return (0L);
}

void setupvals(zshname)		/**/
const char *zshname;
{
    struct passwd *pswd;
    char *ptr;
    struct timezone dummy_tz;

    noeval = 0;
    curhist = 0;
    histsiz = DEFAULT_HISTSIZE;
    lithistsiz = 5;
    inithist();
    mailcheck = logcheck = 60;
    keytimeout = 40;
    dirstacksize = -1;
    listmax = 100;
    clwords = (char **)zcalloc((clwsize = 16) * sizeof(char *));

    cmdstack = (unsigned char *)zalloc(256);
    cmdsp = 0;

    reporttime = -1;
    bangchar = '!';
    hashchar = '#';
    hatchar = '^';
    termok = 0;
    curjob = prevjob = coprocin = coprocout = -1;
    gettimeofday(&shtimer, &dummy_tz);	/* init $SECONDS */
    srand((unsigned int)shtimer.tv_sec);
/* build various hash tables; argument to newhtable is table size */
    aliastab = newhtable(37);
    addreswords();
    addhnode(ztrdup("run-help"), mkanode(ztrdup("man"), 1), aliastab, NULL);
    addhnode(ztrdup("which-command"),
	     mkanode(ztrdup("whence"), 1), aliastab, NULL);
    paramtab = newhtable(151);
    cmdnamtab = newhtable(37);
    compctltab = newhtable(13);
    initxbindtab();

/* Bourne/Korn mode:
		The following variable assignments cause zsh to behave more
		like Bourne and Korn shells when invoked as "sh" or "ksh".
		NULLCMD=":"
		READNULLCMD=":"
		 -- chip@fin.uucp, 1992-06-15
	*/
    if (strcmp(zshname, "sh") == 0 || strcmp(zshname, "ksh") == 0) {
	nullcmd = ztrdup(":");
	readnullcmd = ztrdup(":");
    } else {
	nullcmd = ztrdup("cat");
	readnullcmd = ztrdup("more");
    }

    prompt = ztrdup("%m%# ");
    prompt2 = ztrdup("> ");
    prompt3 = ztrdup("?# ");
    prompt4 = ztrdup("+ ");
    sprompt = ztrdup("zsh: correct `%R' to `%r' [nyae]? ");
    term = ztrdup("");
    ppid = getppid();
#ifdef HAS_TIO
#if defined(HAS_TCCRAP) && defined(HAS_TERMIOS)
    baud = cfgetospeed(&shttyinfo.tio);
    if (baud < 100)
	baud = get_baudrate((int)baud);	/* aren't "standards" great?? */
#else
    baud = get_baudrate(shttyinfo.tio.c_cflag & CBAUD);
#endif
#else
    baud = get_baudrate(shttyinfo.sgttyb.sg_ospeed);
#endif
#ifdef TIOCGWINSZ
    if (!(columns = shttyinfo.winsize.ws_col))
	columns = 80;
    if (!(lines = shttyinfo.winsize.ws_row))
	lines = 24;
#else
    columns = 80;
    lines = 24;
#endif
    ifs = ztrdup(" \t\n");
    timefmt = ztrdup(DEFTIMEFMT);
    watchfmt = ztrdup(DEFWATCHFMT);
    if (!(ttystrname = ztrdup(ttyname(SHTTY))))
	ttystrname = ztrdup("");
    wordchars = ztrdup(DEFWORDCHARS);
    fceditparam = ztrdup(DEFFCEDIT);
    tmpprefix = ztrdup(DEFTMPPREFIX);
    postedit = ztrdup("");
    hostnam = (char *)zalloc(256);
    underscore = ztrdup("");
    gethostname(hostnam, 256);
    mypid = getpid();
    cdpath = mkarray(NULL);
    manpath = mkarray(NULL);
    fignore = mkarray(NULL);
    fpath = mkarray(NULL);
    mailpath = mkarray(NULL);
    watch = mkarray(NULL);
    psvar = mkarray(NULL);
    compctlsetup();
    namdirs = (Nameddirs) zcalloc(sizeof(*namdirs) * 2);
    userdirsz = 2;
    userdirct = 0;
    zoptarg = ztrdup("");
    zoptind = 1;
    schedcmds = NULL;
    path = (char **)zalloc(4 * sizeof *path);
    path[0] = ztrdup("/bin");
    path[1] = ztrdup("/usr/bin");
    path[2] = ztrdup("/usr/ucb");
    path[3] = NULL;
    inittyptab();
    initlextabs();
    setupparams();

    if (!home ||
#ifdef SYSV
	!(username = cuserid(NULL))
#else
	!(username = getlogin())
#endif
	) {
	if ((pswd = getpwuid(getuid()))) {
	    username = ztrdup(pswd->pw_name);
	    if (!home)
		home = ztrdup(pswd->pw_dir);
	} else {
	    username = ztrdup("");
	    if (!home)
		home = ztrdup("/");
	}
    }
    if ((ptr = zgetenv("LOGNAME")))
	zlogname = ztrdup(ptr);
    else
	zlogname = ztrdup(username);

    if (ispwd(home))
	pwd = ztrdup(home);
    else if ((ptr = zgetenv("PWD")) && ispwd(ptr))
	pwd = ztrdup(ptr);
    else
	pwd = zgetwd();
    oldpwd = ztrdup(pwd);

    setparams();

    inittyptab();
    if (!strcmp(term, "emacs"))
	opts[USEZLE] = OPT_UNSET;
#ifndef HAS_RUSAGE
    times(&shtms);
#endif
}

void compctlsetup()
{				/**/
    static char
        *os[] =
    {"setopt", "unsetopt", NULL}, *vs[] =
    {"export", "typeset", "vared", "unset", NULL}, *cs[] =
    {"which", "builtin", NULL}, *bs[] =
    {"bindkey", NULL};

    compctl_process(os, CC_OPTIONS, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
		    NULL, NULL, 0);
    compctl_process(vs, CC_VARS, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
		    NULL, NULL, 0);
    compctl_process(bs, CC_BINDINGS, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
		    NULL, NULL, 0);
    compctl_process(cs, CC_COMMPATH, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
		    NULL, NULL, 0);
    cc_compos.mask = CC_COMMPATH;
    cc_default.refc = 10000;
    cc_default.mask = CC_FILES;
}

void initialize()
{				/**/
#ifdef RLIM_INFINITY
    int t0;

#endif

    breaks = loops = 0;
    lastmailcheck = time(NULL);
    locallist = NULL;
    locallevel = sourcelevel = 0;
    trapreturn = 0;
    dirstack = newlist();
    bufstack = newlist();
    newcmdnamtab();
    inbuf = (char *)zalloc(inbufsz = 256);
    inbufptr = inbuf + inbufsz;
    inbufct = 0;
#ifdef RLIM_INFINITY
    for (t0 = 0; t0 != RLIM_NLIMITS; t0++)
	getrlimit(t0, limits + t0);
#endif
    hsubl = hsubr = NULL;
    lastpid = 0;
    bshin = fdopen(SHIN, "r");
    intr();
#ifndef QDEBUG
    sig_ignore(SIGQUIT);
#endif
    sig_handle(SIGHUP);
    sig_handle(SIGCHLD);
    if (interact) {
	sig_handle(SIGALRM);
#ifdef SIGWINCH
	sig_handle(SIGWINCH);
#endif
	sig_ignore(SIGTERM);
    }
    if (jobbing) {
	long ttypgrp;

	while ((ttypgrp = gettygrp()) != -1 && ttypgrp != mypgrp)
	    kill(0, SIGTTIN);
	if (ttypgrp == -1) {
	    opts[MONITOR] = OPT_UNSET;
	} else {
	    sig_ignore(SIGTTOU);
	    sig_ignore(SIGTSTP);
	    sig_ignore(SIGTTIN);
	    sig_ignore(SIGPIPE);
	    attachtty(mypgrp);
	}
    }
#ifdef SIGNAL_MASKS
    if (islogin) {
	sig_setmask(sig_mask(0));
    } else if (interact) {
	sigset_t set;

	sigemptyset(&set);
	sigaddset(&set, SIGINT);
	sigaddset(&set, SIGQUIT);
	sig_unblock(set);
    }
#endif				/* SIGNAL_MASKS */
}

void addreswords()
{				/**/
    static char *reswds[] =
    {
	"do", "done", "esac", "then", "elif", "else", "fi", "for", "case",
	"if", "while", "function", "repeat", "time", "until", "exec", "command",
	"select", "coproc", "noglob", "-", "nocorrect", "foreach", "end", NULL
    };
    int t0;

    for (t0 = 0; reswds[t0]; t0++)
	addhnode(ztrdup(reswds[t0]), mkanode(NULL, -1 - t0), aliastab, NULL);
}

void runscripts(zshname)	/**/
char *zshname;
{
/*
	   KSH Mode:
	   if called as "ksh", we source the standard
	   sh/ksh scripts:
	   wnp@rcvie.co.at 1992/05/14
	 */

    sourcelevel = 32768;	/* hack to avoid errexit in init scripts */

    if (strcmp(zshname, "ksh") == 0) {
	if (islogin)
	    source("/etc/profile");
	if (islogin)
	    sourcehome(".profile");
	if (!isset(KSHPRIV))
	    source(getsparam("ENV"));
	else
	    source("/etc/suid_profile");
    } else {
#ifdef GLOBALZSHENV
	source(GLOBALZSHENV);
#endif
	if (!isset(NORCS)) {
	    sourcehome(".zshenv");
	    if (islogin) {
#ifdef GLOBALZPROFILE
		source(GLOBALZPROFILE);
#endif
		sourcehome(".zprofile");
	    }
	    if (interact) {
#ifdef GLOBALZSHRC
		source(GLOBALZSHRC);
#endif
		sourcehome(".zshrc");
	    }
	    if (islogin) {
#ifdef GLOBALZLOGIN
		source(GLOBALZLOGIN);
#endif
		sourcehome(".zlogin");
	    }
	}
    }
    sourcelevel = 0;

    if (isset('c')) {
	if (SHIN >= 10)
	    close(SHIN);
	SHIN = movefd(open("/dev/null", O_RDONLY));
	execstring(cmd);
	stopmsg = 1;
	zexit(lastval);
    }
    if (interact && !isset(NORCS))
	readhistfile(getsparam("HISTFILE"), 0);
#ifdef TIOCGWINSZ
    adjustwinsize();
#endif
    if (isset('t') && opti == OPT_UNSET)
	prompt = ztrdup("");
}

void ainit()
{				/**/
    alstackind = 0;		/* reset alias stack */
    alstat = 0;
    isfirstln = 1;
}
                                                                                                                                                                                                                                                                                                      /*
 * jobs.c - job control
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"
#include <errno.h>
#include <setjmp.h>

#if defined(POSIX) && !defined(__386BSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__)
#define JMP_BUF       sigjmp_buf
#define SETJMP(b)     sigsetjmp((b), 1)
#define LONGJMP(b,n)  siglongjmp((b), (n))
#else
#define JMP_BUF       jmp_buf
#define SETJMP(b)     setjmp(b)
#define LONGJMP(b,n)  longjmp((b), (n))
#endif

#if defined(RESETHANDNEEDED) && !defined(POSIX)
#define SIGPROCESS(sig)  sig_ignore(sig)
#define SIGRESET(sig)    sig_handle(sig)
#else
#define SIGPROCESS(sig)  ;
#define SIGRESET(sig)    ;
#endif

/* empty job structure for quick clearing of jobtab entries */

static struct job zero;		/* static variables are initialized to zero */

struct timeval dtimeval, now;
struct timezone dummy_tz;

/* Diff two timevals for elapsed-time computations */

struct timeval *dtime(dt, t1, t2)	/**/
struct timeval *dt;
struct timeval *t1;
struct timeval *t2;
{
    dt->tv_sec = t2->tv_sec - t1->tv_sec;
    dt->tv_usec = t2->tv_usec - t1->tv_usec;
    if (dt->tv_usec < 0) {
	dt->tv_usec += 1000000;
	dt->tv_sec -= 1;
    }
    return dt;
}

/* do a safe, race-free sigpause() to wait for SIGCHLD */

static int chld_longjmp = 0;
static struct z_jmp_buf {
    JMP_BUF jbuf;
} foil_race;

void chldhandler DCLPROTO((struct z_jmp_buf * jump));

void chldsuspend(sig)		/**/
int sig;
{
/* assumes blockchld() is in effect */
    if (SETJMP(foil_race.jbuf) == 0) {
	chld_longjmp = 1;
	unblockchld();
	chldpause(sig);
    }
    chld_longjmp = 0;
}

#ifdef INTHANDTYPE
#define RETURN   { SIGRESET(sig); return 0; }
#else
#define RETURN   { SIGRESET(sig); return; }
#endif

static int from_sig = 0;

/* the signal handler */

HANDTYPE handler(sig)		/**/
int sig;
{
    sigset_t heldsigs;
    int do_jump;
    struct z_jmp_buf jump_to;

    SIGPROCESS(sig);

    fast_block(&heldsigs);	/* Prevent signal traps temporarily */

    do_jump = chld_longjmp;
    chld_longjmp = 0;		/* In case a SIGCHLD somehow arrives */

    if (zigheld) {
	zighold(sig, heldsigs);	/* zigsafe() will fast_unblock(&heldsigs) */
	RETURN;
    }
    if (sig == SIGCHLD) {	/* Traps can cause nested chldsuspend() */
	if (do_jump)
	    jump_to = foil_race;/* copy foil_race */
    }
    fast_unblock(&heldsigs);	/* Signal traps OK again (foil_race copied) */

    switch (sig) {
    case SIGHUP:
	if (sigtrapped[SIGHUP])
	    dotrap(SIGHUP);
	else {
	    stopmsg = 1;
	    from_sig = 1;
	    zexit(SIGHUP);
	}
	break;

    case SIGINT:
	if (sigtrapped[SIGINT])
	    dotrap(SIGINT);
	else {
	    breaks = loops;
	    errflag = 1;
	}
	break;

#if defined(SIGWINCH) && defined(TIOCGWINSZ)
    case SIGWINCH:
	adjustwinsize();
	break;
#endif

    case SIGCHLD:
	chldhandler(do_jump ? &jump_to : (struct z_jmp_buf *)0);
	RETURN;

    default:
	dotrap(sig);
	if (sig == SIGALRM) {
	    if (!sigtrapped[SIGALRM]) {
		zerr("timeout", NULL, 0);
		exit(1);
	    } else if (tmout) {
		alarm(tmout);
	    }
	}
	break;
    }

    RETURN;
}

#undef RETURN

#define RETURN \
    if (jump) { SIGRESET(SIGCHLD); LONGJMP(jump->jbuf, 1); } else return

void chldhandler(jump)
struct z_jmp_buf *jump;
{
    long pid;
    int statusp;
    Job jn;
    struct process *pn;

#ifdef HAS_RUSAGE
    struct rusage ru;

#else
    long chlds, chldu;

#endif

    for (;;) {
	int old_errno = errno;

#ifdef HAS_RUSAGE
	pid = wait3((vptr) & statusp, WNOHANG | WUNTRACED, &ru);
#else
#ifndef WNOHANG
	pid = wait(&statusp);
#else
#ifdef HAS_WAITPID
	pid = waitpid(-1, (vptr) & statusp, WNOHANG | WUNTRACED);
#else
	pid = wait3((vptr) & statusp, WNOHANG | WUNTRACED, NULL);
#endif
#endif
	chlds = shtms.tms_cstime;
	chldu = shtms.tms_cutime;
	times(&shtms);
#endif
	if (pid == -1) {
	    if (errno != ECHILD)
		zerr("wait failed: %e", NULL, errno);
	    errno = old_errno;
	    RETURN;
	}
	errno = old_errno;
	if (!pid)
	    RETURN;
	if (pid == cmdoutpid) {
	    cmdoutdone(statusp);
	    continue;
	}
	findproc(pid, &jn, &pn);/* find the process of this pid */
	if (jn) {
	    pn->statusp = statusp;
#ifdef HAS_RUSAGE
	    pn->ti.ru = ru;
#else
	    pn->ti.st = shtms.tms_cstime - chlds;
	    pn->ti.ut = shtms.tms_cutime - chldu;
#endif
	    gettimeofday(&pn->endtime, &dummy_tz);
	    updatestatus(jn);
	}
#if 0
	else if (WIFSTOPPED(statusp))
	    kill(pid, SIGKILL);	/* kill stopped untraced children */
#endif
    }
}

#undef RETURN

/* clean up after a $() or `` substitution */

void cmdoutdone(statusp)	/**/
int statusp;
{
    cmdoutpid = 0;
    if (WIFSIGNALED(statusp)) {
	cmdoutval = (0200 | WTERMSIG(statusp));
	if (WTERMSIG(statusp) == SIGINT)
	    (void)kill(getpid(), SIGINT);
	else if (sigtrapped[WTERMSIG(statusp)])
	    dotrap(WTERMSIG(statusp));
    } else
	cmdoutval = WEXITSTATUS(statusp);
}

/* change job table entry from stopped to running */

void makerunning(jn)		/**/
Job jn;
{
    struct process *pn;

    jn->stat &= ~STAT_STOPPED;
    for (pn = jn->procs; pn; pn = pn->next)
	if (WIFSTOPPED(pn->statusp))
	    pn->statusp = SP_RUNNING;
}

/* update status of job, possibly printing it */

void updatestatus(jn)		/**/
Job jn;
{
    struct process *pn;
    int notrunning = 1, alldone = 1, val = 0, job = jn - jobtab;
    int statusp = 0, somestopped = 0, inforeground = 0;
    int pgrp;

    pgrp = gettygrp();
    for (pn = jn->procs; pn; pn = pn->next) {
	if (pn->statusp == SP_RUNNING)
	    notrunning = 0;
	if (pn->statusp == SP_RUNNING || WIFSTOPPED(pn->statusp))
	    alldone = 0;
	if (WIFSTOPPED(pn->statusp))
	    somestopped = 1;
	if (!pn->next && jn)
	    val = (WIFSIGNALED(pn->statusp)) ?
		0200 | WTERMSIG(pn->statusp) : WEXITSTATUS(pn->statusp);
	if (pn->pid == jn->gleader) {
	    statusp = pn->statusp;
	    if (pgrp == 0 || pn->pid == pgrp || 
		(pgrp > 1 && kill(-pgrp, 0) == -1))
		inforeground = 1;
	}
    }
    if (!notrunning)
	return;
    if (somestopped) {
	if (jn->stty_in_env && !jn->ty) {
	    jn->ty = (struct ttyinfo *)zalloc(sizeof(struct ttyinfo));

	    gettyinfo(jn->ty);
	}
	if (jn->stat & STAT_STOPPED)
	    return;
    }
    if (alldone && job == thisjob)
	lastval = val;
    if (alldone)
	lastval2 = val;
    if (inforeground && !ttyfrozen && !val && !jn->stty_in_env)
	gettyinfo(&shttyinfo);
#ifdef TIOCGWINSZ
    adjustwinsize();
#endif
    jn->stat |= (alldone) ? STAT_CHANGED | STAT_DONE :
	STAT_CHANGED | STAT_STOPPED;
    if ((jn->stat & (STAT_DONE | STAT_STOPPED)) == STAT_STOPPED) {
	prevjob = curjob;
	curjob = job;
    }
    if ((isset(NOTIFY) || job == thisjob) && (jn->stat & STAT_LOCKED)) {
	printjob(jn, !!isset(LONGLISTJOBS));
	if (zleactive)
	    refresh();
    }
    if (sigtrapped[SIGCHLD] && job != thisjob)
	dotrap(SIGCHLD);

 /* If the foreground job got a signal, pretend we got it, too. */
    if (inforeground && WIFSIGNALED(statusp)) {
	if (sigtrapped[WTERMSIG(statusp)]) {
	    dotrap(WTERMSIG(statusp));
	} else if (WTERMSIG(statusp) == SIGINT ||
		   WTERMSIG(statusp) == SIGQUIT) {
	    breaks = loops;
	    errflag = 1;
	}
    }
}

/* find process and job associated with pid */

void findproc(pid, jptr, pptr)	/**/
int pid;
Job *jptr;
struct process **pptr;
{
    struct process *pn;
    int jn;

    for (jn = 1; jn != MAXJOB; jn++)
	for (pn = jobtab[jn].procs; pn; pn = pn->next)
	    if (pn->pid == pid) {
		*pptr = pn;
		*jptr = jobtab + jn;
		return;
	    }
    *pptr = NULL;
    *jptr = NULL;
}

/*
	lng = 0 means jobs
	lng = 1 means jobs -l
	lng = 2 means jobs -p
*/

void printjob(jn, lng)		/**/
Job jn;
int lng;
{
    int job = jn - jobtab, len = 9, sig, sflag = 0, llen;
    int conted = 0, lineleng = columns, skip = 0, doputnl = 0;
    struct process *pn;

    if (lng < 0) {
	conted = 1;
	lng = 0;
    }
/* find length of longest signame, check to see if we
		really need to print this job */

    for (pn = jn->procs; pn; pn = pn->next) {
	if (pn->statusp != SP_RUNNING)
	    if (WIFSIGNALED(pn->statusp)) {
		sig = WTERMSIG(pn->statusp);
		llen = strlen(sigmsg[sig]);
		if (WCOREDUMP(pn->statusp))
		    llen += 14;
		if (llen > len)
		    len = llen;
		if (sig != SIGINT && sig != SIGPIPE)
		    sflag = 1;
		else if (sig == SIGINT)
		    errflag = 1;
		if (job == thisjob && sig == SIGINT)
		    doputnl = 1;
	    } else if (WIFSTOPPED(pn->statusp)) {
		sig = WSTOPSIG(pn->statusp);
		if ((int)strlen(sigmsg[sig]) > len)
		    len = strlen(sigmsg[sig]);
		if (job == thisjob && sig == SIGTSTP)
		    doputnl = 1;
	    } else if (isset(PRINTEXITVALUE) && isset(SHINSTDIN) &&
		       WEXITSTATUS(pn->statusp))
		sflag = 1;
    }

/* print if necessary */

    if (interact && jobbing && ((jn->stat & STAT_STOPPED) || sflag ||
				job != thisjob)) {
	int len2, fline = 1;
	struct process *qn;

	trashzle();
	if (doputnl)
	    putc('\n', stderr);
	for (pn = jn->procs; pn;) {
	    len2 = ((job == thisjob) ? 5 : 10) + len;	/* 2 spaces */
	    if (lng)
		qn = pn->next;
	    else
		for (qn = pn->next; qn; qn = qn->next) {
		    if (qn->statusp != pn->statusp)
			break;
		    if ((int)strlen(qn->text) + len2 + ((qn->next) ? 3 : 0) > lineleng)
			break;
		    len2 += strlen(qn->text) + 2;
		}
	    if (job != thisjob)
		if (fline)
		    fprintf(stderr, "[%ld]  %c ",
			    (long)(jn - jobtab),
			    (job == curjob) ? '+'
			    : (job == prevjob) ? '-' : ' ');
		else
		    fprintf(stderr, (job > 9) ? "        " : "       ");
	    else
		fprintf(stderr, "zsh: ");
	    if (lng)
		if (lng == 1)
		    fprintf(stderr, "%ld ", pn->pid);
		else {
		    int x = jn->gleader;

		    fprintf(stderr, "%d ", x);
		    do
			skip++;
		    while ((x /= 10));
		    skip++;
		    lng = 0;
	    } else
		fprintf(stderr, "%*s", skip, "");
	    if (pn->statusp == SP_RUNNING)
		if (!conted)
		    fprintf(stderr, "running%*s", len - 7 + 2, "");
		else
		    fprintf(stderr, "continued%*s", len - 9 + 2, "");
	    else if (WIFEXITED(pn->statusp))
		if (WEXITSTATUS(pn->statusp))
		    fprintf(stderr, "exit %-4d%*s", WEXITSTATUS(pn->statusp),
			    len - 9 + 2, "");
		else
		    fprintf(stderr, "done%*s", len - 4 + 2, "");
	    else if (WIFSTOPPED(pn->statusp))
		fprintf(stderr, "%-*s", len + 2, sigmsg[WSTOPSIG(pn->statusp)]);
	    else if (WCOREDUMP(pn->statusp))
		fprintf(stderr, "%s (core dumped)%*s",
			sigmsg[WTERMSIG(pn->statusp)],
			(int)(len - 14 + 2 - strlen(sigmsg[WTERMSIG(pn->statusp)])), "");
	    else
		fprintf(stderr, "%-*s", len + 2, sigmsg[WTERMSIG(pn->statusp)]);
	    for (; pn != qn; pn = pn->next)
		fprintf(stderr, (pn->next) ? "%s | " : "%s", pn->text);
	    putc('\n', stderr);
	    fline = 0;
	}
    } else if (doputnl && interact)
	putc('\n', stderr);
    fflush(stderr);

/* print "(pwd now: foo)" messages */

    if (interact && job == thisjob && strcmp(jn->pwd, pwd)) {
	printf("(pwd now: ");
	printdir(pwd);
	printf(")\n");
	fflush(stdout);
    }
/* delete job if done */

    if (jn->stat & STAT_DONE) {
	if ((jn->stat & STAT_TIMED) || (reporttime != -1 && report(jn))) {
	    dumptime(jn);
	}
	deletejob(jn);
	if (job == curjob) {
	    curjob = prevjob;
	    prevjob = job;
	}
	if (job == prevjob)
	    setprevjob();
    } else
	jn->stat &= ~STAT_CHANGED;
}

void deletejob(jn)		/**/
Job jn;
{
    struct process *pn, *nx;
    char *s;

    for (pn = jn->procs; pn; pn = nx) {
	nx = pn->next;
	zfree(pn, sizeof(struct process));
    }
    zsfree(jn->pwd);
    if (jn->filelist) {
	while ((s = (char *)getnode(jn->filelist))) {
	    unlink(s);
	    zsfree(s);
	}
	zfree(jn->filelist, sizeof(struct lklist));
    }
    if (jn->ty)
	zfree(jn->ty, sizeof(struct ttyinfo));

    *jn = zero;
}

/* set the previous job to something reasonable */

void setprevjob()
{				/**/
    int t0;

    for (t0 = MAXJOB - 1; t0; t0--)
	if ((jobtab[t0].stat & STAT_INUSE) && (jobtab[t0].stat & STAT_STOPPED) &&
	    t0 != curjob && t0 != thisjob)
	    break;
    if (!t0)
	for (t0 = MAXJOB - 1; t0; t0--)
	    if ((jobtab[t0].stat & STAT_INUSE) && t0 != curjob && t0 != thisjob)
		break;
    prevjob = (t0) ? t0 : -1;
}

/* initialize a job table entry */

void initjob()
{				/**/
    jobtab[thisjob].pwd = ztrdup(pwd);
    jobtab[thisjob].stat = STAT_INUSE;
    jobtab[thisjob].gleader = 0;
}

/* add a process to the current job */

void addproc(pid, text)		/**/
long pid;
char *text;
{
    struct process *process;

    if (!jobtab[thisjob].gleader)
	jobtab[thisjob].gleader = pid;
    process = (struct process *)zcalloc(sizeof *process);
    process->pid = pid;
    if (text)
	strcpy(process->text, text);
    else
	*process->text = '\0';
    process->next = NULL;
    process->statusp = SP_RUNNING;
    gettimeofday(&process->bgtime, &dummy_tz);
    if (jobtab[thisjob].procs) {
	struct process *n;

	for (n = jobtab[thisjob].procs; n->next; n = n->next);
	process->next = NULL;
	n->next = process;
    } else
	jobtab[thisjob].procs = process;
}

/* determine if it's all right to exec a command without
	forking in last component of subshells; it's not ok if we have files
	to delete */

int execok()
{				/**/
    Job jn;

    if (!exiting)
	return 0;
    for (jn = jobtab + 1; jn != jobtab + MAXJOB; jn++)
	if (jn->stat && jn->filelist)
	    return 0;
    return 1;

}

void waitforpid(pid)		/**/
long pid;
{
/* blockchld() around this loop in case #ifndef WNOHANG */
    blockchld();		/* unblocked in chldsuspend() */
    while (!errflag && (kill(pid, 0) >= 0 || errno != ESRCH)) {
	chldsuspend(SIGINT);
	blockchld();
    }
    unblockchld();
}

/* wait for a job to finish */

void waitjob(job, sig)		/**/
int job;
int sig;
{
    Job jn = jobtab + job;

    blockchld();		/* unblocked during chldsuspend() */
    if (jn->procs) {		/* if any forks were done */
	jn->stat |= STAT_LOCKED;
	if (jn->stat & STAT_CHANGED)
	    printjob(jobtab + job, !!isset(LONGLISTJOBS));
	while (!errflag && jn->stat &&
	       !(jn->stat & STAT_DONE) &&
	       !(interact && (jn->stat & STAT_STOPPED))) {
	    chldsuspend(sig);
	    blockchld();
	}
    } else
	deletejob(jobtab + job);
    unblockchld();
}

/* wait for running job to finish */

void waitjobs()
{				/**/
    waitjob(thisjob, 0);
    thisjob = -1;
}

/* clear job table when entering subshells */

void clearjobtab()
{				/**/
    int t0;

    for (t0 = 1; t0 != MAXJOB; t0++) {
	if (jobtab[t0].pwd)
	    zsfree(jobtab[t0].pwd);
	if (jobtab[t0].ty)
	    zfree(jobtab[t0].ty, sizeof(struct ttyinfo));

	jobtab[t0] = zero;
    }
}

/* get a free entry in the job table to use */

int getfreejob()
{				/**/
    int t0;

    for (t0 = 1; t0 != MAXJOB; t0++)
	if (!jobtab[t0].stat) {
	    jobtab[t0].stat |= STAT_INUSE;
	    return t0;
	}
    zerr("job table full or recursion limit exceeded", NULL, 0);
    return -1;
}

/* print pids for & */

void spawnjob()
{				/**/
    struct process *pn;

    if (!subsh) {
	if (curjob == -1 || !(jobtab[curjob].stat & STAT_STOPPED)) {
	    curjob = thisjob;
	    setprevjob();
	} else if (prevjob == -1 || !(jobtab[prevjob].stat & STAT_STOPPED))
	    prevjob = thisjob;
	if (interact && jobbing && jobtab[thisjob].procs) {
	    fprintf(stderr, "[%d]", thisjob);
	    for (pn = jobtab[thisjob].procs; pn; pn = pn->next)
		fprintf(stderr, " %ld", pn->pid);
	    fprintf(stderr, "\n");
	    fflush(stderr);
	}
    }
    if (!jobtab[thisjob].procs)
	deletejob(jobtab + thisjob);
    else
	jobtab[thisjob].stat |= STAT_LOCKED;
    thisjob = -1;
}

int report(j)			/**/
Job j;
{
    if (!j->procs)
	return 0;
#ifdef HAS_RUSAGE
    return (j->procs->ti.ru.ru_utime.tv_sec + j->procs->ti.ru.ru_stime.tv_sec)
	>= reporttime;
#else
    return (j->procs->ti.ut + j->procs->ti.st) / HZ >= reporttime;
#endif
}

void printtime(real, ti, desc)	/**/
struct timeval *real;
struct timeinfo *ti;
char *desc;
{
    char *s;
    long real100;

#ifdef HAS_RUSAGE
#ifdef sun
    long ticks = 1;
    int pk = getpagesize() / 1024;

#else
    long sec;

#endif
    struct rusage *ru = &ti->ru;

#endif

    if (!desc)
	desc = "";
#ifdef HAS_RUSAGE
#ifdef sun
    ticks = (ru->ru_utime.tv_sec + ru->ru_stime.tv_sec) * HZ +
	(ru->ru_utime.tv_usec + ru->ru_stime.tv_usec) * HZ / 1000000;
    if (!ticks)
	ticks = 1;
#else
    sec = ru->ru_utime.tv_sec + ru->ru_stime.tv_sec;
    if (!sec)
	sec = 1;
#endif
#endif
    for (s = timefmt; *s; s++)
	if (*s == '%')
	    switch (s++, *s) {
	    case 'E':
		fprintf(stderr, "%ld.%03lds",
			(long)real->tv_sec, (long)real->tv_usec / 1000);
		break;
#ifndef HAS_RUSAGE
	    case 'U':
		fprintf(stderr, "%ld.%03lds",
			ti->ut / HZ, ti->ut * 1000 / HZ % 1000);
		break;
	    case 'S':
		fprintf(stderr, "%ld.%03lds",
			ti->st / HZ, ti->st * 1000 / HZ % 1000);
		break;
	    case 'P':
		if (real->tv_sec > 21000) {
		    real100 = (real->tv_sec + 99) / 100;
		    fprintf(stderr, "%d%%",
			    (int)((ti->ut + ti->st) / HZ) / real100);
		} else {
		    if ((real100 = real->tv_sec * 1000 + real->tv_usec / 1000))
			fprintf(stderr, "%d%%",
				(int)(100000 * ((ti->ut + ti->st) / HZ)) / real100);
		}
		break;
#else
	    case 'U':
		fprintf(stderr, "%ld.%03lds",
			(long)ru->ru_utime.tv_sec,
			(long)ru->ru_utime.tv_usec / 1000);
		break;
	    case 'S':
		fprintf(stderr, "%ld.%03lds",
			(long)ru->ru_stime.tv_sec,
			(long)ru->ru_stime.tv_usec / 1000);
		break;
	    case 'P':
		if (real->tv_sec > 21000) {
		    real100 = (real->tv_sec + 99) / 100;
		    fprintf(stderr, "%ld%%",
			    (ru->ru_utime.tv_sec + ru->ru_stime.tv_sec) / real100);
		} else {
		    if ((real100 = real->tv_sec * 1000 + real->tv_usec / 1000))
			fprintf(stderr, "%ld%%",
				(100000 * (ru->ru_utime.tv_sec + ru->ru_stime.tv_sec)
				 +
				 (ru->ru_utime.tv_usec + ru->ru_stime.tv_usec) / 10)
				/ real100);
		}
		break;
	    case 'W':
		fprintf(stderr, "%ld", ru->ru_nswap);
		break;
#ifdef sun
	    case 'K':
	    case 'D':
		fprintf(stderr, "%ld", ru->ru_idrss / ticks * pk);
		break;
	    case 'M':
		fprintf(stderr, "%ld", ru->ru_maxrss * pk);
		break;
#else
	    case 'X':
		fprintf(stderr, "%ld", ru->ru_ixrss / sec);
		break;
	    case 'D':
		fprintf(stderr, "%ld",
			(ru->ru_idrss + ru->ru_isrss) / sec);
		break;
	    case 'K':
		fprintf(stderr, "%ld",
			(ru->ru_ixrss + ru->ru_idrss + ru->ru_isrss) / sec);
		break;
	    case 'M':
		fprintf(stderr, "%ld", ru->ru_maxrss / 1024);
		break;
#endif
	    case 'F':
		fprintf(stderr, "%ld", ru->ru_majflt);
		break;
	    case 'R':
		fprintf(stderr, "%ld", ru->ru_minflt);
		break;
	    case 'I':
		fprintf(stderr, "%ld", ru->ru_inblock);
		break;
	    case 'O':
		fprintf(stderr, "%ld", ru->ru_oublock);
		break;
	    case 'r':
		fprintf(stderr, "%ld", ru->ru_msgrcv);
		break;
	    case 's':
		fprintf(stderr, "%ld", ru->ru_msgsnd);
		break;
	    case 'k':
		fprintf(stderr, "%ld", ru->ru_nsignals);
		break;
	    case 'w':
		fprintf(stderr, "%ld", ru->ru_nvcsw);
		break;
	    case 'c':
		fprintf(stderr, "%ld", ru->ru_nivcsw);
		break;
#endif
	    case 'J':
		fprintf(stderr, "%s", desc);
		break;
	    default:
		fprintf(stderr, "%%%c", *s);
		break;
	} else
	    putc(*s, stderr);
    putc('\n', stderr);
    fflush(stderr);
}

void dumptime(jn)		/**/
Job jn;
{
    struct process *pn;

    if (!jn->procs)
	return;
    for (pn = jn->procs; pn; pn = pn->next)
	printtime(dtime(&dtimeval, &pn->bgtime, &pn->endtime), &pn->ti, pn->text);
}

void shelltime()
{				/**/
    struct timeinfo ti;

#ifdef HAS_RUSAGE
    struct rusage ru;

    getrusage(RUSAGE_SELF, &ru);
    memcpy(&ti.ru, &ru, sizeof(ru));
    gettimeofday(&now, &dummy_tz);
    printtime(dtime(&dtimeval, &shtimer, &now), &ti, "shell");

    getrusage(RUSAGE_CHILDREN, &ru);
    memcpy(&ti.ru, &ru, sizeof(ru));
    printtime(dtime(&dtimeval, &shtimer, &now), &ti, "children");
#else
    struct tms buf;

    times(&buf);
    ti.ut = buf.tms_utime;
    ti.st = buf.tms_stime;
    gettimeofday(&now, &dummy_tz);
    printtime(dtime(&dtimeval, &shtimer, &now), &ti, "shell");
    ti.ut = buf.tms_cutime;
    ti.st = buf.tms_cstime;
    printtime(dtime(&dtimeval, &shtimer, &now), &ti, "children");
#endif
}

/* SIGHUP any jobs left running */

void killrunjobs()
{				/**/
    int t0, killed = 0;

    if (isset(NOHUP))
	return;
    for (t0 = 1; t0 != MAXJOB; t0++)
	if ((from_sig || t0 != thisjob) && (jobtab[t0].stat & STAT_LOCKED) &&
	    !(jobtab[t0].stat & STAT_STOPPED)) {
	    if (killpg(jobtab[t0].gleader, SIGHUP) != -1)
		killed++;
	}
    if (killed)
	zerr("warning: %d jobs SIGHUPed", NULL, killed);
}

/* check to see if user has jobs running/stopped */

void checkjobs()
{				/**/
    int t0;

    scanjobs();
    for (t0 = 1; t0 != MAXJOB; t0++)
	if (t0 != thisjob && jobtab[t0].stat & STAT_LOCKED)
	    break;
    if (t0 != MAXJOB) {
	if (jobtab[t0].stat & STAT_STOPPED) {
#ifdef USE_SUSPENDED
	    zerr("you have suspended jobs.", NULL, 0);
#else
	    zerr("you have stopped jobs.", NULL, 0);
#endif
	} else
	    zerr("you have running jobs.", NULL, 0);
	stopmsg = 1;
    }
}

/* send a signal to a job (simply involves kill if monitoring is on) */

int killjb(jn, sig)		/**/
Job jn;
int sig;
{
    struct process *pn;
    int err = 0;

    if (jobbing)
	return (killpg(jn->gleader, sig));
    for (pn = jn->procs; pn; pn = pn->next)
	if ((err = kill(pn->pid, sig)) == -1 && errno != ESRCH)
	    return -1;
    return err;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /^[^{]*\/\*\*\/$/{
s/^\(.*\)(.*$/\1 DCLPROTO((/
h
:loop
n
s/;/,/
H
tloop
g
s/,\n{/));/
s/\n//g
s/{.*$/void));/
p
}

/^{.*\/\*\*\/$/{
g
s/^\([^(]*\)(.*$/\1 DCLPROTO((void));/
p
d
}

h
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 *
 * lex.c - lexical analysis
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"

/* lexical state */

static int dbparens, in_brace_param = 0;
int len = 0, bsiz = 256;
char *bptr;

struct lexstack {
    struct lexstack *next;

    int incmdpos;
    int incond;
    int incasepat;
    int dbparens;
    int in_brace_param;
    int alstat;
    char *hlastw;
    int isfirstln;
    int isfirstch;
    int histremmed;
    int histdone;
    int spaceflag;
    int stophist;
    int lithist;
    int alstackind;
    int hlinesz;
    char *hline;
    char *hptr;
    char *tokstr;
    char *bptr;
    int bsiz;

    unsigned char *cstack;
    int csp;
};

static struct lexstack *lstack = NULL;

/* save the lexical state */

/* is this a hack or what? */

void lexsave()
{				/**/
    struct lexstack *ls;

    ls = (struct lexstack *)malloc(sizeof(struct lexstack));

    ls->incmdpos = incmdpos;
    ls->incond = incond;
    ls->incasepat = incasepat;
    ls->dbparens = dbparens;
    ls->in_brace_param = in_brace_param;
    ls->alstat = alstat;
    ls->alstackind = alstackind;
    ls->isfirstln = isfirstln;
    ls->isfirstch = isfirstch;
    ls->histremmed = histremmed;
    ls->histdone = histdone;
    ls->spaceflag = spaceflag;
    ls->stophist = stophist;
    ls->lithist = lithist;
    ls->hline = chline;
    ls->hptr = hptr;
    ls->hlastw = hlastw;
    ls->hlinesz = hlinesz;
    ls->cstack = cmdstack;
    ls->csp = cmdsp;
    cmdstack = (unsigned char *)zalloc(256);
    ls->tokstr = tokstr;
    ls->bptr = bptr;
    ls->bsiz = bsiz;
    in_brace_param = 0;
    cmdsp = 0;
    inredir = 0;

    ls->next = lstack;
    lstack = ls;
}

/* restore lexical state */

void lexrestore()
{				/**/
    struct lexstack *ln;

    if (!lstack) {
	zerr("lexrestore without lexsave", NULL, 0);
	return;
    }
    incmdpos = lstack->incmdpos;
    incond = lstack->incond;
    incasepat = lstack->incasepat;
    dbparens = lstack->dbparens;
    in_brace_param = lstack->in_brace_param;
    alstat = lstack->alstat;
    isfirstln = lstack->isfirstln;
    isfirstch = lstack->isfirstch;
    histremmed = lstack->histremmed;
    histdone = lstack->histdone;
    spaceflag = lstack->spaceflag;
    stophist = lstack->stophist;
    lithist = lstack->lithist;
    chline = lstack->hline;
    hptr = lstack->hptr;
    hlastw = lstack->hlastw;
    if (cmdstack)
	free(cmdstack);
    cmdstack = lstack->cstack;
    cmdsp = lstack->csp;
    tokstr = lstack->tokstr;
    bptr = lstack->bptr;
    bsiz = lstack->bsiz;
    clearalstack();
    alstackind = lstack->alstackind;
    hlinesz = lstack->hlinesz;
    lexstop = errflag = 0;

    ln = lstack->next;
    free(lstack);
    lstack = ln;
}

void yylex()
{				/**/
    if (tok == LEXERR)
	return;
    do
	tok = gettok();
    while (tok != ENDINPUT && exalias());
    if (tok != NEWLIN)
	isnewlin = 0;
    else
	isnewlin = (inbufct) ? -1 : 1;
    if (tok == SEMI || tok == NEWLIN)
	tok = SEPER;
}

void ctxtlex()
{				/**/
    static int oldpos;

    yylex();
    switch (tok) {
    case SEPER:
    case NEWLIN:
    case SEMI:
    case DSEMI:
    case AMPER:
    case INPAR:
    case INBRACE:
    case DBAR:
    case DAMPER:
    case BAR:
    case BARAMP:
    case INOUTPAR:
    case DO:
    case THEN:
    case ELIF:
    case ELSE:
	incmdpos = 1;
	break;
    case STRING:		/* case ENVSTRING: */
    case ENVARRAY:
    case OUTPAR:
    case CASE:
	incmdpos = 0;
	break;
    }
    if (IS_REDIROP(tok) || tok == FOR || tok == FOREACH || tok == SELECT) {
	inredir = 1;
	oldpos = incmdpos;
	incmdpos = 0;
    } else if (inredir) {
	incmdpos = oldpos;
	inredir = 0;
    }
}

#define LX1_BKSLASH 0
#define LX1_COMMENT 1
#define LX1_NEWLIN 2
#define LX1_SEMI 3
#define LX1_BANG 4
#define LX1_AMPER 5
#define LX1_BAR 6
#define LX1_INPAR 7
#define LX1_OUTPAR 8
#define LX1_INBRACE 9
#define LX1_OUTBRACE 10
#define LX1_INBRACK 11
#define LX1_OUTBRACK 12
#define LX1_INANG 13
#define LX1_OUTANG 14
#define LX1_OTHER 15

#define LX2_BREAK 0
#define LX2_OUTPAR 1
#define LX2_BAR 2
#define LX2_STRING 3
#define LX2_INBRACK 4
#define LX2_OUTBRACK 5
#define LX2_TILDE 6
#define LX2_INPAR 7
#define LX2_INBRACE 8
#define LX2_OUTBRACE 9
#define LX2_OUTANG 10
#define LX2_INANG 11
#define LX2_EQUALS 12
#define LX2_BKSLASH 13
#define LX2_QUOTE 14
#define LX2_DQUOTE 15
#define LX2_BQUOTE 16
#define LX2_OTHER 17

unsigned char lexact1[256], lexact2[256], lextok2[256];

void initlextabs()
{				/**/
    int t0;
    static char *lx1 = "\\q\n;!&|(){}[]<>xx";
    static char *lx2 = "x)|$[]~({}><=\\\'\"`x";

    for (t0 = 0; t0 != 256; t0++) {
	lexact1[t0] = LX1_OTHER;
	lexact2[t0] = LX2_OTHER;
	lextok2[t0] = t0;
    }
    for (t0 = 0; lx1[t0]; t0++)
	if (lx1[t0] != 'x')
	    lexact1[(int)lx1[t0]] = t0;
    for (t0 = 0; lx2[t0]; t0++)
	if (lx2[t0] != 'x')
	    lexact2[(int)lx2[t0]] = t0;
    lexact2[';'] = LX2_BREAK;
    lexact2['&'] = LX2_BREAK;
    lextok2[','] = Comma;
    lextok2['*'] = Star;
    lextok2['?'] = Quest;
    lextok2['{'] = Inbrace;
    lextok2['['] = Inbrack;
    lextok2['$'] = String;
}

/* initialize lexical state */

void lexinit()
{				/**/
    incond = incasepat = nocorrect =
    dbparens = alstat = lexstop = in_brace_param = 0;
    incmdpos = 1;
    tok = ENDINPUT;
    if (isset(EXTENDEDGLOB)) {
	lextok2['#'] = Pound;
	lextok2['^'] = Hat;
    } else {
	lextok2['#'] = '#';
	lextok2['^'] = '^';
    }
}

/* add a char to the string buffer */

void add(c)			/**/
int c;
{
    *bptr++ = c;
    if (bsiz == ++len) {
	int newbsiz;

	newbsiz = bsiz * 8;
	while (newbsiz < inbufct)
	    newbsiz *= 2;
	bptr = len + (tokstr = (char *)hrealloc(tokstr, bsiz, newbsiz));
	bsiz = newbsiz;
    }
}

SPROTO(void unadd, (void));

static void unadd()
{
    bptr--;
    len--;
}

int gettok()
{				/**/
    int bct = 0, pct = 0, brct = 0;
    int c, d, intpos = 1;
    int peekfd = -1, peek, ninbracks, intick;

  beginning:
    hlastw = NULL;
    tokstr = NULL;
    parbegin = -1;
    while (iblank(c = hgetc()) && !lexstop);
    isfirstln = 0;
    wordbeg = inbufct;
    hwbegin();
    hwaddc(c);
    if (dbparens) {
	hungetc(c);
	c = '\"';
    } else if (idigit(c)) {	/* handle 1< foo */
	d = hgetc();
	hungetc(d);
	lexstop = 0;
	if (d == '>' || d == '<') {
	    peekfd = c - '0';
	    c = hgetc();
	}
    }
/* chars in initial position in word */

    if (c == hashchar &&
	(isset(INTERACTIVECOMMENTS) ||
	 (!zleparse && (!interact || unset(SHINSTDIN) || strin)))) {
    /* History is handled here to prevent extra newlines
		 * being inserted into the history.
		 *
		 * Also ignore trailing spaces to prevent history from
		 * changing. If trailing spaces are not ignored then
		 * each time a comment inside a command (a 'for' loop
		 * is a good example) is seen an extra space is appended
		 * to the end of the comment causing a new history entry
		 * even if HISTIGNOREDUPS is set.
		 */
	int nsp = 0;		/* number of contiguos spaces */

	while ((c = hgetch()) != '\n' && !lexstop) {
	    if (c == ' ')
		++nsp;
	    else {
		while (nsp) {
		    hwaddc(' ');
		    --nsp;
		}
		hwaddc(c);
	    }
	}
	if (errflag)
	    peek = LEXERR;
	else {
	    hwadd();
	    hwbegin();
	    hwaddc('\n');
	    peek = NEWLIN;
	}
	return peek;
    }
    if (lexstop)
	return (errflag) ? LEXERR : ENDINPUT;
    switch (lexact1[(unsigned char)c]) {
    case LX1_BKSLASH:
	d = hgetc();
	if (d == '\n')
	    goto beginning;
	hungetc(d);
	break;
    case LX1_NEWLIN:
	return NEWLIN;
    case LX1_SEMI:
	d = hgetc();
	if (d != ';') {
	    hungetc(d);
	    return SEMI;
	}
	return DSEMI;
    case LX1_BANG:
	d = hgetc();
	hungetc(d);
	if (!inblank(d))
	    break;
	if (incmdpos || incond)
	    return BANG;
	break;
    case LX1_AMPER:
	d = hgetc();
	if (d != '&') {
	    hungetc(d);
	    return AMPER;
	}
	return DAMPER;
    case LX1_BAR:
	d = hgetc();
	if (d == '|')
	    return DBAR;
	else if (d == '&')
	    return BARAMP;
	hungetc(d);
	return BAR;
    case LX1_INPAR:
	d = hgetc();
	if (d == '(' && incmdpos) {
	    dbparens = 1;
	    return DINPAR;
	} else if (d == ')')
	    return INOUTPAR;
	hungetc(d);
	if (!(incond == 1 || incmdpos))
	    break;
	return INPAR;
    case LX1_OUTPAR:
	return OUTPAR;
    case LX1_INBRACE:
	if (!incmdpos)
	    break;
	return INBRACE;
    case LX1_OUTBRACE:
	return OUTBRACE;
    case LX1_INBRACK:
	if (!incmdpos)
	    break;
	d = hgetc();
	if (d == '[')
	    return DINBRACK;
	hungetc(d);
	break;
    case LX1_OUTBRACK:
	if (!incond)
	    break;
	d = hgetc();
	if (d == ']')
	    return DOUTBRACK;
	hungetc(d);
	break;
    case LX1_INANG:
	d = hgetc();
	if ((!incmdpos && d == '(') || incasepat) {
	    hungetc(d);
	    break;
	} else if (idigit(d) || d == '-' || d == '>') {
	    int tbs = 256, n = 0, nc;
	    char *tbuf, *tbp, *ntb;

	    tbuf = tbp = (char *)zalloc(tbs);
	    hungetc(d);

	    while ((nc = hgetc()) && !lexstop) {
		if (!idigit(nc) && nc != '-')
		    break;
		*tbp++ = (char)nc;
		if (++n == tbs) {
		    ntb = (char *)realloc(tbuf, tbs *= 2);
		    tbp += ntb - tbuf;
		    tbuf = ntb;
		}
	    }
	    if (nc == '>' && !lexstop) {
		lexstop = 0;
		hungetc(nc);
		while (n--)
		    hungetc(*--tbp);
		zfree(tbuf, tbs);
		break;
	    }
	    lexstop = 0;
	    if (nc)
		hungetc(nc);
	    while (n--)
		hungetc(*--tbp);
	    zfree(tbuf, tbs);
	    peek = INANG;
	} else if (d == '<') {
	    int e = hgetc();

	    if (e == '(') {
		hungetc(e);
		hungetc(d);
		peek = INANG;
	    } else if (e == '<')
		peek = TRINANG;
	    else if (e == '-')
		peek = DINANGDASH;
	    else {
		hungetc(e);
		peek = DINANG;
	    }
	} else if (d == '&')
	    peek = INANGAMP;
	else {
	    peek = INANG;
	    hungetc(d);
	}
	tokfd = peekfd;
	return peek;
    case LX1_OUTANG:
	d = hgetc();
	if (d == '(') {
	    hungetc(d);
	    break;
	} else if (d == '&') {
	    d = hgetc();
	    if (d == '!')
		peek = OUTANGAMPBANG;
	    else {
		hungetc(d);
		peek = OUTANGAMP;
	    }
	} else if (d == '!')
	    peek = OUTANGBANG;
	else if (d == '>') {
	    d = hgetc();
	    if (d == '&') {
		d = hgetc();
		if (d == '!')
		    peek = DOUTANGAMPBANG;
		else {
		    hungetc(d);
		    peek = DOUTANGAMP;
		}
	    } else if (d == '!')
		peek = DOUTANGBANG;
	    else if (d == '(') {
		hungetc(d);
		hungetc('>');
		peek = OUTANG;
	    } else {
		hungetc(d);
		peek = DOUTANG;
		if (isset(NOCLOBBER))
		    hwaddc('!');
	    }
	} else {
	    hungetc(d);
	    peek = OUTANG;
	    if (!incond && isset(NOCLOBBER))
		hwaddc('!');
	}
	tokfd = peekfd;
	return peek;
    }

/* we've started a string, now get the rest of it, performing
		tokenization */

    peek = STRING;
    len = 0;
    bptr = tokstr = (char *)ncalloc(bsiz = 256);
    for (;;) {
	int act;
	int e;
	int endchar;

	if (inblank(c) && !bct && !pct)
	    act = LX2_BREAK;
	else {
	    act = lexact2[(unsigned char)c];
	    c = lextok2[(unsigned char)c];
	}
	switch (act) {
	case LX2_BREAK:
	    if (!in_brace_param)
		goto brk;
	    break;
	case LX2_OUTPAR:
	    if (!pct)
		goto brk;
	    c = Outpar;
	    pct--;
	    break;
	case LX2_BAR:
	    if (!pct && !incasepat)
		goto brk;
	    c = Bar;
	    break;
	case LX2_STRING:
	    e = hgetc();
	    if (e == '[') {
		cmdpush(CS_MATHSUBST);
		add(String);
		add(Inbrack);
		ninbracks = 1;
		while (ninbracks && (c = hgetc()) && !lexstop) {
		    if (c == '[')
			ninbracks++;
		    else if (c == ']')
			ninbracks--;
		    if (ninbracks)
			add(c);
		}
		c = Outbrack;
		cmdpop();
	    } else if (e == '(') {
		add(String);
		if (skipcomm()) {
		    peek = LEXERR;
		    goto brk;
		}
		c = Outpar;
	    } else {
		if (e == '{')
		    in_brace_param = 1;
		hungetc(e);
	    }
	    break;
	case LX2_INBRACK:
	    brct++;
	    break;
	case LX2_OUTBRACK:
	    if (incond && !brct)
		goto brk;
	    brct--;
	    c = Outbrack;
	    break;
	case LX2_TILDE:	/* if (intpos) */
	    c = Tilde;
	    break;
	case LX2_INPAR:
	    e = hgetc();
	    hungetc(e);
	    if (e == ')' ||
		(incmdpos && !brct && peek != ENVSTRING))
		goto brk;
	    pct++;
	    c = Inpar;
	    break;
	case LX2_INBRACE:
	    bct++;
	    break;
	case LX2_OUTBRACE:
	    if (!bct)
		goto brk;
	    if (!--bct && in_brace_param)
		in_brace_param = 0;
	    c = Outbrace;
	    break;
	case LX2_OUTANG:
	    e = hgetc();
	    if (e != '(') {
		hungetc(e);
		goto brk;
	    }
	    add(Outang);
	    if (skipcomm()) {
		peek = LEXERR;
		goto brk;
	    }
	    c = Outpar;
	    break;
	case LX2_INANG:
	    e = hgetc();
	    if (!(idigit(e) || e == '-' || e == '>' || e == '(' || e == ')')) {
		hungetc(e);
		goto brk;
	    }
	    c = Inang;
	    if (e == '(') {
		add(c);
		if (skipcomm()) {
		    peek = LEXERR;
		    goto brk;
		}
		c = Outpar;
	    } else if (e == ')')
		hungetc(e);
	    else {
		add(c);
		c = e;
		while (c != '>' && !lexstop)
		    add(c), c = hgetc();
		c = Outang;
	    }
	    break;
	case LX2_EQUALS:
	    if (intpos) {
		e = hgetc();
		if (e != '(') {
		    hungetc(e);
		    c = Equals;
		} else {
		    add(Equals);
		    if (skipcomm()) {
			peek = LEXERR;
			goto brk;
		    }
		    c = Outpar;
		}
	    } else if (peek != ENVSTRING && incmdpos && !bct) {
		e = hgetc();
		if (e == '(' && incmdpos) {
		    *bptr = '\0';
		    return ENVARRAY;
		}
		hungetc(e);
		peek = ENVSTRING;
		intpos = 2;
	    } else
		c = Equals;
	    break;
	case LX2_BKSLASH:
	    c = hgetc();
	    if (c == '\n') {
		c = hgetc();
		continue;
	    }
	    add(Bnull);
	    add(c);
	    c = hgetc();
	    continue;
	case LX2_QUOTE:
	    add(Snull);

	/* we add the Nularg to prevent this:

				echo $PA'TH'

				from printing the path. */

	    cmdpush(CS_QUOTE);
	    for (;;) {
		while ((c = hgetc()) != '\'' && !lexstop) {
		    if (isset(CSHJUNKIEQUOTES) && c == '\n') {
			if (bptr[-1] == '\\')
			    unadd();
			else
			    break;
		    }
		    add(c);
		}
		if (c != '\'') {
		    zerr("unmatched \'", NULL, 0);
		    peek = LEXERR;
		    cmdpop();
		    goto brk;
		}
		e = hgetc();
		if (e != '\'' || unset(RCQUOTES))
		    break;
		add(c);
	    }
	    cmdpop();
	    hungetc(e);
	    c = Snull;
	    break;
	case LX2_DQUOTE:
	    add(Dnull);
	    cmdpush(dbparens ? CS_MATH : CS_DQUOTE);	/* math or dquote */
	    endchar = dbparens ? ')' : '"';
	    intick = 0;
	    while (((c = hgetc()) != endchar || (dbparens && pct > 0))
		   && !lexstop)
		if (c == '\\') {
		    c = hgetc();
		    if (c != '\n') {
			add(c == '$' || c == '\\' ||
			    c == '\"' || c == '`' ? Bnull : '\\');
			add(c);
		    }
		} else {
		    if (isset(CSHJUNKIEQUOTES) && c == '\n') {
			if (bptr[-1] == '\\')
			    unadd();
			else
			    break;
		    }
		    if (c == '$' && !intick) {
			e = hgetc();
			if (e == '(') {
			    add(Qstring);
			    if (skipcomm()) {
				peek = LEXERR;
				cmdpop();
				goto brk;
			    }
			    c = Outpar;
			} else if (e == '[') {
			    add(String);
			    add(Inbrack);
			    while ((c = hgetc()) != ']' && !lexstop)
				add(c);
			    c = Outbrack;
			} else {
			    c = Qstring;
			    hungetc(e);
			}
		    } else if (c == '`') {
			c = Qtick;
			intick = !intick;
		    } else if (dbparens) {
			if (c == '(')
			    pct++;
			else if (c == ')')
			    pct--;
		    }
		    add(c);
		}
	    cmdpop();
	    if (c != endchar || (dbparens && (pct || (c = hgetc()) != ')'))) {
		if (!dbparens)
		    zerr("unmatched \"", NULL, 0);
		peek = LEXERR;
		goto brk;
	    }
	    if (dbparens) {
		dbparens = 0;
		add(Dnull);
		*bptr = '\0';
		return DOUTPAR;
	    }
	    c = Dnull;
	    break;
	case LX2_BQUOTE:
	    add(Tick);
	    cmdpush(CS_BQUOTE);
	    parbegin = inbufct;
	    while ((c = hgetc()) != '`' && !lexstop)
		if (c == '\\') {
		    c = hgetc();
		    if (c != '\n') {
			add(c == '`' || c == '\\' || c == '$' ? Bnull : '\\');
			add(c);
		    }
		} else {
		    if (isset(CSHJUNKIEQUOTES) && c == '\n') {
			if (bptr[-1] == '\\')
			    unadd();
			else
			    break;
		    }
		    add(c);
		}
	    cmdpop();
	    if (c != '`') {
		if (!zleparse)
		    zerr("unmatched `", NULL, 0);
		peek = LEXERR;
		goto brk;
	    }
	    c = Tick;
	    parbegin = -1;
	    break;
	}
	add(c);
	c = hgetc();
	if (intpos)
	    intpos--;
	if (lexstop)
	    break;
    }
  brk:
    hungetc(c);
    *bptr = '\0';
    return peek;
}

/* expand aliases, perhaps */

int exalias()
{				/**/
    struct alias *an;
    char *s, *t;

    s = yytext = hwadd();
    for (t = s; *t && *t != HISTSPACE; t++);
    if (!*t)
	t = NULL;
    else
	*t = '\0';
    if (interact && isset(SHINSTDIN) && !strin && !incasepat && tok == STRING &&
	(isset(CORRECTALL) || (isset(CORRECT) && incmdpos)) && !nocorrect)
	spckword(&tokstr, &s, &t, !incmdpos, 1);
    if (zleparse && !alstackind) {
	int zp = zleparse;

	gotword(s);
	if (zp && !zleparse) {
	    if (t)
		*t = HISTSPACE;
	    return 0;
	}
    }
    an = noaliases ? NULL : (struct alias *)gethnode(s, aliastab);
    if (t)
	*t = HISTSPACE;
    if (alstackind != MAXAL && an && !an->inuse)
	if (!(an->cmd && !incmdpos && alstat != ALSTAT_MORE)) {
	    if (an->cmd < 0) {
		tok = DO - an->cmd - 1;
		return 0;
	    } else {
		an->inuse = 1;
		hungets(ALPOPS);
		hungets((alstack[alstackind++] = an)->text);
		alstat = 0;
	    /* remove from history if it begins with space */
		if (isset(HISTIGNORESPACE) && an->text[0] == ' ')
		    remhist();
		lexstop = 0;
		return 1;
	    }
	}
    return 0;
}

/* skip (...) */

int skipcomm()
{				/**/
    int pct = 1, c;

    cmdpush(CS_CMDSUBST);
    parbegin = inbufct;
    c = Inpar;
    do {
	add(c);
	c = hgetc();
	if (itok(c) || lexstop)
	    break;
	else if (c == '(')
	    pct++;
	else if (c == ')')
	    pct--;
	else if (c == '\\') {
	    add(c);
	    c = hgetc();
	} else if (c == '\'') {
	    add(c);
	    while ((c = hgetc()) != '\'' && !lexstop)
		add(c);
	} else if (c == '\"') {
	    add(c);
	    while ((c = hgetc()) != '\"' && !lexstop)
		if (c == '\\') {
		    add(c);
		    add(hgetc());
		} else
		    add(c);
	} else if (c == '`') {
	    add(c);
	    while ((c = hgetc()) != '`' && !lexstop)
		if (c == '\\')
		    add(c), add(hgetc());
		else
		    add(c);
	}
    }
    while (pct);
    if (!lexstop)
	parbegin = -1;
    cmdpop();
    return lexstop;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  #define VERSIONSTR "zsh 2.5.0"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  wtabsz;
    uct = utabsz;
    uptr = utab;
    wptr = wtab;
    if (errflag) {
	free(utab);
	return;
    }
    while ((uct || wct) && !errflag)
	if (!uct || (wct && ucmp(uptr, wptr) > 0))
	    wct--, watchlog(0, wptr++, s, fmt);
	else if (!wct || (uct && ucmp(uptr, wptr) < 0))
	    uct--, watchlog(1, uptr++, s, fmt);
	else
	    uptr++, wptr++, wct--, uct--;
    free(wtab);
    wtab = utab;
    wtabsz = utabsz;
    fflush(stdout);
}

int bin_log(nam, argv, ops, func)	/**/
char *nam;
char **argv;
char *ops;
int func;
{
    if (!watch)
	return 1;
    if (wtab)
	free(wtab);
    wtab = (struct utmp *)zalloc(1);
    wtabsz = 0;
    lastutmpcheck = 0;
    dowatch();
    return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /*
 *
 * loop.c - loop execution
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"

int execfor(cmd)		/**/
Cmd cmd;
{
    List list;
    struct forcmd *node;
    char *str;
    Lklist args;
    int cj = thisjob;

    loops++;
    exiting = lastval = 0;
    node = cmd->u.forcmd;
    args = cmd->args;
    if (!node->inflag) {
	char **x;

	args = newlist();
	for (x = pparams; *x; x++)
	    addnode(args, ztrdup(*x));
    }
    pushheap();
    while ((str = (char *)ugetnode(args))) {
	setsparam(node->name, ztrdup(str));
	list = (List) dupstruct(node->list);
	execlist(list);
	if (breaks) {
	    breaks--;
	    if (breaks || !contflag)
		break;
	    contflag = 0;
	}
	if (errflag) {
	    lastval = 1;
	    break;
	}
	freeheap();
    }
    popheap();
    thisjob = cj;
    loops--;
    return lastval;
}

int execselect(cmd)		/**/
Cmd cmd;
{
    List list;
    struct forcmd *node;
    char *str, *s;
    Lklist args;
    Lknode n;
    int cj = thisjob, t0;
    FILE *inp;

    node = cmd->u.forcmd;
    args = cmd->args;
    if (!node->inflag) {
	char **x;

	args = newlist();
	for (x = pparams; *x; x++)
	    addnode(args, ztrdup(*x));
    }
    if (empty(args))
	return 1;
    loops++;
    exiting = lastval = 0;
    pushheap();
    inp = fdopen(dup((SHTTY == -1) ? 0 : SHTTY), "r");
    for (;;) {
	do {
	    int pl;

	    selectlist(args);
	    str = putprompt(prompt3, &pl, 0);
	    if (full(bufstack))
		str = (char *)getnode(bufstack);
	    else if (interact && SHTTY != -1 && isset(USEZLE)) {
		str = (char *)zleread((unsigned char *)str, NULL, pl, 0);
	    } else {
		fprintf(stderr, "%s", str);
		fflush(stderr);
		str = fgets(zalloc(256), 256, inp);
	    }
	    if (!str || errflag) {
		if (breaks)
		    breaks--;
		fprintf(stderr, "\n");
		fflush(stderr);
		goto done;
	    }
	    if ((s = strchr(str, '\n')))
		*s = '\0';
	}
	while (!*str);
	setsparam("REPLY", ztrdup(str));
	t0 = atoi(str);
	if (!t0)
	    str = "";
	else {
	    for (t0--, n = firstnode(args); n && t0; incnode(n), t0--);
	    if (n)
		str = (char *)getdata(n);
	    else
		str = "";
	}
	setsparam(node->name, ztrdup(str));
	list = (List) dupstruct(node->list);
	execlist(list);
	freeheap();
	if (breaks) {
	    breaks--;
	    if (breaks || !contflag)
		break;
	    contflag = 0;
	}
	if (errflag)
	    break;
    }
  done:
    popheap();
    fclose(inp);
    thisjob = cj;
    loops--;
    return lastval;
}

int execwhile(cmd)		/**/
Cmd cmd;
{
    List list;
    struct whilecmd *node;
    int cj = thisjob, osl = sourcelevel;

    node = cmd->u.whilecmd;
    exiting = lastval = 0;
    pushheap();
    loops++;
    for (;;) {
	int oldval = lastval;

	list = (List) dupstruct(node->cont);
	sourcelevel |= 32768;
	execlist(list);
	sourcelevel = osl;
	if (!((lastval == 0) ^ node->cond)) {
	    if (breaks)
		breaks--;
	    lastval = oldval;
	    break;
	}
	list = (List) dupstruct(node->loop);
	execlist(list);
	if (breaks) {
	    breaks--;
	    if (breaks || !contflag)
		break;
	    contflag = 0;
	}
	freeheap();
	if (errflag) {
	    lastval = 1;
	    break;
	}
    }
    popheap();
    thisjob = cj;
    loops--;
    return lastval;
}

int execrepeat(cmd)		/**/
Cmd cmd;
{
    List list;
    int cj = thisjob, count;

    exiting = lastval = 0;
    if (empty(cmd->args) || nextnode(firstnode(cmd->args))) {
	zerr("bad argument for repeat", NULL, 0);
	return 1;
    }
    count = atoi(peekfirst(cmd->args));
    pushheap();
    loops++;
    while (count--) {
	list = (List) dupstruct(cmd->u.list);
	execlist(list);
	freeheap();
	if (breaks) {
	    breaks--;
	    if (breaks || !contflag)
		break;
	    contflag = 0;
	}
	if (errflag) {
	    lastval = 1;
	    break;
	}
    }
    popheap();
    thisjob = cj;
    loops--;
    return lastval;
}

int execif(cmd)			/**/
Cmd cmd;
{
    struct ifcmd *node;
    int cj = thisjob, osl = sourcelevel;
    List *i, *t;

    node = cmd->u.ifcmd;
    exiting = 0;
    i = node->ifls;
    t = node->thenls;

    sourcelevel |= 32768;
    while (*i) {
	execlist(*i);
	if (!lastval)
	    break;
	i++;
	t++;
    }
    sourcelevel = osl;

    if (*t)
	execlist(*t);
    else
	lastval = 0;

    thisjob = cj;
    return lastval;
}

int execcase(cmd)		/**/
Cmd cmd;
{
    struct casecmd *node;
    char *word;
    Lklist args;
    int cj = thisjob;
    List *l;
    char **p;

    node = cmd->u.casecmd;
    args = cmd->args;
    l = node->lists;
    p = node->pats;

    exiting = lastval = 0;
    if (firstnode(args) && nextnode(firstnode(args))) {
	zerr("too many arguments to case", NULL, 0);
	return 1;
    }
    if (empty(args))
	word = dupstring("");
    else
	word = (char *)peekfirst(args);

    if (node) {
	while (*p) {
	    singsub(p);
	    if (matchpat(word, *p))
		break;
	    p++;
	    l++;
	}
	if (*l)
	    execlist(*l);
    }
    thisjob = cj;
    return lastval;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /**/
char *name;
char *value;
{
    char **ep, **ep2, **ep3;
    int envct;

    for (ep = environ; *ep; ep++) {
	char *s = *ep, *t = name;

	while (*s && *s == *t)
	    s++, t++;
	if (*s == '=' && !*t) {
	    zsfree(*ep);
	    return *ep = mkenvstr(name, value);
	}
    }
    envct = arrlen(environ);
    ep = ep2 = (char **)zalloc((sizeof(char *)) * (envct + 3));

    for (ep3 = environ; (*ep2 = *ep3); ep3++, ep2++);
    *ep2 = mkenvstr(name, value);
    ep2[1] = NULL;
    free(environ);
    environ = ep;
    return *ep2;
}

void delenv(x)			/**/
char *x;
{
    char **ep;

    ep = environ;
    for (; *ep; ep++)
	if (*ep == x)
	    break;
    if (*ep)
	for (; (ep[0] = ep[1]); ep++);
}

void convbase(s, v, base)	/**/
char *s;
long v;
int base;
{
    int digs = 0;
    long x;

    if (base <= 1)
	base = 10;
    x = v;
    if (x < 0) {
	x = -x;
	digs++;
    }
    for (; x; digs++)
	x /= base;
    if (!digs)
	digs = 1;
    s[digs--] = '\0';
    x = (v < 0) ? -v : v;
    while (digs >= 0) {
	int dig = x % base;

	s[digs--] = (dig < 10) ? '0' + dig : dig - 10 + 'A';
	x /= base;
    }
    if (v < 0)
	s[0] = '-';
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /*
 *
 * math.c - mathematical expression evaluation
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"

static char *ptr;

static long yyval;
static LV yylval;

static int mlevel = 0;

/* != 0 means recognize unary plus, minus, etc. */

static int unary = 1;

void mathparse DCLPROTO((int));

/* LR = left-to-right associativity
	RL = right-to-left associativity
	BOO = short-circuiting boolean */

#define LR 0
#define RL 1
#define BOOL 2

#define M_INPAR 0
#define M_OUTPAR 1
#define NOT 2
#define COMP 3
#define POSTPLUS 4
#define POSTMINUS 5
#define UPLUS 6
#define UMINUS 7
#define AND 8
#define XOR 9
#define OR 10
#define MUL 11
#define DIV 12
#define MOD 13
#define PLUS 14
#define MINUS 15
#define SHLEFT 16
#define SHRIGHT 17
#define LES 18
#define LEQ 19
#define GRE 20
#define GEQ 21
#define DEQ 22
#define NEQ 23
#define DAND 24
#define DOR 25
#define DXOR 26
#define QUEST 27
#define COLON 28
#define EQ 29
#define PLUSEQ 30
#define MINUSEQ 31
#define MULEQ 32
#define DIVEQ 33
#define MODEQ 34
#define ANDEQ 35
#define XOREQ 36
#define OREQ 37
#define SHLEFTEQ 38
#define SHRIGHTEQ 39
#define DANDEQ 40
#define DOREQ 41
#define DXOREQ 42
#define COMMA 43
#define EOI 44
#define PREPLUS 45
#define PREMINUS 46
#define NUM 47
#define ID 48
#define PARAM 49
#define POWER 50
#define CID 51
#define CPARAM 52
#define POWEREQ 53
#define TOKCOUNT 54

/* precedences */

static int prec[TOKCOUNT] =
{
    1, 137, 2, 2, 2,
    2, 2, 2, 4, 5,
    6, 7, 7, 7, 8,
    8, 3, 3, 9, 9,
    9, 9, 10, 10, 11,
    12, 12, 13, 13, 14,
    14, 14, 14, 14, 14,
    14, 14, 14, 14, 14,
    14, 14, 14, 15, 200,
    2, 2, 0, 0, 0,
    8, 0, 0, 14
};

#define TOPPREC 15
#define ARGPREC (15-1)

static int type[TOKCOUNT] =
{
    LR, LR, RL, RL, RL,
    RL, RL, RL, LR, LR,
    LR, LR, LR, LR, LR,
    LR, LR, LR, LR, LR,
    LR, LR, LR, LR, BOOL,
    BOOL, LR, RL, RL, RL,
    RL, RL, RL, RL, RL,
    RL, RL, RL, RL, RL,
    BOOL, BOOL, RL, RL, RL,
    RL, RL, LR, LR, LR,
    RL, LR, LR, RL
};

#define LVCOUNT 32

/* list of lvalues (variables) */

static int lvc;
static char *lvals[LVCOUNT];

int zzlex()
{				/**/
    int cct = 0;

    for (;; cct = 0)
	switch (*ptr++) {
	case '+':
	    if (*ptr == '+' && (unary || !ialnum(*ptr))) {
		ptr++;
		return (unary) ? PREPLUS : POSTPLUS;
	    }
	    if (*ptr == '=') {
		unary = 1;
		ptr++;
		return PLUSEQ;
	    }
	    return (unary) ? UPLUS : PLUS;
	case '-':
	    if (*ptr == '-' && (unary || !ialnum(*ptr))) {
		ptr++;
		return (unary) ? PREMINUS : POSTMINUS;
	    }
	    if (*ptr == '=') {
		unary = 1;
		ptr++;
		return MINUSEQ;
	    }
	    return (unary) ? UMINUS : MINUS;
	case '(':
	    unary = 1;
	    return M_INPAR;
	case ')':
	    return M_OUTPAR;
	case '!':
	    if (*ptr == '=') {
		unary = 1;
		ptr++;
		return NEQ;
	    }
	    return NOT;
	case '~':
	    return COMP;
	case '&':
	    unary = 1;
	    if (*ptr == '&') {
		if (*++ptr == '=') {
		    ptr++;
		    return DANDEQ;
		}
		return DAND;
	    } else if (*ptr == '=') {
		ptr++;
		return ANDEQ;
	    }
	    return AND;
	case '|':
	    unary = 1;
	    if (*ptr == '|') {
		if (*++ptr == '=') {
		    ptr++;
		    return DOREQ;
		}
		return DOR;
	    } else if (*ptr == '=') {
		ptr++;
		return OREQ;
	    }
	    return OR;
	case '^':
	    unary = 1;
	    if (*ptr == '^') {
		if (*++ptr == '=') {
		    ptr++;
		    return DXOREQ;
		}
		return DXOR;
	    } else if (*ptr == '=') {
		ptr++;
		return XOREQ;
	    }
	    return XOR;
	case '*':
	    unary = 1;
	    if (*ptr == '*') {
		if (*++ptr == '=') {
		    ptr++;
		    return POWEREQ;
		}
		return POWER;
	    }
	    if (*ptr == '=') {
		ptr++;
		return MULEQ;
	    }
	    return MUL;
	case '/':
	    unary = 1;
	    if (*ptr == '=') {
		ptr++;
		return DIVEQ;
	    }
	    return DIV;
	case '%':
	    unary = 1;
	    if (*ptr == '=') {
		ptr++;
		return MODEQ;
	    }
	    return MOD;
	case '<':
	    unary = 1;
	    if (*ptr == '<') {
		if (*++ptr == '=') {
		    ptr++;
		    return SHLEFTEQ;
		}
		return SHLEFT;
	    } else if (*ptr == '=') {
		ptr++;
		return LEQ;
	    }
	    return LES;
	case '>':
	    unary = 1;
	    if (*ptr == '>') {
		if (*++ptr == '=') {
		    ptr++;
		    return SHRIGHTEQ;
		}
		return SHRIGHT;
	    } else if (*ptr == '=') {
		ptr++;
		return GEQ;
	    }
	    return GRE;
	case '=':
	    unary = 1;
	    if (*ptr == '=') {
		ptr++;
		return DEQ;
	    }
	    return EQ;
	case '?':
	    unary = 1;
	    return QUEST;
	case ':':
	    unary = 1;
	    return COLON;
	case ',':
	    unary = 1;
	    return COMMA;
	case '\0':
	    unary = 1;
	    ptr--;
	    return EOI;
	case '[':
	    unary = 0;
	    {
		int base = zstrtol(ptr, &ptr, 10);

		if (*ptr == ']')
		    ptr++;
		yyval = zstrtol(ptr, &ptr, lastbase = base);
		return NUM;
	    }
	case ' ':
	case '\t':
	case '\n':
	    break;
	case '#':
	    if (*ptr == '\\') {
		ptr++;
		yyval = (long)*ptr++;
		return NUM;
	    } else
		cct = 1, *--ptr = '$', ptr++;
	/* fall through */
	default:
	    if (idigit(*--ptr)) {
		unary = 0;
		yyval = zstrtol(ptr, &ptr, 10);

		if (*ptr == '#') {
		    ptr++;
		    yyval = zstrtol(ptr, &ptr, lastbase = yyval);
		}
		return NUM;
	    }
	    if (iident(*ptr)) {
		char *p, q;

		p = ptr;
		if (lvc == LVCOUNT) {
		    zerr("too many identifiers (complain to author)", NULL, 0);
		    return EOI;
		}
		unary = 0;
		while (iident(*++ptr));
		q = *ptr;
		*ptr = '\0';
		lvals[yylval = lvc++] = ztrdup(p);
		*ptr = q;
		return cct ? CID : ID;
	    } else if (*ptr == '$') {
		char *p, t;
		int l;

		unary = 0;

		if (lvc == LVCOUNT) {
		    zerr("too many identifiers (complain to author)", NULL, 0);
		    return EOI;
		}
		p = ptr++;
		*p = String;

		if (p[1] == '{') {
		    for (ptr++, l = 0; *ptr && (*ptr != '}' || l); ptr++) {
			if (*ptr == '{')
			    l++;
			if (*ptr == '}')
			    l--;
			if (*ptr == '\\' && ptr[1])
			    ptr++;
		    }
		    if (*ptr) {
			ptr++;
			t = *ptr;
			*ptr = '\0';
			lvals[yylval = lvc++] = ztrdup(p);
			*ptr = t;
			*p = '$';
			return cct ? CPARAM : PARAM;
		    }
		    yyval = 0;
		    *p = '$';
		    return NUM;
		} else if (p[1] == '(') {
		    for (ptr++, l = 0; *ptr && (*ptr != ')' || l); ptr++) {
			if (*ptr == '(')
			    l++;
			if (*ptr == ')')
			    l--;
			if (*ptr == '\\' && ptr[1])
			    ptr++;
		    }
		    if (*ptr) {
			ptr++;
			t = *ptr;
			*ptr = '\0';
			p[1] = Inpar;
			ptr[-1] = Outpar;
			lvals[yylval = lvc++] = ztrdup(p);
			p[1] = '(';
			ptr[-1] = ')';
			*ptr = t;
			*p = '$';
			return cct ? CPARAM : PARAM;
		    }
		    yyval = 0;
		    *p = '$';
		    return NUM;
		}
		ptr++;
		while (iident(*ptr) && *ptr != '[' &&
		       *ptr != ']' && *ptr != ',')
		    ptr++;
		while (*ptr == '[') {
		    for (ptr++, l = 0; *ptr && (*ptr != ']' || l); ptr++) {
			if (*ptr == '[')
			    l++;
			if (*ptr == ']')
			    l--;
			if (*ptr == '\\' && ptr[1])
			    ptr++;
		    }
		    if (*ptr)
			ptr++;
		}
		if (p < ptr) {
		    t = *ptr;
		    *ptr = '\0';
		    lvals[yylval = lvc++] = ztrdup(p);
		    *ptr = t;
		    *p = '$';
		    return cct ? CPARAM : PARAM;
		}
		yyval = 0;
		*p = '$';
		return NUM;
	    }
	    return EOI;
	}
}

/* the value stack */

#define STACKSZ 100
int mtok;			/* last token */
int sp = -1;			/* stack pointer */
struct mathvalue {
    LV lval;
    long val;
}

stack[STACKSZ];

SPROTO(void push, (long val, LV lval));

static void push(val, lval)
long val;
LV lval;
{
    if (sp == STACKSZ - 1)
	zerr("stack overflow", NULL, 0);
    else
	sp++;
    stack[sp].val = val;
    stack[sp].lval = lval;
}

long getvar(s)			/**/
LV s;
{
    long t;

    if (!(t = getiparam(lvals[s])))
	return 0;
    return t;
}

long getcvar(s)			/**/
LV s;
{
    char *t;

    if (!(t = getsparam(lvals[s])))
	return 0;
    return (long)*t;
}

long setvar(s, v)		/**/
LV s;
long v;
{
    if (s == -1 || s >= lvc) {
	zerr("lvalue required", NULL, 0);
	return 0;
    }
    if (noeval)
	return v;
    setiparam(lvals[s], v);
    return v;
}

int notzero(a)			/**/
int a;
{
    if (a == 0) {
	zerr("division by zero", NULL, 0);
	return 0;
    }
    return 1;
}

#define pop2() { b = stack[sp--].val; a = stack[sp--].val; }
#define pop3() {c=stack[sp--].val;b=stack[sp--].val;a=stack[sp--].val;}
#define nolval() {stack[sp].lval= -1;}
#define pushv(X) { push(X,-1); }
#define pop2lv() { pop2() lv = stack[sp+1].lval; }
#define set(X) { push(setvar(lv,X),lv); }

void op(what)			/**/
int what;
{
    long a, b, c;
    LV lv;

    if (sp < 0) {
	zerr("bad math expression: stack empty", NULL, 0);
	return;
    }
    switch (what) {
    case NOT:
	stack[sp].val = !stack[sp].val;
	nolval();
	break;
    case COMP:
	stack[sp].val = ~stack[sp].val;
	nolval();
	break;
    case POSTPLUS:
	(void)setvar(stack[sp].lval, stack[sp].val + 1);
	break;
    case POSTMINUS:
	(void)setvar(stack[sp].lval, stack[sp].val - 1);
	break;
    case UPLUS:
	nolval();
	break;
    case UMINUS:
	stack[sp].val = -stack[sp].val;
	nolval();
	break;
    case AND:
	pop2();
	pushv(a & b);
	break;
    case XOR:
	pop2();
	pushv(a ^ b);
	break;
    case OR:
	pop2();
	pushv(a | b);
	break;
    case MUL:
	pop2();
	pushv(a * b);
	break;
    case DIV:
	pop2();
	if (notzero(b))
	    pushv(a / b);
	break;
    case MOD:
	pop2();
	if (notzero(b))
	    pushv(a % b);
	break;
    case PLUS:
	pop2();
	pushv(a + b);
	break;
    case MINUS:
	pop2();
	pushv(a - b);
	break;
    case SHLEFT:
	pop2();
	pushv(a << b);
	break;
    case SHRIGHT:
	pop2();
	pushv(a >> b);
	break;
    case LES:
	pop2();
	pushv((long)(a < b));
	break;
    case LEQ:
	pop2();
	pushv((long)(a <= b));
	break;
    case GRE:
	pop2();
	pushv((long)(a > b));
	break;
    case GEQ:
	pop2();
	pushv((long)(a >= b));
	break;
    case DEQ:
	pop2();
	pushv((long)(a == b));
	break;
    case NEQ:
	pop2();
	pushv((long)(a != b));
	break;
    case DAND:
	pop2();
	pushv((long)(a && b));
	break;
    case DOR:
	pop2();
	pushv((long)(a || b));
	break;
    case DXOR:
	pop2();
	pushv((long)((a && !b) || (!a && b)));
	break;
    case QUEST:
	pop3();
	pushv((a) ? b : c);
	break;
    case COLON:
	break;
    case EQ:
	b = stack[sp].val;
	sp -= 2;
	lv = stack[sp + 1].lval;
	set(b);
	break;
    case PLUSEQ:
	pop2lv();
	set(a + b);
	break;
    case MINUSEQ:
	pop2lv();
	set(a - b);
	break;
    case MULEQ:
	pop2lv();
	set(a * b);
	break;
    case DIVEQ:
	pop2lv();
	if (notzero(b))
	    set(a / b);
	break;
    case MODEQ:
	pop2lv();
	if (notzero(b))
	    set(a % b);
	break;
    case ANDEQ:
	pop2lv();
	set(a & b);
	break;
    case XOREQ:
	pop2lv();
	set(a ^ b);
	break;
    case OREQ:
	pop2lv();
	set(a | b);
	break;
    case SHLEFTEQ:
	pop2lv();
	set(a << b);
	break;
    case SHRIGHTEQ:
	pop2lv();
	set(a >> b);
	break;
    case DANDEQ:
	pop2lv();
	set((long)(a && b));
	break;
    case DOREQ:
	pop2lv();
	set((long)(a || b));
	break;
    case DXOREQ:
	pop2lv();
	set((long)((a && !b) || (!a && b)));
	break;
    case COMMA:
	b = stack[sp].val;
	sp -= 2;
	pushv(b);
	break;
    case PREPLUS:
	stack[sp].val = setvar(stack[sp].lval,
			       stack[sp].val + 1);
	break;
    case PREMINUS:
	stack[sp].val = setvar(stack[sp].lval,
			       stack[sp].val - 1);
	break;
    case POWER:
	pop2();
	if (b < 0) {
	    zerr("can't handle negative exponents", NULL, 0);
	    return;
	}
	for (c = 1; b--; c *= a);
	pushv(c);
	break;
    case POWEREQ:
	pop2lv();
	if (b < 0) {
	    zerr("can't handle negative exponents", NULL, 0);
	    return;
	}
	for (c = 1; b--; c *= a);
	set(c);
	break;
    default:
	zerr("out of integers", NULL, 0);
	return;
    }
}

void bop(tk)			/**/
int tk;
{
    switch (tk) {
    case DAND:
    case DANDEQ:
	if (!stack[sp].val)
	    noeval++;
	break;
    case DOR:
    case DOREQ:
	if (stack[sp].val)
	    noeval++;
	break;
    };
}

long mathevall(s, prek, ep)	/**/
char *s;
int prek;
char **ep;
{
    int t0;
    int xlastbase, xnoeval, xunary, xlvc;
    char *xptr;
    long xyyval;
    LV xyylval;
    char *xlvals[LVCOUNT];
    int xmtok, xsp;
    struct mathvalue xstack[STACKSZ];
    long ret;

    xlastbase = xnoeval = xunary = xlvc = xyyval = xyylval = xsp = xmtok = 0;
    xptr = NULL;
    if (mlevel++) {
	xlastbase = lastbase;
	xnoeval = noeval;
	xunary = unary;
	xlvc = lvc;
	xptr = ptr;
	xyyval = yyval;
	xyylval = yylval;
	memcpy(xlvals, lvals, LVCOUNT * sizeof(char *));

	xmtok = mtok;
	xsp = sp;
	memcpy(xstack, stack, STACKSZ * sizeof(struct mathvalue));
    }
    lastbase = -1;
    for (t0 = 0; t0 != LVCOUNT; t0++)
	lvals[t0] = NULL;
    lvc = 0;
    ptr = s;
    sp = -1;
    unary = 1;
    mathparse(prek);
    *ep = ptr;
    if (sp)
	zerr("bad math expression: unbalanced stack", NULL, 0);
    for (t0 = 0; t0 != lvc; t0++)
	zsfree(lvals[t0]);

    ret = stack[0].val;

    if (--mlevel) {
	lastbase = xlastbase;
	noeval = xnoeval;
	unary = xunary;
	lvc = xlvc;
	ptr = xptr;
	yyval = xyyval;
	yylval = xyylval;
	memcpy(lvals, xlvals, LVCOUNT * sizeof(char *));

	sp = xsp;
	mtok = xmtok;
	memcpy(stack, xstack, STACKSZ * sizeof(struct mathvalue));
    }
    return ret;
}

long matheval(s)		/**/
char *s;
{
    char *junk;
    long x;

    if (!*s)
	return 0;
    x = mathevall(s, TOPPREC, &junk);
    if (*junk)
	zerr("bad math expression: illegal character: %c", NULL, *junk);
    return x;
}

long mathevalarg(s, ss)		/**/
char *s;
char **ss;
{
    long x;

    x = mathevall(s, ARGPREC, ss);
    if (mtok == COMMA)
	(*ss)--;
    return x;
}

/* operator-precedence parse the string and execute */

void mathparse(pc)		/**/
int pc;
{
    if (errflag)
	return;
    mtok = zzlex();
    while (prec[mtok] <= pc) {
	if (errflag)
	    return;
	if (mtok == NUM)
	    push(yyval, -1);
	else if (mtok == ID)
	    push(getvar(yylval), yylval);
	else if (mtok == CID)
	    push(getcvar(yylval), yylval);
	else if (mtok == PARAM) {
	    char *p = lvals[yylval];

	    singsub(&p);
	    untokenize(p);
	    push(atol(p), -1);
	} else if (mtok == CPARAM) {
	    char *p = lvals[yylval];

	    singsub(&p);
	    untokenize(p);
	    push((long)*p, -1);
	} else if (mtok == M_INPAR) {
	    mathparse(TOPPREC);
	    if (mtok != M_OUTPAR) {
		if (!errflag)
		    zerr("')' expected", NULL, 0);
		return;
	    }
	} else if (mtok == QUEST) {
	    int q = stack[sp].val;

	    if (!q)
		noeval++;
	    mathparse(prec[QUEST] - 1);
	    if (!q)
		noeval--;
	    else
		noeval++;
	    mathparse(prec[QUEST]);
	    if (q)
		noeval--;
	    op(QUEST);
	    continue;
	} else {
	    int otok = mtok, onoeval = noeval;

	    if (type[otok] == BOOL)
		bop(otok);
	    mathparse(prec[otok] - (type[otok] != RL));
	    noeval = onoeval;
	    op(otok);
	    continue;
	}
	mtok = zzlex();
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /*
 *
 * mem.c - memory management
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"

vptr(*alloc) DCLPROTO((int));
vptr(*ncalloc) DCLPROTO((int));

/*

	There are two ways to allocate memory in zsh.  The first way is
	to call zalloc/zcalloc, which call malloc/calloc directly.  It
	is legal to call realloc() or free() on memory allocated this way.
	The second way is to call halloc/hcalloc, which allocates memory
	from one of the memory pools on the heap stack.  A pool can be
	created by calling pushheap(), and destroyed by calling popheap().
	To free the memory in the pool without destroying it, call
	freeheap(); this is equivalent to { popheap(); pushheap(); }
	Memory allocated in this way does not have to be freed explicitly;
	it will all be freed when the pool is destroyed.  In fact,
	attempting to free this memory may result in a core dump.
	The pair of pointers ncalloc and alloc may point to either
	zalloc & zcalloc or halloc & hcalloc; permalloc() sets them to the
	former, and heapalloc() sets them to the latter. This can be useful.
	For example, the dupstruct() routine duplicates a syntax tree,
	allocating the new memory for the tree using alloc().  If you want
	to duplicate a structure for a one-time use (i.e. to execute the list
	in a for loop), call heapalloc(), then dupstruct().  If you want
	to duplicate a structure in order to preserve it (i.e. a function
	definition), call permalloc(), then dupstruct().

	If we use zsh's own allocator we use a simple trick to avoid that
	the (*real*) heap fills up with empty zsh-heaps: we allocate a
	large block of memory before allocating a heap pool, this memory
	is freed again immediatly after the pool is allocated. If there
	are only small blocks on the free list this guarentees that the
	memory for the pool is at the end of the memory which means that
	we can give it back to the systems when the pool is freed.
*/

#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)

int h_m[1025], h_push, h_pop, h_free;

#endif

#define H_ISIZE  sizeof(long)

#define HEAPSIZE (8192 - H_ISIZE)
#define HEAPFREE (16384 - H_ISIZE)

/* set default allocation to heap stack */

void heapalloc()
{				/**/
    alloc = hcalloc;
    ncalloc = halloc;
    useheap = 1;
}

static vptr(*lastcalloc) DCLPROTO((int));
static vptr(*lastncalloc) DCLPROTO((int));
static int lastuseheap;

/* set default allocation to malloc() */

void permalloc()
{				/**/
    lastcalloc = alloc;
    lastncalloc = ncalloc;
    lastuseheap = useheap;
    alloc = zcalloc;
    ncalloc = zalloc;
    useheap = 0;
}

/* reset previous default allocation */

void lastalloc()
{				/**/
    alloc = lastcalloc;
    ncalloc = lastncalloc;
    useheap = lastuseheap;
}

struct heappos {
    struct heappos *next;
    char *ptr;
    int free;
};

struct heap {
    struct heap *next;
    struct heappos pos;
    char *arena;
};

Heap heaps;

/* create a memory pool */

void pushheap()
{				/**/
    Heap h;
    Heappos hp;

#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
    h_push++;
#endif

    for (h = heaps; h; h = h->next) {
	hp = (Heappos) zalloc(sizeof(*hp));
	hp->next = h->pos.next;
	h->pos.next = hp;
	hp->free = h->pos.free;
	hp->ptr = h->pos.ptr;
    }
}

/* reset a memory pool */

void freeheap()
{				/**/
    Heap h;

#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
    h_free++;
#endif
    for (h = heaps; h; h = h->next) {
	if (h->pos.next) {
	    h->pos.free = h->pos.next->free;
	    h->pos.ptr = h->pos.next->ptr;
	} else {
	    h->pos.free += (int)(h->pos.ptr - h->arena);
	    h->pos.ptr = h->arena;
	}
    }
}

/* destroy a memory pool */

void popheap()
{				/**/
    Heap h, hn, hl = NULL;
    Heappos hp, hpn;

#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
    h_pop++;
#endif

    for (h = heaps; h; h = hn) {
	hn = h->next;
	if ((hp = h->pos.next)) {
	    h->pos.next = hp->next;
	    h->pos.free = hp->free;
	    h->pos.ptr = hp->ptr;
	    zfree(hp, sizeof(struct heappos));

	    hl = h;
	} else {
	    for (hp = h->pos.next; hp; hp = hpn) {
		hpn = hp->next;
		free(hp);
	    }
	    zfree(h->arena, HEAPSIZE);
	    zfree(h, sizeof(struct heap));
	}
    }
    if (hl)
	hl->next = NULL;
    else
	heaps = NULL;
}

/* allocate memory from the current memory pool */

vptr halloc(size)		/**/
int size;
{
    Heap h, hp;
    char *ret;

    zigunsafe();

    size = (size + H_ISIZE - 1) & ~(H_ISIZE - 1);

#if defined(MEM_DEBUG) && defined(USE_ZSH_MALLOC)
    h_m[size < 1024 ? (size / H_ISIZE) : 1024]++;
#endif

    for (h = heaps; h && h->pos.free < size; h = h->next);

    if (h) {
	ret = h->pos.ptr;
	h->pos.ptr += size;
	h->pos.free -= size;
    } else {
	int n = (size > HEAPSIZE) ? size : HEAPSIZE;

#ifdef USE_ZSH_MALLOC
	static int called = 0;
	vptr foo;

	if (called)
	    foo = (vptr) malloc(HEAPFREE);
#endif

	for (hp = NULL, h = heaps; h; hp = h, h = h->next);

	h = (Heap) zalloc(sizeof *h);
	h->arena = (char *)zalloc(n);

#ifdef USE_ZSH_MALLOC
	if (called)
	    zfree(foo, HEAPFREE);
	called = 1;
#endif

	h->next = NULL;

	if (hp)
	    hp->next = h;
	else
	    heaps = h;

	h->pos.next = NULL;
	h->pos.ptr = h->arena + size;

	h->pos.free = n - size;

	ret = h->arena;
    }

    zigsafe();

    return (vptr) ret;
}

/* allocate memory from the current memory pool and clear it */

vptr hcalloc(size)		/**/
int size;
{
    vptr ptr;

    ptr = halloc(size);
    memset(ptr, 0, size);
    return ptr;
}

vptr hrealloc(p, old, new)	/**/
char *p;
int old;
int new;
{
    char *ptr;

    ptr = (char *)halloc(new);
    memcpy(ptr, p, old);
    return (vptr) ptr;
}

/* allocate permanent memory */

vptr zalloc(l)			/**/
int l;
{
    vptr z;

    zigunsafe();

    if (!l)
	l = 1;
    if (!(z = (vptr) malloc(l))) {
	zerr("fatal error: out of memory", NULL, 0);
	exit(1);
    }
    zigsafe();

    return z;
}

vptr zcalloc(size)		/**/
int size;
{
    vptr ptr;

    ptr = zalloc(size);
    memset(ptr, 0, size);
    return ptr;
}

char *dupstring(s)		/**/
const char *s;
{
    char *t;

    if (!s)
	return NULL;
    t = (char *)ncalloc(strlen((char *)s) + 1);
    strcpy(t, s);
    return t;
}

char *ztrdup(s)			/**/
const char *s;
{
    char *t;

    if (!s)
	return NULL;
    t = (char *)zalloc(strlen((char *)s) + 1);
    strcpy(t, s);
    return t;
}

#ifdef USE_ZSH_MALLOC

/*
   Below is a simple segment oriented memory allocator for systems on
   which it is better than the system's one. Memory id given in blocks
   aligned to an integer multiple of sizeof(long) (4 bytes on most machines,
   but 8 bytes on e.g. a dec alpha). Each block is preceded by a header
   which contains the length of the data part (in bytes). In allocated
   blocks only this field of the structure m_hdr is senseful. In free
   blocks the second field (next) is a pointer to the next free segment
   on the free list.

   On top of this simple allocator there is a second allocator for small
   chunks of data. It should be both faster and less space-consuming than
   using the normal segment mechanism for such blocks.
   For the first M_NSMALL-1 possible sizes memory is allocated in arrays
   that can hold M_SNUM blocks. Each array is stored in one segment of the
   main allocator. In these segments the third field of the header structure
   (free) contains a pointer to the first free block in the array. The
   last field (used) gives the number of already used blocks in the array.

   If the macro name MEM_DEBUG is defined, some information about the memory
   usage is stored. This information can than be viewed by calling the
   builtin `mem' (which is only available if MEM_DEBUG is set).

   If MEM_WARNING is defined, error messages are printed in case of errors.

   If SECURE_FREE is defined, free() checks if the given address is really
   one that was returned by malloc(), it ignores it if it wasn't (printing
   an error message if MEM_WARNING is also defined).
*/
#if !defined(__hpux) && !defined(DGUX)
#if defined(_BSD) && !defined(SYSV)

extern int brk DCLPROTO((caddr_t));
extern caddr_t sbrk DCLPROTO((int));

#else

extern int brk DCLPROTO((void *));
extern void *sbrk DCLPROTO((int));

#endif
#endif

#if defined(_BSD) && !defined(HAS_STDLIB)

#define FREE_RET_T int
#define FREE_ARG_T char *
#define FREE_DO_RET
#define MALLOC_RET_T char *
#define MALLOC_ARG_T size_t

#else

#define FREE_RET_T void
#define FREE_ARG_T void *
#define MALLOC_RET_T void *
#define MALLOC_ARG_T size_t

#endif

struct m_shdr {
    struct m_shdr *next;
};

struct m_hdr {
    long len;
    struct m_hdr *next;
    struct m_shdr *free;
    long used;
};

#define M_ALIGN (sizeof(long))

#define M_HSIZE (sizeof(struct m_hdr))
#define M_ISIZE (sizeof(long))
#define M_MIN   (2 * M_ISIZE)

struct m_hdr *m_lfree, *m_free;
long m_pgsz = 0;
char *m_high, *m_low;

#define M_SIDX(S)  ((S) / M_ISIZE)
#define M_SNUM     50
#define M_SLEN(M)  ((M)->len / M_SNUM)
#define M_SBLEN(S) ((S) * M_SNUM + sizeof(struct m_shdr *) +  \
		    sizeof(long) + sizeof(struct m_hdr *))
#define M_BSLEN(S) (((S) - sizeof(struct m_shdr *) -  \
		     sizeof(long) - sizeof(struct m_hdr *)) / M_SNUM)
#define M_NSMALL 8

struct m_hdr *m_small[M_NSMALL];

#ifdef MEM_DEBUG

int m_s = 0, m_b = 0;
int m_m[1025], m_f[1025];

struct m_hdr *m_l;

#endif

MALLOC_RET_T malloc(size)
MALLOC_ARG_T size;
{
    struct m_hdr *m, *mp, *mt;
    long n, s, os;
    struct heap *h, *hp, *hf = NULL, *hfp;

    if (!size)
	return (MALLOC_RET_T) m_high;

    if (!m_pgsz) {
#ifdef __hpux
	extern long sysconf DCLPROTO((int));

	m_pgsz = sysconf(_SC_PAGE_SIZE);
#else
#ifdef SYSV
	extern long sysconf DCLPROTO((int));

	m_pgsz = sysconf(_SC_PAGESIZE);
#else
	extern int getpagesize DCLPROTO((void));

	m_pgsz = getpagesize();
#endif
#endif
	m_free = m_lfree = NULL;
    }
    size = (size + M_ALIGN - 1) & ~(M_ALIGN - 1);

    if ((s = M_SIDX(size)) && s < M_NSMALL) {
	for (mp = NULL, m = m_small[s]; m && !m->free; mp = m, m = m->next);

	if (m) {
	    struct m_shdr *sh = m->free;

	    m->free = sh->next;
	    m->used++;

	    if (m->used == M_SNUM && m->next) {
		for (mt = m; mt->next; mt = mt->next);

		mt->next = m;
		if (mp)
		    mp->next = m->next;
		else
		    m_small[s] = m->next;
		m->next = NULL;
	    }
#ifdef MEM_DEBUG
	    m_m[size / M_ISIZE]++;
#endif

	    return (MALLOC_RET_T) sh;
	}
	os = size;
	size = M_SBLEN(size);
    } else
	s = 0;

    for (mp = NULL, m = m_free; m && m->len < size; mp = m, m = m->next);

 /* If there is an empty zsh heap at a lower address we steel it and take
       the memory from it, putting the rest on the free list. */

    for (hp = NULL, h = heaps; h; hp = h, h = h->next)
	if (h->pos.ptr == h->arena &&
	    (!hf || h < hf) &&
	    (!m || ((char *)m) > ((char *)h)))
	    hf = h, hfp = hp;

    if (hf) {
	struct heappos *hpo, *hpn;

	for (hpo = hf->pos.next; hpo; hpo = hpn) {
	    hpn = hpo->next;
	    zfree(hpo, sizeof(struct heappos));
	}
	if (hfp)
	    hfp->next = hf->next;
	else
	    heaps = hf->next;
	zfree(hf->arena, HEAPSIZE);
	zfree(hf, sizeof(struct heap));

	for (mp = NULL, m = m_free; m && m->len < size; mp = m, m = m->next);
    }
    if (!m) {
	n = (size + M_HSIZE + m_pgsz - 1) & ~(m_pgsz - 1);

	if (((char *)(m = (struct m_hdr *)sbrk(n))) == ((char *)-1)) {
#ifdef MEM_WARNING
	    zerr("allocation error at sbrk: %e", NULL, 0);
#endif
	    return NULL;
	}
	if (!m_low)
	    m_low = (char *)m;

#ifdef MEM_DEBUG
	m_s += n;

	if (!m_l)
	    m_l = m;
#endif

	m_high = ((char *)m) + n;

	m->len = n - M_ISIZE;
	m->next = NULL;

	if (mp = m_lfree)
	    m_lfree->next = m;
	m_lfree = m;
    }
    if ((n = m->len - size) > M_MIN) {
	struct m_hdr *mtt = (struct m_hdr *)(((char *)m) + M_ISIZE + size);

	mtt->len = n - M_ISIZE;
	mtt->next = m->next;

	m->len = size;

	if (m_lfree == m)
	    m_lfree = mtt;

	if (mp)
	    mp->next = mtt;
	else
	    m_free = mtt;
    } else if (mp) {
	if (m == m_lfree)
	    m_lfree = mp;
	mp->next = m->next;
    } else {
	m_free = m->next;
	if (m == m_lfree)
	    m_lfree = m_free;
    }

    if (s) {
	struct m_shdr *sh, *shn;

	m->free = sh = (struct m_shdr *)(((char *)m) +
					 sizeof(struct m_hdr) + os);

	m->used = 1;

	for (n = M_SNUM - 2; n--; sh = shn)
	    shn = sh->next = sh + s;
	sh->next = NULL;

	m->next = m_small[s];
	m_small[s] = m;

#ifdef MEM_DEBUG
	m_m[os / M_ISIZE]++;
#endif

	return (MALLOC_RET_T) (((char *)m) + sizeof(struct m_hdr));
    }
#ifdef MEM_DEBUG
    m_m[m->len < (1024 * M_ISIZE) ? (m->len / M_ISIZE) : 1024]++;
#endif

    return (MALLOC_RET_T) & m->next;
}

void zfree(p, sz)		/**/
vptr p;
int sz;
{
    struct m_hdr *m = (struct m_hdr *)(((char *)p) - M_ISIZE), *mp, *mt;
    int i;

#ifdef SECURE_FREE
    sz = 0;
#else
    sz = (sz + M_ALIGN - 1) & ~(M_ALIGN - 1);
#endif

    if (!p)
	return;

    if (((char *)p) < m_low || ((char *)p) > m_high ||
	((long)p) & (M_ALIGN - 1)) {

#ifdef MEM_WARNING
	zerr("attempt to free storage at invalid address", NULL, 0);
#endif

	return;
    }
  fr_rec:

    if ((i = sz / M_ISIZE) < M_NSMALL || !sz)
	for (; i < M_NSMALL; i++) {
	    for (mp = NULL, mt = m_small[i];
		 mt && (((char *)mt) > ((char *)p) ||
			(((char *)mt) + mt->len) < ((char *)p));
		 mp = mt, mt = mt->next);

	    if (mt) {
		struct m_shdr *sh = (struct m_shdr *)p, *sh2;

#ifdef SECURE_FREE
		if ((((char *)p) - (((char *)mt) + sizeof(struct m_hdr))) %
		    M_BSLEN(mt->len)) {

#ifdef MEM_WARNING
		    zerr("attempt to free storage at invalid address", NULL, 0);
#endif
		    return;
		}
		for (sh2 = mt->free; sh2; sh2 = sh2->next)
		    if (((char *)p) == ((char *)sh2)) {

#ifdef MEM_WARNING
			zerr("attempt to free already free storage", NULL, 0);
#endif
			return;
		    }
#endif

		sh->next = mt->free;
		mt->free = sh;

#ifdef MEM_DEBUG
		m_f[M_BSLEN(mt->len) / M_ISIZE]++;
#endif

		if (--mt->used) {
		    if (mp) {
			mp->next = mt->next;
			mt->next = m_small[i];
			m_small[i] = mt;
		    }
		    return;
		}
		if (mp)
		    mp->next = mt->next;
		else
		    m_small[i] = mt->next;

		m = mt;
		p = (vptr) & m->next;

		break;
	    } else if (sz) {
		sz = 0;
		goto fr_rec;
	    }
	}
#ifdef MEM_DEBUG
    if (!mt)
	m_f[m->len < (1024 * M_ISIZE) ? (m->len / M_ISIZE) : 1024]++;
#endif

#ifdef SECURE_FREE
    for (mt = (struct m_hdr *)m_low;
	 ((char *)mt) < m_high;
	 mt = (struct m_hdr *)(((char *)mt) + M_ISIZE + mt->len))
	if (((char *)p) == ((char *)&mt->next))
	    break;

    if (((char *)mt) >= m_high) {

#ifdef MEM_WARNING
	zerr("attempt to free storage at invalid address", NULL, 0);
#endif
	return;
    }
#endif

    for (mp = NULL, mt = m_free; mt && mt < m; mp = mt, mt = mt->next);

    if (m == mt) {

#ifdef MEM_WARNING
	zerr("attempt to free already free storage", NULL, 0);
#endif
	return;
    }
    if (mt && ((char *)mt) == (((char *)m) + M_ISIZE + m->len)) {
	m->len += mt->len + M_ISIZE;
	m->next = mt->next;

	if (mt == m_lfree)
	    m_lfree = m;
    } else
	m->next = mt;

    if (mp && ((char *)m) == (((char *)mp) + M_ISIZE + mp->len)) {
	mp->len += m->len + M_ISIZE;
	mp->next = m->next;

	if (m == m_lfree)
	    m_lfree = mp;
    } else if (mp)
	mp->next = m;
    else
	m_free = m;

    if ((((char *)m_lfree) + M_ISIZE + m_lfree->len) == m_high &&
	m_lfree->len >= m_pgsz + M_MIN) {
	long n = (m_lfree->len - M_MIN) & ~(m_pgsz - 1);

	m_lfree->len -= n;
	if (brk(m_high -= n) == -1) {
#ifdef MEM_WARNING
	    zerr("allocation error at brk: %e", NULL, 0);
#endif
	}
#ifdef MEM_DEBUG
	m_b += n;
#endif
    }
}

FREE_RET_T free(p)
FREE_ARG_T p;
{
    zfree(p, 0);

#ifdef FREE_DO_RET
    return 0;
#endif
}

void zsfree(p)			/**/
char *p;
{
    if (p)
	zfree(p, strlen(p) + 1);
}

MALLOC_RET_T realloc(p, size)
MALLOC_RET_T p;
MALLOC_ARG_T size;
{
    struct m_hdr *m = (struct m_hdr *)(((char *)p) - M_ISIZE), *mp, *mt;
    char *r;
    int i, l = 0;

    if (!p && size)
	return (MALLOC_RET_T) malloc(size);
    if (!p || !size)
	return (MALLOC_RET_T) p;

    for (i = 0; i < M_NSMALL; i++) {
	for (mp = NULL, mt = m_small[i];
	     mt && (((char *)mt) > ((char *)p) ||
		    (((char *)mt) + mt->len) < ((char *)p));
	     mp = mt, mt = mt->next);

	if (mt) {
	    l = M_BSLEN(mt->len);
	    break;
	}
    }
    if (!l)
	l = m->len;

    r = malloc(size);
    memcpy(r, (char *)p, (size > l) ? l : size);
    free(p);

    return (MALLOC_RET_T) r;
}

MALLOC_RET_T calloc(n, size)
MALLOC_ARG_T n;
MALLOC_ARG_T size;
{
    long l;
    char *r;

    if (!(l = n * size))
	return (MALLOC_RET_T) m_high;

    r = malloc(l);

    memset(r, 0, l);

    return (MALLOC_RET_T) r;
}

FREE_RET_T cfree(p)
FREE_ARG_T p;
{
    free(p);

#ifdef FREE_DO_RET
    return 0;
#endif
}

#ifdef MEM_DEBUG

int bin_mem(name, argv, ops, func)	/**/
char *name;
char **argv;
char *ops;
int func;
{
    int i, ii, fi, ui, j;
    struct m_hdr *m, *mf, *ms;
    char *b, *c, buf[40];
    long u = 0, f = 0;
    Lknode nd;

    if (ops['v']) {
	printf("The lower and the upper addresses of the heap. Diff gives\n");
	printf("the difference between them, i.e. the size of the heap.\n\n");
    }
    printf("low mem %ld\t high mem %ld\t diff %ld\n",
	   (long)m_l, (long)m_high, (long)(m_high - ((char *)m_l)));

    if (ops['v']) {
	printf("\nThe number of bytes that were allocated using sbrk() and\n");
	printf("the number of bytes that were given back to the system\n");
	printf("via brk().\n");
    }
    printf("\nsbrk %d\tbrk %d\n", m_s, m_b);

    if (ops['v']) {
	printf("\nInformation about the sizes that were allocated or freed.\n");
	printf("For each size that were used the number of mallocs and\n");
	printf("frees is shown. Diff gives the difference between these\n");
	printf("values, i.e. the number of blocks of that size that is\n");
	printf("currently allocated. Total is the product of size and diff,\n");
	printf("i.e. the number of bytes that are allocated for blocks of\n");
	printf("this size.\n");
    }
    printf("\nsize\tmalloc\tfree\tdiff\ttotal\n");
    for (i = 0; i < 1024; i++)
	if (m_m[i] || m_f[i])
	    printf("%d\t%d\t%d\t%d\t%d\n", i * M_ISIZE, m_m[i], m_f[i],
		   m_m[i] - m_f[i], i * M_ISIZE * (m_m[i] - m_f[i]));

    if (m_m[i] || m_f[i])
	printf("big\t%d\t%d\t%d\n", m_m[i], m_f[i], m_m[i] - m_f[i]);

    if (ops['v']) {
	printf("\nThe list of memory blocks. For each block the following\n");
	printf("information is shown:\n\n");
	printf("num\tthe number of this block\n");
	printf("tnum\tlike num but counted separatedly for used and free\n");
	printf("\tblocks\n");
	printf("addr\tthe address of this block\n");
	printf("len\tthe length of the block\n");
	printf("state\tthe state of this block, this can be:\n");
	printf("\t  used\tthis block is used for one big block\n");
	printf("\t  free\tthis block is free\n");
	printf("\t  small\tthis block is used for an array of small blocks\n");
	printf("cum\tthe accumulated sizes of the blocks, counted\n");
	printf("\tseparatedly for used and free blocks\n");
	printf("\nFor blocks holding small blocks the number of free\n");
	printf("blocks, the number of used blocks and the size of the\n");
	printf("blocks is shown. For otherwise used blocks the first few\n");
	printf("bytes are shown as an ASCII dump.\n");
    }
    printf("\nblock list:\nnum\ttnum\taddr\tlen\tstate\tcum\n");
    for (m = m_l, mf = m_free, ii = fi = ui = 1; ((char *)m) < m_high;
	 m = (struct m_hdr *)(((char *)m) + M_ISIZE + m->len), ii++) {
	for (j = 0, ms = NULL; j < M_NSMALL && !ms; j++)
	    for (ms = m_small[j]; ms; ms = ms->next)
		if (ms == m)
		    break;

	if (m == mf)
	    buf[0] = '\0';
	else if (m == ms)
	    sprintf(buf, "%d %d %d", M_SNUM - ms->used, ms->used,
		    (m->len - sizeof(struct m_hdr)) / M_SNUM + 1);

	else {
	    for (i = 0, b = buf, c = (char *)&m->next; i < 20 && i < m->len;
		 i++, c++)
		*b++ = (*c >= ' ' && *c < 127) ? *c : '.';
	    *b = '\0';
	}

	printf("%d\t%d\t%ld\t%ld\t%s\t%ld\t%s\n", ii,
	       (m == mf) ? fi++ : ui++,
	       (long)m, m->len,
	       (m == mf) ? "free" : ((m == ms) ? "small" : "used"),
	       (m == mf) ? (f += m->len) : (u += m->len),
	       buf);

	if (m == mf)
	    mf = mf->next;
    }

    if (ops['v']) {
	printf("\nHere is some information about the small blocks used.\n");
	printf("For each size the arrays with the number of free and the\n");
	printf("number of used blocks are shown.\n");
    }
    printf("\nsmall blocks:\nsize\tblocks (free/used)\n");

    for (i = 0; i < M_NSMALL; i++)
	if (m_small[i]) {
	    printf("%d\t", i * M_ISIZE);

	    for (ii = 0, m = m_small[i]; m; m = m->next) {
		printf("(%d/%d) ", M_SNUM - m->used, m->used);
		if (!((++ii) & 7))
		    printf("\n\t");
	    }
	    putchar('\n');
	}
    if (ops['v']) {
	printf("\n\nBelow is some information about the allocation\n");
	printf("behaviour of the zsh heaps. First the number of times\n");
	printf("pushheap(), popheap(), and freeheap() were called.\n");
    }
    printf("\nzsh heaps:\n\n");

    printf("push %d\tpop %d\tfree %d\n\n", h_push, h_pop, h_free);

    if (ops['v']) {
	printf("\nThe next list shows for several sizes the number of times\n");
	printf("memory of this size were taken from heaps.\n\n");
    }
    printf("size\tmalloc\ttotal\n");
    for (i = 0; i < 1024; i++)
	if (h_m[i])
	    printf("%d\t%d\t%d\n", i * H_ISIZE, h_m[i], i * H_ISIZE * h_m[i]);
    if (h_m[1024])
	printf("big\t%d\n", h_m[1024]);

    return 0;
}

#endif

#else				/* not USE_ZSH_MALLOC */

void zfree(p, sz)		/**/
vptr p;
int sz;
{
    if (p)
	free(p);
}

void zsfree(p)			/**/
char *p;
{
    if (p)
	free(p);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Your signals.h file should look something like this.  If it doesn't,
perhaps your csh or ed is different.

/* this file is created automatically by buildzsh */
/* if all this is wrong, blame csh ;-) */

#define SIGCOUNT       31

#ifdef GLOBALS

char *sigmsg[SIGCOUNT+2] = {
	"done",
	"hangup",
	"interrupt",
	"quit",
	"illegal instruction",
	"trace trap",
	"abort",
	"EMT instruction",
	"floating point exception",
	"killed",
	"bus error",
	"segmentation fault",
	"bad system call",
	"broken pipe",
	"SIGALRM",
	"terminated",
	"SIGURG",
#ifdef USE_SUSPENDED
	"suspended (signal)",
#else
	"stopped (signal)",
#endif
#ifdef USE_SUSPENDED
	"suspended",
#else
	"stopped",
#endif
	"continued",
	"SIGCHLD",
#ifdef USE_SUSPENDED
	"suspended (tty input)",
#else
	"stopped (tty input)",
#endif
#ifdef USE_SUSPENDED
	"suspended (tty output)",
#else
	"stopped (tty output)",
#endif
	"SIGIO",
	"cpu limit exceeded",
	"filesize limit exceeded",
	"virtual time alarm",
	"SIGPROF",
	"SIGWINCH",
	"SIGLOST",
	"SIGUSR1",
	"SIGUSR2",
	NULL
};

char *sigs[SIGCOUNT+4] = {
	"EXIT",
	"HUP",
	"INT",
	"QUIT",
	"ILL",
	"TRAP",
	"ABRT",
	"EMT",
	"FPE",
	"KILL",
	"BUS",
	"SEGV",
	"SYS",
	"PIPE",
	"ALRM",
	"TERM",
	"URG",
	"STOP",
	"TSTP",
	"CONT",
	"CHLD",
	"TTIN",
	"TTOU",
	"IO",
	"XCPU",
	"XFSZ",
	"VTALRM",
	"PROF",
	"WINCH",
	"LOST",
	"USR1",
	"USR2",
	"ZERR",
	"DEBUG",
	NULL
};

#else

extern char *sigs[SIGCOUNT+4],*sigmsg[SIGCOUNT+2];

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 *
 * params.c - parameters
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"
#include "version.h"
#include <pwd.h>

static Param argvparam;

struct iparam {
    struct hashnode *next;
    char *nam;			/* hash data */
    vptr value;
    int (*func1) ();		/* set func */
    int (*func2) ();		/* get func */
    int ct;			/* output base or field width */
    int flags;
    vptr data;			/* used by getfns */
    char *env;			/* location in environment, if exported */
    char *ename;		/* name of corresponding environment var */
    Param old;			/* old struct for use with local */
    int level;			/* if (old != NULL), level of localness */
};

#define IFN(X) ((int (*)())(X))

/* put predefined params in hash table */

void setupparams()
{				/**/
    static struct iparam pinit[] =
    {
#define IPDEF1(A,B,C,D) {NULL,A,NULL,IFN(C),IFN(B),10,\
		PMFLAG_i|PMFLAG_SPECIAL|D,NULL,NULL,NULL,NULL,0}
	IPDEF1("#", poundgetfn, IFN(nullsetfn), PMFLAG_r),
	IPDEF1("ARGC", poundgetfn, IFN(nullsetfn), PMFLAG_r),
	IPDEF1("ERRNO", errnogetfn, IFN(nullsetfn), PMFLAG_r),
	IPDEF1("GID", gidgetfn, IFN(nullsetfn), PMFLAG_r),
	IPDEF1("EGID", egidgetfn, IFN(nullsetfn), PMFLAG_r),
	IPDEF1("HISTSIZE", histsizegetfn, histsizesetfn, 0),
	IPDEF1("LITHISTSIZE", lithistsizegetfn, lithistsizesetfn, 0),
	IPDEF1("RANDOM", randomgetfn, randomsetfn, 0),
	IPDEF1("SECONDS", secondsgetfn, secondssetfn, 0),
	IPDEF1("UID", uidgetfn, IFN(nullsetfn), PMFLAG_r),
	IPDEF1("EUID", euidgetfn, IFN(nullsetfn), PMFLAG_r),

#define IPDEF2(A,B,C,D) {NULL,A,NULL,IFN(C),IFN(B),0,\
		PMFLAG_SPECIAL|D,NULL,NULL,NULL,NULL,0}
	IPDEF2("-", dashgetfn, IFN(nullsetfn), PMFLAG_r),
	IPDEF2("HISTCHARS", histcharsgetfn, histcharssetfn, 0),
	IPDEF2("HOME", homegetfn, homesetfn, 0),
	IPDEF2("TERM", termgetfn, termsetfn, 0),
	IPDEF2("WORDCHARS", wordcharsgetfn, wordcharssetfn, 0),
	IPDEF2("IFS", ifsgetfn, ifssetfn, 0),
	IPDEF2("_", underscoregetfn, IFN(nullsetfn), PMFLAG_r),

#define IPDEF3(A) {NULL,A,NULL,IFN(nullsetfn),IFN(strconstgetfn),0,PMFLAG_r|\
		PMFLAG_SPECIAL,NULL,NULL,NULL,NULL,0}
	IPDEF3("HOSTTYPE"),
	IPDEF3("VERSION"),

#define IPDEF4(A,B) {NULL,A,NULL,IFN(nullsetfn),IFN(intvargetfn),10,\
		PMFLAG_r|PMFLAG_i|PMFLAG_SPECIAL,(vptr)B,NULL,NULL,NULL,0}
	IPDEF4("!", &lastpid),
	IPDEF4("$", &mypid),
	IPDEF4("?", &lastval),
	IPDEF4("status", &lastval),
	IPDEF4("LINENO", &lineno),
	IPDEF4("PPID", &ppid),

#define IPDEF5(A,B) {NULL,A,NULL,IFN(intvarsetfn),IFN(intvargetfn),10,\
		PMFLAG_i|PMFLAG_SPECIAL,(vptr)B,NULL,NULL,NULL,0}
	IPDEF5("BAUD", &baud),
	IPDEF5("COLUMNS", &columns),
	IPDEF5("DIRSTACKSIZE", &dirstacksize),
	IPDEF5("KEYTIMEOUT", &keytimeout),
	IPDEF5("LINES", &lines),
	IPDEF5("LISTMAX", &listmax),
	IPDEF5("LOGCHECK", &logcheck),
	IPDEF5("MAILCHECK", &mailcheck),
	IPDEF5("OPTIND", &zoptind),
	IPDEF5("PERIOD", &period),
	IPDEF5("REPORTTIME", &reporttime),
	IPDEF5("SAVEHIST", &savehist),
	IPDEF5("SHLVL", &shlvl),
	IPDEF5("TMOUT", &tmout),

#define IPDEF6(A,B) {NULL,A,NULL,IFN(nullsetfn),IFN(strvargetfn),0,\
		PMFLAG_r|PMFLAG_SPECIAL,(vptr)B,NULL,NULL,NULL,0}
	IPDEF6("LOGNAME", &zlogname),
	IPDEF6("PWD", &pwd),
	IPDEF6("TTY", &ttystrname),
	IPDEF6("USERNAME", &username),

#define IPDEF7(A,B) {NULL,A,NULL,IFN(strvarsetfn),IFN(strvargetfn),0,\
		PMFLAG_SPECIAL,(vptr)B,NULL,NULL,NULL,0}
	IPDEF7("FCEDIT", &fceditparam),
	IPDEF7("HOST", &hostnam),
	IPDEF7("OLDPWD", &oldpwd),
	IPDEF7("OPTARG", &zoptarg),
	IPDEF7("MAIL", &mailfile),
	IPDEF7("NULLCMD", &nullcmd),
	IPDEF7("POSTEDIT", &postedit),
	IPDEF7("prompt", &prompt),
	IPDEF7("PROMPT", &prompt),
	IPDEF7("PROMPT2", &prompt2),
	IPDEF7("PROMPT3", &prompt3),
	IPDEF7("PROMPT4", &prompt4),
	IPDEF7("READNULLCMD", &readnullcmd),
	IPDEF7("RPROMPT", &rprompt),
	IPDEF7("PS1", &prompt),
	IPDEF7("PS2", &prompt2),
	IPDEF7("PS3", &prompt3),
	IPDEF7("PS4", &prompt4),
	IPDEF7("RPS1", &rprompt),
	IPDEF7("SPROMPT", &sprompt),
	IPDEF7("TIMEFMT", &timefmt),
	IPDEF7("TMPPREFIX", &tmpprefix),
	IPDEF7("WATCHFMT", &watchfmt),
	IPDEF7("0", &argzero),

#define IPDEF8(A,B,C) {NULL,A,NULL,IFN(colonarrsetfn),IFN(colonarrgetfn),0,\
		PMFLAG_SPECIAL,(vptr)C,NULL,B,NULL,0}
	IPDEF8("CDPATH", "cdpath", &cdpath),
	IPDEF8("FIGNORE", "fignore", &fignore),
	IPDEF8("FPATH", "fpath", &fpath),
	IPDEF8("MAILPATH", "mailpath", &mailpath),
	IPDEF8("MANPATH", "manpath", &manpath),
	IPDEF8("WATCH", "watch", &watch),
	IPDEF8("PSVAR", "psvar", &psvar),
	{NULL, "PATH", NULL, IFN(colonpathsetfn), IFN(colonpathgetfn), 0,
	 PMFLAG_SPECIAL, (vptr) NULL, NULL, "path", NULL, 0},

#define IPDEF9(A,B,C,D) {NULL,A,NULL,IFN(arrvarsetfn),IFN(arrvargetfn),0,\
		PMFLAG_A|PMFLAG_SPECIAL|C,(vptr)B,NULL,D,NULL,0}
	IPDEF9("cdpath", &cdpath, 0, "CDPATH"),
	IPDEF9("fignore", &fignore, 0, "FIGNORE"),
	IPDEF9("fpath", &fpath, 0, "FPATH"),
	IPDEF9("mailpath", &mailpath, 0, "MAILPATH"),
	IPDEF9("manpath", &manpath, 0, "MANPATH"),
	IPDEF9("watch", &watch, 0, "WATCH"),
	IPDEF9("psvar", &psvar, 0, "PSVAR"),
	IPDEF9("signals", &sigptr, PMFLAG_r, NULL),
	IPDEF9("argv", &pparams, 0, NULL),
	IPDEF9("*", &pparams, 0, NULL),
	IPDEF9("@", &pparams, 0, NULL),

	{NULL, "path", NULL, IFN(pathsetfn), IFN(pathgetfn), 0,
	 PMFLAG_A | PMFLAG_SPECIAL, NULL, NULL, "PATH", NULL, 0},

	{NULL,}
    };
    struct iparam *ip;

    for (ip = pinit; ip->nam; ip++)
	addhnode(ztrdup(ip->nam), ip, paramtab, (FFunc) 0);
    argvparam = (Param) gethnode("argv", paramtab);

    ((struct iparam *)gethnode("HOSTTYPE", paramtab))->data = (vptr) ztrdup(HOSTTYPE);
    ((struct iparam *)gethnode("VERSION", paramtab))->data = (vptr) ztrdup(VERSIONSTR);
}

struct param *createparam(name, flags)	/**/
char *name;
int flags;
{
    struct param *pm, *oldpm = (Param) gethnode(name, paramtab);
    int spec;

    spec = oldpm && (oldpm->flags & PMFLAG_SPECIAL);
    if ((oldpm && oldpm->level == locallevel) || spec) {
	pm = oldpm;
	pm->ct = 0;
	oldpm = pm->old;
	pm->flags = (flags & (PMFLAG_x | PMFLAG_L | PMFLAG_R | PMFLAG_Z |
			      PMFLAG_l | PMFLAG_u | PMFLAG_r | PMFLAG_t)) |
	    (pm->flags & (PMFLAG_s | PMFLAG_i | PMFLAG_A | PMFLAG_SPECIAL));
	if (pm->ename) {
	    Param altpm = (Param) gethnode(pm->ename, paramtab);

	    if (altpm)
		altpm->flags &= ~(PMFLAG_UNSET | PMFLAG_x | PMFLAG_L |
				  PMFLAG_R | PMFLAG_Z | PMFLAG_l |
				  PMFLAG_u | PMFLAG_r | PMFLAG_t);
	}
    } else {
	pm = (struct param *)zcalloc(sizeof *pm);
	if ((pm->old = oldpm))
	    remhnode(name, paramtab);	/* needed to avoid freeing oldpm */
	addhnode(ztrdup(name), pm, paramtab, freepm);
    }
    if (isset(ALLEXPORT) && !oldpm)
	pm->flags |= PMFLAG_x;
    if (!spec) {
	pm->flags = flags;
	if ((flags & PMTYPE) == PMFLAG_s) {
	    pm->sets.cfn = strsetfn;
	    pm->gets.cfn = strgetfn;
	} else if ((flags & PMTYPE) == PMFLAG_A) {
	    pm->sets.afn = arrsetfn;
	    pm->gets.afn = arrgetfn;
	} else {
	    pm->sets.ifn = intsetfn;
	    pm->gets.ifn = intgetfn;
	}
    }
    return pm;
}

int isident(s)			/**/
char *s;
{
    char *ss;
    int ne = noeval;

    if (!*s)
	return 0;

    for (ss = s; *ss; ss++)
	if (!iident(*ss))
	    break;
    if (!*ss || (*ss == '[' && ss[1] == '('))
	return 1;
    if (*ss != '[')
	return 0;
    noeval = 1;
    (void)mathevalarg(++ss, &ss);
    if (*ss == ',' || *ss == Comma)
	(void)mathevalarg(++ss, &ss);
    noeval = ne;
    if (*ss != ']' || ss[1])
	return 0;
    return 1;
}

char **garr;

long getarg(str, inv, v, a2, w)	/**/
char **str;
int *inv;
Value v;
int a2;
long *w;
{
    int num = 1, word = 0, rev = 0, ind = 0, down = 0, exp = 0, l, i;
    char *s = *str, *sep = NULL, *t, sav, *d, **ta, **p, *tt;
    long r = 0, rr, rrr;
    Comp c;

    if (*s == '(' || *s == Inpar) {
	for (s++; *s != ')' && *s != Outpar && s != *str; s++) {
	    switch (*s) {
	    case 'r':
		rev = 1;
		down = ind = 0;
		break;
	    case 'R':
		rev = down = 1;
		ind = 0;
		break;
	    case 'i':
		rev = ind = 1;
		down = 0;
		break;
	    case 'I':
		rev = ind = down = 1;
		break;
	    case 'w':
		word = 1;
		break;
	    case 'e':
		exp = 1;
		break;
	    case 'n':
		t = get_strarg(++s);
		if (!*t)
		    goto flagerr;
		sav = *t;
		*t = '\0';
		num = mathevalarg(s + 1, &d);
		if (!num)
		    num = 1;
		*t = sav;
		s = t;
		break;
	    case 's':
		t = get_strarg(++s);
		if (!*t)
		    goto flagerr;
		sav = *t;
		*t = '\0';
		sep = dupstring(s + 1);
		*t = sav;
		s = t;
		break;
	    default:
	      flagerr:
		num = 1;
		word = rev = ind = down = exp = 0;
		sep = NULL;
		s = *str - 1;
	    }
	}
	if (s != *str)
	    s++;
    }
    if (num < 0) {
	down = !down;
	num = -num;
    }
    *inv = ind;

    for (t = s, i = 0; *t && (*t != ']' || i) &&
	 (*t != Outbrack || i) && *t != ','; t++)
	if (*t == '[' || *t == Inbrack)
	    i++;
	else if (*t == ']' || *t == Outbrack)
	    i--;

    if (!*t)
	return 0;
    sav = *t;
    *t = '\0';
    s = dupstring(s);
    *t = sav;
    *str = tt = t;

    if (exp) {
	tokenize(s);
	lexsave();
	strinbeg();
	singsub(&s);
	strinend();
	lexrestore();
	untokenize(s);
    }
    if (!rev) {
	if (!(r = mathevalarg(s, &s)))
	    r = 1;
	if (word && !v->isarr) {
	    s = t = getstrvalue(v);
	    i = wordcount(s, sep, 0);
	    if (r < 0)
		r += i + 1;
	    if (r < 1)
		r = 1;
	    if (r > i)
		r = i;
	    if (!s || !*s)
		return 0;
	    rrr = r;
	    while ((d = findword(&s, sep)) && --r);
	    if (!d)
		return 0;

	    if (a2) {
		if ((d = findword(&s, sep))) {
		    r = (long)(d - t) - (sep ? strlen(sep) + (rrr == i ? 0 : 1) : 1);
		} else
		    r = -1;
	    } else {
		rr = (long)(d - t);
		if (rrr > 1)
		    rr++;
		r = rr;
	    }

	    if (!a2 && *tt != ',' && *tt != Comma)
		*w = (long)(s - t) - 1;
	}
    } else {
	if (!v->isarr && !word) {
	    l = strlen(s);
	    if (a2) {
		if (!l || *s != '*') {
		    d = (char *)ncalloc(l + 2);
		    *d = '*';
		    strcpy(d + 1, s);
		    s = d;
		}
	    } else {
		if (!l || s[l - 1] != '*') {
		    d = (char *)ncalloc(l + 2);
		    strcpy(d, s);
		    strcat(d, "*");
		    s = d;
		}
	    }
	}
	tokenize(s);

	if ((c = parsereg(s))) {
	    if (v->isarr) {
		ta = getarrvalue(v);
		if (!ta || !*ta)
		    return 0;
		if (down)
		    for (r = -1, p = ta + arrlen(ta) - 1; p >= ta; r--, p--) {
			if (domatch(*p, c, 0) && !--num)
			    return r;
		} else
		    for (r = 1, p = ta; *p; r++, p++)
			if (domatch(*p, c, 0) && !--num)
			    return r;
	    } else if (word) {
		ta = sepsplit(d = s = getstrvalue(v), sep);
		if (down) {
		    for (p = ta + (r = arrlen(ta)) - 1; p >= ta; p--, r--)
			if (domatch(*p, c, 0) && !--num)
			    break;
		    if (p < ta)
			return 0;
		} else {
		    for (r = 1, p = ta; *p; r++, p++)
			if (domatch(*p, c, 0) && !--num)
			    break;
		    if (!*p)
			return 0;
		}
		if (a2)
		    r++;
		for (i = 0, t = findword(&d, sep); t && *t;
		     i++, t = findword(&d, sep))
		    if (!--r) {
			r = (long)(t - s + (a2 ? -1 : 1));
			if (!a2 && *tt != ',' && *tt != Comma)
			    *w = r + strlen(ta[i]) - 2;
			return r;
		    }
		return a2 ? -1 : 0;
	    } else {
		d = getstrvalue(v);
		if (!d || !*d)
		    return 0;
		if (a2) {
		    if (down)
			for (r = -2, t = d + strlen(d) - 1; t >= d; r--, t--) {
			    sav = *t;
			    *t = '\0';
			    if (domatch(d, c, 0) && !--num) {
				*t = sav;
				return r;
			    }
			    *t = sav;
		    } else
			for (r = 0, t = d; *t; r++, t++) {
			    sav = *t;
			    *t = '\0';
			    if (domatch(d, c, 0) && !--num) {
				*t = sav;
				return r;
			    }
			    *t = sav;
			}
		} else {
		    if (down)
			for (r = -1, t = d + strlen(d) - 1; t >= d; r--, t--) {
			    if (domatch(t, c, 0) && !--num)
				return r;
		    } else
			for (r = 1, t = d; *t; r++, t++)
			    if (domatch(t, c, 0) && !--num)
				return r;
		}
	    }
	}
    }
    return r;
}

Value getvalue(pptr, bracks)	/**/
char **pptr;
int bracks;
{
    char *s = *pptr, *t = *pptr;
    char sav;
    Value v;
    int inv = 0;

    garr = NULL;

    if (idigit(*s))
	while (idigit(*s))
	    s++;
    else if (iident(*s))
	while (iident(*s))
	    s++;
    else if (*s == Quest)
	*s++ = '?';
    else if (*s == Pound)
	*s++ = '#';
    else if (*s == String)
	*s++ = '$';
    else if (*s == Qstring)
	*s++ = '$';
    else if (*s == Star)
	*s++ = '*';
    else if (*s == '#' || *s == '-' || *s == '?' || *s == '$' ||
	     *s == '_' || *s == '!' || *s == '@' || *s == '*')
	s++;
    else
	return NULL;
    if ((sav = *s))
	*s = '\0';
    if (idigit(*t) && *t != '0') {
	v = (Value) hcalloc(sizeof *v);
	v->pm = argvparam;
	v->inv = 0;
	v->a = v->b = atoi(t) - 1;
	if (sav)
	    *s = sav;
    } else {
	struct param *pm;
	int isvarat = !strcmp(t, "@");

	pm = (struct param *)gethnode(t, paramtab);
	if (sav)
	    *s = sav;
	*pptr = s;
	if (!pm || (pm->flags & PMFLAG_UNSET))
	    return NULL;
	v = (Value) hcalloc(sizeof *v);
	if (pmtype(pm) == PMFLAG_A)
	    v->isarr = isvarat ? -1 : 1;
	v->pm = pm;
	v->inv = 0;
	v->a = 0;
	v->b = -1;
	if (bracks && (*s == '[' || *s == Inbrack)) {
	    int a, b;
	    char *olds = s, *tbrack;

	    *s++ = '[';
	    for (tbrack = s; *tbrack && *tbrack != ']' && *tbrack != Outbrack; tbrack++)
		if (itok(*tbrack))
		    *tbrack = ztokens[*tbrack - Pound];
	    if (*tbrack == Outbrack)
		*tbrack = ']';
	    if ((s[0] == '*' || s[0] == '@') && s[1] == ']') {
		if (v->isarr)
		    v->isarr = (s[0] == '*') ? 1 : -1;
		v->a = 0;
		v->b = -1;
		s += 2;
	    } else {
		long we = 0, dummy;

		a = getarg(&s, &inv, v, 0, &we);
		if (a > 0 && !inv)
		    a--;

		if (inv) {
		    v->inv = 1;
		    if (*s == ']' || *s == Outbrack)
			s++;
		    v->isarr = 0;
		    v->a = v->b = a;
		    if (*s == ',' || *s == Comma) {
			zerr("invalid subscript", NULL, 0);
			while (*s != ']' && *s != Outbrack)
			    s++;
			*pptr = s;
			return v;
		    }
		} else {
		    if (*s == ',' || *s == Comma) {
			s++;
			b = getarg(&s, &inv, v, 1, &dummy);
			if (b > 0)
			    b--;
		    } else {
			b = we ? we : a;
		    }
		    if (*s == ']' || *s == Outbrack) {
			s++;
			if (v->isarr && a == b)
			    v->isarr = 0;
			v->a = a;
			v->b = b;
		    } else
			s = olds;
		}
	    }
	}
    }
    if (!bracks && *s)
	return NULL;
    *pptr = s;
    return v;
}

char *getstrvalue(v)		/**/
Value v;
{
    char *s, **ss;
    static char buf[20];

    if (!v)
	return "";
    if (v->inv) {
	sprintf(buf, "%d", v->a);
	return dupstring(buf);
    }
    if (pmtype(v->pm) != PMFLAG_A) {
	if ((pmtype(v->pm) == PMFLAG_i))
	    convbase(s = buf, v->pm->gets.ifn(v->pm), v->pm->ct);
	else
	    s = v->pm->gets.cfn(v->pm);
	if (v->a == 0 && v->b == -1)
	    return s;
	if (v->a < 0)
	    v->a += strlen(s);
	if (v->b < 0)
	    v->b += strlen(s);
	s = (v->a > (int)strlen(s)) ? dupstring("") : dupstring(s + v->a);
	if (v->b < v->a)
	    s[0] = '\0';
	else if (v->b - v->a < (int)strlen(s))
	    s[v->b - v->a + 1] = '\0';
	return s;
    }
    if (v->isarr)
	return spacejoin(v->pm->gets.afn(v->pm));

    ss = v->pm->gets.afn(v->pm);
    if (v->a < 0)
	v->a += arrlen(ss);
    s = (v->a >= arrlen(ss) || v->a < 0) ? "" : ss[v->a];
    return s;
}

static char *nular[] =
{"", NULL};

char **getarrvalue(v)		/**/
Value v;
{
    char **s;

    if (!v)
	return arrdup(nular);
    if (v->inv) {
	char buf[20];

	s = arrdup(nular);
	sprintf(buf, "%d", v->a);
	s[0] = dupstring(buf);
	return s;
    }
    s = v->pm->gets.afn(v->pm);
    if (v->a == 0 && v->b == -1)
	return s;
    if (v->a < 0)
	v->a += arrlen(s);
    if (v->b < 0)
	v->b += arrlen(s);
    if (v->a > arrlen(s) || v->a < 0)
	s = arrdup(nular);
    else
	s = arrdup(s) + v->a;
    if (v->b < v->a)
	s[0] = NULL;
    else if (v->b - v->a < arrlen(s))
	s[v->b - v->a + 1] = NULL;
    return s;
}

long getintvalue(v)		/**/
Value v;
{
    char **ss;

    if (!v || v->isarr)
	return 0;
    if (v->inv)
	return v->a;
    if (pmtype(v->pm) != PMFLAG_A) {
	if (pmtype(v->pm) == PMFLAG_i)
	    return v->pm->gets.ifn(v->pm);
	return atol(v->pm->gets.cfn(v->pm));
    }
    ss = v->pm->gets.afn(v->pm);
    if (v->a < 0)
	v->a += arrlen(ss);
    if (v->a < 0 || v->a >= arrlen(ss))
	return 0;
    return atol(ss[v->a]);
}

void setstrvalue(v, val)	/**/
Value v;
char *val;
{
    char buf[20];

    if (v->pm->flags & PMFLAG_r) {
	zsfree(val);
	return;
    }
    switch (pmtype(v->pm)) {
    case PMFLAG_s:
	if (v->a == 0 && v->b == -1) {
	    (v->pm->sets.cfn) (v->pm, val);
	    if (v->pm->flags & (PMFLAG_L | PMFLAG_R | PMFLAG_Z) && !v->pm->ct)
		v->pm->ct = strlen(val);
	} else {
	    char *z, *y, *x;
	    int zlen;

	    z = dupstring((v->pm->gets.cfn) (v->pm));
	    zlen = strlen(z);
	    if (v->inv)
		v->a--, v->b--;
	    if (v->a < 0) {
		v->a += zlen;
		if (v->a < 0)
		    v->a = 0;
	    }
	    if (v->a > zlen)
		v->a = zlen;
	    if (v->b < 0)
		v->b += zlen;
	    if (v->b < v->a)
		v->b = v->a;
	    if (v->b > zlen - 1)
		v->b = zlen - 1;
	    z[v->a] = '\0';
	    y = z + v->b + 1;
	    x = (char *)zalloc(strlen(z) + strlen(y) + strlen(val) + 1);
	    strcpy(x, z);
	    strcat(x, val);
	    strcat(x, y);
	    (v->pm->sets.cfn) (v->pm, x);
	    zsfree(val);
	}
	break;
    case PMFLAG_i:
	(v->pm->sets.ifn) (v->pm, matheval(val));
	if (!v->pm->ct && lastbase != 1)
	    v->pm->ct = lastbase;
	zsfree(val);
	break;
    case PMFLAG_A:
	if (v->a != v->b) {
	    char **ss = (char **)zalloc(2 * sizeof(char *));

	    ss[0] = val;
	    ss[1] = NULL;
	} else {
	    char **ss = (v->pm->gets.afn) (v->pm);
	    int ac, ad, t0;

	    if (v->inv)
		v->a--, v->b--;
	    ac = arrlen(ss);
	    if (v->a < 0) {
		v->a += ac;
		if (v->a < 0)
		    v->a = 0;
	    }
	    if (v->a >= ac) {
		char **st = ss;

		ad = v->a + 1;
		ss = (char **)zalloc((ad + 1) * sizeof *ss);
		for (t0 = 0; t0 != ac; t0++)
		    ss[t0] = ztrdup(st[t0]);
		while (ac < ad)
		    ss[ac++] = ztrdup("");
		ss[ac] = NULL;
	    }
	    zsfree(ss[v->a]);
	    ss[v->a] = val;
	    (v->pm->sets.afn) (v->pm, ss);
	}
	break;
    }
    if ((!v->pm->env && !(v->pm->flags & PMFLAG_x) &&
	 !(isset(ALLEXPORT) && !v->pm->old)) ||
	(v->pm->flags & PMFLAG_A) || v->pm->ename)
	return;
    if (pmtype(v->pm) == PMFLAG_i)
	convbase(val = buf, v->pm->gets.ifn(v->pm), v->pm->ct);
    else
	val = v->pm->gets.cfn(v->pm);
    if (v->pm->env)
	v->pm->env = replenv(v->pm->env, val);
    else {
	v->pm->flags |= PMFLAG_x;
	v->pm->env = addenv(v->pm->nam, val);
    }
}

void setintvalue(v, val)	/**/
Value v;
long val;
{
    char buf[20];

    if (v->pm->flags & PMFLAG_r)
	return;
    sprintf(buf, "%ld", val);
    if (v->pm->env) {
	v->pm->env = replenv(v->pm->env, buf);
    } else if ((v->pm->flags & PMFLAG_x) ||
	       (isset(ALLEXPORT) && !v->pm->old)) {
	v->pm->flags |= PMFLAG_x;
	v->pm->env = addenv(v->pm->nam, buf);
    }
    switch (pmtype(v->pm)) {
    case PMFLAG_s:
	(v->pm->sets.cfn) (v->pm, ztrdup(buf));
	break;
    case PMFLAG_i:
	(v->pm->sets.ifn) (v->pm, val);
	if (!v->pm->ct && lastbase != -1)
	    v->pm->ct = lastbase;
	break;
    case PMFLAG_A:
	zerr("attempt to assign integer to array", NULL, 0);
	break;
    }
}

void setintenv(s, val)		/**/
char *s;
long val;
{
    Param pm;
    char buf[20];

    if ((pm = (Param) gethnode(s, paramtab)) && pm->env) {
	sprintf(buf, "%ld", val);
	pm->env = replenv(pm->env, buf);
    }
}

void setarrvalue(v, val)	/**/
Value v;
char **val;
{
    if (v->pm->flags & PMFLAG_r) {
	freearray(val);
	return;
    }
    if (pmtype(v->pm) != PMFLAG_A) {
	freearray(val);
	zerr("attempt to assign array value to non-array", NULL, 0);
	return;
    }
    if (v->a == 0 && v->b == -1)
	(v->pm->sets.afn) (v->pm, val);
    else {
	char **old, **new, **p, **q, **r;
	int n, nn, l, ll, i;

	if (v->inv)
	    v->a--, v->b--;
	q = old = v->pm->gets.afn(v->pm);
	n = arrlen(old);
	if (v->a < 0)
	    v->a += n;
	if (v->b < 0)
	    v->b += n;
	if (v->a < 0)
	    v->a = 0;
	if (v->b < 0)
	    v->b = 0;
	if (v->a >= n)
	    v->a = n;
	if (v->b >= n)
	    v->b = n;

	if (v->a > v->b)
	    (v->pm->sets.afn) (v->pm, arrdup(nular));
	else {
	    l = v->b - v->a + 1;

	    nn = arrlen(val);

	    ll = n - l + nn;

	    p = new = (char **)zcalloc(sizeof(char *) * (ll + 1));

	    for (i = 0; i < v->a; i++)
		*p++ = ztrdup(*q++);
	    for (r = val; *r;)
		*p++ = ztrdup(*r++);
	    if (*q)
		for (q += l; *q;)
		    *p++ = ztrdup(*q++);

	    (v->pm->sets.afn) (v->pm, new);
	}
	freearray(val);
	freearray(old);
    }
}

long getiparam(s)		/**/
char *s;
{
    Value v;

    if (!(v = getvalue(&s, 0)))
	return 0;
    return getintvalue(v);
}

char *getsparam(s)		/**/
char *s;
{
    Value v;

    if (!(v = getvalue(&s, 0)))
	return NULL;
    return getstrvalue(v);
}

char **getaparam(s)		/**/
char *s;
{
    Value v;

    if (!((v = getvalue(&s, 0)) && v->isarr))
	return NULL;
    return getarrvalue(v);
}

Param setsparam(s, val)		/**/
char *s;
char *val;
{
    Value v;
    char *t = s;
    char *ss;

    if (!isident(s)) {
	zerr("not an identifier: %s", s, 0);
	zsfree(val);
	errflag = 1;
	return NULL;
    }
    if ((ss = strchr(s, '['))) {
	*ss = '\0';
	if (!(v = getvalue(&s, 1)))
	    createparam(t, PMFLAG_A);
	*ss = '[';
	v = NULL;
    } else {
	if (!(v = getvalue(&s, 1)))
	    createparam(t, PMFLAG_s);
	else if ((v->pm->flags & PMTYPE) == PMFLAG_A &&
		 !(v->pm->flags & PMFLAG_SPECIAL)) {
	    unsetparam(t);
	    createparam(t, PMFLAG_s);
	    v = NULL;
	}
    }
    if (!v)
	v = getvalue(&t, 1);
    setstrvalue(v, val);
    return v->pm;
}

Param setaparam(s, val)		/**/
char *s;
char **val;
{
    Value v;
    char *t = s;
    char *ss;

    if (!isident(s)) {
	zerr("not an identifier: %s", s, 0);
	freearray(val);
	errflag = 1;
	return NULL;
    }
    if ((ss = strchr(s, '['))) {
	*ss = '\0';
	if (!(v = getvalue(&s, 1)))
	    createparam(t, PMFLAG_A);
	*ss = '[';
	v = NULL;
    } else {
	if (!(v = getvalue(&s, 1)))
	    createparam(t, PMFLAG_A);
	else if ((v->pm->flags & PMTYPE) != PMFLAG_A &&
		 !(v->pm->flags & PMFLAG_SPECIAL)) {
	    unsetparam(t);
	    createparam(t, PMFLAG_A);
	    v = NULL;
	}
    }
    if (!v)
	v = getvalue(&t, 1);
    setarrvalue(v, val);
    return v->pm;
}

Param setiparam(s, val)		/**/
char *s;
long val;
{
    Value v;
    char *t = s;
    Param pm;

    if (!isident(s)) {
	zerr("not an identifier: %s", s, 0);
	errflag = 1;
	return NULL;
    }
    if (!(v = getvalue(&s, 0))) {
	pm = createparam(t, PMFLAG_i);
	pm->u.val = val;
	return pm;
    }
    setintvalue(v, val);
    return v->pm;
}

void unsetparam(s)		/**/
char *s;
{
    Param pm, oldpm;
    int spec;
    static int altflag = 0;

    if (!(pm = (Param) gethnode(s, paramtab)))
	return;
    if ((pm->flags & PMFLAG_r) && pm->level <= locallevel)
	return;
    spec = (pm->flags & PMFLAG_SPECIAL) && !pm->level;
    switch (pmtype(pm)) {
    case 0:
	(pm->sets.cfn) (pm, NULL);
	break;
    case PMFLAG_i:
	(pm->sets.ifn) (pm, 0);
	break;
    case PMFLAG_A:
	(pm->sets.afn) (pm, NULL);
	break;
    }
    if ((pm->flags & PMFLAG_x) && pm->env) {
	delenv(pm->env);
	zsfree(pm->env);
	pm->env = NULL;
    }
    if (pm->ename && !altflag) {
	altflag = 1;
	unsetparam(pm->ename);
	altflag = 0;
    }
    if ((locallevel && locallevel == pm->level) || spec) {
	pm->flags |= PMFLAG_UNSET;
    } else {
	oldpm = pm->old;
	freepm(remhnode(s, paramtab));
	if (oldpm) {
	    addhnode(ztrdup(s), oldpm, paramtab, freepm);
	    if (!(oldpm->flags & PMTYPE) && oldpm->sets.cfn == strsetfn)
		adduserdir(oldpm->nam, oldpm->u.str, 0, 1);
	}
    }
}

void intsetfn(pm, x)		/**/
Param pm;
long x;
{
    pm->u.val = x;
}

long intgetfn(pm)		/**/
Param pm;
{
    return pm->u.val;
}

void strsetfn(pm, x)		/**/
Param pm;
char *x;
{
    zsfree(pm->u.str);
    pm->u.str = x;
    adduserdir(pm->nam, x, 0, 2);
}

char *strgetfn(pm)		/**/
Param pm;
{
    return pm->u.str ? pm->u.str : "";
}

void nullsetfn(pm, x)		/**/
Param pm;
char *x;
{
    zsfree(x);
}

void arrsetfn(pm, x)		/**/
Param pm;
char **x;
{
    if (pm->u.arr && pm->u.arr != x)
	freearray(pm->u.arr);
    pm->u.arr = x;
}

char **arrgetfn(pm)		/**/
Param pm;
{
    char *nullarray = NULL;

    return pm->u.arr ? pm->u.arr : &nullarray;
}

void intvarsetfn(pm, x)		/**/
Param pm;
long x;
{
    *((long *)pm->data) = x;
}

long intvargetfn(pm)		/**/
Param pm;
{
    return *((long *)pm->data);
}

void strvarsetfn(pm, x)		/**/
Param pm;
char *x;
{
    char **q = ((char **)pm->data);

    zsfree(*q);
    *q = x;
}

char *strvargetfn(pm)		/**/
Param pm;
{
    char *s = *((char **)pm->data);

    if (!s)
	return "";
    return s;
}

char *strconstgetfn(pm)		/**/
Param pm;
{
    return (char *)pm->data;
}

char **colonfix(x, ename)	/**/
char *x;
char *ename;
{
    char **s, **t;

    s = colonsplit(x);
    if (ename)
	arrfixenv(ename, s);
    zsfree(x);
    for (t = s; *t; t++)
	if (!**t) {
	    free(*t);
	    *t = ztrdup(".");
	}
    return s;
}

void colonarrsetfn(pm, x)	/**/
Param pm;
char *x;
{
    char ***dptr = (char ***)pm->data;

    freearray(*dptr);
    if (pm->data == (vptr) & mailpath && x && !*x) {
	zsfree(x);
	*dptr = mkarray(NULL);
    } else
	*dptr = x ? colonfix(x, pm->ename ? pm->nam : NULL) : mkarray(NULL);
}

void colonpathsetfn(pm, x)	/**/
Param pm;
char *x;
{
    freearray(path);
    path = x ? colonfix(x, pm->nam) : mkarray(NULL);
    newcmdnamtab();
}

char *colonarrgetfn(pm)		/**/
Param pm;
{
    return join(*(char ***)pm->data, ':');
}

char *colonpathgetfn(pm)	/**/
Param pm;
{
    return join(path, ':');
}

char **arrvargetfn(pm)		/**/
Param pm;
{
    return *((char ***)pm->data);
}

void arrvarsetfn(pm, x)		/**/
Param pm;
char **x;
{
    char ***dptr = (char ***)pm->data;

    if (*dptr != x)
	freearray(*dptr);
    *dptr = x ? x : mkarray(NULL);
    if (pm->ename && x)
	arrfixenv(pm->ename, x);
}

char **pathgetfn(pm)		/**/
Param pm;
{
    return path;
}

void pathsetfn(pm, x)		/**/
Param pm;
char **x;
{
    if (path != x)
	freearray(path);
    path = x ? x : mkarray(NULL);
    newcmdnamtab();
    if (x)
	arrfixenv("PATH", x);
}

long poundgetfn(pm)		/**/
Param pm;
{
    return arrlen(pparams);
}

long randomgetfn(pm)		/**/
Param pm;
{
    return rand() & 0x7fff;
}

void randomsetfn(pm, v)		/**/
Param pm;
long v;
{
    srand((unsigned int)v);
}

long secondsgetfn(pm)		/**/
Param pm;
{
    return time(NULL) - shtimer.tv_sec;
}

void secondssetfn(pm, x)	/**/
Param pm;
long x;
{
    shtimer.tv_sec = time(NULL) - x;
    shtimer.tv_usec = 0;
}

long uidgetfn(pm)		/**/
Param pm;
{
    return getuid();
}

long euidgetfn(pm)		/**/
Param pm;
{
    return geteuid();
}

long gidgetfn(pm)		/**/
Param pm;
{
    return getgid();
}

long egidgetfn(pm)		/**/
Param pm;
{
    return getegid();
}

char *ifsgetfn(pm)		/**/
Param pm;
{
    return ifs;
}

void ifssetfn(pm, x)		/**/
Param pm;
char *x;
{
    if (x) {
	zsfree(ifs);
	ifs = x;
    }
    inittyptab();
}

void histsizesetfn(pm, v)	/**/
Param pm;
long v;
{
    if ((histsiz = v) <= 2)
	histsiz = 2;
    resizehistents();
}

long histsizegetfn(pm)		/**/
Param pm;
{
    return histsiz;
}

void lithistsizesetfn(pm, v)	/**/
Param pm;
long v;
{
    if ((lithistsiz = v) <= 2)
	lithistsiz = 2;
    resizehistents();
}

long lithistsizegetfn(pm)	/**/
Param pm;
{
    return lithistsiz;
}

long errnogetfn(pm)		/**/
Param pm;
{
    return errno;
}

char *dashgetfn(pm)		/**/
Param pm;
{
    static char buf[100];
    char *val;
    int t0;

    for (val = buf, t0 = ' '; t0 <= 'z'; t0++)
	if (isset(t0))
	    *val++ = t0;
    *val = '\0';
    return buf;
}

void histcharssetfn(pm, x)	/**/
Param pm;
char *x;
{
    if (x) {
	bangchar = x[0];
	hatchar = (bangchar) ? x[1] : '\0';
	hashchar = (hatchar) ? x[2] : '\0';
	zsfree(x);
    }
}

char *histcharsgetfn(pm)	/**/
Param pm;
{
    static char buf[4];

    buf[0] = bangchar;
    buf[1] = hatchar;
    buf[2] = hashchar;
    buf[3] = '\0';
    return buf;
}

char *homegetfn(pm)		/**/
Param pm;
{
    return home;
}

void homesetfn(pm, x)		/**/
Param pm;
char *x;
{
    zsfree(home);
    if (x && isset(CHASELINKS) && (home = xsymlink(x)))
	zsfree(x);
    else
	home = x ? x : ztrdup("");
    adduserdir("", home, 0, 1);
}

char *wordcharsgetfn(pm)	/**/
Param pm;
{
    return wordchars;
}

void wordcharssetfn(pm, x)	/**/
Param pm;
char *x;
{
    zsfree(wordchars);
    if (x)
	wordchars = x;
    else
	wordchars = ztrdup(DEFWORDCHARS);
    inittyptab();
}

char *underscoregetfn(pm)	/**/
Param pm;
{
    char *s, *t;

    if (!(s = qgetevent(curhist - 1)))
	return "";
    for (t = s + strlen(s); t > s; t--)
	if (*t == HISTSPACE)
	    break;
    if (t != s)
	t++;
    return t;
}

char *termgetfn(pm)		/**/
Param pm;
{
    return term;
}

extern hasam;

void termsetfn(pm, x)		/**/
Param pm;
char *x;
{
    zsfree(term);
    term = x ? x : ztrdup("");
    if (!interact || unset(USEZLE))
	return;
    if (!*term) {
	termok = 0;
    } else if (tgetent(termbuf, term) != 1) {
	zerr("can't find termcap info for %s", term, 0);
	errflag = 0;
	termok = 0;
    } else {
	char tbuf[1024], *pp;
	int t0;

	termok = 1;
	for (t0 = 0; t0 != TC_COUNT; t0++) {
	    pp = tbuf;
	    zsfree(tcstr[t0]);
	/* AIX tgetstr() ignores second argument */
	    if (!(pp = tgetstr(tccapnams[t0], &pp)))
		tcstr[t0] = NULL, tclen[t0] = 0;
	    else {
		tcstr[t0] = (char *)zalloc(tclen[t0] = strlen(pp) + 1);
		memcpy(tcstr[t0], pp, tclen[t0]);
	    }
	}

    /* if there's no termcap entry for cursor up, forget it.
	Use single line mode. */

	if (!tccan(TCUP)) {
	    termok = 0;
	    return;
	}
	hasam = tgetflag("am");
    /* if there's no termcap entry for cursor left, use \b. */

	if (!tccan(TCLEFT)) {
	    tcstr[TCLEFT] = ztrdup("\b");
	    tclen[TCLEFT] = 1;
	}
    /* if there's no termcap entry for clear, use ^L. */

	if (!tccan(TCCLEARSCREEN)) {
	    tcstr[TCCLEARSCREEN] = ztrdup("\14");
	    tclen[TCCLEARSCREEN] = 1;
	}
    /* if the termcap entry for down is \n, don't use it. */

	if (tccan(TCDOWN) && tcstr[TCDOWN][0] == '\n') {
	    tclen[TCDOWN] = 0;
	    zsfree(tcstr[TCDOWN]);
	    tcstr[TCDOWN] = NULL;
	}
    }
}

void setparams()
{				/**/
    char **envp, **envp2, **envp3, *str;
    char buf[50];
    struct param *pm;
    int ct;

    noerrs = 1;
    for (envp = environ, ct = 2; *envp; envp++, ct++);
    envp = environ;
    envp2 = envp3 = (char **)zalloc(sizeof(char *) * ct);

    for (; *envp; envp++)
	*envp2++ = ztrdup(*envp);
    *envp2 = NULL;
    envp = environ;
    environ = envp2 = envp3;
    for (; *envp; envp++, envp2++) {
	for (str = *envp; *str && *str != '='; str++);
	if (*str == '=') {
	    char *iname = NULL;

	    *str = '\0';
	    pm = (!idigit(**envp) && isident(*envp) && !strchr(*envp, '[')) ?
		setsparam(iname = *envp, ztrdup(str + 1)) : NULL;
	    if (pm) {
		pm->flags |= PMFLAG_x;
		pm->env = *envp2;
		if (pm->flags & PMFLAG_SPECIAL)
		    pm->env = replenv(pm->env, getsparam(iname));
	    }
	    *str = '=';
	}
    }
    pm = (struct param *)gethnode("HOME", paramtab);
    if (!(pm->flags & PMFLAG_x)) {
	pm->flags |= PMFLAG_x;
	pm->env = addenv("HOME", home);
    }
    pm = (struct param *)gethnode("PWD", paramtab);
    if (!(pm->flags & PMFLAG_x)) {
	pm->flags |= PMFLAG_x;
	pm->env = addenv("PWD", pwd);
    }
    pm = (struct param *)gethnode("LOGNAME", paramtab);
    if (!(pm->flags & PMFLAG_x)) {
	pm->flags |= PMFLAG_x;
	pm->env = addenv("LOGNAME", zlogname);
    }
    pm = (struct param *)gethnode("SHLVL", paramtab);
    if (!(pm->flags & PMFLAG_x))
	pm->flags |= PMFLAG_x;
    sprintf(buf, "%d", (int)++shlvl);
    pm->env = addenv("SHLVL", buf);
    noerrs = 0;
}

char *mkenvstr(x, y)		/**/
char *x;
char *y;
{
    char *z;
    int xl = strlen(x), yl = strlen(y);

    z = (char *)zalloc(xl + yl + 2);
    strcpy(z, x);
    z[xl] = '=';
    strcpy(z + xl + 1, y);
    z[xl + yl + 1] = '\0';
    return z;
}

void arrfixenv(s, t)		/**/
char *s;
char **t;
{
    char **ep, *u = join(t, ':');
    int sl = strlen(s);
    Param pm = (Param) gethnode(s, paramtab);

    for (ep = environ; *ep; ep++)
	if (!strncmp(*ep, s, sl) && (*ep)[sl] == '=') {
	    pm->env = replenv(*ep, u);
	    return;
	}
    if (isset(ALLEXPORT))
	pm->flags |= PMFLAG_x;
    if (pm->flags & PMFLAG_x)
	pm->env = addenv(s, u);
}

char *replenv(e, value)		/**/
char *e;
char *value;
{
    char **ep;

    for (ep = environ; *ep; ep++)
	if (*ep == e) {
	    char *s = e;

	    while (*s++ != '=');
	    *s = '\0';
	    *ep = (char *)zalloc(strlen(e) + strlen(value) + 2);
	    strcpy(*ep, e);
	    strcat(*ep, value);
	    zsfree(e);
	    return *ep;
	}
    return NULL;
}

char *addenv(name, value)	/*
 *
 * parse.c - parser
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"

#define YYERROR { tok = LEXERR; return NULL; }
#define YYERRORV { tok = LEXERR; return; }

#define make_list() allocnode(N_LIST)
#define make_sublist() allocnode(N_SUBLIST)
#define make_pline() allocnode(N_PLINE)
#define make_cmd() allocnode(N_CMD)
#define make_forcmd() allocnode(N_FOR)
#define make_casecmd() allocnode(N_CASE)
#define make_ifcmd() allocnode(N_IF)
#define make_whilecmd() allocnode(N_WHILE)
#define make_varnode() allocnode(N_VARASG)
#define make_cond() allocnode(N_COND)

/*
 * event	: ENDINPUT
 *			| SEPER
 *			| sublist [ SEPER | AMPER ]
 */
List parse_event()
{				/**/
    tok = ENDINPUT;
    incmdpos = 1;
    yylex();
    return par_event();
}

List par_event()
{				/**/
    Sublist sl;
    List l = NULL;

    while (tok == SEPER) {
	if (isnewlin > 0)
	    return NULL;
	yylex();
    }
    if (tok == ENDINPUT)
	return NULL;
    if ((sl = par_sublist()))
	if (tok == ENDINPUT) {
	    l = (List) make_list();
	    l->type = SYNC;
	    l->left = sl;
	} else if (tok == SEPER) {
	    l = (List) make_list();
	    l->type = SYNC;
	    l->left = sl;
	    if (isnewlin <= 0)
		yylex();
	} else if (tok == AMPER) {
	    l = (List) make_list();
	    l->type = ASYNC;
	    l->left = sl;
	    yylex();
	} else
	    l = NULL;
    if (!l) {
	if (errflag) {
	    yyerror();
	    return NULL;
	}
	yyerror();
	errflag = 0;
	if (isnewlin <= 0) {
	    int c;

	    hwbegin();
	    while ((c = hgetc()) != '\n' && !lexstop);
	    if (c == '\n')
		hungetc('\n');
	    hwaddc(HISTSPACE);
	    hwadd();
	}
	errflag = 1;
	return NULL;
    } else {
	l->right = par_event();
    }
    return l;
}

List parse_list()
{				/**/
    List ret;

    tok = ENDINPUT;
    incmdpos = 1;
    yylex();
    ret = par_list();
    if (tok == LEXERR) {
	yyerror();
	return NULL;
    }
    return ret;
}

/*
 * list	: { SEPER } [ sublist [ { SEPER | AMPER } list ] ]
 */
List par_list()
{				/**/
    Sublist sl;
    List l = NULL;

    while (tok == SEPER)
	yylex();
    if ((sl = par_sublist()))
	if (tok == SEPER || tok == AMPER) {
	    l = (List) make_list();
	    l->left = sl;
	    l->type = (tok == SEPER) ? SYNC : ASYNC;
	    incmdpos = 1;
	    while (tok == SEPER || tok == AMPER)
		yylex();
	    l->right = par_list();
	} else {
	    l = (List) make_list();
	    l->left = sl;
	    l->type = SYNC;
	}
    return l;
}

List par_list1()
{				/**/
    Sublist sl;
    List l = NULL;

    if ((sl = par_sublist())) {
	l = (List) make_list();
	l->type = SYNC;
	l->left = sl;
    }
    return l;
}

/*
 * sublist	: sublist2 [ ( DBAR | DAMPER ) { SEPER } sublist ]
 */
Sublist par_sublist()
{				/**/
    Sublist sl;

    if ((sl = par_sublist2()))
	if (tok == DBAR || tok == DAMPER) {
	    int qtok = tok;

	    cmdpush(tok == DBAR ? CS_CMDOR : CS_CMDAND);
	    yylex();
	    while (tok == SEPER)
		yylex();
	    sl->right = par_sublist();
	    sl->type = (qtok == DBAR) ? ORNEXT : ANDNEXT;
	    cmdpop();
	}
    return sl;
}

/*
 * sublist2	: [ COPROC | BANG ] pline
 */
Sublist par_sublist2()
{				/**/
    Sublist sl;
    Pline p;

    sl = (Sublist) make_sublist();
    if (tok == COPROC) {
	sl->flags |= PFLAG_COPROC;
	yylex();
    } else if (tok == BANG) {
	sl->flags |= PFLAG_NOT;
	yylex();
    }
    if (!(p = par_pline()) && !sl->flags)
	return NULL;
    sl->left = p;
    return sl;
}

/*
 * pline	: cmd [ ( BAR | BARAMP ) { SEPER } pline ]
 */
Pline par_pline()
{				/**/
    Cmd c;
    Pline p, p2;

    if (!(c = par_cmd()))
	return NULL;
    if (tok == BAR) {
	c->flags &= ~CFLAG_EXEC;
	cmdpush(CS_PIPE);
	yylex();
	while (tok == SEPER)
	    yylex();
	p2 = par_pline();
	cmdpop();
	p = (Pline) make_pline();
	p->left = c;
	p->right = p2;
	p->type = PIPE;
	return p;
    } else if (tok == BARAMP) {
	struct redir *rdr = (struct redir *)allocnode(N_REDIR);

	c->flags &= ~CFLAG_EXEC;
	rdr->type = MERGEOUT;
	rdr->fd1 = 2;
	rdr->fd2 = 1;
	addnode(c->redir, rdr);

	cmdpush(CS_ERRPIPE);
	yylex();
	p2 = par_pline();
	cmdpop();
	p = (Pline) make_pline();
	p->left = c;
	p->right = p2;
	p->type = PIPE;
	return p;
    } else {
	p = (Pline) make_pline();
	p->left = c;
	p->type = END;
	return p;
    }
}

/*
 * cmd	: { redir } ( for | case | if | while | repeat |
 *				subsh | funcdef | time | dinbrack | dinpar | simple ) { redir }
 */
Cmd par_cmd()
{				/**/
    Cmd c;

    c = (Cmd) make_cmd();
    c->lineno = lineno;
    c->args = newlist();
    c->redir = newlist();
    c->vars = newlist();
    while (IS_REDIROP(tok))
	par_redir(c->redir);
    switch (tok) {
    case FOR:
	cmdpush(CS_FOR);
	par_for(c);
	cmdpop();
	break;
    case FOREACH:
	cmdpush(CS_FOREACH);
	par_for(c);
	cmdpop();
	break;
    case SELECT:
	cmdpush(CS_SELECT);
	par_for(c);
	cmdpop();
	break;
    case CASE:
	cmdpush(CS_CASE);
	par_case(c);
	cmdpop();
	break;
    case IF:
	par_if(c);
	break;
    case WHILE:
	cmdpush(CS_WHILE);
	par_while(c);
	cmdpop();
	break;
    case UNTIL:
	cmdpush(CS_UNTIL);
	par_while(c);
	cmdpop();
	break;
    case REPEAT:
	cmdpush(CS_REPEAT);
	par_repeat(c);
	cmdpop();
	break;
    case INPAR:
	cmdpush(CS_SUBSH);
	par_subsh(c);
	cmdpop();
	break;
    case INBRACE:
	cmdpush(CS_CURSH);
	par_subsh(c);
	cmdpop();
	break;
    case FUNC:
	cmdpush(CS_FUNCDEF);
	par_funcdef(c);
	cmdpop();
	break;
    case TIME:
	par_time(c);
	break;
    case DINBRACK:
	cmdpush(CS_COND);
	par_dinbrack(c);
	cmdpop();
	break;
    case DINPAR:
	cmdpush(CS_MATH);
	par_dinpar(c);
	cmdpop();
	break;
    default:
	if (!par_simple(c))
	    return NULL;
	break;
    }
    while (IS_REDIROP(tok))
	par_redir(c->redir);
    incmdpos = 1;
    incasepat = 0;
    incond = 0;
    return c;
}

/*
 * for	: ( FOR[EACH] | SELECT ) name ( "in" wordlist | INPAR wordlist OUTPAR )
				{ SEPER } ( DO list DONE | INBRACE list OUTBRACE |
				list ZEND | list1 )
 */
void par_for(c)			/**/
Cmd c;
{
    struct forcmd *f;
    int csh = (tok == FOREACH);

    f = (struct forcmd *)make_forcmd();
    c->type = (tok == SELECT) ? CSELECT : CFOR;
    incmdpos = 0;
    yylex();
    if (tok != STRING || !isident(tokstr))
	YYERRORV;
    f->name = tokstr;
    incmdpos = 1;
    yylex();
    if (tok == STRING && !strcmp(tokstr, "in")) {
	f->inflag = 1;
	incmdpos = 0;
	yylex();
	c->args = par_wordlist();
	if (tok != SEPER)
	    YYERRORV;
    } else if (tok == INPAR && (csh || isset(CSHJUNKIEPAREN))) {
	f->inflag = 1;
	incmdpos = 0;
	yylex();
	c->args = par_nl_wordlist();
	if (tok != OUTPAR)
	    YYERRORV;
	incmdpos = 1;
	yylex();
    }
    incmdpos = 1;
    while (tok == SEPER)
	yylex();
    if (tok == DO) {
	yylex();
	f->list = par_list();
	if (tok != DONE)
	    YYERRORV;
	yylex();
    } else if (tok == INBRACE) {
	yylex();
	f->list = par_list();
	if (tok != OUTBRACE)
	    YYERRORV;
	yylex();
    } else if (csh || isset(CSHJUNKIELOOPS)) {
	f->list = par_list();
	if (tok != ZEND)
	    YYERRORV;
	yylex();
    } else if (isset(NOSHORTLOOPS)) {
	YYERRORV;
    } else
	f->list = par_list1();
    c->u.forcmd = f;
}

/*
 * case	: CASE STRING { SEPER } ( "in" | INBRACE )
				{ { SEPER } STRING { BAR STRING } OUTPAR list [ DSEMI ] }
				{ SEPER } ( "esac" | OUTBRACE )
 */
void par_case(c)		/**/
Cmd c;
{
    int brflag;
    Lklist pats, lists;
    int n = 0;
    char **pp;
    List *ll;
    Lknode no;
    struct casecmd *cc;

    c->type = CCASE;
    incmdpos = 0;
    yylex();
    if (tok != STRING)
	YYERRORV;
    addnode(c->args, tokstr);
    incmdpos = 1;
    yylex();
    while (tok == SEPER)
	yylex();
    if (!(tok == STRING && !strcmp(tokstr, "in")) && tok != INBRACE)
	YYERRORV;
    brflag = (tok == INBRACE);
    incasepat = 1;
    incmdpos = 0;
    yylex();
    cc = c->u.casecmd = (struct casecmd *)make_casecmd();
    pats = newlist();
    lists = newlist();
    for (;;) {
	char *str;

	while (tok == SEPER)
	    yylex();
	if (tok == OUTBRACE) {
	    yylex();
	    break;
	}
	if (tok != STRING)
	    YYERRORV;
	if (!strcmp(tokstr, "esac")) {
	    yylex();
	    break;
	}
	str = tokstr;
	yylex();
	while (tok == BAR) {
	    char *str2;
	    int sl = strlen(str);

	    yylex();
	    if (tok != STRING)
		YYERRORV;
	    str2 = (char *)alloc(sl + strlen(tokstr) + 2);
	    strcpy(str2, str);
	    str2[sl] = Bar;
	    strcpy(str2 + sl + 1, tokstr);
	    str = str2;
	    yylex();
	}
	if (tok != OUTPAR)
	    YYERRORV;
	incasepat = 0;
	incmdpos = 1;
	yylex();
	addnode(pats, str);
	addnode(lists, par_list());
	n++;
	if ((tok == ESAC && !brflag) || (tok == OUTBRACE && brflag)) {
	    yylex();
	    break;
	}
	if (tok != DSEMI)
	    YYERRORV;
	incasepat = 1;
	incmdpos = 0;
	yylex();
    }

    cc->pats = (char **)alloc((n + 1) * sizeof(char *));

    for (pp = cc->pats, no = firstnode(pats); no; incnode(no))
	*pp++ = (char *)getdata(no);
    *pp = NULL;
    cc->lists = (List *) alloc((n + 1) * sizeof(List));
    for (ll = cc->lists, no = firstnode(lists); no; incnode(no), ll++)
	if (!(*ll = (List) getdata(no)))
	    *ll = &dummy_list;
    *ll = NULL;
}

/*
 * if	: { ( IF | ELIF ) { SEPER } ( INPAR list OUTPAR | list )
			{ SEPER } ( THEN list | INBRACE list OUTBRACE | list1 ) }
			[ FI | ELSE list FI | ELSE { SEPER } INBRACE list OUTBRACE ]
			(you get the idea...?)
 */
void par_if(c)			/**/
Cmd c;
{
    struct ifcmd *i;
    int xtok;
    unsigned char nc;
    Lklist ifsl, thensl;
    Lknode no;
    int ni = 0, nt = 0;
    List l, *ll;

    ifsl = newlist();
    thensl = newlist();

    c->type = CIF;
    for (;;) {
	xtok = tok;
	cmdpush(xtok == IF ? CS_IF : CS_ELIF);
	yylex();
	if (xtok == FI)
	    break;
	if (xtok == ELSE)
	    break;
	while (tok == SEPER)
	    yylex();
	if (!(xtok == IF || xtok == ELIF)) {
	    cmdpop();
	    YYERRORV;
	}
	if (tok == INPAR && isset(CSHJUNKIEPAREN)) {
	    yylex();
	    l = par_list();
	    if (tok != OUTPAR) {
		cmdpop();
		YYERRORV;
	    }
	    addnode(ifsl, l);
	    ni++;
	    incmdpos = 1;
	    yylex();
	} else {
	    addnode(ifsl, par_list());
	    ni++;
	    incmdpos = 1;
	}
	while (tok == SEPER)
	    yylex();
	xtok = FI;
	nc = cmdstack[cmdsp - 1] == CS_IF ? CS_IFTHEN : CS_ELIFTHEN;
	if (tok == THEN) {
	    cmdpop();
	    cmdpush(nc);
	    yylex();
	    addnode(thensl, par_list());
	    nt++;
	    incmdpos = 1;
	    cmdpop();
	} else if (isset(CSHJUNKIEPAREN)) {
	    if (tok == INBRACE) {
		cmdpop();
		cmdpush(nc);
		yylex();
		l = par_list();
		if (tok != OUTBRACE) {
		    cmdpop();
		    YYERRORV;
		}
		addnode(thensl, l);
		nt++;
		yylex();
		incmdpos = 1;
		if (tok == SEPER)
		    break;
		cmdpop();
	    } else if (isset(NOSHORTLOOPS)) {
		cmdpop();
		YYERRORV;
	    } else {
		cmdpop();
		cmdpush(nc);
		addnode(thensl, par_list1());
		nt++;
		cmdpop();
		incmdpos = 1;
		break;
	    }
	} else {
	    cmdpop();
	    YYERRORV;
	}
    }
    cmdpop();
    if (xtok == ELSE) {
	cmdpush(CS_ELSE);
	while (tok == SEPER)
	    yylex();
	if (tok == INBRACE) {
	    yylex();
	    l = par_list();
	    if (tok != OUTBRACE) {
		cmdpop();
		YYERRORV;
	    }
	    addnode(thensl, l);
	    nt++;
	    yylex();
	} else {
	    l = par_list();
	    if (tok != FI) {
		cmdpop();
		YYERRORV;
	    }
	    addnode(thensl, l);
	    nt++;
	    yylex();
	}
	cmdpop();
    }
    i = (struct ifcmd *)make_ifcmd();
    i->ifls = (List *) alloc((ni + 1) * sizeof(List));
    i->thenls = (List *) alloc((nt + 1) * sizeof(List));

    for (ll = i->ifls, no = firstnode(ifsl); no; incnode(no), ll++)
	if (!(*ll = (List) getdata(no)))
	    *ll = &dummy_list;
    *ll = NULL;
    for (ll = i->thenls, no = firstnode(thensl); no; incnode(no), ll++)
	if (!(*ll = (List) getdata(no)))
	    *ll = &dummy_list;
    *ll = NULL;

    c->u.ifcmd = i;
}

/*
 * while	: ( WHILE | UNTIL ) ( INPAR list OUTPAR | list ) { SEPER }
				( DO list DONE | INBRACE list OUTBRACE | list ZEND )
 */
void par_while(c)		/**/
Cmd c;
{
    struct whilecmd *w;

    c->type = CWHILE;
    w = c->u.whilecmd = (struct whilecmd *)make_whilecmd();
    w->cond = (tok == UNTIL);
    yylex();
    if (tok == INPAR && isset(CSHJUNKIEPAREN)) {
	yylex();
	w->cont = par_list();
	if (tok != OUTPAR)
	    YYERRORV;
	yylex();
    } else {
	w->cont = par_list();
    }
    incmdpos = 1;
    while (tok == SEPER)
	yylex();
    if (tok == DO) {
	yylex();
	w->loop = par_list();
	if (tok != DONE)
	    YYERRORV;
	yylex();
    } else if (tok == INBRACE) {
	yylex();
	w->loop = par_list();
	if (tok != OUTBRACE)
	    YYERRORV;
	yylex();
    } else if (isset(CSHJUNKIELOOPS)) {
	w->loop = par_list();
	if (tok != ZEND)
	    YYERRORV;
	yylex();
    } else
	YYERRORV;
}

/*
 * repeat	: REPEAT STRING { SEPER } ( DO list DONE | list1 )
 */
void par_repeat(c)		/**/
Cmd c;
{
    c->type = CREPEAT;
    incmdpos = 0;
    yylex();
    if (tok != STRING)
	YYERRORV;
    addnode(c->args, tokstr);
    incmdpos = 1;
    yylex();
    while (tok == SEPER)
	yylex();
    if (tok == DO) {
	yylex();
	c->u.list = par_list();
	if (tok != DONE)
	    YYERRORV;
	yylex();
    } else {
	c->u.list = par_list1();
    }
}

/*
 * subsh	: ( INPAR | INBRACE ) list ( OUTPAR | OUTBRACE )
 */
void par_subsh(c)		/**/
Cmd c;
{
    c->type = (tok == INPAR) ? SUBSH : CURSH;
    yylex();
    c->u.list = par_list();
    if (tok != ((c->type == SUBSH) ? OUTPAR : OUTBRACE))
	YYERRORV;
    incmdpos = 0;
    yylex();
}

/*
 * funcdef	: FUNCTION wordlist [ INOUTPAR ] { SEPER }
 *					( list1 | INBRACE list OUTBRACE )
 */
void par_funcdef(c)		/**/
Cmd c;
{
    nocorrect = 1;
    incmdpos = 0;
    yylex();
    c->type = FUNCDEF;
    c->args = newlist();
    incmdpos = 1;
    while (tok == STRING) {
	if (*tokstr == Inbrace && !tokstr[1]) {
	    tok = INBRACE;
	    break;
	}
	addnode(c->args, tokstr);
	yylex();
    }
    nocorrect = 0;
    if (tok == INOUTPAR)
	yylex();
    while (tok == SEPER)
	yylex();
    if (tok == INBRACE) {
	yylex();
	c->u.list = par_list();
	if (tok != OUTBRACE)
	    YYERRORV;
	yylex();
    } else if (isset(NOSHORTLOOPS)) {
	YYERRORV;
    } else
	c->u.list = par_list1();
}

/*
 * time	: TIME sublist2
 */
void par_time(c)		/**/
Cmd c;
{
    yylex();
    c->type = ZCTIME;
    c->u.pline = par_sublist2();
}

/*
 * dinbrack	: DINBRACK cond DOUTBRACK
 */
void par_dinbrack(c)		/**/
Cmd c;
{
    c->type = COND;
    incond = 1;
    incmdpos = 0;
    yylex();
    c->u.cond = par_cond();
    if (tok != DOUTBRACK)
	YYERRORV;
    incond = 0;
    incmdpos = 1;
    yylex();
}

/*
 * dinpar : DINPAR expr DOUTPAR
 */
void par_dinpar(c)		/**/
Cmd c;
{
    c->type = SIMPLE;
    addnode(c->args, dupstring("builtin"));
    addnode(c->args, dupstring("let"));
    incmdpos = 0;
    yylex();
    if (tok != DOUTPAR)
	YYERRORV;
    addnode(c->args, tokstr);
    if (underscore)
	free(underscore);
    underscore = ztrdup(tokstr);
    untokenize(underscore);
    incmdpos = 1;
    yylex();
}

/*
 * simple	: { COMMAND | EXEC | NOGLOB | NOCORRECT | DASH }
					{ STRING | ENVSTRING | ENVARRAY wordlist OUTPAR | redir }
					[ INOUTPAR { SEPER } ( list1 | INBRACE list OUTBRACE ) ]
 */
Cmd par_simple(c)		/**/
Cmd c;
{
    int isnull = 1;

    c->type = SIMPLE;
    for (;;) {
	if (tok == COMMAND)
	    c->flags |= CFLAG_COMMAND;
	else if (tok == EXEC)
	    c->flags |= CFLAG_EXEC;
	else if (tok == NOGLOB)
	    c->flags |= CFLAG_NOGLOB;
	else if (tok == NOCORRECT)
	    nocorrect = 1;
	else if (tok == DASH)
	    c->flags = CFLAG_DASH;
	else
	    break;
	yylex();
    }
    if (tok == AMPER)
	YYERROR;
    for (;;) {
	if (tok == STRING) {
	    incmdpos = 0;
	    addnode(c->args, tokstr);
	    yylex();
	} else if (tok == ENVSTRING) {
	    struct varasg *v = (struct varasg *)make_varnode();

	    v->type = PMFLAG_s;
	    equalsplit(v->name = tokstr, &v->str);
	    addnode(c->vars, v);
	    yylex();
	} else if (tok == ENVARRAY) {
	    struct varasg *v = (struct varasg *)make_varnode();
	    int oldcmdpos = incmdpos;

	    v->type = PMFLAG_A;
	    incmdpos = 0;
	    v->name = tokstr;
	    cmdpush(CS_ARRAY);
	    yylex();
	    v->arr = par_nl_wordlist();
	    cmdpop();
	    if (tok != OUTPAR)
		YYERROR;
	    incmdpos = oldcmdpos;
	    yylex();
	    addnode(c->vars, v);
	} else if (IS_REDIROP(tok)) {
	    par_redir(c->redir);
	} else if (tok == INOUTPAR) {
	    incmdpos = 1;
	    cmdpush(CS_FUNCDEF);
	    yylex();
	    while (tok == SEPER)
		yylex();
	    if (tok == INBRACE) {
		yylex();
		c->u.list = par_list();
		if (tok != OUTBRACE) {
		    cmdpop();
		    YYERROR;
		}
		yylex();
	    } else if (isset(NOSHORTLOOPS)) {
		cmdpop();
		YYERROR;
	    } else
		c->u.list = par_list1();
	    cmdpop();
	    c->type = FUNCDEF;
	} else
	    break;
	isnull = 0;
    }
    if (isnull && empty(c->redir))
	return NULL;
    if (full(c->args)) {
	if (underscore)
	    free(underscore);
	underscore = ztrdup(getdata(lastnode(c->args)));
	untokenize(underscore);
    }
    incmdpos = 1;
    return c;
}

/*
 * cond	: cond_1 { SEPER } [ DBAR { SEPER } cond ]
 */
Cond par_cond()
{				/**/
    Cond c, c2;

    c = par_cond_1();
    while (tok == SEPER)
	yylex();
    if (tok == DBAR) {
	yylex();
	while (tok == SEPER)
	    yylex();
	c2 = (Cond) make_cond();
	c2->left = (vptr) c;
	c2->right = (vptr) par_cond();
	c2->type = COND_OR;
	return c2;
    }
    return c;
}

/*
 * cond_1 : cond_2 { SEPER } [ DAMPER { SEPER } cond_1 ]
 */
Cond par_cond_1()
{				/**/
    Cond c, c2;

    c = par_cond_2();
    while (tok == SEPER)
	yylex();
    if (tok == DAMPER) {
	yylex();
	while (tok == SEPER)
	    yylex();
	c2 = (Cond) make_cond();
	c2->left = (vptr) c;
	c2->right = (vptr) par_cond_1();
	c2->type = COND_AND;
	return c2;
    }
    return c;
}

/*
 * cond_2	: BANG cond_2
				| INPAR { SEPER } cond_2 { SEPER } OUTPAR
				| STRING STRING STRING
				| STRING STRING
				| STRING ( INANG | OUTANG ) STRING
 */
Cond par_cond_2()
{				/**/
    Cond c, c2;
    char *s1, *s2, *s3;
    int xtok;

    if (tok == BANG) {
	yylex();
	c = par_cond_2();
	c2 = (Cond) make_cond();
	c2->left = (vptr) c;
	c2->type = COND_NOT;
	return c2;
    }
    if (tok == INPAR) {
	yylex();
	while (tok == SEPER)
	    yylex();
	c = par_cond();
	while (tok == SEPER)
	    yylex();
	if (tok != OUTPAR)
	    YYERROR;
	yylex();
	return c;
    }
    if (tok != STRING)
	YYERROR;
    s1 = tokstr;
    yylex();
    xtok = tok;
    if (tok == INANG || tok == OUTANG) {
	yylex();
	if (tok != STRING)
	    YYERROR;
	s3 = tokstr;
	yylex();
	c = (Cond) make_cond();
	c->left = (vptr) s1;
	c->right = (vptr) s3;
	c->type = (xtok == INANG) ? COND_STRLT : COND_STRGTR;
	c->ntype = NT_SET(N_COND, 1, NT_STR, NT_STR, 0, 0);
	return c;
    }
    if (tok != STRING)
	YYERROR;
    s2 = tokstr;
    incond++;			/* parentheses do globbing */
    yylex();
    incond--;			/* parentheses do grouping */
    if (tok == STRING) {
	s3 = tokstr;
	yylex();
	return par_cond_triple(s1, s2, s3);
    } else
	return par_cond_double(s1, s2);
}

/*
 * redir	: ( OUTANG | ... | TRINANG ) STRING
 */
void par_redir(l)		/**/
Lklist l;
{
    char *toks;
    struct redir *fn = (struct redir *)allocnode(N_REDIR);
    int mergerror = 0;
    int oldcmdpos, oldnc;
    unsigned char bc = bangchar;

    oldcmdpos = incmdpos;
    incmdpos = 0;
    oldnc = nocorrect;
    if (tok != INANG)
	nocorrect = 1;
    fn->type = redirtab[tok - OUTANG];
    fn->fd1 = tokfd;
    if (fn->type == HEREDOC || fn->type == HEREDOCDASH)
	bangchar = '\0';
    yylex();
    bangchar = bc;
    if (tok != STRING && tok != ENVSTRING)
	YYERRORV;
    toks = tokstr;
    incmdpos = oldcmdpos;
    nocorrect = oldnc;
    yylex();

/* assign default fd */

    if (fn->fd1 == -1)
	fn->fd1 = IS_READFD(fn->type) ? 0 : 1;

/* > >(...) or < <(...) */

    if ((*toks == Inang || *toks == Outang) && toks[1] == Inpar) {
	if ((fn->type & ~1) == WRITE)
	    fn->type = OUTPIPE;
	else if (fn->type == READ)
	    fn->type = INPIPE;
	else
	    YYERRORV;
	fn->name = toks;

    /* <<[-] name */

    } else if (fn->type == HEREDOC || fn->type == HEREDOCDASH) {
	char tbuf[256], *tlin = NULL;
	int tsiz = 0, redirl;

    /* Save the rest of the current line for later tokenization */
	if (!isnewlin) {
	    while (hgets(tbuf, 256) != NULL) {
		redirl = strlen(tbuf);
		if (tsiz == 0) {
		    tlin = ztrdup(tbuf);	/* Test for failure? */
		    tsiz = redirl;
		} else {
		    tlin = realloc(tlin, tsiz + redirl + 1);	/* Test for failure? */
		    strcpy(&tlin[tsiz], tbuf);
		    tsiz += redirl;
		}
		if (tbuf[redirl - 1] == '\n')
		    break;
	    }
	}
	cmdpush(fn->type == HEREDOC ? CS_HEREDOC : CS_HEREDOCD);
    /* Now grab the document */
	fn->name = gethere(toks, fn->type);
	fn->type = HERESTR;
	cmdpop();
    /* Put back the saved line to resume tokenizing */
	if (tsiz > 0) {
	    hungets(tlin);
	    free(tlin);
	}
    /* >& name or >>& name */

    } else if (IS_ERROR_REDIR(fn->type) && getfdstr(toks) == FD_WORD) {
	mergerror = 1;
	fn->name = toks;
	fn->type = UN_ERROR_REDIR(fn->type);

    /* >>& and >>&! are only valid with a name after them */

    } else if (fn->type == ERRAPP || fn->type == ERRAPPNOW) {
	YYERRORV;

    /* >& # */

    } else if (fn->type == MERGE || fn->type == MERGEOUT) {
	fn->fd2 = getfdstr(toks);
	if (fn->fd2 == FD_CLOSE)
	    fn->type = CLOSE;
	else if (fn->fd2 == FD_WORD)
	    fn->fd2 = (fn->type == MERGEOUT) ? 1 : 0;
    } else
	fn->name = toks;
    addnode(l, fn);
    if (mergerror) {
	struct redir *fe = (struct redir *)allocnode(N_REDIR);

	fe->fd1 = 2;
	fe->fd2 = fn->fd1;
	fe->type = MERGEOUT;
	addnode(l, fe);
    }
}

/*
 * wordlist	: { STRING }
 */
Lklist par_wordlist()
{				/**/
    Lklist l;

    l = newlist();
    while (tok == STRING) {
	addnode(l, tokstr);
	yylex();
    }
    return l;
}

/*
 * nl_wordlist	: { STRING | SEPER }
 */
Lklist par_nl_wordlist()
{				/**/
    Lklist l;

    l = newlist();
    while (tok == STRING || tok == SEPER) {
	if (tok != SEPER)
	    addnode(l, tokstr);
	yylex();
    }
    return l;
}

/* get fd associated with str */

int getfdstr(s)			/**/
char *s;
{
    if (s[1])
	return FD_WORD;
    if (idigit(*s))
	return *s - '0';
    if (*s == 'p')
	return FD_COPROC;
    if (*s == '-')
	return FD_CLOSE;
    return FD_WORD;
}

Cond par_cond_double(a, b)	/**/
char *a;
char *b;
{
    Cond n = (Cond) make_cond();

    if (a[0] != '-' || !a[1] || a[2]) {
	zerr("parse error: condition expected: %s", a, 0);
	return NULL;
    }
    n->left = (vptr) b;
    n->type = a[1];
    n->ntype = NT_SET(N_COND, 1, NT_STR, NT_STR, 0, 0);
    return n;
}

int get_cond_num(tst)		/**/
char *tst;
{
    static char *condstrs[] =
    {
	"nt", "ot", "ef", "eq", "ne", "lt", "gt", "le", "ge", NULL
    };
    int t0;

    for (t0 = 0; condstrs[t0]; t0++)
	if (!strcmp(condstrs[t0], tst))
	    return t0;
    return -1;
}

Cond par_cond_triple(a, b, c)	/**/
char *a;
char *b;
char *c;
{
    Cond n = (Cond) make_cond();
    int t0;

    if ((b[0] == Equals || b[0] == '=') && !b[1])
	n->type = COND_STREQ;
    else if (b[0] == '!' && (b[1] == Equals || b[1] == '=') && !b[2])
	n->type = COND_STRNEQ;
    else if (b[0] == '-') {
	if ((t0 = get_cond_num(b + 1)) > -1)
	    n->type = t0 + COND_NT;
	else
	    zerr("unrecognized condition: %s", b, 0);
    } else
	zerr("condition expected: %s", b, 0);
    n->left = (vptr) a;
    n->right = (vptr) c;
    n->ntype = NT_SET(N_COND, 1, NT_STR, NT_STR, 0, 0);
    return n;
}

void yyerror()
{				/**/
    int t0;

    for (t0 = 0; t0 != 20; t0++)
	if (!yytext[t0] || yytext[t0] == '\n' || yytext[t0] == HISTSPACE)
	    break;
    if (t0 == 20)
	zerr("parse error near `%l...'", yytext, 20);
    else if (t0)
	zerr("parse error near `%l'", yytext, t0);
    else
	zerr("parse error", NULL, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 *
 * subst.c - various substitutions
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"
#include <pwd.h>

/* do substitutions before fork */

void prefork(list, flags)	/**/
Lklist list;
int flags;
{
    Lknode node = firstnode(list);
    int qt;

 /* bits 0 and 1 of flags are flags to filesub (treat as assignment)
     * bit 2 is a flag to paramsubst (single word sub)
     */
    while (node) {
	char *str, *str3;
	int keep = 1;

	str = str3 = (char *)getdata(node);
	if ((*str == Inang || *str == Outang || *str == Equals) &&
	    str[1] == Inpar) {
	    if (*str == Inang)
		setdata(node, (vptr) getoutproc(str + 2));	/* <(...) */
	    else if (*str == Equals)
		setdata(node, (vptr) getoutputfile(str + 2));	/* =(...) */
	    else
		setdata(node, (vptr) getinproc(str + 2));	/* >(...) */
	    if (!getdata(node)) {
		zerr("parse error in process substitution", NULL, 0);
		return;
	    }
	} else
	    while (*str) {
		if ((qt = *str == Qstring) || *str == String)
		    if (str[1] != Inpar)
			if (str[1] == Inbrack) {
			    arithsubst((vptr *) & str, &str3);	/* $[...] */
			    setdata(node, (vptr) str3);
			    str = str3;
			    continue;
			} else {
			    if (!paramsubst(list, node, str, str3,
					    qt | (flags & 4), !(flags & 010)))
				keep = 0;
			    if (errflag)
				return;
			    if (!keep)
				break;
			    str3 = str = (char *)getdata(node);
			    continue;
			}
		str++;
		if (errflag)
		    return;
	    }
	if (keep) {
	    if (*(char *)getdata(node))
		remnulargs(getdata(node));
	    if (unset(IGNOREBRACES))
		while (hasbraces(getdata(node)))
		    xpandbraces(list, &node);
	    filesub((char **)getaddrdata(node), flags & 3);
	    if (errflag)
		return;
	    incnode(node);
	} else {
	    Lknode zapnode;

	    zapnode = node;
	    incnode(node);
	    uremnode(list, zapnode);
	}
    }
}

void postfork(list, flags)	/**/
Lklist list;
int flags;
{
    Lknode node = firstnode(list);
    int glb = 1;

 /* bit 0 of flags is to do glob, bit 1 is flag for single substitution */
    badcshglob = 0;
    if (isset(NOGLOBOPT) || !(flags & 1))
	glb = 0;
    while (node) {
	char *str3, *str;

	str = str3 = (char *)getdata(node);
	while (*str) {
	    if (((*str == String || *str == Qstring) && str[1] == Inpar) ||
		*str == Tick || *str == Qtick) {
		Lknode n = prevnode(node);

	    /* `...`,$(...) */
		commsubst(list, node, str, str3,
			  (*str == Qstring || *str == Qtick || flags > 1));
		if (errflag)
		    return;
		if (!(node = nextnode(n)))
		    return;
		str = str3 = (char *)getdata(node);
		continue;
	    }
	    str++;
	}
	if (glb) {
	    if (haswilds(getdata(node)))
		glob(list, &node);
	    if (errflag)
		return;
	}
	incnode(node);
    }
    if (badcshglob == 1)
	zerr("no match", NULL, 0);
}

/* perform substitution on a single word */

void singsub(s)			/**/
char **s;
{
    Lklist foo;

    foo = newlist();
    addnode(foo, *s);
    prefork(foo, 014);
    if (errflag)
	return;
    postfork(foo, 010);
    if (errflag)
	return;
    *s = (char *)ugetnode(foo);
    remnulargs(*s);
    if (firstnode(foo))
	zerr("ambiguous: %s", *s, 0);
}

/* ~, = subs: assign = 2 => typeset; assign = 1 => something that looks
	like an assignment but may not be; assign = 3 => normal assignment */

void filesub(namptr, assign)	/**/
char **namptr;
int assign;
{
    char *sub = (char *)NULL, *str, *ptr;
    int len;

    filesubstr(namptr, assign);

    if (!assign)
	return;

    if (assign < 3)
	if ((*namptr)[1] && (sub = strchr(*namptr + 1, Equals))) {
	    if (assign == 1)
		for (ptr = *namptr; ptr != sub; ptr++)
		    if (!iident(*ptr) && !INULL(*ptr))
			return;
	    *sub = Equals;
	    str = sub + 1;
	    if ((sub[1] == Tilde || sub[1] == Equals) && filesubstr(&str, assign)) {
		sub[1] = '\0';
		*namptr = dyncat(*namptr, str);
	    }
	} else
	    return;

    ptr = *namptr;
    while ((sub = strchr(ptr, ':'))) {
	str = sub + 1;
	len = sub - *namptr;
	if ((sub[1] == Tilde || sub[1] == Equals) && filesubstr(&str, assign)) {
	    sub[1] = '\0';
	    *namptr = dyncat(*namptr, str);
	}
	ptr = *namptr + len + 1;
    }
}

int filesubstr(namptr, assign)	/**/
char **namptr;
int assign;
{
    char *str = *namptr, *cnam;

    if (*str == Tilde && str[1] != '=' && str[1] != Equals) {
	if (str[1] == '+' && (str[2] == '/' || str[2] == Inpar ||
			      (assign && str[2] == ':') || !str[2])) {
	    *namptr = dyncat(pwd, str + 2);	/* ~+ */
	    return 1;
	} else if (str[1] == '-' && (str[2] == '/' || str[2] == Inpar ||
				     (assign && str[2] == ':') || !str[2])) {
	    *namptr = dyncat((cnam = oldpwd) ? cnam : pwd, str + 2);	/* ~- */
	    return 1;
	} else if (ialpha(str[1])) {	/* ~foo */
	    char *ptr, *hom;

	    for (ptr = ++str; *ptr && iuser(*ptr); ptr++);
	    if (*ptr && *ptr != '/' && *ptr != Inpar &&
		(!assign || *ptr != ':'))
		return 0;
	    if (!(hom = getnamedir(str, ptr - str))) {
		if (!isset(NONOMATCH))
		    zerr("user not found: %l", str, ptr - str);
		return 0;
	    }
	    *namptr = dyncat(hom, ptr);
	    return 1;
	} else if (str[1] == '/' || str[1] == Inpar ||
		   (assign && str[1] == ':')) {	/* ~/foo */
	    *namptr = dyncat(home, str + 1);
	    return 1;
	} else if (!str[1]) {	/* ~ by itself */
	    *namptr = dupstring(home);
	    return 1;
	}
    } else if (*str == Equals && unset(NOEQUALS) && str[1]) {
	char *ptr, *ds;
	int val;

	if (str[1] == '-') {	/* =- */
	    val = -1;
	    ptr = str + 2;
	} else if (idigit(str[1]))
	    val = zstrtol(str + 1, &ptr, 10);	/* =# */
	else
	/* =foo */
	{
	    char sav, *pp;

	    for (pp = str + 1; *pp && *pp != Inpar && (!assign || *pp != ':');
		 pp++);
	    sav = *pp;
	    *pp = '\0';
	    if (!(cnam = findcmd(str + 1))) {
		if (!isset(NONOMATCH))
		    zerr("%s not found", str + 1, 0);
		return 0;
	    }
	    *namptr = dupstring(cnam);
	    zsfree(cnam);
	    if (sav) {
		*pp = sav;
		*namptr = dyncat(*namptr, pp);
	    }
	    return 1;
	}
	ds = dstackent(val);
	if (!ds)
	    return 1;
	*namptr = dyncat(ds, ptr);
	return 1;
    }
    return 0;
}

/* get a named directory */

char *getnamedir(user, len)	/**/
char *user;
int len;
{
    char sav, *str, *ret_val = NULL;
    struct passwd *pw;
    int t0;
    struct param *pm;

    if (len == 0)
	return dupstring(home);
    sav = user[len];
    user[len] = '\0';
    if ((t0 = findname(user)) != -1)
	ret_val = dupstring(namdirs[t0].dir);
    else if ((pm = (struct param *)gethnode(user, paramtab)) &&
	     !(pm->flags & (PMFLAG_i | PMFLAG_A)) &&
	     (str = getsparam(user)) && *str == '/') {
	adduserdir(user, str, 0, 1);
	ret_val = str;
    } else if ((pw = getpwnam(user))) {
	str = xsymlink(pw->pw_dir);
	adduserdir(user, str, 1, 1);
	ret_val = dupstring(str);
	zsfree(str);
    }
    user[len] = sav;
    return ret_val;
}

/* `...`, $(...) */

void commsubst(l, n, str3, str, qt)	/**/
Lklist l;
Lknode n;
char *str3;
char *str;
int qt;
{
    char *str2;
    Lknode where = prevnode(n);
    Lklist pl;

    if (*str3 == Tick || *str3 == Qtick) {
	*str3 = '\0';
	for (str2 = ++str3; *str3 && *str3 != Tick && *str3 != Qtick; str3++);
	*str3++ = '\0';
    } else {
	*str3++ = '\0';
	for (str2 = ++str3; *str3 && *str3 != Outpar; str3++);
	*str3++ = '\0';
    }
    uremnode(l, n);
    if (!(pl = getoutput(str2, qt))) {
	if (!errflag)
	    zerr("parse error in command substitution", NULL, 0);
	return;
    }
    if (full(pl)) {
	setdata(firstnode(pl), (vptr) dyncat(str, peekfirst(pl)));
	setdata(lastnode(pl), (vptr) dyncat(getdata(lastnode(pl)), str3));
	inslist(pl, where, l);
    } else
	insnode(l, where, dyncat(str, str3));
}

void strcatsub(dest, src, globsubst)	/**/
char *dest;
char *src;
int globsubst;
{
    strcat(dest, src);
    if (globsubst)
	tokenize(dest);
}

int strpcmp(a, b)		/**/
const void *a;
const void *b;
{
    return strcmp(*(char **)a, *(char **)b);
}

int invstrpcmp(a, b)		/**/
const void *a;
const void *b;
{
    return -strcmp(*(char **)a, *(char **)b);
}

int cstrpcmp(a, b)		/**/
const void *a;
const void *b;
{
    char *c = *(char **)a, *d = *(char **)b;

    for (; *c && tulower(*c) == tulower(*d); c++, d++);

    return (int)(unsigned char)tulower(*c) - (int)(unsigned char)tulower(*d);
}

int invcstrpcmp(a, b)		/**/
const void *a;
const void *b;
{
    char *c = *(char **)a, *d = *(char **)b;

    for (; *c && tulower(*c) == tulower(*d); c++, d++);

    return (int)(unsigned char)tulower(*d) - (int)(unsigned char)tulower(*c);
}

char *dopadding(str, prenum, postnum, preone, postone, premul, postmul)	/**/
char *str;
int prenum;
int postnum;
char *preone;
char *postone;
char *premul;
char *postmul;
{
    char def[2], *ret, *t, *r;
    int ls, ls2, lpreone, lpostone, lpremul, lpostmul, lr, f, m, c, cc;

    def[0] = ifs[0];
    def[1] = '\0';
    if (preone && !*preone)
	preone = def;
    if (postone && !*postone)
	postone = def;
    if (!premul || !*premul)
	premul = def;
    if (!postmul || !*postmul)
	postmul = def;

    ls = strlen(str);
    lpreone = preone ? strlen(preone) : 0;
    lpostone = postone ? strlen(postone) : 0;
    lpremul = strlen(premul);
    lpostmul = strlen(postmul);

    lr = prenum + postnum;

    if (lr == ls)
	return str;

    r = ret = (char *)halloc(lr + 1);

    if (prenum) {
	if (postnum) {
	    ls2 = ls / 2;

	    f = prenum - ls2;
	    if (f <= 0)
		for (str -= f, c = prenum; c--; *r++ = *str++);
	    else {
		if (f <= lpreone)
		    for (c = f, t = preone + lpreone - f; c--; *r++ = *t++);
		else {
		    f -= lpreone;
		    if ((m = f % lpremul))
			for (c = m, t = premul + lpremul - m; c--; *r++ = *t++);
		    for (cc = f / lpremul; cc--;)
			for (c = lpremul, t = premul; c--; *r++ = *t++);
		    for (c = lpreone; c--; *r++ = *preone++);
		}
		for (c = ls2; c--; *r++ = *str++);
	    }
	    ls2 = ls - ls2;
	    f = postnum - ls2;
	    if (f <= 0)
		for (c = postnum; c--; *r++ = *str++);
	    else {
		for (c = ls2; c--; *r++ = *str++);
		if (f <= lpostone)
		    for (c = f; c--; *r++ = *postone++);
		else {
		    f -= lpostone;
		    for (c = lpostone; c--; *r++ = *postone++);
		    for (cc = f / lpostmul; cc--;)
			for (c = lpostmul, t = postmul; c--; *r++ = *t++);
		    if ((m = f % lpostmul))
			for (; m--; *r++ = *postmul++);
		}
	    }
	} else {
	    f = prenum - ls;
	    if (f <= 0)
		for (c = prenum, str -= f; c--; *r++ = *str++);
	    else {
		if (f <= lpreone)
		    for (c = f, t = preone + lpreone - f; c--; *r++ = *t++);
		else {
		    f -= lpreone;
		    if ((m = f % lpremul))
			for (c = m, t = premul + lpremul - m; c--; *r++ = *t++);
		    for (cc = f / lpremul; cc--;)
			for (c = lpremul, t = premul; c--; *r++ = *t++);
		    for (c = lpreone; c--; *r++ = *preone++);
		}
		for (c = ls; c--; *r++ = *str++);
	    }
	}
    } else if (postnum) {
	f = postnum - ls;
	if (f <= 0)
	    for (c = postnum; c--; *r++ = *str++);
	else {
	    for (c = ls; c--; *r++ = *str++);
	    if (f <= lpostone)
		for (c = f; c--; *r++ = *postone++);
	    else {
		f -= lpostone;
		for (c = lpostone; c--; *r++ = *postone++);
		for (cc = f / lpostmul; cc--;)
		    for (c = lpostmul, t = postmul; c--; *r++ = *t++);
		if ((m = f % lpostmul))
		    for (; m--; *r++ = *postmul++);
	    }
	}
    }
    *r = '\0';

    return ret;
}

char *get_strarg(s)		/**/
char *s;
{
    char t = *s++;

    if (!t)
	return s - 1;

    switch (t) {
    case '(':
	t = ')';
	break;
    case '[':
	t = ']';
	break;
    case '{':
	t = '}';
	break;
    case '<':
	t = '>';
	break;
    case Inpar:
	t = Outpar;
	break;
    case Inang:
	t = Outang;
	break;
    case Inbrace:
	t = Outbrace;
	break;
    case Inbrack:
	t = Outbrack;
	break;
    }

    while (*s && *s != t)
	s++;

    return s;
}

/* parameter substitution */

#define	isstring(c)	(c == '$' || c == String || c == Qstring)
#define	isbrace(c)	(c == '{' || c == Inbrace)

int paramsubst(l, n, aptr, bptr, qt, sp)	/**/
Lklist l;
Lknode n;
char *aptr;
char *bptr;
int qt;				/* if bit 0 set, real quote, else single word substitution */
int sp;
{
    char *s = aptr, *u, *idbeg, *idend, *ostr = bptr;
    int brs;			/* != 0 means ${...}, otherwise $... */
    int colf;			/* != 0 means we found a colon after the name */
    int doub = 0;		/* != 0 means we have %%, not %, or ##, not # */
    int isarr = 0;
    int plan9 = isset(RCEXPANDPARAM);
    int globsubst = isset(GLOBSUBST);
    int getlen = 0;
    int whichlen = 0;
    int chkset = 0;
    int vunset = 0;
    int spbreak = isset(SHWORDSPLIT) && sp && !qt;
    char *val = NULL, **aval = NULL;
    int fwidth = 0;
    Value v;
    int flags = 0;
    int flnum = 0;
    int substr = 0;
    int sortit = 0, casind = 0;
    int casmod = 0;
    char *sep = NULL, *spsep = NULL;
    char *premul = NULL, *postmul = NULL, *preone = NULL, *postone = NULL;
    long prenum = 0, postnum = 0;
    int copied = 0;

    *s++ = '\0';
    if (!ialnum(*s) && *s != '#' && *s != Pound && *s != '-' &&
	*s != '!' && *s != '$' && *s != String && *s != Qstring &&
	*s != '?' && *s != Quest && *s != '_' &&
	*s != '*' && *s != Star && *s != '@' && *s != '{' &&
	*s != Inbrace && *s != '=' && *s != Equals && *s != Hat &&
	*s != '^' &&
	*s != '+') {
	s[-1] = '$';
	return 1;
    }
    if ((brs = (*s == '{' || *s == Inbrace))) {
	s++;

	if (*s == '(' || *s == Inpar) {
	    char *t, sav, *d;
	    int tt = 0;
	    long num;

	    for (s++; *s != ')' && *s != Outpar; s++, tt = 0) {
		switch (*s) {
		case ')':
		case Outpar:
		    break;
		case 'M':
		    flags |= 8;
		    break;
		case 'R':
		    flags |= 16;
		    break;
		case 'B':
		    flags |= 32;
		    break;
		case 'E':
		    flags |= 64;
		    break;
		case 'N':
		    flags |= 128;
		    break;
		case 'S':
		    substr = 1;
		    break;
		case 'I':
		    flnum = 0;
		    t = get_strarg(++s);
		    if (*t) {
			sav = *t;
			*t = '\0';
			d = dupstring(s + 1);
			untokenize(d);
			if ((flnum = mathevalarg(s + 1, &d)) < 0)
			    flnum = -flnum;
			*t = sav;
			s = t;
		    } else
			goto flagerr;
		    break;

		case 'L':
		    casmod = 2;
		    break;
		case 'U':
		    casmod = 1;
		    break;
		case 'C':
		    casmod = 3;
		    break;

		case 'o':
		    sortit = 1;
		    break;
		case 'O':
		    sortit = 2;
		    break;
		case 'i':
		    casind = 1;
		    break;

		case 'c':
		    whichlen = 1;
		    break;
		case 'w':
		    whichlen = 2;
		    break;

		case 's':
		    tt = 1;
		/* fall through */
		case 'j':
		    t = get_strarg(++s);
		    if (*t) {
			sav = *t;
			*t = '\0';
			if (tt)
			    spsep = dupstring(s + 1);
			else
			    sep = dupstring(s + 1);
			*t = sav;
			s = t;
		    } else
			goto flagerr;
		    break;

		case 'l':
		    tt = 1;
		/* fall through */
		case 'r':
		    t = get_strarg(++s);
		    if (!*t)
			goto flagerr;
		    sav = *t;
		    *t = '\0';
		    d = dupstring(s + 1);
		    untokenize(d);
		    if ((num = mathevalarg(d, &d)) < 0)
			num = -num;
		    if (tt)
			prenum = num;
		    else
			postnum = num;
		    *t = sav;
		    sav = *s;
		    s = t + 1;
		    if (*s != sav) {
			s--;
			break;
		    }
		    t = get_strarg(s);
		    if (!*t)
			goto flagerr;
		    sav = *t;
		    *t = '\0';
		    if (tt)
			premul = dupstring(s + 1);
		    else
			postmul = dupstring(s + 1);
		    *t = sav;
		    sav = *s;
		    s = t + 1;
		    if (*s != sav) {
			s--;
			break;
		    }
		    t = get_strarg(s);
		    if (!*t)
			goto flagerr;
		    sav = *t;
		    *t = '\0';
		    if (tt)
			preone = dupstring(s + 1);
		    else
			postone = dupstring(s + 1);
		    *t = sav;
		    s = t;
		    break;

		default:
		  flagerr:
		    zerr("error in flags", NULL, 0);
		    return 1;
		}
	    }
	    s++;
	}
    }
    if (sortit && casind)
	sortit |= (casind << 1);

    if (!premul)
	premul = " ";
    if (!postmul)
	postmul = " ";

    for (;;) {
	if (*s == '^' || *s == Hat)
	    plan9 ^= 1, s++;
	else if (*s == '=' || *s == Equals)
	    spbreak ^= 1, s++;
	else if ((*s == '#' || *s == Pound) && (iident(s[1])
						|| s[1] == '*' || s[1] == Star || s[1] == '@'
						|| (isstring(s[1]) && isbrace(s[2]) && iident(s[3]))))
	    getlen = 1 + whichlen, s++;
	else if (*s == '~' || *s == Tilde)
	    globsubst ^= 1, s++;
	else if (*s == '+' && iident(s[1]))
	    chkset = 1, s++;
	else
	    break;
    }
    globsubst = globsubst && !(qt & 1);

    idbeg = s;
    if (isstring(*s) && isbrace(s[1])) {
	int bct, sav;

	val = s;
	for (bct = 1, s += 2; *s && bct; ++s)
	    if (*s == Inbrace || *s == '{')
		++bct;
	    else if (*s == Outbrace || *s == '}')
		--bct;
	sav = *s;
	*s = 0;
	singsub(&val);
	*s = sav;
	isarr = 0;
	v = (Value) NULL;
    } else if (!(v = getvalue(&s, 1))) {
	vunset = 1;
    } else if ((isarr = v->isarr)) {
	aval = getarrvalue(v);
	if (qt && ((qt & 1) || !getlen) && isarr > 0) {
	    val = sepjoin(aval, sep);
	    isarr = 0;
	}
    } else {
	if (v->pm->flags & PMFLAG_A) {
	    int tmplen = arrlen(v->pm->gets.afn(v->pm));

	    if (v->a < 0)
		v->a += tmplen + v->inv;
	    if (!v->inv && (v->a >= tmplen || v->a < 0))
		vunset = 1;
	}
	if (!vunset) {
	    val = getstrvalue(v);
	    fwidth = v->pm->ct ? v->pm->ct : strlen(val);
	    switch (v->pm->flags & (PMFLAG_L | PMFLAG_R | PMFLAG_Z)) {
		char *t;
		int t0;

	    case PMFLAG_L:
	    case PMFLAG_L | PMFLAG_Z:
		t = val;
		if (v->pm->flags & PMFLAG_Z)
		    while (*t == '0')
			t++;
		else
		    while (isep(*t))
			t++;
		val = (char *)ncalloc(fwidth + 1);
		val[fwidth] = '\0';
		if ((t0 = strlen(t)) > fwidth)
		    t0 = fwidth;
		memset(val, ' ', fwidth);
		strncpy(val, t, t0);
		break;
	    case PMFLAG_R:
	    case PMFLAG_Z:
	    case PMFLAG_Z | PMFLAG_R:
		if (strlen(val) < fwidth) {
		    t = (char *)ncalloc(fwidth + 1);
		    memset(t, (v->pm->flags & PMFLAG_R) ? ' ' : '0', fwidth);
		    if ((t0 = strlen(val)) > fwidth)
			t0 = fwidth;
		    strcpy(t + (fwidth - t0), val);
		    val = t;
		} else {
		    t = (char *)ncalloc(fwidth + 1);
		    t[fwidth] = '\0';
		    strncpy(t, val + strlen(val) - fwidth, fwidth);
		    val = t;
		}
		break;
	    }
	    switch (v->pm->flags & (PMFLAG_l | PMFLAG_u)) {
		char *t;

	    case PMFLAG_l:
		t = val;
		for (; *t; t++)
		    *t = tulower(*t);
		break;
	    case PMFLAG_u:
		t = val;
		for (; *t; t++)
		    *t = tuupper(*t);
		break;
	    }
	}
    }
    idend = s;
    if ((colf = *s == ':'))
	s++;

/* check for ${..?...} or ${..=..} or one of those.  Only works
		if the name is in braces. */

    if (brs && (*s == '-' || *s == '=' || *s == Equals || *s == '?' ||
		*s == '+' || *s == '#' || *s == '%' || *s == Quest || *s == Pound)) {

	if (!flnum)
	    flnum++;
	if (*s == '%')
	    flags |= 1;

	if ((*s == '%' || *s == '#' || *s == Pound) && *s == s[1]) {
	    s++;
	    doub = 1;
	}
	u = ++s;

	flags |= (doub | (substr << 1)) << 1;
	if (!(flags & 0xf8))
	    flags |= 16;

	if (brs) {
	    int bct = 1;

	    for (;;) {
		if (*s == '{' || *s == Inbrace)
		    bct++;
		else if (*s == '}' || *s == Outbrace)
		    bct--;
		if (!bct || !*s)
		    break;
		s++;
	    }
	} else {
	    while (*s++);
	    s--;
	}
	if (*s)
	    *s++ = '\0';
	if (colf && !vunset)
	    vunset = (isarr) ? !*aval : !*val;

	switch ((int)(unsigned char)u[-1]) {
	case '-':
	    if (vunset)
		val = dupstring(u), isarr = 0;
	    break;
	case '=':
	case (int)STOUC(Equals):
	    if (vunset) {
		char sav = *idend;

		*idend = '\0';
		val = dupstring(u);
		singsub(&val);
		setsparam(idbeg, ztrdup(val));
		*idend = sav;
		isarr = 0;
	    }
	    break;
	case '?':
	case (int)STOUC(Quest):
	    if (vunset) {
		char *msg;

		*idend = '\0';
		msg = tricat(idbeg, ": ", *u ? u : "parameter not set");
		zerr("%s", msg, 0);
		zsfree(msg);
		if (!interact)
		    exit(1);
		return 1;
	    }
	    break;
	case '+':
	    if (vunset)
		val = dupstring("");
	    else
		val = dupstring(u);
	    isarr = 0;
	    break;
	case '%':
	case '#':
	case (int)STOUC(Pound):
	    if (qt & 1)
		tokenize(u);

	    if (!vunset && v && v->isarr) {
		char **ap = aval;
		char **pp = aval = (char **)ncalloc(sizeof(char *) * (arrlen(aval) + 1));

		singsub(&u);
		while ((*pp = *ap++)) {
		    getmatch(pp, u, flags, flnum);
		    pp++;
		}
		if (!isarr)
		    val = sepjoin(aval, sep);
	    } else {
		if (vunset)
		    val = dupstring("");
		singsub(&u);
		getmatch(&val, u, flags, flnum);
	    }
	    break;
	}
    } else {			/* no ${...=...} or anything, but possible modifiers. */
	if (chkset) {
	    val = dupstring(vunset ? "0" : "1");
	    isarr = 0;
	} else if (vunset) {
	    if (isset(NOUNSET)) {
		*idend = '\0';
		zerr("%s: parameter not set", idbeg, 0);
		return 1;
	    }
	    val = dupstring("");
	}
	if (colf) {
	    s--;
	    if (!isarr)
		modify(&val, &s);
	    else {
		char *ss = s;
		char **ap = aval;
		char **pp = aval = (char **)ncalloc(sizeof(char *) * (arrlen(aval) + 1));

		while ((*pp = *ap++)) {
		    ss = s;
		    modify(pp++, &ss);
		}
		s = ss;
	    }
	}
	if (brs) {
	    if (*s != '}' && *s != Outbrace) {
		zerr("closing brace expected", NULL, 0);
		return 1;
	    }
	    s++;
	}
    }
    if (errflag)
	return 1;
    if (getlen) {
	long len = 0;
	char buf[14];

	if (isarr) {
	    char **ctr;
	    int sl = sep ? strlen(sep) : 1;

	    if (getlen == 1)
		for (ctr = aval; *ctr; ctr++, len++);
	    else if (getlen == 2)
		for (len = -sl, ctr = aval; *ctr; len += sl + strlen(*ctr), ctr++);
	    else
		for (ctr = aval;
		     *ctr;
		     len += wordcount(*ctr, sep, getlen > 3), ctr++);
	} else {
	    if (getlen < 3)
		len = strlen(val);
	    else
		len = wordcount(val, sep, getlen > 3);
	}

	sprintf(buf, "%ld", len);
	val = dupstring(buf);
	isarr = 0;
    }
    if (isarr > 0 && !plan9 && (!aval || !aval[0])) {
	val = dupstring("");
	isarr = 0;
    } else if (isarr && aval && aval[0] && !aval[1]) {
	val = aval[0];
	isarr = 0;
    }
    if (!qt && (spbreak || spsep || sep)) {
	if (isarr)
	    val = sepjoin(aval, sep);
	if (spbreak || spsep) {
	    isarr = 1;
	    aval = sepsplit(val, spsep);
	    if (!aval || !aval[0]) {
		val = dupstring("");
		isarr = 0;
	    } else if (!aval[1]) {
		val = aval[0];
		isarr = 0;
	    }
	} else
	    isarr = 0;
    }
    if (casmod) {
	if (isarr) {
	    char **ap;

	    ap = aval = arrdup(aval);
	    copied = 1;

	    if (casmod == 1)
		for (; *ap; ap++)
		    makeuppercase(ap);
	    else if (casmod == 2)
		for (; *ap; ap++)
		    makelowercase(ap);
	    else
		for (; *ap; ap++)
		    makecapitals(ap);

	} else {
	    val = dupstring(val);
	    copied = 1;
	    if (casmod == 1)
		makeuppercase(&val);
	    else if (casmod == 2)
		makelowercase(&val);
	    else
		makecapitals(&val);
	}
    }
    if (isarr) {
	char *x;
	char *y;
	int xlen;
	int i;

	if (!aval[0]) {
	    if (plan9)
		return 0;
	    y = (char *)ncalloc((aptr - bptr) + strlen(s) + 1);
	    strcpy(y, ostr);
	    strcat(y, s);
	    remnulargs(y);
	    if (INULL(*y))
		return 0;
	    else {
		setdata(n, (vptr) y);
		return 1;
	    }
	}
	if (sortit && !copied)
	    aval = arrdup(aval);
	if (sortit == 1)
	    qsort(aval, arrlen(aval), sizeof(char *), (int (*)())strpcmp);

	else if (sortit == 2)
	    qsort(aval, arrlen(aval), sizeof(char *), (int (*)())invstrpcmp);

	else if (sortit == 3)
	    qsort(aval, arrlen(aval), sizeof(char *), (int (*)())cstrpcmp);

	else if (sortit)
	    qsort(aval, arrlen(aval), sizeof(char *), (int (*)())invcstrpcmp);

	if (plan9) {
	    int dlen;

	    dlen = (aptr - bptr) + strlen(s) + 1;
	    i = 0;
	    while (aval[i]) {
		x = aval[i++];
		if (prenum || postnum)
		    x = dopadding(x, prenum, postnum, preone, postone,
				  premul, postmul);
		if (qt && !*x) {
		    x = nulstring;
		    xlen = nulstrlen;
		} else
		    xlen = strlen(x);
		y = (char *)ncalloc(dlen + xlen);
		strcpy(y, ostr);
		strcatsub(y, x, globsubst);
		strcat(y, s);
		if (i == 1)
		    setdata(n, (vptr) y);
		else
		    insnode(l, n, (vptr) y), incnode(n);
	    }
	} else {
	    x = aval[0];
	    if (prenum || postnum)
		x = dopadding(x, prenum, postnum, preone, postone,
			      premul, postmul);
	    if (qt && !*x) {
		x = nulstring;
		xlen = nulstrlen;
	    } else
		xlen = strlen(x);
	    y = (char *)ncalloc((aptr - bptr) + xlen + 1);
	    strcpy(y, ostr);
	    strcatsub(y, x, globsubst);
	    setdata(n, (vptr) y);

	    i = 1;
	    while (aval[i] && aval[i + 1]) {
		x = aval[i++];
		if (prenum || postnum)
		    x = dopadding(x, prenum, postnum, preone, postone,
				  premul, postmul);
		if (qt && !*x)
		    y = dupstring(nulstring);
		else if (globsubst) {
		    y = (char *)ncalloc(strlen(x) + 1);
		    *y = '\0';
		    strcatsub(y, x, 1);
		} else
		    y = x;
		insnode(l, n, (vptr) y), incnode(n);
	    }

	    x = aval[i];
	    if (prenum || postnum)
		x = dopadding(x, prenum, postnum, preone, postone,
			      premul, postmul);
	    if (qt && !*x) {
		x = nulstring;
		xlen = nulstrlen;
	    } else
		xlen = strlen(x);
	    y = (char *)ncalloc(xlen + strlen(s) + 1);
	    strcpy(y, x);
	    strcat(y, s);
	    insnode(l, n, (vptr) y);
	}
    } else {
	int xlen;
	char *x;
	char *y;

	x = val;
	if (prenum || postnum)
	    x = dopadding(x, prenum, postnum, preone, postone,
			  premul, postmul);
	if (qt && !*x) {
	    x = nulstring;
	    xlen = nulstrlen;
	} else
	    xlen = strlen(x);
	y = (char *)ncalloc((aptr - bptr) + xlen + strlen(s) + 1);
	strcpy(y, ostr);
	strcatsub(y, x, globsubst);
	strcat(y, s);
	setdata(n, (vptr) y);
    }

    return 1;
}

/* arithmetic substitution */

void arithsubst(aptr, bptr)	/**/
vptr *aptr;
char **bptr;
{
    char *s = (char *)*aptr, *t, buf[16];
    long v;

    *s = '\0';
    for (; *s != Outbrack; s++);
    *s++ = '\0';
    v = matheval((char *)*aptr + 2);
    sprintf(buf, "%ld", v);
    t = (char *)ncalloc(strlen(*bptr) + strlen(buf) + strlen(s) + 1);
    strcpy(t, *bptr);
    strcat(t, buf);
    strcat(t, s);
    *bptr = t;
}

void modify(str, ptr)		/**/
char **str;
char **ptr;
{
    char *ptr1, *ptr2, *ptr3, del, *lptr, c, *test, *sep, *t, *tt, tc, *e;
    char *copy, *all, *tmp, sav;
    int gbal, wall, rec, al, nl;

    test = NULL;

    if (**ptr == ':')
	*str = dupstring(*str);

    while (**ptr == ':') {
	lptr = *ptr;
	(*ptr)++;
	wall = gbal = 0;
	rec = 1;
	c = '\0';
	sep = NULL;

	for (; !c && **ptr;) {
	    switch (**ptr) {
	    case 'h':
	    case 'r':
	    case 'e':
	    case 't':
	    case 'l':
	    case 'u':
		c = **ptr;
		break;

	    case 's':
		c = **ptr;
		(*ptr)++;
		zsfree(hsubl);
		zsfree(hsubr);
		ptr1 = *ptr;
		del = *ptr1++;
		for (ptr2 = ptr1; *ptr2 != del && *ptr2; ptr2++);
		if (!*ptr2) {
		    zerr("bad subtitution", NULL, 0);
		    return;
		}
		*ptr2++ = '\0';
		for (ptr3 = ptr2; *ptr3 != del && *ptr3; ptr3++);
		if ((sav = *ptr3))
		    *ptr3++ = '\0';
		for (tt = hsubl = ztrdup(ptr1); *tt; tt++)
		    if (INULL(*tt))
			chuck(tt);
		for (tt = hsubr = ztrdup(ptr2); *tt; tt++)
		    if (INULL(*tt))
			chuck(tt);
		ptr2[-1] = del;
		if (sav)
		    ptr3[-1] = sav;
		*ptr = ptr3 - 1;
		break;

	    case '&':
		c = 's';
		break;

	    case 'g':
		(*ptr)++;
		gbal = 1;
		break;

	    case 'w':
		wall = 1;
		(*ptr)++;
		break;
	    case 'W':
		wall = 1;
		(*ptr)++;
		ptr1 = get_strarg(ptr2 = *ptr);
		if ((sav = *ptr1))
		    *ptr1 = '\0';
		sep = dupstring(ptr2 + 1);
		if (sav)
		    *ptr1 = sav;
		*ptr = ptr1 + 1;
		c = '\0';
		break;

	    case 'f':
		rec = -1;
		(*ptr)++;
		break;
	    case 'F':
		rec = -1;
		(*ptr)++;
		ptr1 = get_strarg(ptr2 = *ptr);
		if ((sav = *ptr1))
		    *ptr1 = '\0';
		ptr2 = dupstring(ptr2 + 1);
		if (sav)
		    *ptr1 = sav;
		untokenize(ptr2);
		rec = mathevalarg(ptr2, &ptr2);
		*ptr = ptr1 + 1;
		c = '\0';
		break;
	    default:
		*ptr = lptr;
		return;
	    }
	}
	(*ptr)++;
	if (!c) {
	    *ptr = lptr;
	    return;
	}
	if (rec < 0)
	    test = dupstring(*str);

	while (rec--) {
	    if (wall) {
		al = 0;
		all = NULL;
		for (t = e = *str; (tt = findword(&e, sep));) {
		    tc = *e;
		    *e = '\0';
		    copy = dupstring(tt);
		    *e = tc;
		    switch (c) {
		    case 'h':
			remtpath(&copy);
			break;
		    case 'r':
			remtext(&copy);
			break;
		    case 'e':
			rembutext(&copy);
			break;
		    case 't':
			remlpaths(&copy);
			break;
		    case 'l':
			downcase(&copy);
			break;
		    case 'u':
			upcase(&copy);
			break;
		    case 's':
			if (hsubl && hsubr)
			    subst(&copy, hsubl, hsubr, gbal);
			break;
		    }
		    tc = *tt;
		    *tt = '\0';
		    nl = al + strlen(t) + strlen(copy);
		    ptr1 = tmp = (char *)halloc(nl + 1);
		    if (all)
			for (ptr2 = all; *ptr2;)
			    *ptr1++ = *ptr2++;
		    for (ptr2 = t; *ptr2;)
			*ptr1++ = *ptr2++;
		    *tt = tc;
		    for (ptr2 = copy; *ptr2;)
			*ptr1++ = *ptr2++;
		    *ptr1 = '\0';
		    al = nl;
		    all = tmp;
		    t = e;
		}
		*str = all;

	    } else {
		switch (c) {
		case 'h':
		    remtpath(str);
		    break;
		case 'r':
		    remtext(str);
		    break;
		case 'e':
		    rembutext(str);
		    break;
		case 't':
		    remlpaths(str);
		    break;
		case 'l':
		    downcase(str);
		    break;
		case 'u':
		    upcase(str);
		    break;
		case 's':
		    if (hsubl && hsubr) {
			char *oldstr = *str;

			subst(str, hsubl, hsubr, gbal);
			if (*str != oldstr) {
			    *str = dupstring(oldstr = *str);
			    zsfree(oldstr);
			}
		    }
		    break;
		}
	    }
	    if (rec < 0) {
		if (!strcmp(test, *str))
		    rec = 0;
		else
		    test = dupstring(*str);
	    }
	}
    }
}

/* get a directory stack entry */

char *dstackent(val)		/**/
int val;
{
    Lknode node;

    if ((val < 0 && !firstnode(dirstack)) || !val--)
	return pwd;
    if (val < 0)
	node = lastnode(dirstack);
    else
	for (node = firstnode(dirstack); node && val; val--, incnode(node));
    if (!node) {
	if (!isset(NONOMATCH))
	    zerr("not enough dir stack entries.", NULL, 0);
	return NULL;
    }
    return (char *)getdata(node);
}

/* make an alias hash table node */

struct alias *mkanode(txt, cmflag)	/**/
char *txt;
int cmflag;
{
    struct alias *ptr = (Alias) zcalloc(sizeof *ptr);

    ptr->text = txt;
    ptr->cmd = cmflag;
    ptr->inuse = 0;
    return ptr;
}
                                                                                                                                                                                                                                                                                                                       reak;
	case MERGE:
	case MERGEOUT:
	    if (f->fd1 != ((f->type == MERGEOUT) ? 1 : 0))
		taddchr('0' + f->fd1);
	    taddstr(fstr[f->type]);
	    if (f->fd2 == FD_COPROC)
		taddchr('p');
	    else
		taddint(f->fd2);
	    taddchr(' ');
	    break;
	case CLOSE:
	    taddchr(f->fd1 + '0');
	    taddstr(">&- ");
	    break;
	case INPIPE:
	case OUTPIPE:
	    if (f->fd1 != ((f->type == INPIPE) ? 0 : 1))
		taddchr('0' + f->fd1);
	    taddstr((f->type == INPIPE) ? "< " : "> ");
	    taddstr(f->name);
	    taddchr(' ');
	    break;
	}
    }
    tptr--;
}

void taddlist(l)		/**/
Lklist l;
{
    Lknode n;

    if (!(n = firstnode(l)))
	return;
    for (; n; incnode(n)) {
	taddstr(getdata(n));
	taddchr(' ');
    }
    tptr--;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 *
 * table.c - linked lists and hash tables
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define TABLE_C
#include "zsh.h"

/* get an empty linked list header */

Lklist newlist()
{				/**/
    Lklist list;

    list = (Lklist) alloc(sizeof *list);
    list->first = 0;
    list->last = (Lknode) list;
    return list;
}

/* get an empty hash table */

Hashtab newhtable(size)		/**/
int size;
{
    Hashtab ret;

    ret = (Hashtab) zcalloc(sizeof *ret);
    ret->hsize = size;
    ret->nodes = (Hashnode *) zcalloc(size * sizeof(Hashnode));
    return ret;
}

/* the hash function used by Chris Torek */
/* The Peter J. Weinberger hash function from the Dragon Book
 * used to be here but it
 * a) was slower than this
 * b) took 32-bit integers for granted
 *    b1) there are other integer widths
 *    b2) integer constant like 0xf0000000 is unsigned in ANSI C,
 *        signed with pcc
 * c) I _believe_ after some testing that this hashes better
 *    Jarkko Hietaniemi <Jarkko.Hietaniemi@hut.fi>
 */

unsigned hasher(s)		/**/
char *s;
{
    unsigned hash;

    for (hash = 0; *s; s++)
	hash = hash + (hash << 5) + *s;
 /* if hashing counted strings: (size_t, char *) pairs,
     * "+ 1" should be appended to the above line */

    return hash;
}

/* add a node to a hash table */

void addhnode(nam, dat, ht, freefunc)	/**/
char *nam;
vptr dat;
Hashtab ht;
FFunc freefunc;
{
    int hval = hasher(nam) % ht->hsize;
    struct hashnode **hp = ht->nodes + hval, *hn;

    for (; *hp; hp = &(*hp)->next)
	if (!strcmp((*hp)->nam, nam)) {
	    zsfree((*hp)->nam);
	    hn = (struct hashnode *)dat;
	    hn->next = (*hp)->next;
	    if (!freefunc)
		zerr("attempt to call NULL freefunc", NULL, 0);
	    else
		freefunc(*hp);
	    *hp = hn;
	    hn->nam = nam;
	    return;
	}
    hn = (Hashnode) dat;
    hn->nam = nam;
    hn->next = ht->nodes[hval];
    ht->nodes[hval] = hn;
    if (++ht->ct == ht->hsize * 4)
	expandhtab(ht);
}

/* add a node to command hash table */

void addhcmdnode(nam, pnam)	/**/
char *nam;
char **pnam;
{
    int hval = hasher(nam) % cmdnamtab->hsize;
    struct hashnode *hp = cmdnamtab->nodes[hval], *hn;
    Cmdnam cc;

    for (; hp; hp = hp->next)
	if (!strcmp(hp->nam, nam))
	    return;
    cc = (Cmdnam) zcalloc(sizeof *cc);
    cc->flags = EXCMD;
    cc->u.name = pnam;
    hn = (Hashnode) cc;
    hn->nam = ztrdup(nam);
    hn->next = cmdnamtab->nodes[hval];
    cmdnamtab->nodes[hval] = hn;
    if (++cmdnamtab->ct == cmdnamtab->hsize * 4)
	expandhtab(cmdnamtab);
}

/* expand hash tables when they get too many entries */

void expandhtab(ht)		/**/
Hashtab ht;
{
    struct hashnode **arr, **ha, *hn, *hp;
    int osize = ht->hsize, nsize = osize * 8, os = osize;

    ht->hsize = nsize;
    arr = ht->nodes;
    ht->nodes = (Hashnode *) zcalloc(nsize * sizeof(struct hashnode *));

    ht->ct = 0;

    for (ha = arr; osize; osize--, ha++)
	for (hn = *ha; hn;) {
	    hp = hn->next;
	    addhnode(hn->nam, (vptr) hn, ht, (FFunc) 0);
	    hn = hp;
	}
    zfree(arr, os * sizeof(struct hashnode *));
}

/* get an entry in a hash table */

vptr gethnode(nam, ht)		/**/
char *nam;
Hashtab ht;
{
    int hval = hasher(nam) % ht->hsize;
    struct hashnode *hn = ht->nodes[hval];

    for (; hn; hn = hn->next)
	if (!strcmp(hn->nam, nam))
	    return (vptr) hn;
    return NULL;
}

void freehtab(ht, freefunc)	/**/
Hashtab ht;
FFunc freefunc;
{
    int val;
    struct hashnode *hn, **hp = &ht->nodes[0], *next;

    for (val = ht->hsize; val; val--, hp++)
	for (hn = *hp; hn;) {
	    next = hn->next;
	    zsfree(hn->nam);
	    freefunc(hn);
	    hn = next;
	}
    zfree(ht->nodes, ht->hsize * sizeof(struct hashnode *));
    zfree(ht, sizeof(struct hashtab));
}

/* remove a hash table entry and return a pointer to it */

vptr remhnode(nam, ht)		/**/
char *nam;
Hashtab ht;
{
    int hval = hasher(nam) % ht->hsize;
    struct hashnode *hn = ht->nodes[hval], *hp;

    if (!hn)
	return NULL;
    if (!strcmp(hn->nam, nam)) {
	ht->nodes[hval] = hn->next;
	zsfree(hn->nam);
	ht->ct--;
	return (vptr) hn;
    }
    for (hp = hn, hn = hn->next; hn; hn = (hp = hn)->next)
	if (!strcmp(hn->nam, nam)) {
	    hp->next = hn->next;
	    zsfree(hn->nam);
	    ht->ct--;
	    return (vptr) hn;
	}
    return NULL;
}

/* insert a node in a linked list after 'llast' */

void insnode(list, llast, dat)	/**/
Lklist list;
Lknode llast;
vptr dat;
{
    Lknode tmp;

    tmp = llast->next;
    llast->next = (Lknode) alloc(sizeof *tmp);
    llast->next->last = llast;
    llast->next->dat = dat;
    llast->next->next = tmp;
    if (tmp)
	tmp->last = llast->next;
    else
	list->last = llast->next;
}

/* remove a node from a linked list */

vptr remnode(list, nd)		/**/
Lklist list;
Lknode nd;
{
    vptr dat;

    nd->last->next = nd->next;
    if (nd->next)
	nd->next->last = nd->last;
    else
	list->last = nd->last;
    dat = nd->dat;
    zfree(nd, sizeof(struct lknode));

    return dat;
}

/* remove a node from a linked list */

vptr uremnode(list, nd)		/**/
Lklist list;
Lknode nd;
{
    vptr dat;

    nd->last->next = nd->next;
    if (nd->next)
	nd->next->last = nd->last;
    else
	list->last = nd->last;
    dat = nd->dat;
    return dat;
}

/* delete a character in a string */

void chuck(str)			/**/
char *str;
{
    while ((str[0] = str[1]))
	str++;
}

/* get top node in a linked list */

vptr getnode(list)		/**/
Lklist list;
{
    vptr dat;
    Lknode node = list->first;

    if (!node)
	return NULL;
    dat = node->dat;
    list->first = node->next;
    if (node->next)
	node->next->last = (Lknode) list;
    else
	list->last = (Lknode) list;
    zfree(node, sizeof(struct lknode));

    return dat;
}

/* get top node in a linked list without freeing */

vptr ugetnode(list)		/**/
Lklist list;
{
    vptr dat;
    Lknode node = list->first;

    if (!node)
	return NULL;
    dat = node->dat;
    list->first = node->next;
    if (node->next)
	node->next->last = (Lknode) list;
    else
	list->last = (Lknode) list;
    return dat;
}

void freetable(tab, freefunc)	/**/
Lklist tab;
FFunc freefunc;
{
    Lknode node = tab->first, next;

    while (node) {
	next = node->next;
	if (freefunc)
	    freefunc(node->dat);
	zfree(node, sizeof(struct lknode));

	node = next;
    }
    zfree(tab, sizeof(struct lklist));
}

char *ztrstr(s, t)		/**/
char *s;
char *t;
{
    char *p1, *p2;

    for (; *s; s++) {
	for (p1 = s, p2 = t; *p2; p1++, p2++)
	    if (*p1 != *p2)
		break;
	if (!*p2)
	    return (char *)s;
    }
    return NULL;
}

/* insert a list in another list */

void inslist(l, where, x)	/**/
Lklist l;
Lknode where;
Lklist x;
{
    Lknode nx = where->next;

    if (!l->first)
	return;
    where->next = l->first;
    l->last->next = nx;
    l->first->last = where;
    if (nx)
	nx->last = l->last;
    else
	x->last = l->last;
}

int countnodes(x)		/**/
Lklist x;
{
    Lknode y;
    int ct = 0;

    for (y = firstnode(x); y; incnode(y), ct++);
    return ct;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
/*
 *
 * text.c - textual representations of syntax trees
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"

static char *tptr, *tbuf, *tlim;
static int tsiz, tindent, tnewlins;

/* add a character to the text buffer */

void taddchr(c)			/**/
int c;
{
    *tptr++ = c;
    if (tptr == tlim) {
	if (!tbuf) {
	    tptr--;
	    return;
	}
	tbuf = realloc(tbuf, tsiz *= 2);
	tlim = tbuf + tsiz;
	tptr = tbuf + tsiz / 2;
    }
}

/* add a string to the text buffer */

void taddstr(s)			/**/
char *s;
{
    int sl = strlen(s);

    while (tptr + sl >= tlim) {
	int x = tptr - tbuf;

	if (!tbuf)
	    return;
	tbuf = realloc(tbuf, tsiz *= 2);
	tlim = tbuf + tsiz;
	tptr = tbuf + x;
    }
    strcpy(tptr, s);
    tptr += sl;
}

/* add an integer to the text buffer */

void taddint(x)			/**/
int x;
{
    char buf[10];

    sprintf(buf, "%d", x);
    taddstr(buf);
}

/* add a newline, or something equivalent, to the text buffer */

void taddnl()
{				/**/
    int t0;

    if (tnewlins) {
	taddchr('\n');
	for (t0 = 0; t0 != tindent; t0++)
	    taddchr('\t');
    } else
	taddstr("; ");
}

/* get a permanent textual representation of n */

char *getpermtext(n)		/**/
struct node *n;
{
    tnewlins = 1;
    tbuf = (char *)zalloc(tsiz = 32);
    tptr = tbuf;
    tlim = tbuf + tsiz;
    tindent = 1;
    gettext2(n);
    *tptr = '\0';
    untokenize(tbuf);
    return tbuf;
}

/* get a representation of n in a job text buffer */

char *getjobtext(n)		/**/
struct node *n;
{
    static char jbuf[JOBTEXTSIZE];

    tnewlins = 0;
    tbuf = NULL;
    tptr = jbuf;
    tlim = tptr + JOBTEXTSIZE - 1;
    tindent = 1;
    gettext2(n);
    *tptr = '\0';
    untokenize(jbuf);
    return jbuf;
}

#define gt2(X) gettext2((struct node *) (X))

/*
	"gettext2" or "type checking and how to avoid it"
	an epic function by Paul Falstad
*/

#define _Cond(X) ((Cond) (X))
#define _Cmd(X) ((Cmd) (X))
#define _Pline(X) ((Pline) (X))
#define _Sublist(X) ((Sublist) (X))
#define _List(X) ((List) (X))
#define _casecmd(X) ((struct casecmd *) (X))
#define _ifcmd(X) ((struct ifcmd *) (X))
#define _whilecmd(X) ((struct whilecmd *) (X))

void gettext2(n)		/**/
struct node *n;
{
    Cmd nn;
    Cond nm;

    if (!n || ((List) n) == &dummy_list)
	return;
    switch (NT_TYPE(n->type)) {
    case N_LIST:
	gt2(_List(n)->left);
	if (_List(n)->type == ASYNC)
	    taddstr(" &");
	simplifyright(_List(n));
	if (_List(n)->right) {
	    if (tnewlins)
		taddnl();
	    else
		taddstr((_List(n)->type == ASYNC) ? " " : "; ");
	    gt2(_List(n)->right);
	}
	break;
    case N_SUBLIST:
	if (_Sublist(n)->flags & PFLAG_NOT)
	    taddstr("! ");
	if (_Sublist(n)->flags & PFLAG_COPROC)
	    taddstr("coproc ");
	gt2(_Sublist(n)->left);
	if (_Sublist(n)->right) {
	    taddstr((_Sublist(n)->type == ORNEXT) ? " || " : " && ");
	    gt2(_Sublist(n)->right);
	}
	break;
    case N_PLINE:
	gt2(_Pline(n)->left);
	if (_Pline(n)->type == PIPE) {
	    taddstr(" | ");
	    gt2(_Pline(n)->right);
	}
	break;
    case N_CMD:
	nn = _Cmd(n);
	if (nn->flags & CFLAG_EXEC)
	    taddstr("exec ");
	if (nn->flags & CFLAG_COMMAND)
	    taddstr("command ");
	switch (nn->type) {
	case SIMPLE:
	    getsimptext(nn);
	    break;
	case SUBSH:
	    taddstr("( ");
	    tindent++;
	    gt2(nn->u.list);
	    tindent--;
	    taddstr(" )");
	    break;
	case ZCTIME:
	    taddstr("time ");
	    tindent++;
	    gt2(nn->u.pline);
	    tindent--;
	    break;
	case FUNCDEF:
	    taddlist(nn->args);
	    taddstr(" () {");
	    tindent++;
	    taddnl();
	    gt2(nn->u.list);
	    tindent--;
	    taddnl();
	    taddstr("}");
	    break;
	case CURSH:
	    taddstr("{ ");
	    tindent++;
	    gt2(nn->u.list);
	    tindent--;
	    taddstr(" }");
	    break;
	case CFOR:
	case CSELECT:
	    taddstr((nn->type == CFOR) ? "for " : "select ");
	    taddstr(nn->u.forcmd->name);
	    if (nn->u.forcmd->inflag) {
		taddstr(" in ");
		taddlist(nn->args);
	    }
	    taddnl();
	    taddstr("do");
	    tindent++;
	    taddnl();
	    gt2(nn->u.forcmd->list);
	    tindent--;
	    taddnl();
	    taddstr("done");
	    break;
	case CIF:
	    gt2(nn->u.ifcmd);
	    taddstr("fi");
	    break;
	case CCASE:
	    taddstr("case ");
	    taddlist(nn->args);
	    taddstr(" in");
	    tindent++;
	    taddnl();
	    gt2(nn->u.casecmd);
	    tindent--;
	    if (tnewlins)
		taddnl();
	    else
		taddchr(' ');
	    taddstr("esac");
	    break;
	case COND:
	    taddstr("[[ ");
	    gt2(nn->u.cond);
	    taddstr(" ]]");
	    break;
	case CREPEAT:
	    taddstr("repeat ");
	    taddlist(nn->args);
	    taddnl();
	    taddstr("do");
	    tindent++;
	    taddnl();
	    gt2(nn->u.list);
	    tindent--;
	    taddnl();
	    taddstr("done");
	    break;
	case CWHILE:
	    gt2(nn->u.whilecmd);
	    break;
	}
	getredirs(nn);
	break;
    case N_COND:
	nm = _Cond(n);
	switch (nm->type) {
	case COND_NOT:
	    taddstr("! ");
	    gt2(nm->left);
	    break;
	case COND_AND:
	    taddstr("( ");
	    gt2(nm->left);
	    taddstr(" && ");
	    gt2(nm->right);
	    taddstr(" )");
	    break;
	case COND_OR:
	    taddstr("( ");
	    gt2(nm->left);
	    taddstr(" || ");
	    gt2(nm->right);
	    taddstr(" )");
	    break;
	default:
	    {
		static char *c1[] =
		{
		    " = ", " != ", " < ", " > ", " -nt ", " -ot ", " -ef ", " -eq ",
		    " -ne ", " -lt ", " -gt ", " -le ", " -ge "
		};

		if (nm->right)
		    taddstr(nm->left);
		if (nm->type <= COND_GE)
		    taddstr(c1[nm->type - COND_STREQ]);
		else {
		    char c2[5];

		    c2[0] = ' ';
		    c2[1] = '-';
		    c2[2] = nm->type;
		    c2[3] = ' ';
		    c2[4] = '\0';
		    taddstr(c2);
		}
		taddstr((nm->right) ? nm->right : nm->left);
	    }
	    break;
	}
	break;
    case N_CASE:
	{
	    List *l;
	    char **p;

	    l = _casecmd(n)->lists;
	    p = _casecmd(n)->pats;

	    for (; *l; p++, l++) {
		taddstr(*p);
		taddstr(") ");
		tindent++;
		gt2(*l);
		tindent--;
		taddstr(";;");
		if (tnewlins)
		    taddnl();
		else
		    taddchr(' ');
	    }
	    break;
	}
    case N_IF:
	{
	    List *i, *t;

	    taddstr("if ");
	    for (i = _ifcmd(n)->ifls, t = _ifcmd(n)->thenls; *i; i++, t++) {
		tindent++;
		gt2(*i);
		tindent--;
		taddnl();
		taddstr("then");
		tindent++;
		taddnl();
		gt2(*t);
		tindent--;
		taddnl();
		if (i[1]) {
		    taddstr("elif ");
		}
	    }
	    if (*t) {
		taddstr("else");
		tindent++;
		taddnl();
		gt2(*t);
		tindent--;
		taddnl();
	    }
	    break;
	}
    case N_WHILE:
	taddstr((_whilecmd(n)->cond) ? "until " : "while ");
	tindent++;
	gt2(_whilecmd(n)->cont);
	tindent--;
	taddnl();
	taddstr("do");
	tindent++;
	taddnl();
	gt2(_whilecmd(n)->loop);
	tindent--;
	taddnl();
	taddstr("done");
	break;
    }
}

void getsimptext(cmd)		/**/
Cmd cmd;
{
    Lknode n;

    for (n = firstnode(cmd->vars); n; incnode(n)) {
	struct varasg *v = (struct varasg *)getdata(n);

	taddstr(v->name);
	taddchr('=');
	if ((v->type & PMTYPE) == PMFLAG_A) {
	    taddchr('(');
	    taddlist(v->arr);
	    taddstr(") ");
	} else {
	    taddstr(v->str);
	    taddchr(' ');
	}
    }
    taddlist(cmd->args);
}

void getredirs(cmd)		/**/
Cmd cmd;
{
    Lknode n;
    static char *fstr[] =
    {
	">", ">!", ">>", ">>!", ">&", ">&!", ">>&", ">>&!", "<", "<<",
	"<<-", "<<<", "<&", ">&-", "..", ".."
    };

    taddchr(' ');
    for (n = firstnode(cmd->redir); n; incnode(n)) {
	struct redir *f = (struct redir *)getdata(n);

	switch (f->type) {
	case WRITE:
	case WRITENOW:
	case APP:
	case APPNOW:
	case READ:
	case HERESTR:
	    if (f->fd1 != ((f->type == READ) ? 0 : 1))
		taddchr('0' + f->fd1);
	    taddstr(fstr[f->type]);
	    taddchr(' ');
	    taddstr(f->name);
	    taddchr(' ');
	    b/*
 *
 * utils.c - miscellaneous utilities
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"
#include <pwd.h>
#include <errno.h>
#include <fcntl.h>

/* source a file */

int source(s)			/**/
char *s;
{
    int fd, cj = thisjob;
    int oldlineno = lineno, oldshst;
    FILE *obshin = bshin;
    int osubsh = subsh;

    fd = SHIN;
    lineno = 0;
    oldshst = opts[SHINSTDIN];
    opts[SHINSTDIN] = OPT_UNSET;
    if ((SHIN = movefd(open(s, O_RDONLY))) == -1) {
	SHIN = fd;
	thisjob = cj;
	opts[SHINSTDIN] = oldshst;
	return 1;
    }
    bshin = fdopen(SHIN, "r");
    subsh = 0;
    sourcelevel++;
    loop(0);
    sourcelevel--;
    fclose(bshin);
    bshin = obshin;
    subsh = osubsh;
    opts[SHINSTDIN] = oldshst;
    SHIN = fd;
    thisjob = cj;
    errflag = 0;
    retflag = 0;
    lineno = oldlineno;
    return 0;
}

/* try to source a file in the home directory */

void sourcehome(s)		/**/
char *s;
{
    char buf[MAXPATHLEN];
    char *h;

    if (!(h = getsparam("ZDOTDIR")))
	h = home;
    sprintf(buf, "%s/%s", h, s);
    (void)source(buf);
}

/* print an error */

void zwarnnam(cmd, fmt, str, num)	/**/
char *cmd;
char *fmt;
char *str;
int num;
{
    int waserr = errflag;

    zerrnam(cmd, fmt, str, num);
    errflag = waserr;
}

void zerrnam(cmd, fmt, str, num)/**/
char *cmd;
char *fmt;
char *str;
int num;
{
    if (cmd) {
	if (errflag || noerrs)
	    return;
	errflag = 1;
	trashzle();
	if (isset(SHINSTDIN))
	    fprintf(stderr, "%s: ", cmd);
	else
	    fprintf(stderr, "%s: %s: ", argzero, cmd);
    }
    while (*fmt)
	if (*fmt == '%') {
	    fmt++;
	    switch (*fmt++) {
	    case 's':
		while (*str)
		    niceputc(*str++, stderr);
		break;
	    case 'l':
		while (num--)
		    niceputc(*str++, stderr);
		break;
	    case 'd':
		fprintf(stderr, "%d", num);
		break;
	    case '%':
		putc('%', stderr);
		break;
	    case 'c':
		niceputc(num, stderr);
		break;
	    case 'e':
		if (num == EINTR) {
		    fputs("interrupt\n", stderr);
		    errflag = 1;
		    return;
		}
		if (num == EIO)
		    fputs(sys_errlist[num], stderr);
		else {
		    fputc(tulower(sys_errlist[num][0]), stderr);
		    fputs(sys_errlist[num] + 1, stderr);
		}
		break;
	    }
	} else
	    putc(*fmt++, stderr);
    if (unset(SHINSTDIN) && lineno)
	fprintf(stderr, " [%ld]\n", lineno);
    else
	putc('\n', stderr);
    fflush(stderr);
}

void zerr(fmt, str, num)	/**/
char *fmt;
char *str;
int num;
{
    if (errflag || noerrs)
	return;
    errflag = 1;
    trashzle();
    fprintf(stderr, "%s: ", (isset(SHINSTDIN)) ? "zsh" : argzero);
    zerrnam(NULL, fmt, str, num);
}

void niceputc(c, f)		/**/
int c;
FILE *f;
{
    if (itok(c)) {
	if (c >= Pound && c <= Comma)
	    putc(ztokens[c - Pound], f);
	return;
    }
    c &= 0xff;
    if (isprint(c))
	putc(c, f);
    else if (c == '\n') {
	putc('\\', f);
	putc('n', f);
    } else {
	putc('^', f);
	putc(c | '@', f);
    }
}

void sig_handle(sig)		/**/
int sig;
{
#ifdef POSIX

    struct sigaction act;

    act.sa_handler = (SIGVEC_HANDTYPE) handler;
    sigemptyset(&act.sa_mask);
    sigaddset(&act.sa_mask, sig);
#ifdef SA_INTERRUPT
    if (interact)
	act.sa_flags = SA_INTERRUPT;
    else
#endif
	act.sa_flags = 0;
    sigaction(sig, &act, (struct sigaction *)NULL);

#else
#ifdef SV_INTERRUPT

    struct sigvec vec;

    vec.sv_handler = (SIGVEC_HANDTYPE) handler;
    vec.sv_mask = sigmask(sig);
    vec.sv_flags = SV_INTERRUPT;
    sigvec(sig, &vec, (struct sigvec *)NULL);

#else

    signal(sig, handler);

#endif
#endif
}

void sig_ignore(sig)		/**/
int sig;
{
    signal(sig, SIG_IGN);
}

void sig_default(sig)		/**/
int sig;
{
    signal(sig, SIG_DFL);
}

/* enable ^C interrupts */

void intr()
{				/**/
    if (interact)
	sig_handle(SIGINT);
}

/* disable ^C interrupts */

void nointr()
{				/**/
    if (interact)
	sig_ignore(SIGINT);
}

/* temporary hold ^C interrupts */

void holdintr()
{				/**/
    if (interact) {
#ifdef SIGNAL_MASKS
	sig_block(sig_mask(SIGINT));
#else
	sig_ignore(SIGINT);
#endif
    }
}

/* release ^C interrupts */

void noholdintr()
{				/**/
    if (interact) {
#ifdef SIGNAL_MASKS
	sig_unblock(sig_mask(SIGINT));
#else
	sig_handle(SIGINT);
#endif
    }
}

/* block or unblock a signal */

sigset_t sig_mask(sig)		/**/
int sig;
{
    sigset_t set;

    sigemptyset(&set);
    if (sig)
	sigaddset(&set, sig);
    return set;
}

sigset_t sig_notmask(sig)	/**/
int sig;
{
    sigset_t set;

    sigfillset(&set);
    if (sig)
	sigdelset(&set, sig);
    return set;
}

#if !defined(POSIX) && !defined(SIGNAL_MASKS)
static sigset_t heldset;

#endif

sigset_t sig_block(set)		/**/
sigset_t set;
{
    sigset_t oset;

#ifdef POSIX
    sigprocmask(SIG_BLOCK, &set, &oset);
#else
#ifdef SIGNAL_MASKS
    oset = sigblock(set);
#else
    int i;

    oset = heldset;
    for (i = 1; i <= NSIG; ++i) {
	if (sigismember(&set, i) && !sigismember(&heldset, i)) {
	    sigaddset(&heldset, i);
	    sighold(i);
	}
    }
#endif
#endif

    return oset;
}

sigset_t sig_unblock(set)	/**/
sigset_t set;
{
    sigset_t oset;

#ifdef POSIX
    sigprocmask(SIG_UNBLOCK, &set, &oset);
#else
#ifdef SIGNAL_MASKS
    sigfillset(&oset);
    oset = sigsetmask(oset);
    sigsetmask(oset & ~set);
#else
    int i;

    oset = heldset;
    for (i = 1; i <= NSIG; ++i) {
	if (sigismember(&set, i) && sigismember(&heldset, i)) {
	    sigdelset(&heldset, i);
	    sigrelse(i);
	}
    }
#endif
#endif

    return oset;
}

sigset_t sig_setmask(set)	/**/
sigset_t set;
{
    sigset_t oset;

#ifdef POSIX
    sigprocmask(SIG_SETMASK, &set, &oset);
#else
#ifdef SIGNAL_MASKS
    oset = sigsetmask(set);
#else
    int i;

    oset = heldset;
    for (i = 1; i <= NSIG; ++i) {
	if (sigismember(&set, i) && !sigismember(&heldset, i)) {
	    sigaddset(&heldset, i);
	    sighold(i);
	} else if (!sigismember(&set, i) && sigismember(&heldset, i)) {
	    sigdelset(&heldset, i);
	    sigrelse(i);
	}
    }
#endif
#endif

    return oset;
}

int sig_suspend(sig, sig2)		/**/
int sig;
int sig2;
{
    int ret;

#ifdef POSIX
    sigset_t set;

    if (sig) {
	set = sig_notmask(sig);
	sigdelset(&set, SIGHUP);
	sigdelset(&set, sig2);
    } else
	sigemptyset(&set);
    ret = sigsuspend(&set);
#else
#ifdef HAS_SIGRELSE
    /* Use System V version of sigpause.  */
    ret = sigpause(sig);
#else
    /* Use BSD version of sigpause.  */
    sigset_t set = sig_notmask(sig);
    if (sig2)
      sigdelset(&set, sig2);
    ret = sigpause(set);
#endif
#endif

    return ret;
}

/* get a symlink-free pathname for s relative to PWD */

char *findpwd(s)		/**/
char *s;
{
    char *t;

    if (*s == '/')
	return xsymlink(s);
    s = tricat((pwd[1]) ? pwd : "", "/", s);
    t = xsymlink(s);
    zsfree(s);
    return t;
}

static char xbuf[MAXPATHLEN];

int ispwd(s)			/**/
char *s;
{
    struct stat sbuf, tbuf;

    if (stat(s, &sbuf) == 0 && stat(".", &tbuf) == 0)
	if (sbuf.st_dev == tbuf.st_dev && sbuf.st_ino == tbuf.st_ino)
	    return 1;
    return 0;
}

/* expand symlinks in s, and remove other weird things */

char *xsymlink(s)		/**/
char *s;
{
    if (unset(CHASELINKS))
	return ztrdup(s);
    if (*s != '/')
	return NULL;
    strcpy(xbuf, "");
    if (xsymlinks(s + 1, 1))
	return ztrdup(s);
    if (!*xbuf)
	return ztrdup("/");
    return ztrdup(xbuf);
}

char **slashsplit(s)		/**/
char *s;
{
    char *t, **r, **q;
    int t0;

    if (!*s)
	return (char **)zcalloc(sizeof(char **));

    for (t = s, t0 = 0; *t; t++)
	if (*t == '/')
	    t0++;
    q = r = (char **)zalloc(sizeof(char **) * (t0 + 2));

    while ((t = strchr(s, '/'))) {
	*t = '\0';
	*q++ = ztrdup(s);
	*t = '/';
	while (*t == '/')
	    t++;
	if (!*t) {
	    *q = NULL;
	    return r;
	}
	s = t;
    }
    *q++ = ztrdup(s);
    *q = NULL;
    return r;
}

/* expands symlinks and .. or . expressions */
/* if flag = 0, only expand .. and . expressions */

int xsymlinks(s, flag)		/**/
char *s;
int flag;
{
    char **pp, **opp;
    char xbuf2[MAXPATHLEN], xbuf3[MAXPATHLEN];
    int t0;

    opp = pp = slashsplit(s);
    for (; *pp; pp++) {
	if (!strcmp(*pp, ".")) {
	    zsfree(*pp);
	    continue;
	}
	if (!strcmp(*pp, "..")) {
	    char *p;

	    zsfree(*pp);
	    if (!strcmp(xbuf, "/"))
		continue;
	    p = xbuf + strlen(xbuf);
	    while (*--p != '/');
	    *p = '\0';
	    continue;
	}
	if (unset(CHASELINKS)) {
	    strcat(xbuf, "/");
	    strcat(xbuf, *pp);
	    zsfree(*pp);
	    continue;
	}
	sprintf(xbuf2, "%s/%s", xbuf, *pp);
	t0 = readlink(xbuf2, xbuf3, MAXPATHLEN);
	if (t0 == -1 || !flag) {
	    strcat(xbuf, "/");
	    strcat(xbuf, *pp);
	    zsfree(*pp);
	} else {
	    xbuf3[t0] = '\0';	/* STUPID */
	    if (*xbuf3 == '/') {
		strcpy(xbuf, "");
		if (xsymlinks(xbuf3 + 1, flag))
		    return 1;
	    } else if (xsymlinks(xbuf3, flag))
		return 1;
	    zsfree(*pp);
	}
    }
    free(opp);
    return 0;
}

/* print a directory */

void fprintdir(s, f)		/**/
char *s;
FILE *f;
{
    int t0;

    t0 = finddir(s);
    if (t0 == -1) {
	fputs(s, f);
    } else {
	putc('~', f);
	fputs(namdirs[t0].name, f);
	fputs(s + namdirs[t0].len, f);
    }
}

void printdir(s)		/**/
char *s;
{
    fprintdir(s, stdout);
}

void printdircr(s)		/**/
char *s;
{
    fprintdir(s, stdout);
    putchar('\n');
}

int findname(s)			/**/
char *s;
{
    int t0;

    for (t0 = 0; t0 < userdirct; t0++)
	if (!strcmp(namdirs[t0].name, s))
	    return t0;
    return -1;
}

/* see if a path has a named directory as its prefix */

int finddir(s)			/**/
char *s;
{
    int t0, slen, min, max;
    static int last = -1;
    static char previous[MAXPATHLEN] = "\0";

    if (!s) {			/* Invalidate directory cache */
	*previous = '\0';
	return last = -1;
    }
    if (!strcmp(s, previous))
	return last;

/* The named directories are sorted in increasing length of the path. For the
   same path length, it is sorted in DECREASING order of name length, unless
   HIDE_NAMES is defined, in which case the last included name comes last. */

/* This binary search doesn't seem to make much difference but... */

    slen = strlen(s);
    min = 0;
    max = userdirct;
    while ((t0 = (min + max) >> 1) != min)
	if (slen < namdirs[t0].len)
	    max = t0;
	else
	    min = t0;

/* Binary search alone doesn't work because we want the longest match, not
   necessarily an exact one */

    for (t0 = min; t0 >= 0; t0--)
	if (namdirs[t0].len <= slen && !dircmp(namdirs[t0].dir, s)) {
	    strcpy(previous, s);
	    return last = t0;
	}
    return -1;
}

/* add a named directory */

void adduserdir(s, t, ishomedir, always)	/**/
char *s;
char *t;
int ishomedir;
int always;
{
    int t0 = -1, t1, t2;

    if (!interact)
	return;

    if (ishomedir) {
	if (!strcmp(t, "/") || (t0 = findname(s) != -1))
	    return;
    } else if (!t || *t != '/' || !strcmp(t, "/")) {
	if ((t0 = findname(s)) != -1) {	/* remove the name */
	    zsfree(namdirs[t0].name);
	    zsfree(namdirs[t0].dir);
	    for (; t0 < userdirct - 1; t0++)
		memcpy((vptr) & namdirs[t0], (vptr) & namdirs[t0 + 1],
		       sizeof *namdirs);
	    userdirct--;
	    finddir(0);
	}
	return;
    }
    if (unset(AUTONAMEDIRS) && findname(s) == -1 && always == 2)
	return;

    t2 = strlen(t);
    if (!ishomedir && t2 < MAXPATHLEN && (t0 = findname(s)) != -1) {

    /* update value */

	zsfree(namdirs[t0].dir);
	namdirs[t0].dir = ztrdup(t);
	t1 = namdirs[t0].len;
	namdirs[t0].len = t2;
	if (t2 < t1)
	    qsort((vptr) namdirs, t0 + 1, sizeof *namdirs,
		  (int (*)DCLPROTO((const void *, const void *)))lencmp);
	else
	    qsort((vptr) & namdirs[t0], userdirct - t0, sizeof *namdirs,
		  (int (*)DCLPROTO((const void *, const void *)))lencmp);

	finddir(0);		/* Invalidate directory cache */
	return;
    }
 /* add the name */

    if (userdirsz == userdirct) {
	userdirsz *= 2;
	namdirs = (Nameddirs) realloc((vptr) namdirs,
				      sizeof *namdirs * userdirsz);
	if (!namdirs)
	    return;
    }
    for (t0 = 0; t0 < userdirct; t0++)
	if (namdirs[t0].len > t2)
	    break;
    for (t1 = userdirct; t1 > t0; t1--)
	memcpy((vptr) & namdirs[t1], (vptr) & namdirs[t1 - 1],
	       sizeof *namdirs);
    namdirs[t0].len = t2;
    namdirs[t0].namelen = strlen(s);
    namdirs[t0].name = ztrdup(s);
    namdirs[t0].dir = ztrdup(t);
    namdirs[t0].homedir = ishomedir;
    userdirct++;
    if (t0 && namdirs[t0 - 1].len == t2)
	qsort((vptr) namdirs, t0 + 1, sizeof *namdirs,
	      (int (*)DCLPROTO((const void *, const void *)))lencmp);
    finddir(0);
}

int dircmp(s, t)		/**/
char *s;
char *t;
{
    if (s) {
	for (; *s == *t; s++, t++)
	    if (!*s)
		return 0;
	if (!*s && *t == '/')
	    return 0;
    }
    return 1;
}

int lencmp(first, sec)		/**/
vptr first;
vptr sec;
{
    int i;

#ifndef HIDE_NAMES
    if ((i = ((Nameddirs) first)->len - ((Nameddirs) sec)->len))
	return i;
    else
	return			/* for paths with the same lenght put the shortest name AFTER */
	    ((Nameddirs) sec)->namelen - ((Nameddirs) first)->namelen;
#else
    return ((Nameddirs) first)->len - ((Nameddirs) sec)->len;
#endif
}

int ddifftime(t1, t2)		/**/
time_t t1;
time_t t2;
{
    return ((long)t2 - (long)t1);
}

/* see if jobs need printing */

void scanjobs()
{				/**/
    int t0;

    for (t0 = 1; t0 != MAXJOB; t0++)
	if (jobtab[t0].stat & STAT_CHANGED)
	    printjob(jobtab + t0, 0);
}

/* do pre-prompt stuff */

void preprompt()
{				/**/
    int diff;
    List list;
    struct schedcmd *sch, *schl;

    if (unset(NOTIFY))
	scanjobs();
    if (errflag)
	return;
    if ((list = getshfunc("precmd")))
	doshfuncnoval(list, NULL, 0);
    if (errflag)
	return;
    if (period && (time(NULL) > lastperiod + period) &&
	(list = getshfunc("periodic"))) {
	doshfuncnoval(list, NULL, 0);
	lastperiod = time(NULL);
    }
    if (errflag)
	return;
    if (watch) {
	diff = (int)ddifftime(lastwatch, time(NULL));
	if (diff > logcheck) {
	    dowatch();
	    lastwatch = time(NULL);
	}
    }
    if (errflag)
	return;
    diff = (int)ddifftime(lastmailcheck, time(NULL));
    if (diff > mailcheck) {
	if (mailpath && *mailpath && **mailpath)
	    checkmailpath(mailpath);
	else if (mailfile && *mailfile) {
	    char *x[2];

	    x[0] = mailfile;
	    x[1] = NULL;
	    checkmailpath(x);
	}
	lastmailcheck = time(NULL);
    }
    for (schl = (struct schedcmd *)&schedcmds, sch = schedcmds; sch;
	 sch = (schl = sch)->next) {
	if (sch->time < time(NULL)) {
	    execstring(sch->cmd);
	    schl->next = sch->next;
	    zsfree(sch->cmd);
	    zfree(sch, sizeof(struct schedcmd));

	    sch = schl;
	}
	if (errflag)
	    return;
    }
}

int arrlen(s)			/**/
char **s;
{
    int t0;

    for (t0 = 0; *s; s++, t0++);
    return t0;
}

void checkmailpath(s)		/**/
char **s;
{
    struct stat st;
    char *v, *u, c;

    while (*s) {
	for (v = *s; *v && *v != '?'; v++);
	c = *v;
	*v = '\0';
	if (c != '?')
	    u = NULL;
	else
	    u = v + 1;
	if (**s == 0) {
	    *v = c;
	    zerr("empty MAILPATH component: %s", *s, 0);
	} else if (stat(*s, &st) == -1) {
	    if (errno != ENOENT)
		zerr("%e: %s", *s, errno);
	} else if (S_ISDIR(st.st_mode)) {
	    Lklist l;
	    DIR *lock = opendir(*s);
	    char buf[MAXPATHLEN * 2], **arr, **ap;
	    struct dirent *de;
	    int ct = 1;

	    if (lock) {
		pushheap();
		heapalloc();
		l = newlist();
		readdir(lock);
		readdir(lock);
		while ((de = readdir(lock))) {
		    if (errflag)
			break;
		    if (u)
			sprintf(buf, "%s/%s?%s", *s, de->d_name, u);
		    else
			sprintf(buf, "%s/%s", *s, de->d_name);
		    addnode(l, dupstring(buf));
		    ct++;
		}
		closedir(lock);
		ap = arr = (char **)alloc(ct * sizeof(char *));

		while ((*ap++ = (char *)ugetnode(l)));
		checkmailpath(arr);
		popheap();
	    }
	} else {
	    if (st.st_size && st.st_atime <= st.st_mtime &&
		st.st_mtime > lastmailcheck)
		if (!u) {
		    fprintf(stderr, "You have new mail.\n");
		    fflush(stderr);
		} else {
		    char *z = u;

		    while (*z)
			if (*z == '$' && z[1] == '_') {
			    fprintf(stderr, "%s", *s);
			    z += 2;
			} else
			    fputc(*z++, stderr);
		    fputc('\n', stderr);
		    fflush(stderr);
		}
	    if (isset(MAILWARNING) && st.st_atime > st.st_mtime &&
		st.st_atime > lastmailcheck && st.st_size) {
		fprintf(stderr, "The mail in %s has been read.\n", *s);
		fflush(stderr);
	    }
	}
	*v = c;
	s++;
    }
}

void saveoldfuncs(x, y)		/**/
char *x;
Cmdnam y;
{
    Cmdnam cc;

    if (y->flags & (SHFUNC | DISABLED)) {
	cc = (Cmdnam) zcalloc(sizeof *cc);
	*cc = *y;
	y->u.list = NULL;
	addhnode(ztrdup(x), cc, cmdnamtab, freecmdnam);
    }
}

/* create command hashtable */

void newcmdnamtab()
{				/**/
    Hashtab oldcnt;

    oldcnt = cmdnamtab;
    permalloc();
    cmdnamtab = newhtable(101);
    addbuiltins();
    if (oldcnt) {
	listhtable(oldcnt, (HFunc) saveoldfuncs);
	freehtab(oldcnt, freecmdnam);
    }
    lastalloc();
    pathchecked = path;
}

void freecmdnam(a)		/**/
vptr a;
{
    struct cmdnam *c = (struct cmdnam *)a;

    if (c->flags & SHFUNC) {
	if (c->u.list)
	    freestruct(c->u.list);
    } else if ((c->flags & HASHCMD) == HASHCMD)
	zsfree(c->u.cmd);

    zfree(c, sizeof(struct cmdnam));
}

void freecompcond(a)		/**/
vptr a;
{
    Compcond cc = (Compcond) a;
    Compcond and, or, c;
    int n;

    for (c = cc; c; c = or) {
	or = c->or;
	for (; c; c = and) {
	    and = c->and;
	    if (c->type == CCT_POS ||
		c->type == CCT_NUMWORDS) {
		free(c->u.r.a);
		free(c->u.r.b);
	    } else if (c->type == CCT_CURSUF ||
		       c->type == CCT_CURPRE) {
		for (n = 0; n < c->n; n++)
		    if (c->u.s.s[n])
			zsfree(c->u.s.s[n]);
		free(c->u.s.s);
	    } else if (c->type == CCT_RANGESTR ||
		       c->type == CCT_RANGEPAT) {
		for (n = 0; n < c->n; n++)
		    if (c->u.l.a[n])
			zsfree(c->u.l.a[n]);
		free(c->u.l.a);
		for (n = 0; n < c->n; n++)
		    if (c->u.l.b[n])
			zsfree(c->u.l.b[n]);
		free(c->u.l.b);
	    } else {
		for (n = 0; n < c->n; n++)
		    if (c->u.s.s[n])
			zsfree(c->u.s.s[n]);
		free(c->u.s.p);
		free(c->u.s.s);
	    }
	    zfree(c, sizeof(struct compcond));
	}
    }
}

void freecompctl(a)		/**/
vptr a;
{
    Compctl cc = (Compctl) a;

    if (cc == &cc_default ||
	cc == &cc_compos ||
	--cc->refc > 0)
	return;

    zsfree(cc->keyvar);
    zsfree(cc->glob);
    zsfree(cc->str);
    zsfree(cc->func);
    zsfree(cc->explain);
    zsfree(cc->prefix);
    zsfree(cc->suffix);
    zsfree(cc->hpat);
    zsfree(cc->subcmd);
    if (cc->cond)
	freecompcond(cc->cond);
    if (cc->ext) {
	Compctl n, m;

	n = cc->ext;
	do {
	    m = (Compctl) (n->next);
	    freecompctl(n);
	    n = m;
	}
	while (n);
    }
    if (cc->xor && cc->xor != &cc_default)
	freecompctl(cc->xor);
    zfree(cc, sizeof(struct compctl));
}

void freecompctlp(a)		/**/
vptr a;
{
    Compctlp ccp = (Compctlp) a;

    freecompctl(ccp->cc);
}

void freestr(a)			/**/
vptr a;
{
    zsfree(a);
}

void freeanode(a)		/**/
vptr a;
{
    struct alias *c = (struct alias *)a;

    zsfree(c->text);
    zfree(c, sizeof(struct alias));
}

void freepm(a)			/**/
vptr a;
{
    struct param *pm = (Param) a;

    zfree(pm, sizeof(struct param));
}

void gettyinfo(ti)		/**/
struct ttyinfo *ti;
{
    if (SHTTY != -1) {
#ifdef HAS_TERMIOS
#ifdef HAS_TCCRAP
	if (tcgetattr(SHTTY, &ti->tio) == -1)
#else
	if (ioctl(SHTTY, TCGETS, &ti->tio) == -1)
#endif
	    zerr("bad tcgets: %e", NULL, errno);
#else
#ifdef HAS_TERMIO
	ioctl(SHTTY, TCGETA, &ti->tio);
#else
	ioctl(SHTTY, TIOCGETP, &ti->sgttyb);
	ioctl(SHTTY, TIOCLGET, &ti->lmodes);
	ioctl(SHTTY, TIOCGETC, &ti->tchars);
	ioctl(SHTTY, TIOCGLTC, &ti->ltchars);
#endif
#endif
#ifdef TIOCGWINSZ
/*	if (ioctl(SHTTY, TIOCGWINSZ, &ti->winsize) == -1)
	    	zerr("bad tiocgwinsz: %e",NULL,errno);*/
	ioctl(SHTTY, TIOCGWINSZ, (char *)&ti->winsize);
#endif
    }
}

void settyinfo(ti)		/**/
struct ttyinfo *ti;
{
    if (SHTTY != -1) {
#ifdef HAS_TERMIOS
#ifdef HAS_TCCRAP
#ifndef TCSADRAIN
#define TCSADRAIN 1		/* XXX Princeton's include files are screwed up */
#endif
	tcsetattr(SHTTY, TCSADRAIN, &ti->tio);
    /* if (tcsetattr(SHTTY, TCSADRAIN, &ti->tio) == -1) */
#else
	ioctl(SHTTY, TCSETS, &ti->tio);
    /* if (ioctl(SHTTY, TCSETS, &ti->tio) == -1) */
#endif
	/*	zerr("settyinfo: %e",NULL,errno)*/ ;
#else
#ifdef HAS_TERMIO
	ioctl(SHTTY, TCSETA, &ti->tio);
#else
	ioctl(SHTTY, TIOCSETN, &ti->sgttyb);
	ioctl(SHTTY, TIOCLSET, &ti->lmodes);
	ioctl(SHTTY, TIOCSETC, &ti->tchars);
	ioctl(SHTTY, TIOCSLTC, &ti->ltchars);
#endif
#endif
    }
}

#ifdef TIOCGWINSZ
extern winchanged;

void adjustwinsize()
{				/**/
    int oldcols = columns, oldrows = lines;

    if (SHTTY == -1)
	return;

    ioctl(SHTTY, TIOCGWINSZ, (char *)&shttyinfo.winsize);
    if (shttyinfo.winsize.ws_col)
	columns = shttyinfo.winsize.ws_col;
    if (shttyinfo.winsize.ws_row)
	lines = shttyinfo.winsize.ws_row;
    if (oldcols != columns) {
	if (zleactive) {
	    resetneeded = winchanged = 1;
	    refresh();
	}
	setintenv("COLUMNS", columns);
    }
    if (oldrows != lines)
	setintenv("LINES", lines);
}
#endif

int zyztem(s, t)		/**/
char *s;
char *t;
{
    int cj = thisjob;

    s = tricat(s, " ", t);
    execstring(s);		/* Depends on recursion condom in execute() */
    zsfree(s);
    thisjob = cj;
    return lastval;
}

/* move a fd to a place >= 10 */

int movefd(fd)			/**/
int fd;
{
    int fe;

    if (fd == -1)
	return fd;
#ifdef F_DUPFD
    fe = fcntl(fd, F_DUPFD, 10);
#else
    if ((fe = dup(fd)) < 10)
	fe = movefd(fe);
#endif
    close(fd);
    return fe;
}

/* move fd x to y */

void redup(x, y)		/**/
int x;
int y;
{
    if (x != y) {
	dup2(x, y);
	close(x);
    }
}

void settrap(t0, l)		/**/
int t0;
List l;
{
    Cmd c;

    if (l) {
	c = l->left->left->left;
	if (c->type == SIMPLE && empty(c->args) && empty(c->redir)
	    && empty(c->vars) && !c->flags)
	    l = NULL;
    }
    if (t0 == -1)
	return;
    if (jobbing && (t0 == SIGTTOU || t0 == SIGTSTP || t0 == SIGTTIN
		    || t0 == SIGPIPE)) {
	zerr("can't trap SIG%s in interactive shells", sigs[t0], 0);
	return;
    }
    if (sigfuncs[t0])
	freestruct(sigfuncs[t0]);
    if (!l) {
	sigtrapped[t0] = 2;
	sigfuncs[t0] = NULL;
	if (t0 && t0 <= SIGCOUNT &&
#ifdef SIGWINCH
	    t0 != SIGWINCH &&
#endif
	    t0 != SIGCHLD)
	    sig_ignore(t0);
    } else {
	if (t0 && t0 <= SIGCOUNT &&
#ifdef SIGWINCH
	    t0 != SIGWINCH &&
#endif
	    t0 != SIGCHLD)
	    sig_handle(t0);
	sigtrapped[t0] = 1;
	permalloc();
	sigfuncs[t0] = (List) dupstruct(l);
	heapalloc();
    }
}

void unsettrap(t0)		/**/
int t0;
{
    if (t0 == -1)
	return;
    if (jobbing && (t0 == SIGTTOU || t0 == SIGTSTP || t0 == SIGTTIN
		    || t0 == SIGPIPE)) {
	return;
    }
    sigtrapped[t0] = 0;
    if (t0 == SIGINT)
	intr();
    else if (t0 == SIGHUP)
	sig_handle(t0);
    else if (t0 && t0 <= SIGCOUNT &&
#ifdef SIGWINCH
	     t0 != SIGWINCH &&
#endif
	     t0 != SIGCHLD)
	sig_default(t0);
    if (sigfuncs[t0]) {
	freestruct(sigfuncs[t0]);
	sigfuncs[t0] = NULL;
    }
}

void dotrap(sig)		/**/
int sig;
{
    int sav, savval;

    sav = sigtrapped[sig];
    savval = lastval;
    if (sav == 2)
	return;
    sigtrapped[sig] = 2;
    if (sigfuncs[sig]) {
	Lklist args;
	char *name, num[4];

	lexsave();
	permalloc();
	args = newlist();
	name = (char *)zalloc(5 + strlen(sigs[sig]));
	sprintf(name, "TRAP%s", sigs[sig]);
	addnode(args, name);
	sprintf(num, "%d", sig);
	addnode(args, num);
	trapreturn = -1;
	doshfuncnoval(sigfuncs[sig], args, 0);
	lexrestore();
	freetable(args, (FFunc) NULL);
	zsfree(name);
	if (trapreturn > 0) {
	    breaks = loops;
	    errflag = 1;
	} else
	    trapreturn = 0;
    }
    if (sigtrapped[sig])
	sigtrapped[sig] = sav;
    lastval = savval;
}

/* copy len chars from t into s, and null terminate */

void ztrncpy(s, t, len)		/**/
char *s;
char *t;
int len;
{
    while (len--)
	*s++ = *t++;
    *s = '\0';
}

/* copy t into *s and update s */

void strucpy(s, t)		/**/
char **s;
char *t;
{
    char *u = *s;

    while ((*u++ = *t++));
    *s = u - 1;
}

void struncpy(s, t, n)		/**/
char **s;
char *t;
int n;
{
    char *u = *s;

    while (n--)
	*u++ = *t++;
    *s = u;
    *u = '\0';
}

int checkrmall(s)		/**/
char *s;
{
    fflush(stdin);
    if (*s == '/')
	fprintf(stderr, "zsh: sure you want to delete all the files in %s? ", s);
    else
	fprintf(stderr, "zsh: sure you want to delete all the files in %s/%s? ",
		(pwd[1]) ? pwd : "", s);
    fflush(stderr);
    feep();
    return (getquery() == 'y');
}

int getquery()
{				/**/
    char c, d;
    int val, isem = !strcmp(term, "emacs");

    attachtty(mypgrp);
    if (!isem)
	setcbreak();
#ifdef FIONREAD
    ioctl(SHTTY, FIONREAD, (char *)&val);
    if (val) {
	if (!isem)
	    settyinfo(&shttyinfo);
	write(2, "n\n", 2);
	return 'n';
    }
#endif
    if (read(SHTTY, &c, 1) == 1)
	if (c == 'y' || c == 'Y' || c == '\t')
	    c = 'y';
    if (isem) {
	if (c != '\n')
	    while (read(SHTTY, &d, 1) == 1 && d != '\n');
    } else {
	settyinfo(&shttyinfo);
	if (c != '\n')
	    write(2, "\n", 1);
    }
    return (int)c;
}

static int d;
static char *guess, *best;

void spscan(s, junk)		/**/
char *s;
char *junk;
{
    int nd;

    nd = spdist(s, guess, (int)strlen(guess) / 4 + 1);
    if (nd <= d) {
	best = s;
	d = nd;
    }
}

/* spellcheck a word */
/* fix s and s2 ; if s2 is non-null, fix the history list too */

void spckword(s, s2, tptr, cmd, ask)	/**/
char **s;
char **s2;
char **tptr;
int cmd;
int ask;
{
    char *t, *u;
    char firstchar;
    int x;
    int pram = 0;

    if (**s == '-' || **s == '%')
	return;
    if (!strcmp(*s, "in"))
	return;
    if (!(*s)[0] || !(*s)[1])
	return;
    if (gethnode(*s, cmdnamtab) || gethnode(*s, aliastab))
	return;
    else if (isset(HASHLISTALL)) {
	fullhash();
	if (gethnode(*s, cmdnamtab))
	    return;
    }
    t = *s;
    if (*t == Tilde || *t == Equals || *t == String)
	t++;
    for (; *t; t++)
	if (itok(*t))
	    return;
    best = NULL;
    for (t = *s; *t; t++)
	if (*t == '/')
	    break;
    if (**s == String) {
	if (*t)
	    return;
	pram = 1;
	guess = *s + 1;
	while (*guess == '+' || *guess == '^' ||
	       *guess == '#' || *guess == '~' ||
	       *guess == '=')
	    guess++;
	d = 100;
	listhtable(paramtab, spscan);
    } else {
	if ((u = spname(guess = *s)) != *s)
	    best = u;
	if (!*t && !cmd) {
	    if (access(*s, F_OK) == 0)
		return;
	    if (hashcmd(*s, pathchecked))
		return;
	    guess = *s;
	    d = 100;
	    listhtable(aliastab, spscan);
	    listhtable(cmdnamtab, spscan);
	}
    }
    if (errflag)
	return;
    if (best && (int)strlen(best) > 1 && strcmp(best, guess)) {
	if (ask) {
	    char *pp;
	    int junk;

	    rstring = best;
	    Rstring = guess;
	    firstchar = *guess;
	    if (*guess == Tilde)
		*guess = '~';
	    else if (*guess == String)
		*guess = '$';
	    else if (*guess == Equals)
		*guess = '=';
	    pp = putprompt(sprompt, &junk, 1);
	    *guess = firstchar;
	    fprintf(stderr, "%s", pp);
	    fflush(stderr);
	    feep();
	    x = getquery();
	} else
	    x = 'y';
	if (x == 'y' || x == ' ') {
	    if (!pram) {
		*s = dupstring(best);
	    } else {
		*s = (char *)alloc(strlen(best) + 2);
		strcpy(*s + 1, best);
		**s = String;
	    }
	    if (s2) {
		if (*tptr && !strcmp(hlastw, *s2) && hlastw < hptr) {
		    char *z;

		    hptr = hlastw;
		    if (pram)
			hwaddc('$');
		    for (z = best; *z; z++)
			hwaddc(*z);
		    hwaddc(HISTSPACE);
		    *tptr = hptr - 1;
		    **tptr = '\0';
		}
		*s2 = dupstring(best);
	    }
	} else if (x == 'a') {
	    histdone |= HISTFLAG_NOEXEC;
	} else if (x == 'e') {
	    histdone |= HISTFLAG_NOEXEC | HISTFLAG_RECALL;
	}
    }
}

int ztrftime(buf, bufsize, fmt, tm)	/**/
char *buf;
int bufsize;
char *fmt;
struct tm *tm;
{
    static char *astr[] =
    {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    static char *estr[] =
    {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
     "Aug", "Sep", "Oct", "Nov", "Dec"};
    static char *lstr[] =
    {"12", " 1", " 2", " 3", " 4", " 5", " 6", " 7", " 8", " 9",
     "10", "11"};
    char tmp[3];

#ifdef HAS_STRFTIME
    char *origbuf = buf;

#endif

    tmp[0] = '%';
    tmp[2] = '\0';
    while (*fmt)
	if (*fmt == '%') {
	    fmt++;
	    switch (*fmt++) {
	    case 'a':
		strucpy(&buf, astr[tm->tm_wday]);
		break;
	    case 'b':
		strucpy(&buf, estr[tm->tm_mon]);
		break;
	    case 'd':
		*buf++ = '0' + tm->tm_mday / 10;
		*buf++ = '0' + tm->tm_mday % 10;
		break;
	    case 'e':
		if (tm->tm_mday > 9)
		    *buf++ = '0' + tm->tm_mday / 10;
		*buf++ = '0' + tm->tm_mday % 10;
		break;
	    case 'k':
		if (tm->tm_hour > 9)
		    *buf++ = '0' + tm->tm_hour / 10;
		*buf++ = '0' + tm->tm_hour % 10;
		break;
	    case 'l':
		strucpy(&buf, lstr[tm->tm_hour % 12]);
		break;
	    case 'm':
		*buf++ = '0' + (tm->tm_mon + 1) / 10;
		*buf++ = '0' + (tm->tm_mon + 1) % 10;
		break;
	    case 'M':
		*buf++ = '0' + tm->tm_min / 10;
		*buf++ = '0' + tm->tm_min % 10;
		break;
	    case 'p':
		*buf++ = (tm->tm_hour > 11) ? 'p' : 'a';
		*buf++ = 'm';
		break;
	    case 'S':
		*buf++ = '0' + tm->tm_sec / 10;
		*buf++ = '0' + tm->tm_sec % 10;
		break;
	    case 'y':
		*buf++ = '0' + tm->tm_year / 10;
		*buf++ = '0' + tm->tm_year % 10;
		break;
	    default:
#ifdef HAS_STRFTIME
		*buf = '\0';
		tmp[1] = fmt[-1];
		strftime(buf, bufsize - strlen(origbuf), tmp, tm);
		buf += strlen(buf);
#else
		*buf++ = '%';
		*buf++ = fmt[-1];
#endif
		break;
	    }
	} else
	    *buf++ = *fmt++;
    *buf = '\0';
    return 0;
}

char *join(arr, delim)		/**/
char **arr;
int delim;
{
    int len = 0;
    char **s, *ret, *ptr;
    static char *lastmem = NULL;

    for (s = arr; *s; s++)
	len += strlen(*s) + 1;
    if (!len)
	return "";
    zsfree(lastmem);
    lastmem = ptr = ret = (char *)zalloc(len);
    for (s = arr; *s; s++) {
	strucpy(&ptr, *s);
	*ptr++ = delim;
    }
    ptr[-1] = '\0';
    return ret;
}

char *spacejoin(s)		/**/
char **s;
{
    return join(s, *ifs);
}

char **colonsplit(s)		/**/
char *s;
{
    int ct;
    char *t, **ret, **ptr;

    for (t = s, ct = 0; *t; t++)
	if (*t == ':')
	    ct++;
    ptr = ret = (char **)zalloc(sizeof(char **) * (ct + 2));

    t = s;
    do {
	for (s = t; *t && *t != ':'; t++);
	*ptr = (char *)zalloc((t - s) + 1);
	ztrncpy(*ptr++, s, t - s);
    }
    while (*t++);
    *ptr = NULL;
    return ret;
}

char **spacesplit(s)		/**/
char *s;
{
    int ct;
    char *t, **ret, **ptr;

    for (t = s, ct = 0; *t; t++)
	if (isep(*t))
	    ct++;
    ptr = ret = (char **)zalloc(sizeof(char **) * (ct + 2));

    t = s;
    do {
	for (s = t; *t && !isep(*t); t++);
	*ptr = (char *)zalloc((t - s) + 1);
	ztrncpy(*ptr++, s, t - s);
    }
    while (*t++);
    *ptr = NULL;
    return ret;
}

int findsep(s, sep)		/**/
char **s;
char *sep;
{
    int i;
    char *t, *tt;

    if (!sep) {
	for (t = *s, i = 1; i && *t;) {
	    for (tt = ifs, i = 1; i && *tt; tt++)
		if (*tt == *t)
		    i = 0;
	    if (i)
		t++;
	}
	i = t - *s;
	*s = t;
	return i;
    }
    if (!sep[0]) {
	i = strlen(*s);
	*s += i;
	return i;
    }
    for (i = 0; **s; (*s)++, i++) {
	for (t = sep, tt = *s; *t && *tt && *t == *tt; t++, tt++);
	if (!*t)
	    return i;
    }
    return -1;
}

char *findword(s, sep)		/**/
char **s;
char *sep;
{
    char *r, *t, *tt;
    int f, sl;

    if (!**s)
	return NULL;

    if (sep) {
	sl = strlen(sep);
	r = *s;
	while (!(f = findsep(s, sep))) {
	    r = *s += sl;
	}
	return r;
    }
    for (t = *s, f = 1; f && *t;) {
	for (tt = ifs, f = 0; !f && *tt; tt++)
	    if (*tt == *t)
		f = 1;
	if (f)
	    t++;
    }
    *s = t;
    findsep(s, sep);
    return t;
}

int wordcount(s, sep, mul)	/**/
char *s;
char *sep;
int mul;
{
    int r = 1, sl, c, cc;
    char *t = s, *ti;

    if (sep) {
	sl = strlen(sep);
	for (; (c = findsep(&t, sep)) >= 0; t += sl)
	    if ((c && *(t + sl)) || mul)
		r++;
    } else {
	if (!mul)
	    for (c = 1; c && *t;) {
		for (c = 0, ti = ifs; !c && *ti; ti++)
		    if (*ti == *t)
			c = 1;
		if (c)
		    t++;
	    }
	if (!*t)
	    return 0;
	for (; *t; t++) {
	    for (c = 0, ti = ifs; !c && *ti; ti++)
		if (*ti == *t)
		    c = 1;
	    if (c && !mul) {
		for (cc = 1, t++; cc && *t;) {
		    for (cc = 0, ti = ifs; !cc && *ti; ti++)
			if (*ti == *t)
			    cc = 1;
		    if (cc)
			t++;
		}
		if (*t)
		    r++;
	    } else if (c)
		r++;
	}
    }
    return r;
}

char *sepjoin(s, sep)		/**/
char **s;
char *sep;
{
    char *r, *p, **t;
    int l, sl, elide = 0;
    static char *lastmem = NULL;
    char sepbuf[2];

    if (!*s)
	return "";
    if (!sep) {
	elide = 1;
	sep = sepbuf;
	sepbuf[0] = *ifs;
	sepbuf[1] = '\0';
    }
    sl = strlen(sep);
    for (t = s, l = 1 - sl; *t; l += strlen(*t) + sl, t++);
    if (l == 1)
	return "";
    zsfree(lastmem);
    lastmem = r = p = (char *)zalloc(l);
    t = s;
    if (elide)
	while (*t && !**t)
	    t++;
    for (; *t; t++) {
	strucpy(&p, *t);
	if (t[1] && (!elide || t[1][0]))
	    strucpy(&p, sep);
    }
    return r;
}

char **sepsplit(s, sep)		/**/
char *s;
char *sep;
{
    int n, sl, f;
    char *t, *tt, **r, **p;

    if (!sep)
	return spacesplit(s);

    sl = strlen(sep);
    n = wordcount(s, sep, 1);
    r = p = (char **)zalloc((n + 1) * sizeof(char *));

    for (t = s; n--;) {
	tt = t;
	f = findsep(&t, sep);	/* f set not but not used? ++jhi; */
	*p = (char *)zalloc(t - tt + 1);
	strncpy(*p, tt, t - tt);
	(*p)[t - tt] = '\0';
	p++;
	t += sl;
    }
    *p = NULL;

    return r;
}

List getshfunc(nam)		/**/
char *nam;
{
    Cmdnam x = (Cmdnam) gethnode(nam, cmdnamtab);

    if (x && (x->flags & SHFUNC)) {
	if (x->flags & PMFLAG_u) {
	    List l;

	    if (!(l = getfpfunc(nam))) {
		zerr("function not found: %s", nam, 0);
		return NULL;
	    }
	    x->flags &= ~PMFLAG_u;
	    permalloc();
	    x->u.list = (List) dupstruct(l);
	    lastalloc();
	}
	return x->u.list;
    }
    return NULL;
}

/* allocate a tree element */

static int sizetab[N_COUNT] =
{
    sizeof(struct list),
    sizeof(struct sublist),
    sizeof(struct pline),
    sizeof(struct cmd),
    sizeof(struct redir),
    sizeof(struct cond),
    sizeof(struct forcmd),
    sizeof(struct casecmd),
    sizeof(struct ifcmd),
    sizeof(struct whilecmd),
    sizeof(struct varasg)};

static int flagtab[N_COUNT] =
{
    NT_SET(N_LIST, 1, NT_NODE, NT_NODE, 0, 0),
    NT_SET(N_SUBLIST, 2, NT_NODE, NT_NODE, 0, 0),
    NT_SET(N_PLINE, 1, NT_NODE, NT_NODE, 0, 0),
    NT_SET(N_CMD, 2, NT_STR | NT_LIST, NT_NODE, NT_NODE | NT_LIST, NT_NODE | NT_LIST),
    NT_SET(N_REDIR, 3, NT_STR, 0, 0, 0),
    NT_SET(N_COND, 1, NT_NODE, NT_NODE, 0, 0),
    NT_SET(N_FOR, 1, NT_STR, NT_NODE, 0, 0),
    NT_SET(N_CASE, 0, NT_STR | NT_ARR, NT_NODE | NT_ARR, 0, 0),
    NT_SET(N_IF, 0, NT_NODE | NT_ARR, NT_NODE | NT_ARR, 0, 0),
    NT_SET(N_WHILE, 1, NT_NODE, NT_NODE, 0, 0),
    NT_SET(N_VARASG, 1, NT_STR, NT_STR, NT_STR | NT_LIST, 0)};

vptr allocnode(type)		/**/
int type;
{
    struct node *n = (struct node *)alloc(sizetab[type]);

    memset((char *)n, 0, sizetab[type]);
    n->type = flagtab[type];
    if (useheap)
	n->type |= NT_HEAP;

    return (vptr) n;
}

vptr dupstruct(a)		/**/
vptr a;
{
    struct node *n = (struct node *)a, *r;

    if (!a || ((List) a) == &dummy_list)
	return (vptr) a;

    if ((n->type & NT_HEAP) && !useheap) {
	heapalloc();
	n = (struct node *)dupstruct2((vptr) n);
	permalloc();
	n = simplifystruct(n);
    }
    r = (struct node *)dupstruct2((vptr) n);

    if (!(n->type & NT_HEAP) && useheap)
	r = expandstruct(r, N_LIST);

    return (vptr) r;
}

struct node *simplifystruct(n)	/**/
struct node *n;
{
    if (!n || ((List) n) == &dummy_list)
	return n;

    switch (NT_TYPE(n->type)) {
    case N_LIST:
	{
	    List l = (List) n;

	    l->left = (Sublist) simplifystruct((struct node *)l->left);
	    if (l->type == SYNC && !l->right)
		return (struct node *)l->left;
	}
	break;
    case N_SUBLIST:
	{
	    Sublist sl = (Sublist) n;

	    sl->left = (Pline) simplifystruct((struct node *)sl->left);
	    if (sl->type == END && !sl->flags && !sl->right)
		return (struct node *)sl->left;
	}
	break;
    case N_PLINE:
	{
	    Pline pl = (Pline) n;

	    pl->left = (Cmd) simplifystruct((struct node *)pl->left);
	    if (pl->type == END && !pl->right)
		return (struct node *)pl->left;
	}
	break;
    case N_CMD:
	{
	    Cmd c = (Cmd) n;
	    int i = 0;

	    if (empty(c->args))
		c->args = NULL, i++;
	    if (empty(c->redir))
		c->redir = NULL, i++;
	    if (empty(c->vars))
		c->vars = NULL, i++;

	    c->u.list = (List) simplifystruct((struct node *)c->u.list);
	    if (i == 3 && !c->flags &&
		(c->type == CWHILE || c->type == CIF ||
		 c->type == COND))
		return (struct node *)c->u.list;
	}
	break;
    case N_FOR:
	{
	    struct forcmd *f = (struct forcmd *)n;

	    f->list = (List) simplifystruct((struct node *)f->list);
	}
	break;
    case N_CASE:
	{
	    struct casecmd *c = (struct casecmd *)n;
	    List *l;

	    for (l = c->lists; *l; l++)
		*l = (List) simplifystruct((struct node *)*l);
	}
	break;
    case N_IF:
	{
	    struct ifcmd *i = (struct ifcmd *)n;
	    List *l;

	    for (l = i->ifls; *l; l++)
		*l = (List) simplifystruct((struct node *)*l);
	    for (l = i->thenls; *l; l++)
		*l = (List) simplifystruct((struct node *)*l);
	}
	break;
    case N_WHILE:
	{
	    struct whilecmd *w = (struct whilecmd *)n;

	    w->cont = (List) simplifystruct((struct node *)w->cont);
	    w->loop = (List) simplifystruct((struct node *)w->loop);
	}
    }

    return n;
}

struct node *expandstruct(n, exp)	/**/
struct node *n;
int exp;
{
    struct node *m;

    if (!n || ((List) n) == &dummy_list)
	return n;

    if (exp != N_COUNT && exp != NT_TYPE(n->type)) {
	switch (exp) {
	case N_LIST:
	    {
		List l;

		m = (struct node *)allocnode(N_LIST);
		l = (List) m;
		l->type = SYNC;
		l->left = (Sublist) expandstruct(n, N_SUBLIST);

		return (struct node *)l;
	    }
	case N_SUBLIST:
	    {
		Sublist sl;

		m = (struct node *)allocnode(N_SUBLIST);
		sl = (Sublist) m;
		sl->type = END;
		sl->left = (Pline) expandstruct(n, N_PLINE);

		return (struct node *)sl;
	    }
	case N_PLINE:
	    {
		Pline pl;

		m = (struct node *)allocnode(N_PLINE);
		pl = (Pline) m;
		pl->type = END;
		pl->left = (Cmd) expandstruct(n, N_CMD);

		return (struct node *)pl;
	    }
	case N_CMD:
	    {
		Cmd c;

		m = (struct node *)allocnode(N_CMD);
		c = (Cmd) m;
		switch (NT_TYPE(n->type)) {
		case N_WHILE:
		    c->type = CWHILE;
		    break;
		case N_IF:
		    c->type = CIF;
		    break;
		case N_COND:
		    c->type = COND;
		}
		c->u.list = (List) expandstruct(n, NT_TYPE(n->type));
		c->args = newlist();
		c->vars = newlist();
		c->redir = newlist();

		return (struct node *)c;
	    }
	}
    } else
	switch (NT_TYPE(n->type)) {
	case N_LIST:
	    {
		List l = (List) n;

		l->left = (Sublist) expandstruct((struct node *)l->left,
						 N_SUBLIST);
		l->right = (List) expandstruct((struct node *)l->right,
					       N_LIST);
	    }
	    break;
	case N_SUBLIST:
	    {
		Sublist sl = (Sublist) n;

		sl->left = (Pline) expandstruct((struct node *)sl->left,
						N_PLINE);
		sl->right = (Sublist) expandstruct((struct node *)sl->right,
						   N_SUBLIST);
	    }
	    break;
	case N_PLINE:
	    {
		Pline pl = (Pline) n;

		pl->left = (Cmd) expandstruct((struct node *)pl->left,
					      N_CMD);
		pl->right = (Pline) expandstruct((struct node *)pl->right,
						 N_PLINE);
	    }
	    break;
	case N_CMD:
	    {
		Cmd c = (Cmd) n;

		if (!c->args)
		    c->args = newlist();
		if (!c->vars)
		    c->vars = newlist();
		if (!c->redir)
		    c->redir = newlist();

		switch (c->type) {
		case CFOR:
		case CSELECT:
		    c->u.list = (List) expandstruct((struct node *)c->u.list,
						    N_FOR);
		    break;
		case CWHILE:
		    c->u.list = (List) expandstruct((struct node *)c->u.list,
						    N_WHILE);
		    break;
		case CIF:
		    c->u.list = (List) expandstruct((struct node *)c->u.list,
						    N_IF);
		    break;
		case CCASE:
		    c->u.list = (List) expandstruct((struct node *)c->u.list,
						    N_CASE);
		    break;
		case COND:
		    c->u.list = (List) expandstruct((struct node *)c->u.list,
						    N_COND);
		    break;
		case ZCTIME:
		    c->u.list = (List) expandstruct((struct node *)c->u.list,
						    N_SUBLIST);
		    break;
		default:
		    c->u.list = (List) expandstruct((struct node *)c->u.list,
						    N_LIST);
		}
	    }
	    break;
	case N_FOR:
	    {
		struct forcmd *f = (struct forcmd *)n;

		f->list = (List) expandstruct((struct node *)f->list,
					      N_LIST);
	    }
	    break;
	case N_CASE:
	    {
		struct casecmd *c = (struct casecmd *)n;
		List *l;

		for (l = c->lists; *l; l++)
		    *l = (List) expandstruct((struct node *)*l, N_LIST);
	    }
	    break;
	case N_IF:
	    {
		struct ifcmd *i = (struct ifcmd *)n;
		List *l;

		for (l = i->ifls; *l; l++)
		    *l = (List) expandstruct((struct node *)*l, N_LIST);
		for (l = i->thenls; *l; l++)
		    *l = (List) expandstruct((struct node *)*l, N_LIST);
	    }
	    break;
	case N_WHILE:
	    {
		struct whilecmd *w = (struct whilecmd *)n;

		w->cont = (List) expandstruct((struct node *)w->cont,
					      N_LIST);
		w->loop = (List) expandstruct((struct node *)w->loop,
					      N_LIST);
	    }
	}

    return n;
}

/* duplicate a syntax tree node of given type, argument number */

vptr dupnode(type, a, argnum)	/**/
int type;
vptr a;
int argnum;
{
    if (!a)
	return NULL;
    switch (NT_N(type, argnum)) {
    case NT_NODE:
	return (vptr) dupstruct2(a);
    case NT_STR:
	return (useheap) ? ((vptr) dupstring(a)) :
	    ((vptr) ztrdup(a));
    case NT_LIST | NT_NODE:
	if (type & NT_HEAP)
	    if (useheap)
		return (vptr) duplist(a, (VFunc) dupstruct2);
	    else
		return (vptr) list2arr(a, (VFunc) dupstruct2);
	else if (useheap)
	    return (vptr) arr2list(a, (VFunc) dupstruct2);
	else
	    return (vptr) duparray(a, (VFunc) dupstruct2);
    case NT_LIST | NT_STR:
	if (type & NT_HEAP)
	    if (useheap)
		return (vptr) duplist(a, (VFunc) dupstring);
	    else
		return (vptr) list2arr(a, (VFunc) ztrdup);
	else if (useheap)
	    return (vptr) arr2list(a, (VFunc) dupstring);
	else
	    return (vptr) duparray(a, (VFunc) ztrdup);
    case NT_NODE | NT_ARR:
	return (vptr) duparray(a, (VFunc) dupstruct2);
    case NT_STR | NT_ARR:
	return (vptr) duparray(a, (VFunc) (useheap ? dupstring : ztrdup));
    default:
	abort();
    }
}

/* Free a syntax tree node of given type, argument number */

void freenode(type, a, argnum)	/**/
int type;
vptr a;
int argnum;
{
    if (!a)
	return;
    switch (NT_N(type, argnum)) {
    case NT_NODE:
	freestruct(a);
	break;
    case NT_STR:
	zsfree(a);
	break;
    case NT_LIST | NT_NODE:
    case NT_NODE | NT_ARR:
	{
	    char **p = (char **)a;

	    while (*p)
		freestruct(*p++);
	    free(a);
	}
	break;
    case NT_LIST | NT_STR:
    case NT_STR | NT_ARR:
	freearray(a);
	break;
    default:
	abort();
    }
}

/* duplicate a syntax tree */

vptr *dupstruct2(a)		/**/
vptr a;
{
    struct node *n = (struct node *)a, *m;
    int type;

    if (!n || ((List) n) == &dummy_list)
	return a;
    type = n->type;
    m = (struct node *)alloc(sizetab[NT_TYPE(type)]);
    m->type = (type & ~NT_HEAP);
    if (useheap)
	m->type |= NT_HEAP;
    switch (NT_TYPE(type)) {
    case N_LIST:
	{
	    List nl = (List) n;
	    List ml = (List) m;

	    ml->type = nl->type;
	    ml->left = (Sublist) dupnode(type, nl->left, 0);
	    ml->right = (List) dupnode(type, nl->right, 1);
	}
	break;
    case N_SUBLIST:
	{
	    Sublist nsl = (Sublist) n;
	    Sublist msl = (Sublist) m;

	    msl->type = nsl->type;
	    msl->flags = nsl->flags;
	    msl->left = (Pline) dupnode(type, nsl->left, 0);
	    msl->right = (Sublist) dupnode(type, nsl->right, 1);
	}
	break;
    case N_PLINE:
	{
	    Pline npl = (Pline) n;
	    Pline mpl = (Pline) m;

	    mpl->type = npl->type;
	    mpl->left = (Cmd) dupnode(type, npl->left, 0);
	    mpl->right = (Pline) dupnode(type, npl->right, 1);
	}
	break;
    case N_CMD:
	{
	    Cmd nc = (Cmd) n;
	    Cmd mc = (Cmd) m;

	    mc->type = nc->type;
	    mc->flags = nc->flags;
	    mc->lineno = nc->lineno;
	    mc->args = (Lklist) dupnode(type, nc->args, 0);
	    mc->u.generic = (vptr) dupnode(type, nc->u.generic, 1);
	    mc->redir = (Lklist) dupnode(type, nc->redir, 2);
	    mc->vars = (Lklist) dupnode(type, nc->vars, 3);
	}
	break;
    case N_REDIR:
	{
	    Redir nr = (Redir) n;
	    Redir mr = (Redir) m;

	    mr->type = nr->type;
	    mr->fd1 = nr->fd1;
	    mr->fd2 = nr->fd2;
	    mr->name = (char *)dupnode(type, nr->name, 0);
	}
	break;
    case N_COND:
	{
	    Cond nco = (Cond) n;
	    Cond mco = (Cond) m;

	    mco->type = nco->type;
	    mco->left = (vptr) dupnode(type, nco->left, 0);
	    mco->right = (vptr) dupnode(type, nco->right, 1);
	}
	break;
    case N_FOR:
	{
	    struct forcmd *nf = (struct forcmd *)n;
	    struct forcmd *mf = (struct forcmd *)m;

	    mf->inflag = nf->inflag;
	    mf->name = (char *)dupnode(type, nf->name, 0);
	    mf->list = (List) dupnode(type, nf->list, 1);
	}
	break;
    case N_CASE:
	{
	    struct casecmd *ncc = (struct casecmd *)n;
	    struct casecmd *mcc = (struct casecmd *)m;

	    mcc->pats = (char **)dupnode(type, ncc->pats, 0);
	    mcc->lists = (List *) dupnode(type, ncc->lists, 1);
	}
	break;
    case N_IF:
	{
	    struct ifcmd *nic = (struct ifcmd *)n;
	    struct ifcmd *mic = (struct ifcmd *)m;

	    mic->ifls = (List *) dupnode(type, nic->ifls, 0);
	    mic->thenls = (List *) dupnode(type, nic->thenls, 1);

	}
	break;
    case N_WHILE:
	{
	    struct whilecmd *nwc = (struct whilecmd *)n;
	    struct whilecmd *mwc = (struct whilecmd *)m;

	    mwc->cond = nwc->cond;
	    mwc->cont = (List) dupnode(type, nwc->cont, 0);
	    mwc->loop = (List) dupnode(type, nwc->loop, 1);
	}
	break;
    case N_VARASG:
	{
	    Varasg nva = (Varasg) n;
	    Varasg mva = (Varasg) m;

	    mva->type = nva->type;
	    mva->name = (char *)dupnode(type, nva->name, 0);
	    mva->str = (char *)dupnode(type, nva->str, 1);
	    mva->arr = (Lklist) dupnode(type, nva->arr, 2);
	}
	break;
    }
    return (vptr *) m;
}

/* free a syntax tree */

void freestruct(a)		/**/
vptr a;
{
    struct node *n = (struct node *)a;
    int type;

    if (!n || ((List) n) == &dummy_list)
	return;

    type = n->type;
    switch (NT_TYPE(type)) {
    case N_LIST:
	{
	    List nl = (List) n;

	    freenode(type, nl->left, 0);
	    freenode(type, nl->right, 1);
	}
	break;
    case N_SUBLIST:
	{
	    Sublist nsl = (Sublist) n;

	    freenode(type, nsl->left, 0);
	    freenode(type, nsl->right, 1);
	}
	break;
    case N_PLINE:
	{
	    Pline npl = (Pline) n;

	    freenode(type, npl->left, 0);
	    freenode(type, npl->right, 1);
	}
	break;
    case N_CMD:
	{
	    Cmd nc = (Cmd) n;

	    freenode(type, nc->args, 0);
	    freenode(type, nc->u.generic, 1);
	    freenode(type, nc->redir, 2);
	    freenode(type, nc->vars, 3);
	}
	break;
    case N_REDIR:
	{
	    Redir nr = (Redir) n;

	    freenode(type, nr->name, 0);
	}
	break;
    case N_COND:
	{
	    Cond nco = (Cond) n;

	    freenode(type, nco->left, 0);
	    freenode(type, nco->right, 1);
	}
	break;
    case N_FOR:
	{
	    struct forcmd *nf = (struct forcmd *)n;

	    freenode(type, nf->name, 0);
	    freenode(type, nf->list, 1);
	}
	break;
    case N_CASE:
	{
	    struct casecmd *ncc = (struct casecmd *)n;

	    freenode(type, ncc->pats, 0);
	    freenode(type, ncc->lists, 1);
	}
	break;
    case N_IF:
	{
	    struct ifcmd *nic = (struct ifcmd *)n;

	    freenode(type, nic->ifls, 0);
	    freenode(type, nic->thenls, 1);

	}
	break;
    case N_WHILE:
	{
	    struct whilecmd *nwc = (struct whilecmd *)n;

	    freenode(type, nwc->cont, 0);
	    freenode(type, nwc->loop, 1);
	}
	break;
    case N_VARASG:
	{
	    Varasg nva = (Varasg) n;

	    freenode(type, nva->name, 0);
	    freenode(type, nva->str, 1);
	    freenode(type, nva->arr, 2);
	}
	break;
    }
    zfree(n, sizetab[NT_TYPE(type)]);
}

Lklist duplist(l, func)		/**/
Lklist l;
VFunc func;
{
    Lklist ret;
    Lknode node;

    ret = newlist();
    for (node = firstnode(l); node; incnode(node))
	addnode(ret, func(getdata(node)));
    return ret;
}

char **duparray(arr, func)	/**/
char **arr;
VFunc func;
{
    char **ret = (char **)alloc((arrlen(arr) + 1) * sizeof(char *)), **rr;

    for (rr = ret; *arr;)
	*rr++ = (char *)func(*arr++);
    *rr = NULL;

    return ret;
}

char **list2arr(l, func)	/**/
Lklist l;
VFunc func;
{
    char **arr, **r;
    Lknode n;

    arr = r = (char **)alloc((countnodes(l) + 1) * sizeof(char *));

    for (n = firstnode(l); n; incnode(n))
	*r++ = (char *)func(getdata(n));
    *r = NULL;

    return arr;
}

Lklist arr2list(arr, func)	/**/
char **arr;
VFunc func;
{
    Lklist l = newlist();

    while (*arr)
	addnode(l, func(*arr++));

    return l;
}

char **mkarray(s)		/**/
char *s;
{
    char **t = (char **)zalloc((s) ? (2 * sizeof s) : (sizeof s));

    if ((*t = s))
	t[1] = NULL;
    return t;
}

void feep()
{				/**/
    if (unset(NOBEEP))
	write(2, "\07", 1);
}

void freearray(s)		/**/
char **s;
{
    char **t = s;

    while (*s)
	zsfree(*s++);
    free(t);
}

int equalsplit(s, t)		/**/
char *s;
char **t;
{
    for (; *s && *s != '='; s++);
    if (*s == '=') {
	*s++ = '\0';
	*t = s;
	return 1;
    }
    return 0;
}

/* see if the right side of a list is trivial */

void simplifyright(l)		/**/
List l;
{
    Cmd c;

    if (l == &dummy_list || !l->right)
	return;
    if (l->right->right || l->right->left->right ||
	l->right->left->flags || l->right->left->left->right ||
	l->left->flags)
	return;
    c = l->left->left->left;
    if (c->type != SIMPLE || full(c->args) || full(c->redir)
	|| full(c->vars))
	return;
    l->right = NULL;
    return;
}

/* initialize the ztypes table */

void inittyptab()
{				/**/
    int t0;
    char *s;

    for (t0 = 0; t0 != 256; t0++)
	typtab[t0] = 0;
    for (t0 = 0; t0 != 32; t0++)
	typtab[t0] = typtab[t0 + 128] = ICNTRL;
    typtab[127] = ICNTRL;
    for (t0 = '0'; t0 <= '9'; t0++)
	typtab[t0] = IDIGIT | IALNUM | IWORD | IIDENT | IUSER;
    for (t0 = 'a'; t0 <= 'z'; t0++)
	typtab[t0] = typtab[t0 - 'a' + 'A'] = IALPHA | IALNUM | IIDENT | IUSER | IWORD;
    for (t0 = 0240; t0 != 0400; t0++)
	typtab[t0] = IALPHA | IALNUM | IIDENT | IUSER | IWORD;
    typtab['_'] = IIDENT | IUSER;
    typtab['-'] = IUSER;
    typtab[' '] |= IBLANK | INBLANK;
    typtab['\t'] |= IBLANK | INBLANK;
    typtab['\n'] |= INBLANK;
    for (t0 = (int)STOUC(ALPOP); t0 <= (int)STOUC(Nularg);
	 t0++)
	typtab[t0] |= ITOK;
    for (s = ifs; *s; s++)
	typtab[(int)(unsigned char)*s] |= ISEP;
    for (s = wordchars; *s; s++)
	typtab[(int)(unsigned char)*s] |= IWORD;
    for (s = SPECCHARS; *s; s++)
	typtab[(int)(unsigned char)*s] |= ISPECIAL;
}

char **arrdup(s)		/**/
char **s;
{
    char **x, **y;

    y = x = (char **)ncalloc(sizeof(char *) * (arrlen(s) + 1));

    while ((*x++ = dupstring(*s++)));
    return y;
}

/* next few functions stolen (with changes) from Kernighan & Pike */
/* "The UNIX Programming Environment" (w/o permission) */

char *spname(oldname)		/**/
char *oldname;
{
    char *p, spnameguess[MAXPATHLEN + 1], spnamebest[MAXPATHLEN + 1];
    static char newname[MAXPATHLEN + 1];
    char *new = newname, *old;

    if (itok(*oldname)) {
	singsub(&oldname);
	if (!oldname)
	    return NULL;
    }
    if (access(oldname, F_OK) == 0)
	return NULL;
    old = oldname;
    for (;;) {
	while (*old == '/')
	    *new++ = *old++;
	*new = '\0';
	if (*old == '\0')
	    return newname;
	p = spnameguess;
	for (; *old != '/' && *old != '\0'; old++)
	    if (p < spnameguess + MAXPATHLEN)
		*p++ = *old;
	*p = '\0';
	if (mindist(newname, spnameguess, spnamebest) >= 3)
	    return NULL;
	for (p = spnamebest; (*new = *p++);)
	    new++;
    }
}

int mindist(dir, mindistguess, mindistbest)	/**/
char *dir;
char *mindistguess;
char *mindistbest;
{
    int mindistd, nd;
    DIR *dd;
    struct dirent *de;
    char buf[MAXPATHLEN];

    if (dir[0] == '\0')
	dir = ".";
    mindistd = 100;
    sprintf(buf, "%s/%s", dir, mindistguess);
    if (access(buf, F_OK) == 0) {
	strcpy(mindistbest, mindistguess);
	return 0;
    }
    if (!(dd = opendir(dir)))
	return mindistd;
    while ((de = readdir(dd))) {
	nd = spdist(de->d_name, mindistguess,
		    (int)strlen(mindistguess) / 4 + 1);
	if (nd <= mindistd) {
	    strcpy(mindistbest, de->d_name);
	    mindistd = nd;
	    if (mindistd == 0)
		break;
	}
    }
    closedir(dd);
    return mindistd;
}

int spdist(s, t, thresh)	/**/
char *s;
char *t;
int thresh;
{
    char *p, *q;
    char *keymap =
    "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\
\t1234567890-=\t\
\tqwertyuiop[]\t\
\tasdfghjkl;'\n\t\
\tzxcvbnm,./\t\t\t\
\n\n\n\n\n\n\n\n\n\n\n\n\n\n\
\t!@#$%^&*()_+\t\
\tQWERTYUIOP{}\t\
\tASDFGHJKL:\"\n\t\
\tZXCVBNM<>?\n\n\t\
\n\n\n\n\n\n\n\n\n\n\n\n\n\n";

    if (!strcmp(s, t))
	return 0;
/* any number of upper/lower mistakes allowed (dist = 1) */
    for (p = s, q = t; *p && tulower(*p) == tulower(*q); p++, q++);
    if (!*p && !*q)
	return 1;
    if (!thresh)
	return 200;
    for (p = s, q = t; *p && *q; p++, q++)
	if (*p == *q)
	    continue;		/* don't consider "aa" transposed, ash */
	else if (p[1] == q[0] && q[1] == p[0])	/* transpositions */
	    return spdist(p + 2, q + 2, thresh - 1) + 1;
	else if (p[1] == q[0])	/* missing letter */
	    return spdist(p + 1, q + 0, thresh - 1) + 2;
	else if (p[0] == q[1])	/* missing letter */
	    return spdist(p + 0, q + 1, thresh - 1) + 2;
	else if (*p != *q)
	    break;
    if ((!*p && strlen(q) == 1) || (!*q && strlen(p) == 1))
	return 2;
    for (p = s, q = t; *p && *q; p++, q++)
	if (p[0] != q[0] && p[1] == q[1]) {
	    int t0;
	    char *z;

	/* mistyped letter */

	    if (!(z = strchr(keymap, p[0])) || *z == '\n' || *z == '\t')
		return spdist(p + 1, q + 1, thresh - 1) + 1;
	    t0 = z - keymap;
	    if (*q == keymap[t0 - 15] || *q == keymap[t0 - 14] ||
		*q == keymap[t0 - 13] ||
		*q == keymap[t0 - 1] || *q == keymap[t0 + 1] ||
		*q == keymap[t0 + 13] || *q == keymap[t0 + 14] ||
		*q == keymap[t0 + 15])
		return spdist(p + 1, q + 1, thresh - 1) + 2;
	    return 200;
	} else if (*p != *q)
	    break;
    return 200;
}

char *zgetenv(s)		/**/
char *s;
{
    char **av, *p, *q;

    for (av = environ; *av; av++) {
	for (p = *av, q = s; *p && *p != '=' && *q && *p == *q; p++, q++);
	if (*p == '=' && !*q)
	    return p + 1;
    }
    return NULL;
}

int tulower(c)			/**/
int c;
{
    c &= 0xff;
    return (isupper(c) ? tolower(c) : c);
}

int tuupper(c)			/**/
int c;
{
    c &= 0xff;
    return (islower(c) ? toupper(c) : c);
}

#ifdef SYSV
#include <sys/utsname.h>

int gethostname(nameptr, maxlength)
char *nameptr;
int maxlength;
{
    struct utsname name;
    int result;

    result = uname(&name);
    if (result >= 0) {
	strncpy(nameptr, name.nodename, maxlength);
	return 0;
    } else
	return -1;
}

#endif

/* set cbreak mode, or the equivalent */

void setcbreak()
{				/**/
    struct ttyinfo ti;

    ti = shttyinfo;
#ifdef HAS_TIO
    ti.tio.c_lflag &= ~ICANON;
    ti.tio.c_cc[VMIN] = 1;
    ti.tio.c_cc[VTIME] = 0;
#else
    ti.sgttyb.sg_flags |= CBREAK;
#endif
    settyinfo(&ti);
}

/* give the tty to some process */

void attachtty(pgrp)		/**/
long pgrp;
{
    static int ep = 0;

    if (jobbing) {
#ifdef HAS_TCSETPGRP
	if (SHTTY != -1 && tcsetpgrp(SHTTY, pgrp) == -1 && !ep)
#else
#if ardent
	if (SHTTY != -1 && setpgrp() == -1 && !ep)
#else
	int arg = pgrp;

	if (SHTTY != -1 && ioctl(SHTTY, TIOCSPGRP, &arg) == -1 && !ep)
#endif
#endif
	{
	    zerr("can't set tty pgrp: %e", NULL, errno);
	    fflush(stderr);
	    opts[MONITOR] = OPT_UNSET;
	    ep = 1;
	    errflag = 0;
	}
    }
}

/* get the tty pgrp */

long gettygrp()
{				/**/
    int arg;

    if (SHTTY == -1)
	return -1;
#ifdef HAS_TCSETPGRP
    arg = tcgetpgrp(SHTTY);
#else
#if ardent
    arg = getpgrp();
#else
    ioctl(SHTTY, TIOCGPGRP, &arg);
#endif
#endif
    return arg;
}

#if defined(SCO)
void gettimeofday(struct timeval *tv, struct timezone *tz)
{
    tv->tv_usec = 0;
    tv->tv_sec = (long)time((time_t) 0);
}
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
/*
 *
 * watch.c - login/logout watching
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "zsh.h"

static int wtabsz;
struct utmp *wtab;
static time_t lastutmpcheck;

/* get the time of login/logout for WATCH */

time_t getlogtime(u, inout)	/**/
struct utmp *u;
int inout;
{
    FILE *in;
    struct utmp uu;
    int first = 1;
    int srchlimit = 50;		/* max number of wtmp records to search */

    if (inout)
	return u->ut_time;
    if (!(in = fopen(WTMP_FILE, "r")))
	return time(NULL);
    fseek(in, 0, 2);
    do {
	if (fseek(in, ((first) ? -1 : -2) * sizeof(struct utmp), 1)) {
	    fclose(in);
	    return time(NULL);
	}
	first = 0;
	if (!fread(&uu, sizeof(struct utmp), 1, in)) {
	    fclose(in);
	    return time(NULL);
	}
	if (uu.ut_time < lastwatch || !srchlimit--) {
	    fclose(in);
	    return time(NULL);
	}
    }
    while (memcmp(&uu, u, sizeof(uu)));

    do
	if (!fread(&uu, sizeof(struct utmp), 1, in)) {
	    fclose(in);
	    return time(NULL);
	}
    while (strncmp(uu.ut_line, u->ut_line, sizeof(u->ut_line)));
    fclose(in);
    return uu.ut_time;
}

/* Mutually recursive call to handle ternaries in watchfmt */

#define BEGIN3	'('
#define END3	')'

char *watch3ary(inout, u, fmt, prnt)	/**/
int inout;
struct utmp *u;
char *fmt;
int prnt;
{
    int truth = 1, sep;

    switch (*fmt++) {
    case 'n':
	truth = (u->ut_name[0] != 0);
	break;
    case 'a':
	truth = inout;
	break;
    case 'l':
	if (!strncmp(u->ut_line, "tty", 3))
	    truth = (u->ut_line[3] != 0);
	else
	    truth = (u->ut_line[0] != 0);
	break;
#ifdef UTMP_HOST
    case 'm':
    case 'M':
	truth = (u->ut_host[0] != 0);
	break;
#endif
    default:
	prnt = 0;		/* Skip unknown conditionals entirely */
	break;
    }
    sep = *fmt++;
    fmt = watchlog2(inout, u, fmt, (truth && prnt), sep);
    return watchlog2(inout, u, fmt, (!truth && prnt), END3);
}

/* print a login/logout event */

char *watchlog2(inout, u, fmt, prnt, fini)	/**/
int inout;
struct utmp *u;
char *fmt;
int prnt;
int fini;
{
    char *p, buf[40], *bf;
    int i;
    time_t timet;
    struct tm *tm;
    char *fm2;

    while (*fmt)
	if (*fmt == '\\')
	    if (*++fmt) {
		if (prnt)
		    putchar(*fmt);
		++fmt;
	    } else if (fini)
		return fmt;
	    else
		break;
	else if (*fmt == fini)
	    return ++fmt;
	else if (*fmt != '%') {
	    if (prnt)
		putchar(*fmt);
	    ++fmt;
	} else {
	    if (*++fmt == BEGIN3)
		fmt = watch3ary(inout, u, ++fmt, prnt);
	    else if (!prnt)
		++fmt;
	    else
		switch (*(fm2 = fmt++)) {
		case 'n':
		    printf("%.*s", (int)sizeof(u->ut_name), u->ut_name);
		    break;
		case 'a':
		    printf("%s", (!inout) ? "logged off" : "logged on");
		    break;
		case 'l':
		    if (!strncmp(u->ut_line, "tty", 3))
			printf("%.*s", (int)sizeof(u->ut_line) - 3, u->ut_line + 3);
		    else
			printf("%.*s", (int)sizeof(u->ut_line), u->ut_line);
		    break;
#ifdef UTMP_HOST
		case 'm':
		    for (p = u->ut_host, i = sizeof(u->ut_host); i && *p; i--, p++) {
			if (*p == '.' && !idigit(p[1]))
			    break;
			putchar(*p);
		    }
		    break;
		case 'M':
		    printf("%.*s", (int)sizeof(u->ut_host), u->ut_host);
		    break;
#endif
		case 'T':
		case 't':
		case '@':
		case 'W':
		case 'w':
		case 'D':
		    switch (*fm2) {
		    case '@':
		    case 't':
			fm2 = "%l:%M%p";
			break;
		    case 'T':
			fm2 = "%k:%M";
			break;
		    case 'w':
			fm2 = "%a %e";
			break;
		    case 'W':
			fm2 = "%m/%d/%y";
			break;
		    case 'D':
			fm2 = "%y-%m-%d";
			break;
		    }
		    timet = getlogtime(u, inout);
		    tm = localtime(&timet);
		    ztrftime(buf, 40, fm2, tm);
		    printf("%s", (*buf == ' ') ? buf + 1 : buf);
		    break;
		case '%':
		    putchar('%');
		    break;
		case 'S':
		case 's':
		case 'B':
		case 'b':
		case 'U':
		case 'u':
		    switch (*fm2) {
		    case 'S':
			fm2 = "so";
			break;
		    case 's':
			fm2 = "se";
			break;
		    case 'B':
			fm2 = "md";
			break;
		    case 'b':
			fm2 = "me";
			break;
		    case 'U':
			fm2 = "us";
			break;
		    case 'u':
			fm2 = "ue";
			break;
		    }
		    bf = buf;
		    if (tgetstr(fm2, &bf))
			tputs(buf, 1, putraw);
		    break;
		default:
		    putchar('%');
		    putchar(*fm2);
		    break;
		}
	}
    if (prnt)
	putchar('\n');

    return fmt;
}

/* check the List for login/logouts */

void watchlog(inout, u, w, fmt)	/**/
int inout;
struct utmp *u;
char **w;
char *fmt;
{
    char *v, *vv, sav;
    int bad;

    if (*w && !strcmp(*w, "all")) {
	(void)watchlog2(inout, u, fmt, 1, 0);
	return;
    }
    if (*w && !strcmp(*w, "notme") &&
	strncmp(u->ut_name, username, sizeof(u->ut_name))) {
	(void)watchlog2(inout, u, fmt, 1, 0);
	return;
    }
    for (; *w; w++) {
	bad = 0;
	v = *w;
	if (*v != '@' && *v != '%') {
	    for (vv = v; *vv && *vv != '@' && *vv != '%'; vv++);
	    sav = *vv;
	    *vv = '\0';
	    if (strncmp(u->ut_name, v, sizeof(u->ut_name)))
		bad = 1;
	    *vv = sav;
	    v = vv;
	}
	for (;;)
	    if (*v == '%') {
		for (vv = ++v; *vv && *vv != '@'; vv++);
		sav = *vv;
		*vv = '\0';
		if (strncmp(u->ut_line, v, sizeof(u->ut_line)))
		    bad = 1;
		*vv = sav;
		v = vv;
	    }
#ifdef UTMP_HOST
	    else if (*v == '@') {
		for (vv = ++v; *vv && *vv != '%'; vv++);
		sav = *vv;
		*vv = '\0';
		if (strncmp(u->ut_host, v, strlen(v)))
		    bad = 1;
		*vv = sav;
		v = vv;
	    }
#endif
	    else
		break;
	if (!bad) {
	    (void)watchlog2(inout, u, fmt, 1, 0);
	    return;
	}
    }
}

/* compare 2 utmp entries */

int ucmp(u, v)			/**/
struct utmp *u;
struct utmp *v;
{
    if (u->ut_time == v->ut_time)
	return strncmp(u->ut_line, v->ut_line, sizeof(u->ut_line));
    return u->ut_time - v->ut_time;
}

/* initialize the user List */

void readwtab()
{				/**/
    struct utmp *uptr;
    int wtabmax = 32;
    FILE *in;

    wtabsz = 0;
    if (!(in = fopen(UTMP_FILE, "r")))
	return;
    uptr = wtab = (struct utmp *)zalloc(wtabmax * sizeof(struct utmp));
    while (fread(uptr, sizeof(struct utmp), 1, in))
#ifdef USER_PROCESS
	if   (uptr->ut_type == USER_PROCESS)
#else
	if   (uptr->ut_name[0])
#endif
	{
	    uptr++;
	    if (++wtabsz == wtabmax)
		uptr = (wtab = (struct utmp *)realloc((vptr) wtab, (wtabmax *= 2) *
						      sizeof(struct utmp))) + wtabsz;
	}
    fclose(in);

    if (wtabsz)
	qsort((vptr) wtab, wtabsz, sizeof(struct utmp),
	           (int (*)DCLPROTO((const void *, const void *)))ucmp);
}

/* check for login/logout events; executed before each prompt
	if WATCH is set */

void dowatch()
{				/**/
    char **s = watch;
    char *fmt = (watchfmt) ? watchfmt : DEFWATCHFMT;
    FILE *in;
    int utabsz = 0, utabmax = wtabsz + 4, uct, wct;
    struct utmp *utab, *uptr, *wptr;
    struct stat st;

    holdintr();
    if (!fmt)
	fmt = "%n has %a %l from %m.";
    if (!wtab) {
	readwtab();
	noholdintr();
	return;
    }
    if ((stat(UTMP_FILE, &st) == -1) || (st.st_mtime <= lastutmpcheck)) {
	noholdintr();
	return;
    }
    lastutmpcheck = st.st_mtime;
    uptr = utab = (struct utmp *)zalloc(utabmax * sizeof(struct utmp));

    if (!(in = fopen(UTMP_FILE, "r"))) {
	free(utab);
	noholdintr();
	return;
    }
    while (fread(uptr, sizeof *uptr, 1, in))
#ifdef USER_PROCESS
	if (uptr->ut_type == USER_PROCESS)
#else
	if (uptr->ut_name[0])
#endif
	{
	    uptr++;
	    if (++utabsz == utabmax)
		uptr = (utab = (struct utmp *)realloc((vptr) utab, (utabmax *= 2) *
						      sizeof(struct utmp))) + utabsz;
	}
    fclose(in);
    noholdintr();
    if (errflag) {
	free(utab);
	return;
    }
    if (utabsz)
	qsort((vptr) utab, utabsz, sizeof(struct utmp),
	           (int (*)DCLPROTO((const void *, const void *)))ucmp);

    wct =/*
 *
 * zle.h - header file for line editor
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#ifdef ZLEGLOBALS
#define ZLEXTERN
#else
#define ZLEXTERN extern
#endif

#ifdef ZLE

/* cursor position */
ZLEXTERN int cs;

/* line length */
ZLEXTERN int ll;

/* size of line buffer */
ZLEXTERN int linesz;

/* location of mark */
ZLEXTERN int mark;

/* last character pressed */
ZLEXTERN int c;

/* the z_ binding id for this key */
ZLEXTERN int bindk;

/* command argument */
ZLEXTERN int mult;

/* insert mode/overwrite mode flag */
ZLEXTERN int insmode;

/* cost of last update */
#ifdef HAS_SELECT
ZLEXTERN int cost;

#endif

/* number of lines displayed */
ZLEXTERN int nlnct;

/* flags associated with last command */
ZLEXTERN int lastcmd;

/* column position before last LINEMOVE movement */
ZLEXTERN int lastcol;

/* != 0 if we're getting a vi range */
ZLEXTERN int virangeflag;

/* kludge to get cw and dw to work right */
ZLEXTERN int wordflag;

#endif

/* last named command done */
ZLEXTERN int lastnamed;

/* != 0 if we're done editing */
ZLEXTERN int done;

/* length of prompt, rprompt on screen */
ZLEXTERN int pptlen, ppt2len;

/* current history line number */
ZLEXTERN int histline;

/* != 0 if we need to call resetvideo() */
ZLEXTERN int resetneeded;

/* != 0 if the line editor is active */
ZLEXTERN int zleactive;

/* the line buffer */
ZLEXTERN unsigned char *line;

/* the cut buffer */
ZLEXTERN char *cutbuf;

/* prompt and rprompt */
ZLEXTERN char *pmpt, *pmpt2;

/* the last line in the history (the current one) */
ZLEXTERN char *curhistline;

/* the status line */
ZLEXTERN char *statusline;

/* !=0 if a complete added a suffix at the end of a completion */
ZLEXTERN int addedsuffix;

/* 1 if we expect special keys after completing a parameter name */
ZLEXTERN int complexpect;

/*
	the current history line and cursor position for the top line
	on the buffer stack
*/

ZLEXTERN int stackhist, stackcs;

/* != 0 if we are in the middle of a menu completion */
ZLEXTERN int menucmp;

/* != 0 if we are making undo records */
ZLEXTERN int undoing;

/* != 0 if executing a shell function called from zle */
ZLEXTERN int inzlefunc;

/* last vi change buffer */
ZLEXTERN int vichgbufsz, vichgbufptr, vichgflag;
ZLEXTERN char *vichgbuf;

ZLEXTERN int viinsbegin;

typedef void bindfunc DCLPROTO((void));
typedef bindfunc *F;

struct key {
    struct hashnode *next;
    char *nam;			/* hash data */
    int func;			/* function code for this key */
    char *str;			/* string corresponding to this key,
			   if func = z_sendstring */
    int len;			/* length of string */
    int prefixct;		/* number of strings for which this is a prefix */
};

struct zlecmd {
    char *name;			/* name of function */
    F func;			/* handler function */
    int flags;
};

/* undo event */

struct undoent {
    int pref;			/* number of initial chars unchanged */
    int suff;			/* number of trailing chars unchanged */
    int len;			/* length of changed chars */
    int cs;			/* cursor pos before change */
    char *change;		/* NOT null terminated */
};

#define UNDOCT 64

ZLEXTERN struct undoent undos[UNDOCT];

/* the line before last mod (for undo purposes) */
ZLEXTERN unsigned char *lastline;

/* buffer specified with "x */
ZLEXTERN int vibufspec;

ZLEXTERN int undoct, lastcs;

ZLEXTERN char *visrchstr;
ZLEXTERN int visrchsense;

#define ZLE_MOVEMENT  	 1
#define ZLE_MENUCMP  	 2
#define ZLE_UNDO      	 4
#define ZLE_YANK     	 8
#define ZLE_LINEMOVE 	 16
#define ZLE_ARG      	 32
#define ZLE_NAMEDBUFFER 128
#define ZLE_KILL        (64|ZLE_NAMEDBUFFER)
#define ZLE_HISTSEARCH  256
#define ZLE_NEGARG      512
#define ZLE_INSERT     1024
#define ZLE_DELETE     2048

typedef struct key *Key;

ZLEXTERN int *bindtab, *mainbindtab;
extern int emacsbind[], viinsbind[], vicmdbind[];
ZLEXTERN int altbindtab[256];

#define KRINGCT 8
ZLEXTERN char *kring[KRINGCT];
ZLEXTERN int kringnum;
ZLEXTERN char *vibuf[36];

#define z_acceptandhold 0
#define z_acceptandinfernexthistory 1
#define z_acceptandmenucomplete 2
#define z_acceptline 3
#define z_acceptlineanddownhistory 4
#define z_backwardchar 5
#define z_backwarddeletechar 6
#define z_backwarddeleteword 7
#define z_backwardkillline 8
#define z_backwardkillword 9
#define z_backwardword 10
#define z_beginningofbufferorhistory 11
#define z_beginningofhistory 12
#define z_beginningofline 13
#define z_beginningoflinehist 14
#define z_capitalizeword 15
#define z_clearscreen 16
#define z_completeword 17
#define z_copyprevword 18
#define z_copyregionaskill 19
#define z_deletechar 20
#define z_deletecharorlist 21
#define z_deleteword 22
#define z_digitargument 23
#define z_downcaseword 24
#define z_downhistory 25
#define z_downlineorhistory 26
#define z_endofbufferorhistory 27
#define z_endofhistory 28
#define z_endofline 29
#define z_endoflinehist 30
#define z_exchangepointandmark 31
#define z_executelastnamedcmd 32
#define z_executenamedcmd 33
#define z_expandhistory 34
#define z_expandorcomplete 35
#define z_expandword 36
#define z_forwardchar 37
#define z_forwardword 38
#define z_getline 39
#define z_gosmacstransposechars 40
#define z_historyincrementalsearchbackward 41
#define z_historyincrementalsearchforward 42
#define z_historysearchbackward 43
#define z_historysearchforward 44
#define z_infernexthistory 45
#define z_insertlastword 46
#define z_killbuffer 47
#define z_killline 48
#define z_killregion 49
#define z_killwholeline 50
#define z_listchoices 51
#define z_listexpand 52
#define z_magicspace 53
#define z_menucompleteword 54
#define z_menuexpandorcomplete 55
#define z_overwritemode 56
#define z_pushline 57
#define z_quotedinsert 58
#define z_quoteline 59
#define z_quoteregion 60
#define z_redisplay 61
#define z_reversemenucomplete 62
#define z_runhelp 63
#define z_selfinsert 64
#define z_selfinsertunmeta 65
#define z_sendbreak 66
#define z_sendstring 67
#define z_sequenceleadin 68
#define z_setmarkcommand 69
#define z_spellword 70
#define z_toggleliteralhistory 71
#define z_transposechars 72
#define z_transposewords 73
#define z_undefinedkey 74
#define z_undo 75
#define z_universalargument 76
#define z_upcaseword 77
#define z_uphistory 78
#define z_uplineorhistory 79
#define z_viaddeol 80
#define z_viaddnext 81
#define z_vibackwardblankword 82
#define z_vibackwardchar 83
#define z_vibackwarddeletechar 84
#define z_vibeginningofline 85
#define z_vicapslockpanic 86
#define z_vichange 87
#define z_vichangeeol 88
#define z_vichangewholeline 89
#define z_vicmdmode 90
#define z_videlete 91
#define z_videletechar 92
#define z_vidigitorbeginningofline 93
#define z_viendofline 94
#define z_vifetchhistory 95
#define z_vifindnextchar 96
#define z_vifindnextcharskip 97
#define z_vifindprevchar 98
#define z_vifindprevcharskip 99
#define z_vifirstnonblank 100
#define z_viforwardblankword 101
#define z_viforwardblankwordend 102
#define z_viforwardchar 103
#define z_viforwardwordend 104
#define z_vigotocolumn 105
#define z_vigotomark 106
#define z_vigotomarkline 107
#define z_vihistorysearchbackward 108
#define z_vihistorysearchforward 109
#define z_viindent 110
#define z_viinsert 111
#define z_viinsertbol 112
#define z_vijoin 113
#define z_vimatchbracket 114
#define z_viopenlineabove 115
#define z_viopenlinebelow 116
#define z_vioperswapcases 117
#define z_viputafter 118
#define z_virepeatchange 119
#define z_virepeatfind 120
#define z_virepeatsearch 121
#define z_vireplace 122
#define z_vireplacechars 123
#define z_virevrepeatfind 124
#define z_virevrepeatsearch 125
#define z_visetbuffer 126
#define z_visetmark 127
#define z_visubstitute 128
#define z_viswapcase 129
#define z_viundochange 130
#define z_viunindent 131
#define z_viyank 132
#define z_viyankeol 133
#define z_whichcommand 134
#define z_yank 135
#define z_yankpop 136
#define z_emacsbackwardword 137
#define z_emacsforwardword 138
#define z_killword 139
#define z_vikillline 140
#define z_vibackwardkillword 141
#define z_expandcmdpath 142
#define z_negargument 143
#define z_poundinsert 144
#define z_viforwardword 145
#define z_vibackwardword 146
#define z_uplineorsearch 147
#define z_downlineorsearch 148
#define z_pushinput 149
#define z_pushpopinput 150
#define z_historybeginningsearchbackward 151
#define z_historybeginningsearchforward 152
#define z_expandorcompleteprefix 153
#define ZLECMDCOUNT 154

extern struct zlecmd zlecmds[];
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  z_acceptline,
    /* ^K */ z_killline,
    /* ^L */ z_clearscreen,
    /* ^M */ z_acceptline,
    /* ^N */ z_selfinsert,
    /* ^O */ z_selfinsert,
    /* ^P */ z_selfinsert,
    /* ^Q */ z_selfinsert,
    /* ^R */ z_redisplay,
    /* ^S */ z_selfinsert,
    /* ^T */ z_selfinsert,
    /* ^U */ z_vikillline,
    /* ^V */ z_quotedinsert,
    /* ^W */ z_vibackwardkillword,
    /* ^X */ z_selfinsert,
    /* ^Y */ z_selfinsert,
    /* ^Z */ z_selfinsert,
    /* ^[ */ z_sequenceleadin,
    /* ^\ */ z_selfinsert,
    /* ^] */ z_selfinsert,
    /* ^^ */ z_selfinsert,
    /* ^_ */ z_selfinsert,
};

int vicmdbind[128] =
{
    /* ^@ */ z_undefinedkey,
    /* ^A */ z_beginningofline,
    /* ^B */ z_undefinedkey,
    /* ^C */ z_undefinedkey,
    /* ^D */ z_listchoices,
    /* ^E */ z_endofline,
    /* ^F */ z_undefinedkey,
    /* ^G */ z_listexpand,
    /* ^H */ z_backwarddeletechar,
    /* ^I */ z_completeword,
    /* ^J */ z_acceptline,
    /* ^K */ z_killline,
    /* ^L */ z_clearscreen,
    /* ^M */ z_acceptline,
    /* ^N */ z_downhistory,
    /* ^O */ z_undefinedkey,
    /* ^P */ z_uphistory,
    /* ^Q */ z_undefinedkey,
    /* ^R */ z_redisplay,
    /* ^S */ z_undefinedkey,
    /* ^T */ z_undefinedkey,
    /* ^U */ z_killbuffer,
    /* ^V */ z_undefinedkey,
    /* ^W */ z_backwardkillword,
    /* ^X */ z_expandorcomplete,
    /* ^Y */ z_undefinedkey,
    /* ^Z */ z_undefinedkey,
    /* ^[ */ z_sequenceleadin,
    /* ^\ */ z_undefinedkey,
    /* ^] */ z_undefinedkey,
    /* ^^ */ z_undefinedkey,
    /* ^_ */ z_undefinedkey,
    /*   */ z_viforwardchar,
    /* ! */ z_undefinedkey,
    /* " */ z_visetbuffer,
    /* # */ z_poundinsert,
    /* $ */ z_viendofline,
    /* % */ z_vimatchbracket,
    /* & */ z_undefinedkey,
    /* ' */ z_vigotomarkline,
    /* ( */ z_undefinedkey,
    /* ) */ z_undefinedkey,
    /* * */ z_undefinedkey,
    /* + */ z_downlineorhistory,
    /* , */ z_virevrepeatfind,
    /* - */ z_uplineorhistory,
    /* . */ z_virepeatchange,
    /* / */ z_vihistorysearchbackward,
    /* 0 */ z_vidigitorbeginningofline,
    /* 1 */ z_digitargument,
    /* 2 */ z_digitargument,
    /* 3 */ z_digitargument,
    /* 4 */ z_digitargument,
    /* 5 */ z_digitargument,
    /* 6 */ z_digitargument,
    /* 7 */ z_digitargument,
    /* 8 */ z_digitargument,
    /* 9 */ z_digitargument,
    /* : */ z_undefinedkey,
    /* ; */ z_virepeatfind,
    /* < */ z_viunindent,
    /* = */ z_listchoices,
    /* > */ z_viindent,
    /* ? */ z_vihistorysearchforward,
    /* @ */ z_undefinedkey,
    /* A */ z_viaddeol,
    /* B */ z_vibackwardblankword,
    /* C */ z_vichangeeol,
    /* D */ z_killline,
    /* E */ z_viforwardblankwordend,
    /* F */ z_vifindprevchar,
    /* G */ z_vifetchhistory,
    /* H */ z_vicapslockpanic,
    /* I */ z_viinsertbol,
    /* J */ z_historysearchforward,
    /* K */ z_historysearchbackward,
    /* L */ z_undefinedkey,
    /* M */ z_undefinedkey,
    /* N */ z_virevrepeatsearch,
    /* O */ z_viopenlineabove,
    /* P */ z_yank,
    /* Q */ z_undefinedkey,
    /* R */ z_vireplace,
    /* S */ z_vichangewholeline,
    /* T */ z_vifindprevcharskip,
    /* U */ z_undefinedkey,
    /* V */ z_undefinedkey,
    /* W */ z_viforwardblankword,
    /* X */ z_vibackwarddeletechar,
    /* Y */ z_viyankeol,
    /* Z */ z_undefinedkey,
    /* [ */ z_undefinedkey,
    /* \ */ z_completeword,
    /* ] */ z_undefinedkey,
    /* ^ */ z_vifirstnonblank,
    /* _ */ z_undefinedkey,
    /* ` */ z_vigotomark,
    /* a */ z_viaddnext,
    /* b */ z_vibackwardword,
    /* c */ z_vichange,
    /* d */ z_videlete,
    /* e */ z_viforwardwordend,
    /* f */ z_vifindnextchar,
    /* g */ z_undefinedkey,
    /* h */ z_vibackwardchar,
    /* i */ z_viinsert,
    /* j */ z_downlineorhistory,
    /* k */ z_uplineorhistory,
    /* l */ z_viforwardchar,
    /* m */ z_visetmark,
    /* n */ z_virepeatsearch,
    /* o */ z_viopenlinebelow,
    /* p */ z_viputafter,
    /* q */ z_undefinedkey,
    /* r */ z_vireplacechars,
    /* s */ z_visubstitute,
    /* t */ z_vifindnextcharskip,
    /* u */ z_viundochange,
    /* v */ z_undefinedkey,
    /* w */ z_viforwardword,
    /* x */ z_videletechar,
    /* y */ z_viyank,
    /* z */ z_undefinedkey,
    /* { */ z_undefinedkey,
    /* | */ z_vigotocolumn,
    /* } */ z_undefinedkey,
    /* ~ */ z_viswapcase,
    /* ^? */ z_backwarddeletechar,
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
/*
 *
 * zle_bindings.c - commands and keymaps
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define ZLE
#include "zsh.h"

struct zlecmd zlecmds[] =
{
    {"accept-and-hold", acceptandhold, 0},
    {"accept-and-infer-next-history", acceptandinfernexthistory, 0},
    {"accept-and-menu-complete", acceptandmenucomplete, ZLE_MENUCMP},
    {"accept-line", acceptline, 0},
    {"accept-line-and-down-history", acceptlineanddownhistory, 0},
    {"backward-char", backwardchar, ZLE_MOVEMENT},
    {"backward-delete-char", backwarddeletechar, ZLE_DELETE},
    {"backward-delete-word", backwarddeleteword, ZLE_DELETE},
    {"backward-kill-line", backwardkillline, ZLE_KILL},
    {"backward-kill-word", backwardkillword, ZLE_KILL | ZLE_DELETE},
    {"backward-word", backwardword, ZLE_MOVEMENT},
    {"beginning-of-buffer-or-history", beginningofbufferorhistory, ZLE_MOVEMENT},
    {"beginning-of-history", beginningofhistory, 0},
    {"beginning-of-line", beginningofline, ZLE_MOVEMENT},
    {"beginning-of-line-hist", beginningoflinehist, ZLE_MOVEMENT},
    {"capitalize-word", capitalizeword, 0},
    {"clear-screen", clearscreen, 0},
    {"complete-word", completeword, ZLE_MENUCMP},
    {"copy-prev-word", copyprevword, 0},
    {"copy-region-as-kill", copyregionaskill, ZLE_KILL},
    {"delete-char", deletechar, ZLE_DELETE},
    {"delete-char-or-list", deletecharorlist, ZLE_MENUCMP},
    {"delete-word", deleteword, ZLE_DELETE},
    {"digit-argument", digitargument, ZLE_ARG},
    {"down-case-word", downcaseword, 0},
    {"down-history", downhistory, 0},
    {"down-line-or-history", downlineorhistory, ZLE_MOVEMENT | ZLE_LINEMOVE},
    {"end-of-buffer-or-history", endofbufferorhistory, ZLE_MOVEMENT},
    {"end-of-history", endofhistory, 0},
    {"end-of-line", endofline, ZLE_MOVEMENT},
    {"end-of-line-hist", endoflinehist, ZLE_MOVEMENT},
    {"exchange-point-and-mark", exchangepointandmark, ZLE_MOVEMENT},
    {"execute-last-named-cmd", (F) 0, 0},
    {"execute-named-cmd", (F) 0, 0},
    {"expand-history", expandhistory, 0},
    {"expand-or-complete", expandorcomplete, ZLE_MENUCMP},
    {"expand-word", expandword, 0},
    {"forward-char", forwardchar, ZLE_MOVEMENT},
    {"forward-word", forwardword, ZLE_MOVEMENT},
    {"get-line", getline, 0},
    {"gosmacs-transpose-chars", gosmacstransposechars, 0},
    {"history-incremental-search-backward", historyincrementalsearchbackward, 0},
    {"history-incremental-search-forward", historyincrementalsearchforward, 0},
    {"history-search-backward", historysearchbackward, ZLE_HISTSEARCH},
    {"history-search-forward", historysearchforward, ZLE_HISTSEARCH},
    {"infer-next-history", infernexthistory, 0},
    {"insert-last-word", insertlastword, ZLE_INSERT},
    {"kill-buffer", killbuffer, ZLE_KILL},
    {"kill-line", killline, ZLE_KILL},
    {"kill-region", killregion, ZLE_KILL},
    {"kill-whole-line", killwholeline, ZLE_KILL},
    {"list-choices", listchoices, ZLE_DELETE | ZLE_MENUCMP},	/* ZLE_DELETE fixes autoremoveslash */
    {"list-expand", listexpand, ZLE_MENUCMP},
    {"magic-space", magicspace, 0},
    {"menu-complete", menucompleteword, ZLE_MENUCMP},
    {"menu-expand-or-complete", menuexpandorcomplete, ZLE_MENUCMP},
    {"overwrite-mode", overwritemode, 0},
    {"push-line", pushline, 0},
    {"quoted-insert", quotedinsert, ZLE_INSERT},
    {"quote-line", quoteline, 0},
    {"quote-region", quoteregion, 0},
    {"redisplay", redisplay, 0},
    {"reverse-menu-complete", reversemenucomplete, ZLE_MENUCMP},
    {"run-help", processcmd, 0},
    {"self-insert", selfinsert, ZLE_INSERT},
    {"self-insert-unmeta", selfinsertunmeta, ZLE_INSERT},
    {"send-break", sendbreak, 0},
    {"send-string", sendstring, 0},
    {"prefix", (F) 0, 0},
    {"set-mark-command", setmarkcommand, 0},
    {"spell-word", spellword, 0},
    {"toggle-literal-history", toggleliteralhistory, 0},
    {"transpose-chars", transposechars, 0},
    {"transpose-words", transposewords, 0},
    {"undefined-key", undefinedkey, 0},
    {"undo", undo, ZLE_UNDO},
    {"universal-argument", universalargument, ZLE_ARG},
    {"up-case-word", upcaseword, 0},
    {"up-history", uphistory, 0},
    {"up-line-or-history", uplineorhistory, ZLE_LINEMOVE | ZLE_MOVEMENT},
    {"vi-add-eol", viaddeol, 0},
    {"vi-add-next", viaddnext, 0},
    {"vi-backward-blank-word", vibackwardblankword, ZLE_MOVEMENT},
    {"vi-backward-char", vibackwardchar, ZLE_MOVEMENT},
    {"vi-backward-delete-char", vibackwarddeletechar, ZLE_DELETE},
    {"vi-beginning-of-line", vibeginningofline, ZLE_MOVEMENT},
    {"vi-caps-lock-panic", vicapslockpanic, 0},
    {"vi-change", vichange, 0},
    {"vi-change-eol", vichangeeol, 0},
    {"vi-change-whole-line", vichangewholeline, 0},
    {"vi-cmd-mode", vicmdmode, 0},
    {"vi-delete", videlete, ZLE_KILL},
    {"vi-delete-char", videletechar, ZLE_DELETE},
    {"vi-digit-or-beginning-of-line", (F) 0, 0},
    {"vi-end-of-line", viendofline, ZLE_MOVEMENT},
    {"vi-fetch-history", vifetchhistory, 0},
    {"vi-find-next-char", vifindnextchar, ZLE_MOVEMENT},
    {"vi-find-next-char-skip", vifindnextcharskip, ZLE_MOVEMENT},
    {"vi-find-prev-char", vifindprevchar, ZLE_MOVEMENT},
    {"vi-find-prev-char-skip", vifindprevcharskip, ZLE_MOVEMENT},
    {"vi-first-non-blank", vifirstnonblank, ZLE_MOVEMENT},
    {"vi-forward-blank-word", viforwardblankword, ZLE_MOVEMENT},
    {"vi-forward-blank-word-end", viforwardblankwordend, ZLE_MOVEMENT},
    {"vi-forward-char", viforwardchar, ZLE_MOVEMENT},
    {"vi-forward-word-end", viforwardwordend, ZLE_MOVEMENT},
    {"vi-goto-column", vigotocolumn, ZLE_MOVEMENT},
    {"vi-goto-mark", vigotomark, ZLE_MOVEMENT},
    {"vi-goto-mark-line", vigotomarkline, ZLE_MOVEMENT},
    {"vi-history-search-backward", vihistorysearchbackward, 0},
    {"vi-history-search-forward", vihistorysearchforward, 0},
    {"vi-indent", viindent, 0},
    {"vi-insert", viinsert, 0},
    {"vi-insert-bol", viinsertbol, 0},
    {"vi-join", vijoin, 0},
    {"vi-match-bracket", vimatchbracket, ZLE_MOVEMENT},
    {"vi-open-line-above", viopenlineabove, 0},
    {"vi-open-line-below", viopenlinebelow, 0},
    {"vi-oper-swap-case", vioperswapcase, 0},
    {"vi-put-after", viputafter, ZLE_YANK},
    {"vi-repeat-change", virepeatchange, ZLE_ARG},
    {"vi-repeat-find", virepeatfind, ZLE_MOVEMENT},
    {"vi-repeat-search", virepeatsearch, ZLE_MOVEMENT},
    {"vi-replace", vireplace, 0},
    {"vi-replace-chars", vireplacechars, 0},
    {"vi-rev-repeat-find", virevrepeatfind, ZLE_MOVEMENT},
    {"vi-rev-repeat-search", virevrepeatsearch, ZLE_MOVEMENT},
    {"vi-set-buffer", visetbuffer, 0},
    {"vi-set-mark", visetmark, 0},
    {"vi-substitute", visubstitute, 0},
    {"vi-swap-case", viswapcase, 0},
    {"vi-undo-change", undo, 0},
    {"vi-unindent", viunindent, 0},
    {"vi-yank", viyank, 0},
    {"vi-yank-eol", viyankeol, 0},
    {"which-command", processcmd, 0},
    {"yank", yank, ZLE_YANK | ZLE_NAMEDBUFFER},
    {"yank-pop", yankpop, ZLE_YANK},
    {"emacs-backward-word", emacsbackwardword, ZLE_MOVEMENT},
    {"emacs-forward-word", emacsforwardword, ZLE_MOVEMENT},
    {"kill-word", killword, ZLE_KILL},
    {"vi-kill-line", vikillline, ZLE_KILL},
    {"vi-backward-kill-word", vibackwardkillword, ZLE_KILL},
    {"expand-cmd-path", expandcmdpath, 0},
    {"neg-argument", negargument, ZLE_NEGARG | ZLE_ARG},
    {"pound-insert", poundinsert, 0},
    {"vi-forward-word", viforwardword, ZLE_MOVEMENT},
    {"vi-backward-word", vibackwardword, ZLE_MOVEMENT},
    {"up-line-or-search", uplineorsearch, ZLE_MOVEMENT | ZLE_LINEMOVE | ZLE_HISTSEARCH},
    {"down-line-or-search", downlineorsearch, ZLE_MOVEMENT | ZLE_LINEMOVE | ZLE_HISTSEARCH},
    {"push-input", pushinput, 0},
    {"push-line-or-edit", pushpopinput, 0},
    {"history-beginning-search-backward", historybeginningsearchbackward, ZLE_HISTSEARCH},
    {"history-beginning-search-forward", historybeginningsearchforward, ZLE_HISTSEARCH},
    {"expand-or-complete-prefix", expandorcompleteprefix, ZLE_MENUCMP},
    {"", (F) 0, 0}
};

int emacsbind[256] =
{
    /* ^@ */ z_setmarkcommand,
    /* ^A */ z_beginningofline,
    /* ^B */ z_backwardchar,
    /* ^C */ z_undefinedkey,
    /* ^D */ z_deletecharorlist,
    /* ^E */ z_endofline,
    /* ^F */ z_forwardchar,
    /* ^G */ z_sendbreak,
    /* ^H */ z_backwarddeletechar,
    /* ^I */ z_expandorcomplete,
    /* ^J */ z_acceptline,
    /* ^K */ z_killline,
    /* ^L */ z_clearscreen,
    /* ^M */ z_acceptline,
    /* ^N */ z_downlineorhistory,
    /* ^O */ z_acceptlineanddownhistory,
    /* ^P */ z_uplineorhistory,
    /* ^Q */ z_pushline,
    /* ^R */ z_historyincrementalsearchbackward,
    /* ^S */ z_historyincrementalsearchforward,
    /* ^T */ z_transposechars,
    /* ^U */ z_killwholeline,
    /* ^V */ z_quotedinsert,
    /* ^W */ z_backwardkillword,
    /* ^X */ z_sequenceleadin,
    /* ^Y */ z_yank,
    /* ^Z */ z_undefinedkey,
    /* ^[ */ z_sequenceleadin,
    /* ^\ */ z_undefinedkey,
    /* ^] */ z_undefinedkey,
    /* ^^ */ z_undefinedkey,
    /* ^_ */ z_undo,
    /*   */ z_selfinsert,
    /* ! */ z_selfinsert,
    /* " */ z_selfinsert,
    /* # */ z_selfinsert,
    /* $ */ z_selfinsert,
    /* % */ z_selfinsert,
    /* & */ z_selfinsert,
    /* ' */ z_selfinsert,
    /* ( */ z_selfinsert,
    /* ) */ z_selfinsert,
    /* * */ z_selfinsert,
    /* + */ z_selfinsert,
    /* , */ z_selfinsert,
    /* - */ z_selfinsert,
    /* . */ z_selfinsert,
    /* / */ z_selfinsert,
    /* 0 */ z_selfinsert,
    /* 1 */ z_selfinsert,
    /* 2 */ z_selfinsert,
    /* 3 */ z_selfinsert,
    /* 4 */ z_selfinsert,
    /* 5 */ z_selfinsert,
    /* 6 */ z_selfinsert,
    /* 7 */ z_selfinsert,
    /* 8 */ z_selfinsert,
    /* 9 */ z_selfinsert,
    /* : */ z_selfinsert,
    /* ; */ z_selfinsert,
    /* < */ z_selfinsert,
    /* = */ z_selfinsert,
    /* > */ z_selfinsert,
    /* ? */ z_selfinsert,
    /* @ */ z_selfinsert,
    /* A */ z_selfinsert,
    /* B */ z_selfinsert,
    /* C */ z_selfinsert,
    /* D */ z_selfinsert,
    /* E */ z_selfinsert,
    /* F */ z_selfinsert,
    /* G */ z_selfinsert,
    /* H */ z_selfinsert,
    /* I */ z_selfinsert,
    /* J */ z_selfinsert,
    /* K */ z_selfinsert,
    /* L */ z_selfinsert,
    /* M */ z_selfinsert,
    /* N */ z_selfinsert,
    /* O */ z_selfinsert,
    /* P */ z_selfinsert,
    /* Q */ z_selfinsert,
    /* R */ z_selfinsert,
    /* S */ z_selfinsert,
    /* T */ z_selfinsert,
    /* U */ z_selfinsert,
    /* V */ z_selfinsert,
    /* W */ z_selfinsert,
    /* X */ z_selfinsert,
    /* Y */ z_selfinsert,
    /* Z */ z_selfinsert,
    /* [ */ z_selfinsert,
    /* \ */ z_selfinsert,
    /* ] */ z_selfinsert,
    /* ^ */ z_selfinsert,
    /* _ */ z_selfinsert,
    /* ` */ z_selfinsert,
    /* a */ z_selfinsert,
    /* b */ z_selfinsert,
    /* c */ z_selfinsert,
    /* d */ z_selfinsert,
    /* e */ z_selfinsert,
    /* f */ z_selfinsert,
    /* g */ z_selfinsert,
    /* h */ z_selfinsert,
    /* i */ z_selfinsert,
    /* j */ z_selfinsert,
    /* k */ z_selfinsert,
    /* l */ z_selfinsert,
    /* m */ z_selfinsert,
    /* n */ z_selfinsert,
    /* o */ z_selfinsert,
    /* p */ z_selfinsert,
    /* q */ z_selfinsert,
    /* r */ z_selfinsert,
    /* s */ z_selfinsert,
    /* t */ z_selfinsert,
    /* u */ z_selfinsert,
    /* v */ z_selfinsert,
    /* w */ z_selfinsert,
    /* x */ z_selfinsert,
    /* y */ z_selfinsert,
    /* z */ z_selfinsert,
    /* { */ z_selfinsert,
    /* | */ z_selfinsert,
    /* } */ z_selfinsert,
    /* ~ */ z_selfinsert,
    /* ^? */ z_backwarddeletechar,
    /* M-^@ */ z_undefinedkey,
    /* M-^A */ z_undefinedkey,
    /* M-^B */ z_undefinedkey,
    /* M-^C */ z_undefinedkey,
    /* M-^D */ z_listchoices,
    /* M-^E */ z_undefinedkey,
    /* M-^F */ z_undefinedkey,
    /* M-^G */ z_sendbreak,
    /* M-^H */ z_backwardkillword,
    /* M-^I */ z_selfinsertunmeta,
    /* M-^J */ z_selfinsertunmeta,
    /* M-^K */ z_undefinedkey,
    /* M-^L */ z_clearscreen,
    /* M-^M */ z_selfinsertunmeta,
    /* M-^N */ z_undefinedkey,
    /* M-^O */ z_undefinedkey,
    /* M-^P */ z_undefinedkey,
    /* M-^Q */ z_undefinedkey,
    /* M-^R */ z_undefinedkey,
    /* M-^S */ z_undefinedkey,
    /* M-^T */ z_undefinedkey,
    /* M-^U */ z_undefinedkey,
    /* M-^V */ z_undefinedkey,
    /* M-^W */ z_undefinedkey,
    /* M-^X */ z_undefinedkey,
    /* M-^Y */ z_undefinedkey,
    /* M-^Z */ z_undefinedkey,
    /* M-^[ */ z_undefinedkey,
    /* M-^\ */ z_undefinedkey,
    /* M-^] */ z_undefinedkey,
    /* M-^^ */ z_undefinedkey,
    /* M-^_ */ z_copyprevword,
    /* M-  */ z_expandhistory,
    /* M-! */ z_expandhistory,
    /* M-" */ z_quoteregion,
    /* M-# */ z_undefinedkey,
    /* M-$ */ z_spellword,
    /* M-% */ z_undefinedkey,
    /* M-& */ z_undefinedkey,
    /* M-' */ z_quoteline,
    /* M-( */ z_undefinedkey,
    /* M-) */ z_undefinedkey,
    /* M-* */ z_undefinedkey,
    /* M-+ */ z_undefinedkey,
    /* M-, */ z_undefinedkey,
    /* M-- */ z_negargument,
    /* M-. */ z_insertlastword,
    /* M-/ */ z_undefinedkey,
    /* M-0 */ z_digitargument,
    /* M-1 */ z_digitargument,
    /* M-2 */ z_digitargument,
    /* M-3 */ z_digitargument,
    /* M-4 */ z_digitargument,
    /* M-5 */ z_digitargument,
    /* M-6 */ z_digitargument,
    /* M-7 */ z_digitargument,
    /* M-8 */ z_digitargument,
    /* M-9 */ z_digitargument,
    /* M-: */ z_undefinedkey,
    /* M-; */ z_undefinedkey,
    /* M-< */ z_beginningofbufferorhistory,
    /* M-= */ z_undefinedkey,
    /* M-> */ z_endofbufferorhistory,
    /* M-? */ z_whichcommand,
    /* M-@ */ z_undefinedkey,
    /* M-A */ z_acceptandhold,
    /* M-B */ z_backwardword,
    /* M-C */ z_capitalizeword,
    /* M-D */ z_killword,
    /* M-E */ z_undefinedkey,
    /* M-F */ z_forwardword,
    /* M-G */ z_getline,
    /* M-H */ z_runhelp,
    /* M-I */ z_undefinedkey,
    /* M-J */ z_undefinedkey,
    /* M-K */ z_undefinedkey,
    /* M-L */ z_downcaseword,
    /* M-M */ z_undefinedkey,
    /* M-N */ z_historysearchforward,
    /* M-O */ z_undefinedkey,
    /* M-P */ z_historysearchbackward,
    /* M-Q */ z_pushline,
    /* M-R */ z_toggleliteralhistory,
    /* M-S */ z_spellword,
    /* M-T */ z_transposewords,
    /* M-U */ z_upcaseword,
    /* M-V */ z_undefinedkey,
    /* M-W */ z_copyregionaskill,
    /* M-X */ z_undefinedkey,
    /* M-Y */ z_undefinedkey,
    /* M-Z */ z_undefinedkey,
    /* M-[ */ z_undefinedkey,
    /* M-\ */ z_undefinedkey,
    /* M-] */ z_undefinedkey,
    /* M-^ */ z_undefinedkey,
    /* M-_ */ z_insertlastword,
    /* M-` */ z_undefinedkey,
    /* M-a */ z_acceptandhold,
    /* M-b */ z_backwardword,
    /* M-c */ z_capitalizeword,
    /* M-d */ z_killword,
    /* M-e */ z_undefinedkey,
    /* M-f */ z_forwardword,
    /* M-g */ z_getline,
    /* M-h */ z_runhelp,
    /* M-i */ z_undefinedkey,
    /* M-j */ z_undefinedkey,
    /* M-k */ z_undefinedkey,
    /* M-l */ z_downcaseword,
    /* M-m */ z_undefinedkey,
    /* M-n */ z_historysearchforward,
    /* M-o */ z_undefinedkey,
    /* M-p */ z_historysearchbackward,
    /* M-q */ z_pushline,
    /* M-r */ z_toggleliteralhistory,
    /* M-s */ z_spellword,
    /* M-t */ z_transposewords,
    /* M-u */ z_upcaseword,
    /* M-v */ z_undefinedkey,
    /* M-w */ z_copyregionaskill,
    /* M-x */ z_executenamedcmd,
    /* M-y */ z_yankpop,
    /* M-z */ z_executelastnamedcmd,
    /* M-{ */ z_undefinedkey,
    /* M-| */ z_vigotocolumn,
    /* M-} */ z_undefinedkey,
    /* M-~ */ z_undefinedkey,
    /* M-^? */ z_backwardkillword,
};

int viinsbind[32] =
{
    /* ^@ */ z_undefinedkey,
    /* ^A */ z_selfinsert,
    /* ^B */ z_selfinsert,
    /* ^C */ z_undefinedkey,
    /* ^D */ z_listchoices,
    /* ^E */ z_selfinsert,
    /* ^F */ z_selfinsert,
    /* ^G */ z_selfinsert,
    /* ^H */ z_vibackwarddeletechar,
    /* ^I */ z_expandorcomplete,
    /* ^J *//*
 *
 * zle_hist.c - history editing
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define ZLE
#include "zsh.h"

void toggleliteralhistory()
{				/**/
    char *s;

    if (histline == curhist) {
	zsfree(curhistline);
	curhistline = ztrdup(UTOSCP(line));
    }
    lithist ^= 1;
    if (!(s = qgetevent(histline)))
	feep();
    else
	sethistline(STOUCP(s));
}

void uphistory()
{				/**/
    char *s;

    if (mult < 0) {
	mult = -mult;
	downhistory();
	return;
    }
    if (histline == curhist) {
	zsfree(curhistline);
	curhistline = ztrdup(UTOSCP(line));
    }
    histline -= mult;
    if (!(s = qgetevent(histline))) {
	if (unset(NOHISTBEEP))
	    feep();
	histline += mult;
    } else
	sethistline(STOUCP(s));
}

void uplineorhistory()
{				/**/
    int ocs = cs;

    if (mult < 0) {
	mult = -mult;
	downlineorhistory();
	return;
    }
    if ((lastcmd & ZLE_LINEMOVE) != ZLE_LINEMOVE)
	lastcol = cs - findbol();
    cs = findbol();
    while (mult) {
	if (!cs)
	    break;
	cs--;
	cs = findbol();
	mult--;
    }
    if (mult) {
	cs = ocs;
	if (virangeflag) {
	    feep();
	    return;
	}
	uphistory();
    } else {
	int x = findeol();

	if ((cs += lastcol) > x)
	    cs = x;
    }
}

void uplineorsearch()
{				/**/
    int ocs = cs;

    if (mult < 0) {
	mult = -mult;
	downlineorsearch();
	return;
    }
    if ((lastcmd & ZLE_LINEMOVE) != ZLE_LINEMOVE)
	lastcol = cs - findbol();
    cs = findbol();
    while (mult) {
	if (!cs)
	    break;
	cs--;
	cs = findbol();
	mult--;
    }
    if (mult) {
	cs = ocs;
	if (virangeflag) {
	    feep();
	    return;
	}
	historysearchbackward();
    } else {
	int x = findeol();

	if ((cs += lastcol) > x)
	    cs = x;
    }
}

void downlineorhistory()
{				/**/
    int ocs = cs;

    if (mult < 0) {
	mult = -mult;
	uplineorhistory();
	return;
    }
    if ((lastcmd & ZLE_LINEMOVE) != ZLE_LINEMOVE)
	lastcol = cs - findbol();
    while (mult) {
	int x = findeol();

	if (x == ll)
	    break;
	cs = x + 1;
	mult--;
    }
    if (mult) {
	cs = ocs;
	if (virangeflag) {
	    feep();
	    return;
	}
	downhistory();
    } else {
	int x = findeol();

	if ((cs += lastcol) > x)
	    cs = x;
    }
}

void downlineorsearch()
{				/**/
    int ocs = cs;

    if (mult < 0) {
	mult = -mult;
	uplineorsearch();
	return;
    }
    if ((lastcmd & ZLE_LINEMOVE) != ZLE_LINEMOVE)
	lastcol = cs - findbol();
    while (mult) {
	int x = findeol();

	if (x == ll)
	    break;
	cs = x + 1;
	mult--;
    }
    if (mult) {
	cs = ocs;
	if (virangeflag) {
	    feep();
	    return;
	}
	historysearchforward();
    } else {
	int x = findeol();

	if ((cs += lastcol) > x)
	    cs = x;
    }
}

void acceptlineanddownhistory()
{				/**/
    char *s, *t;

    if (!(s = qgetevent(histline + 1))) {
	feep();
	return;
    }
    pushnode(bufstack, t = ztrdup(s));
    for (; *t; t++)
	if (*t == HISTSPACE)
	    *t = ' ';
    done = 1;
    stackhist = histline + 1;
}

void downhistory()
{				/**/
    char *s;

    if (mult < 0) {
	mult = -mult;
	uphistory();
	return;
    }
    histline += mult;
    if (!(s = qgetevent(histline))) {
	if (unset(NOHISTBEEP))
	    feep();
	histline -= mult;
	return;
    }
    sethistline(STOUCP(s));
}

static int histpos;

void historysearchbackward()
{				/**/
    int t0, ohistline = histline;
    char *s;

    if (histline == curhist) {
	zsfree(curhistline);
	curhistline = ztrdup(UTOSCP(line));
    }
    if (lastcmd & ZLE_HISTSEARCH)
	t0 = histpos;
    else
	for (t0 = 0; line[t0] && !iblank(line[t0]); t0++);
    histpos = t0;
    for (;;) {
	histline--;
	if (!(s = qgetevent(histline))) {
	    feep();
	    histline = ohistline;
	    return;
	}
	if (!hstrncmp(s, UTOSCP(line), t0) && hstrcmp(s, UTOSCP(line)))
	    break;
    }
    sethistline(STOUCP(s));
}

void historysearchforward()
{				/**/
    int t0, ohistline = histline;
    char *s;

    if (histline == curhist) {
	zsfree(curhistline);
	curhistline = ztrdup(UTOSCP(line));
    }
    if (lastcmd & ZLE_HISTSEARCH)
	t0 = histpos;
    else
	for (t0 = 0; line[t0] && !iblank(line[t0]); t0++);
    histpos = t0;
    for (;;) {
	histline++;
	if (!(s = qgetevent(histline))) {
	    feep();
	    histline = ohistline;
	    return;
	}
	if (!hstrncmp(s, UTOSCP(line), t0) && hstrcmp(s, UTOSCP(line)))
	    break;
    }
    sethistline(STOUCP(s));
}

void beginningofbufferorhistory()
{				/**/
    if (findbol())
	cs = 0;
    else
	beginningofhistory();
}

void beginningofhistory()
{				/**/
    char *s;

    if (histline == curhist) {
	zsfree(curhistline);
	curhistline = ztrdup(UTOSCP(line));
    }
    if (!(s = qgetevent(firsthist()))) {
	if (unset(NOHISTBEEP))
	    feep();
	return;
    }
    histline = firsthist();
    sethistline(STOUCP(s));
}

void endofbufferorhistory()
{				/**/
    if (findeol() != ll)
	cs = ll;
    else
	endofhistory();
}

void endofhistory()
{				/**/
    if (histline == curhist) {
	if (unset(NOHISTBEEP))
	    feep();
    } else {
	histline = curhist;
	sethistline(STOUCP(curhistline));
    }
}

void insertlastword()
{				/**/
    char *s, *t;
    int len, z = lithist;

/* multiple calls will now search back through the history, pem */
    static char *lastinsert;
    static int lasthist, lastpos;
    int evhist = curhist - 1;

    if (lastinsert) {
	int lastlen = strlen(lastinsert);
	int pos = cs;

	if (lastpos <= pos &&
	    lastlen == pos - lastpos &&
	    strncmp(lastinsert, (char *)&line[lastpos], lastlen) == 0) {
	    evhist = --lasthist;
	    cs = lastpos;
	    foredel(pos - cs);
	}
	zsfree(lastinsert);
	lastinsert = NULL;
    }
    lithist = 0;
    if (!(s = qgetevent(evhist), lithist = z, s)) {
	feep();
	return;
    }
    for (t = s + strlen(s); t > s; t--)
	if (*t == HISTSPACE)
	    break;
    if (t != s)
	t++;
    lasthist = evhist;
    lastpos = cs;
    lastinsert = ztrdup(t);
    spaceinline(len = strlen(t));
    strncpy((char *)line + cs, t, len);
    cs += len;
}

char *qgetevent(ev)		/**/
int ev;
{
    if (ev > curhist)
	return NULL;
    return ((ev == curhist) ? curhistline : quietgetevent(ev));
}

void pushline()
{				/**/
    if (mult < 0)
	return;
    pushnode(bufstack, ztrdup(UTOSCP(line)));
    while (--mult)
	pushnode(bufstack, ztrdup(""));
    stackcs = cs;
    *line = '\0';
    ll = cs = 0;
}

void pushpopinput()
{				/**/
    int ics;
    char *iline;
    Histent curhistent = gethistent(curhist);

    if (mult < 0)
	return;
    if (*(curhistent->lit)) {
	ics = strlen(curhistent->lit);
	iline = (char *)zalloc(strlen((char *)line) + ics + 1);
	strcpy(iline, curhistent->lit);
	strcat(iline, (char *)line);
	free(line);
	line = (unsigned char *)iline;
	ll += ics;
	cs += ics;
	*(curhistent->lit) = '\0';
    }
    pushline();
    if (!isfirstln) {
	*(hptr = chline) = '\0';
	errflag = done = 1;
    }
}

void pushinput()
{				/**/
    if (mult < 0)
	return;
    if (!isfirstln)
	mult++;
    pushpopinput();
}

void getline()
{				/**/
    char *s = (char *)getnode(bufstack);

    if (!s)
	feep();
    else {
	int cc;

	cc = strlen(s);
	spaceinline(cc);
	strncpy((char *)line + cs, s, cc);
	cs += cc;
	zsfree(s);
    }
}

void historyincrementalsearchbackward()
{				/**/
    doisearch(-1);
}

void historyincrementalsearchforward()
{				/**/
    doisearch(1);
}

extern int ungetok;

void doisearch(dir)		/**/
int dir;
{
    char *s, *oldl;
    char ibuf[256], *sbuf = ibuf + 14;
    int sbptr = 0, cmd, ohl = histline, ocs = cs;
    int nomatch, chequiv = 0;

    strcpy(ibuf, (dir == -1) ? "bck-i-search: " : "fwd-i-search: ");
    statusline = ibuf;
    oldl = ztrdup(UTOSCP(line));
    if (histline == curhist) {
	zsfree(curhistline);
	curhistline = ztrdup(UTOSCP(line));
    }
    for (;;) {
	nomatch = 0;
	if (sbptr > 1 || (sbptr == 1 && sbuf[0] != '^')) {
	    int ohistline = histline;

	    for (;;) {
		char *t;

		if (!(s = qgetevent(histline))) {
		    feep();
		    nomatch = 1;
		    histline = ohistline;
		    break;
		}
		if ((sbuf[0] == '^') ?
		    (t = (hstrncmp(s, sbuf + 1, sbptr - 1)) ? NULL : s) :
		    (t = hstrnstr(s, sbuf, sbptr)))
		    if (!(chequiv && !hstrcmp(UTOSCP(line), s))) {
			sethistline(STOUCP(s));
			cs = t - s + sbptr - (sbuf[0] == '^');
			break;
		    }
		histline += dir;
	    }
	    chequiv = 0;
	}
	refresh();
	if ((cmd = getkeycmd()) < 0 || cmd == z_sendbreak) {
	    setline(oldl);
	    cs = ocs;
	    histline = ohl;
	    break;
	}
	switch (cmd) {
	case z_backwarddeletechar:
	    if (sbptr)
		sbuf[--sbptr] = '\0';
	    else
		feep();
	    histline = ohl;
	    continue;
	case z_acceptandhold:
	    acceptandhold();
	    goto brk;
	case z_acceptandinfernexthistory:
	    acceptandinfernexthistory();
	    goto brk;
	case z_acceptlineanddownhistory:
	    acceptlineanddownhistory();
	    goto brk;
	case z_acceptline:
	    acceptline();
	    goto brk;
	case z_historyincrementalsearchbackward:
	    ohl = (histline += (dir = -1));
	    chequiv = 1;
	    memcpy(ibuf, "bck", 3);
	    refresh();
	    continue;
	case z_historyincrementalsearchforward:
	    ohl = (histline += (dir = 1));
	    chequiv = 1;
	    memcpy(ibuf, "fwd", 3);
	    refresh();
	    continue;
	case z_sendstring:
	    sendstring();
	    continue;
	case z_quotedinsert:
	    if ((c = getkey(0)) == EOF)
		goto brk;
	    else
		cmd = z_selfinsert;
	default:
	    if (cmd == z_magicspace)
		c = ' ';
	    else if (cmd != z_selfinsert && cmd != z_selfinsertunmeta) {
		if (ungetok)
		    ungetkey(c);
		else
		    feep();
		goto brk;
	    }
	    if (!nomatch && sbptr != 39) {
		sbuf[sbptr++] = c;
		sbuf[sbptr] = '\0';
	    }
	}
    }
  brk:
    free(oldl);
    statusline = NULL;
}

void acceptandinfernexthistory()
{				/**/
    int t0;
    char *s, *t;

    done = 1;
    for (t0 = histline - 2;; t0--) {
	if (!(s = qgetevent(t0)))
	    return;
	if (!hstrncmp(s, UTOSCP(line), ll))
	    break;
    }
    if (!(s = qgetevent(t0 + 1)))
	return;
    pushnode(bufstack, t = ztrdup(s));
    for (; *t; t++)
	if (*t == HISTSPACE)
	    *t = ' ';
    stackhist = t0 + 1;
}

void infernexthistory()
{				/**/
    int t0;
    char *s, *t;

    if (!(t = qgetevent(histline - 1))) {
	feep();
	return;
    }
    for (t0 = histline - 2;; t0--) {
	if (!(s = qgetevent(t0))) {
	    feep();
	    return;
	}
	if (!strcmp(s, t))
	    break;
    }
    if (!(s = qgetevent(t0 + 1))) {
	feep();
	return;
    }
    histline = t0 + 1;
    sethistline(STOUCP(s));
}

void vifetchhistory()
{				/**/
    char *s;

    if (mult < 0)
	return;
    if (histline == curhist) {
	if (!(lastcmd & ZLE_ARG)) {
	    cs = ll;
	    cs = findbol();
	    return;
	}
	zsfree(curhistline);
	curhistline = ztrdup(UTOSCP(line));
    }
    if (!(lastcmd & ZLE_ARG))
	mult = curhist;
    if (!(s = qgetevent(mult)))
	feep();
    else {
	histline = mult;
	sethistline(STOUCP(s));
    }
}

extern int viins_cur_bindtab[];

int getvisrchstr()
{				/**/
    static char sbuf[80] = "/";
    int sptr = 1, cmd, ret = 0;
    int *obindtab = NULL;

    if (visrchstr) {
	zsfree(visrchstr);
	visrchstr = NULL;
    }
    statusline = sbuf;
    sbuf[1] = '\0';
    if (bindtab == altbindtab) {
	obindtab = bindtab;
	bindtab = viins_cur_bindtab;
    }
    while (sptr) {
	refresh();
	if ((cmd = getkeycmd()) < 0 || cmd == z_sendbreak) {
	    ret = 0;
	    break;
	} else if (cmd == z_acceptline || cmd == z_vicmdmode) {
	    visrchstr = ztrdup(sbuf + 1);
	    ret = 1;
	    break;
	} else if (cmd == z_backwarddeletechar ||
		   cmd == z_vibackwarddeletechar) {
	    sbuf[--sptr] = '\0';
	    continue;
	} else if (cmd == z_sendstring) {
	    sendstring();
	    continue;
	} else if (cmd == z_quotedinsert) {
	    if ((c = getkey(0)) == EOF) {
		feep();
		continue;
	    }
	} else if (cmd != z_selfinsert && cmd != z_selfinsertunmeta) {
	    feep();
	    continue;
	}
	if (sptr != 79) {
	    sbuf[sptr++] = c;
	    sbuf[sptr] = '\0';
	}
    }
    statusline = NULL;
    if (obindtab)
	bindtab = obindtab;
    return ret;
}

void vihistorysearchforward()
{				/**/
    visrchsense = 1;
    if (getvisrchstr())
	virepeatsearch();
}

void vihistorysearchbackward()
{				/**/
    visrchsense = -1;
    if (getvisrchstr())
	virepeatsearch();
}

void virepeatsearch()
{				/**/
    int ohistline = histline, t0;
    char *s;

    if (!visrchstr) {
	feep();
	return;
    }
    t0 = strlen(visrchstr);
    if (histline == curhist) {
	zsfree(curhistline);
	curhistline = ztrdup(UTOSCP(line));
    }
    for (;;) {
	histline += visrchsense;
	if (!(s = qgetevent(histline))) {
	    feep();
	    histline = ohistline;
	    return;
	}
	if (!hstrcmp(UTOSCP(line), s))
	    continue;
	if (*visrchstr == '^') {
	    if (!hstrncmp(s, visrchstr + 1, t0 - 1))
		break;
	} else if (hstrnstr(s, visrchstr, t0))
	    break;
    }
    sethistline(STOUCP(s));
}

void virevrepeatsearch()
{				/**/
    visrchsense = -visrchsense;
    virepeatsearch();
    visrchsense = -visrchsense;
}

/* Extra function added by A.R. Iano-Fletcher.	*/
/*The extern variable "cs" is the position of the cursor. */
/* history-beginning-search-backward */

void historybeginningsearchbackward()
{				/**/
    int cpos = cs;		/* save cursor position */
    int ohistline = histline;
    char *s;

    if (histline == curhist) {
	zsfree(curhistline);
	curhistline = ztrdup((char *)line);
    }
    for (;;) {
	histline--;
	if (!(s = qgetevent(histline))) {
	    feep();
	    histline = ohistline;
	    return;
	}
	if (!hstrncmp(s, (char *)line, cs) && hstrcmp(s, (char *)line))
	    break;
    }

    sethistline((unsigned char *)s);	/* update command line.		*/
    cs = cpos;			/* reset cursor position.	*/
}

/* Extra function added by A.R. Iano-Fletcher.	*/

/* history-beginning-search-forward */
void historybeginningsearchforward()
{				/**/
    int cpos = cs;		/* save cursor position */
    int ohistline = histline;
    char *s;

    if (histline == curhist) {
	zsfree(curhistline);
	curhistline = ztrdup((char *)line);
    }
    for (;;) {
	histline++;
	if (!(s = qgetevent(histline))) {
	    feep();
	    histline = ohistline;
	    return;
	}
	if (!hstrncmp(s, (char *)line, cs) && hstrcmp(s, (char *)line))
	    break;
    }

    sethistline((unsigned char *)s);	/* update command line.		*/
    cs = cpos;			/* reset cursor position.	*/
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 *
 * zle_main.c - main routines for line editor
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define ZLEGLOBALS
#define ZLE
#include "zsh.h"
#include <sys/types.h>
#include <errno.h>
#ifdef HAS_SYS_SELECT
#include <sys/select.h>
#endif

static int emacs_cur_bindtab[256], eofchar, eofsent;
int viins_cur_bindtab[256], ungetok;	/* needed in zle_hist */

/* hash table containing the zle multi-character bindings */

static Hashtab xbindtab, vi_xbindtab, em_xbindtab;

static Key cky;

/* set up terminal */

void setterm()
{				/**/
    struct ttyinfo ti;

#if defined(CLOBBERS_TYPEAHEAD) && defined(FIONREAD)
    int val;

    ioctl(SHTTY, FIONREAD, (char *)&val);
    if (val)
	return;
#endif

/* sanitize the tty */
#ifdef HAS_TIO
    shttyinfo.tio.c_lflag |= ICANON | ECHO;
#ifdef FLUSHO
    shttyinfo.tio.c_lflag &= ~FLUSHO;
#endif
#else				/* not HAS_TIO */
    shttyinfo.sgttyb.sg_flags = (shttyinfo.sgttyb.sg_flags & ~CBREAK) | ECHO;
    shttyinfo.lmodes &= ~LFLUSHO;
#endif

    attachtty(mypgrp);
    ti = shttyinfo;
#ifdef HAS_TIO
    if (isset(NOFLOWCONTROL))
	ti.tio.c_iflag &= ~IXON;
    ti.tio.c_lflag &= ~(ICANON | ECHO
#ifdef FLUSHO
			| FLUSHO
#endif
	);
#ifdef TAB3
    ti.tio.c_oflag &= ~TAB3;
#else
#ifdef OXTABS
    ti.tio.c_oflag &= ~OXTABS;
#else
    ti.tio.c_oflag &= ~XTABS;
#endif
#endif
    ti.tio.c_oflag |= ONLCR;
    ti.tio.c_cc[VQUIT] =
#ifdef VDISCARD
	ti.tio.c_cc[VDISCARD] =
#endif
#ifdef VSUSP
	ti.tio.c_cc[VSUSP] =
#endif
#ifdef VDSUSP
	ti.tio.c_cc[VDSUSP] =
#endif
#ifdef VSWTCH
	ti.tio.c_cc[VSWTCH] =
#endif
#ifdef VLNEXT
	ti.tio.c_cc[VLNEXT] =
#endif
	VDISABLEVAL;
#if defined(VSTART) && defined(VSTOP)
    if (isset(NOFLOWCONTROL))
	ti.tio.c_cc[VSTART] = ti.tio.c_cc[VSTOP] = VDISABLEVAL;
#endif
    eofchar = ti.tio.c_cc[VEOF];
    ti.tio.c_cc[VMIN] = 1;
    ti.tio.c_cc[VTIME] = 0;
    ti.tio.c_iflag |= (INLCR | ICRNL);
 /* this line exchanges \n and \r; it's changed back in getkey
	so that the net effect is no change at all inside the shell.
	This double swap is to allow typeahead in common cases, eg.

	% bindkey -s '^J' 'echo foo^M'
	% sleep 10
	echo foo<return>  <--- typed before sleep returns

	The shell sees \n instead of \r, since it was changed by the kernel
	while zsh wasn't looking. Then in getkey() \n is changed back to \r,
	and it sees "echo foo<accept line>", as expected. Without the double
	swap the shell would see "echo foo\n", which is translated to
	"echo fooecho foo<accept line>" because of the binding.
	Note that if you type <line-feed> during the sleep the shell just sees
	\n, which is translated to \r in getkey(), and you just get another
	prompt. For type-ahead to work in ALL cases you have to use
	stty inlcr.
	This workaround is due to Sven Wischnowsky <oberon@cs.tu-berlin.de>.

	Unfortunately it's IMPOSSIBLE to have a general solution if both
	<return> and <line-feed> are mapped to the same character. The shell
	could check if there is input and read it before setting it's own
	terminal modes but if we get a \n we don't know whether to keep it or
	change to \r :-(
	*/

#else				/* not HAS_TIO */
    ti.sgttyb.sg_flags = (ti.sgttyb.sg_flags | CBREAK) & ~ECHO & ~XTABS;
    ti.lmodes &= ~LFLUSHO;
    eofchar = ti.tchars.t_eofc;
    ti.tchars.t_quitc =
	ti.ltchars.t_suspc =
	ti.ltchars.t_flushc =
	ti.ltchars.t_dsuspc = ti.ltchars.t_lnextc = -1;
#endif

#if defined(TTY_NEEDS_DRAINING) && defined(TIOCOUTQ) && defined(HAS_SELECT)
/* this is mostly stolen from bash's draino() */
    if (baud) {			/**/
	int n = 0;

	while ((ioctl(SHTTY, TIOCOUTQ, (char *)&n) >= 0) && n) {
	    struct timeval tv;

	    tv.tv_sec = n / baud;
	    tv.tv_usec = ((n % baud) * 1000000) / baud;
	    select(0, NULL, NULL, NULL, &tv);
	}
    }
#endif

    settyinfo(&ti);
}

static char *kungetbuf;
static int kungetct, kungetsz;

void ungetkey(ch)		/**/
int ch;
{
    if (kungetct == kungetsz)
	kungetbuf = realloc(kungetbuf, kungetsz *= 2);
    kungetbuf[kungetct++] = ch;
}

void ungetkeys(s, len)		/**/
char *s;
int len;
{
    s += len;
    while (len--)
	ungetkey(*--s);
}

#if defined(pyr) && defined(HAS_SELECT)
static int breakread(fd, buf, n)
int fd, n;
char *buf;
{
    fd_set f;

    FD_ZERO(&f);
    FD_SET(fd, &f);
    return (select(fd + 1, (SELECT_ARG_2_T) & f, NULL, NULL, NULL) == -1 ?
	    EOF : read(fd, buf, n));
}

#define read    breakread
#endif

int getkey(keytmout)		/**/
int keytmout;
{
    char cc;
    unsigned int ret;
    long exp100ths;
    int die = 0, r;
    int old_errno = errno;

#ifdef HAS_SELECT
    fd_set foofd;

#else
#ifdef HAS_TIO
    struct ttyinfo ti;

#endif
#endif

    if (kungetct)
	ret = (int)(unsigned char)kungetbuf[--kungetct];
    else {
	if (keytmout) {
	    if (keytimeout > 500)
		exp100ths = 500;
	    else if (keytimeout > 0)
		exp100ths = keytimeout;
	    else
		exp100ths = 0;
#ifdef HAS_SELECT
	    if (exp100ths) {
		struct timeval expire_tv;

		expire_tv.tv_sec = exp100ths / 100;
		expire_tv.tv_usec = (exp100ths % 100) * 10000L;
		FD_ZERO(&foofd);
		FD_SET(0, &foofd);
		if (select(1, (SELECT_ARG_2_T) & foofd, NULL, NULL, &expire_tv) <= 0)
		    return EOF;
	    }
#else
#ifdef HAS_TIO
	    ti = shttyinfo;
	    ti.tio.c_lflag &= ~ICANON;
	    ti.tio.c_cc[VMIN] = 0;
	    ti.tio.c_cc[VTIME] = exp100ths / 10;
	    ioctl(SHTTY, TCSETA, &ti.tio);
	    r = read(0, &cc, 1);
	    ioctl(SHTTY, TCSETA, &shttyinfo.tio);
	    return (r <= 0) ? -1 : cc;
#endif
#endif
	}
	while ((r = read(0, &cc, 1)) != 1) {
	    if (r == 0) {
		if (isset(IGNOREEOF))
		    continue;
		stopmsg = 1;
		zexit(1);
	    }
	    if (errno == EINTR) {
		die = 0;
		if (!errflag)
		    continue;
		errflag = 0;
		errno = old_errno;
		return EOF;
	    } else if (errno == EWOULDBLOCK) {
		fcntl(0, F_SETFL, 0);
	    } else if (errno == EIO && !die) {
		ret = jobbingv;
		jobbingv = OPT_SET;
		attachtty(mypgrp);
		refresh();	/* kludge! */
		jobbingv = ret;
		die = 1;
	    } else if (errno != 0) {
		zerr("error on TTY read: %e", NULL, errno);
		stopmsg = 1;
		zexit(1);
	    }
	}
	if (cc == '\r')		/* undo the exchange of \n and \r determined by */
	    cc = '\n';		/* setterm() */
	else if (cc == '\n')
	    cc = '\r';

	ret = (int)(unsigned char)cc;
    }
    if (vichgflag) {
	if (vichgbufptr == vichgbufsz)
	    vichgbuf = realloc(vichgbuf, vichgbufsz *= 2);
	vichgbuf[vichgbufptr++] = ret;
    }
    errno = old_errno;
    return ret;
}

/* read a line */

unsigned char *zleread(ppt, ppt2, plen, p2len)	/**/
unsigned char *ppt;
unsigned char *ppt2;
int plen;
int p2len;
{
    int z;
    unsigned char *s;
    int old_errno = errno;

#ifdef HAS_SELECT
    long costmult = (baud) ? 3840000L / baud : 0;
    struct timeval tv;
    fd_set foofd;

    tv.tv_sec = 0;
#endif

    fflush(stdout);
    fflush(stderr);
    intr();
    insmode = unset(OVERSTRIKE);
    eofsent = 0;
    resetneeded = 0;
    pmpt = (char *)ppt;
    pmpt2 = (char *)ppt2;
    pptlen = plen;
    ppt2len = p2len;
    permalloc();
    histline = curhist;
#ifdef HAS_SELECT
    FD_ZERO(&foofd);
#endif
    undoing = 1;
    line = (unsigned char *)zalloc((linesz = 256) + 1);
    *line = '\0';
    virangeflag = lastcmd = done = cs = ll = mark = 0;
    curhistline = NULL;
    mult = 1;
    vibufspec = 0;
    bindtab = mainbindtab;
    addedsuffix = complexpect = vichgflag = 0;
    viinsbegin = 0;
    statusline = NULL;
    if ((s = (unsigned char *)getnode(bufstack))) {
	setline((char *)s);
	zsfree((char *)s);
	if (stackcs != -1) {
	    cs = stackcs;
	    stackcs = -1;
	    if (cs > ll)
		cs = ll;
	}
	if (stackhist != -1) {
	    histline = stackhist;
	    stackhist = -1;
	}
    }
    initundo();
    if (unset(NOPROMPTCR))
	putchar('\r');
    if (tmout)
	alarm(tmout);
    zleactive = 1;
    resetneeded = 1;
    refresh();
    errflag = retflag = 0;
    while (!done && !errflag) {
	struct zlecmd *zc;

	statusline = NULL;
	bindk = getkeycmd();
	if (!ll && c == eofchar) {
	    eofsent = 1;
	    break;
	}
	if (bindk != -1) {
	    int ce = complexpect;

	    zc = zlecmds + bindk;
	    if (!(lastcmd & ZLE_ARG))
		mult = 1;
	    if ((lastcmd & ZLE_UNDO) != (zc->flags & ZLE_UNDO) && undoing)
		addundo();
	    if (bindk != z_sendstring) {
		if (!(zc->flags & ZLE_MENUCMP) && menucmp)
		    menucmp = 0;
		if (!(zc->flags & ZLE_MENUCMP) &&
		    addedsuffix && !(zc->flags & ZLE_DELETE) &&
		    !((zc->flags & ZLE_INSERT) && c != ' ')) {
		    backdel(addedsuffix);
		}
		if (!menucmp)
		    addedsuffix = 0;
	    }
	    if (zc->func)
		(*zc->func) ();
	    if (ce == complexpect && ce)
		complexpect = 0;
	    if (bindk != z_sendstring)
		lastcmd = zc->flags;
	    if (!(lastcmd & ZLE_UNDO) && undoing)
		addundo();
	} else {
	    errflag = 1;
	    break;
	}
#ifdef HAS_SELECT
	if (baud && (!lastcmd & ZLE_MENUCMP)) {
	    FD_SET(0, &foofd);
	    if ((tv.tv_usec = cost * costmult) > 500000)
		tv.tv_usec = 500000;
	    if (!kungetct && select(1, (SELECT_ARG_2_T) & foofd, NULL, NULL, &tv) <= 0)
		refresh();
	} else
#endif
	if (!kungetct)
	    refresh();
    }
    statusline = NULL;
    trashzle();
    zleactive = 0;
    alarm(0);
    z = strlen(UTOSCP(line));
    line[z] = '\n';
    line[z + 1] = 0;
    heapalloc();
    zsfree(curhistline);
    if (eofsent) {
	free(line);
	line = NULL;
    }
    free(lastline);		/* freeundo */
    errno = old_errno;
    return line;
}

int getkeycmd()
{				/**/
    int ret;
    static int hops = 0;

    cky = NULL;

    if ((c = getkey(0)) < 0)
	return -1;
    if ((ret = bindtab[c]) == z_sequenceleadin) {
	int lastlen = 0, t0 = 1, buflen = 50;
	Key ky;
	char *buf;

	buf = (char *)zalloc(buflen);
	ungetok = 0;
	buf[0] = c, buf[1] = '\0';
	if ((cky = (Key) gethnode(buf, xbindtab))->func == z_undefinedkey)
	    cky = NULL;
	else
	    lastlen = 1;
	if (!c)
	    buf[0] = (char)0x80;
	for (;;) {
	    if ((c = getkey(cky ? 1 : 0)) >= 0) {
		if (t0 == buflen - 1)
		    buf = (char *)realloc(buf, buflen *= 2);
		buf[t0++] = (c) ? c : 0x80;
		buf[t0] = '\0';
		ky = (Key) gethnode(buf, xbindtab);
	    } else
		ky = NULL;
	    if (ky) {
		if (ky->func == z_undefinedkey)
		    continue;
		cky = ky;
		if (!ky->prefixct) {
		    ret = ky->func;
		    break;
		}
		lastlen = t0;
	    } else if (cky) {
		ungetkeys(&buf[lastlen], t0 - lastlen);
		ret = cky->func;
		c = buf[lastlen - 1];
		break;
	    } else
		return z_undefinedkey;
	}
	zfree(buf, buflen);
    } else
	ungetok = 1;		/* for doisearch() */
    if (ret == z_vidigitorbeginningofline)
	ret = (lastcmd & ZLE_ARG) ? z_digitargument : z_beginningofline;
    else if (ret == z_executenamedcmd && !statusline)
	ret = executenamedcommand();
    else if (ret == z_executelastnamedcmd)
	ret = lastnamed;
    else if (ret == z_sendstring) {
#define MAXHOPS 20
	if (++hops == MAXHOPS) {
	    zerr("string inserting another one too many times", NULL, 0);
	    hops = 0;
	    return -1;
	}
    } else
	hops = 0;
    return ret;
}

void sendstring()
{				/**/
    if (!cky) {
	char buf[2];

	buf[0] = c;
	buf[1] = '\0';
	cky = (Key) gethnode(buf, xbindtab);
    }
    ungetkeys(cky->str, cky->len);
}

Key makefunckey(fun)		/**/
int fun;
{
    Key ky = (Key) zcalloc(sizeof *ky);

    ky->func = fun;
    return ky;
}

/* initialize the bindings */

void initxbindtab()
{				/**/
    int t0, vi = 0;
    char buf[3], *s;
    Key ky;

    lastnamed = z_undefinedkey;
    for (t0 = 0; t0 != 32; t0++)
	viins_cur_bindtab[t0] = viinsbind[t0];
    for (t0 = 32; t0 != 256; t0++)
	viins_cur_bindtab[t0] = z_selfinsert;
    viins_cur_bindtab[127] = z_backwarddeletechar;
    for (t0 = 0; t0 != 128; t0++)
	emacs_cur_bindtab[t0] = emacsbind[t0];
    for (t0 = 128; t0 != 256; t0++)
	emacs_cur_bindtab[t0] = z_selfinsert;
    em_xbindtab = newhtable(67);
    vi_xbindtab = newhtable(20);
    if ((s = zgetenv("VISUAL"))) {
	if (ztrstr(s, "vi"))
	    vi = 1;
    } else if ((s = zgetenv("EDITOR")) && ztrstr(s, "vi"))
	vi = 1;
    if (vi) {
	mainbindtab = viins_cur_bindtab;
	xbindtab = vi_xbindtab;
    } else {
	mainbindtab = emacs_cur_bindtab;
	xbindtab = em_xbindtab;
    }
    for (t0 = 0200; t0 != 0240; t0++)
	emacs_cur_bindtab[t0] = viins_cur_bindtab[t0] = z_undefinedkey;
    for (t0 = 0; t0 != 128; t0++)
	altbindtab[t0] = vicmdbind[t0];
    for (t0 = 128; t0 != 256; t0++)
	altbindtab[t0] = emacsbind[t0];
    bindtab = mainbindtab;
    if (!kungetbuf)
	kungetbuf = (char *)zalloc(kungetsz = 32);

    addhnode(ztrdup("\33\133"), ky = makefunckey(z_undefinedkey), em_xbindtab, 0);
    ky->prefixct = 4;
    addhnode(ztrdup("\33\133C"), makefunckey(z_forwardchar), em_xbindtab, 0);
    addhnode(ztrdup("\33\133D"), makefunckey(z_backwardchar), em_xbindtab, 0);
    addhnode(ztrdup("\33\133A"), makefunckey(z_uplineorhistory), em_xbindtab, 0);
    addhnode(ztrdup("\33\133B"), makefunckey(z_downlineorhistory), em_xbindtab, 0);
    addhnode(ztrdup("\33"), ky = makefunckey(z_vicmdmode), vi_xbindtab, 0);
    ky->prefixct = 4;
    addhnode(ztrdup("\33\133"), ky = makefunckey(z_undefinedkey), vi_xbindtab, 0);
    ky->prefixct = 4;
    addhnode(ztrdup("\33\133C"), makefunckey(z_forwardchar), vi_xbindtab, 0);
    addhnode(ztrdup("\33\133D"), makefunckey(z_backwardchar), vi_xbindtab, 0);
    addhnode(ztrdup("\33\133A"), makefunckey(z_uplineorhistory), vi_xbindtab, 0);
    addhnode(ztrdup("\33\133B"), makefunckey(z_downlineorhistory), vi_xbindtab, 0);
    addhnode(ztrdup("\30"), ky = makefunckey(z_undefinedkey), em_xbindtab, 0);
    ky->prefixct = 15;
    addhnode(ztrdup("\30*"), makefunckey(z_expandword), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30g"), makefunckey(z_listexpand), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30G"), makefunckey(z_listexpand), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30\16"), makefunckey(z_infernexthistory), em_xbindtab, 0);
    addhnode(ztrdup("\30\13"), makefunckey(z_killbuffer), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30\6"), makefunckey(z_vifindnextchar), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30\17"), makefunckey(z_overwritemode), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30\25"), makefunckey(z_undo), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30\26"), makefunckey(z_vicmdmode), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30\12"), makefunckey(z_vijoin), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30\2"), makefunckey(z_vimatchbracket), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30s"), makefunckey(z_historyincrementalsearchforward),
	     em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30r"), makefunckey(z_historyincrementalsearchbackward),
	     em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30u"), makefunckey(z_undo), em_xbindtab, (FFunc) 0);
    addhnode(ztrdup("\30\30"), makefunckey(z_exchangepointandmark), em_xbindtab, 0);
    addhnode(ztrdup("\33"), ky = makefunckey(z_undefinedkey), em_xbindtab, 0);
    ky->prefixct = 4;

    strcpy(buf, "\33q");
    for (t0 = 128; t0 != 256; t0++)
	if (emacsbind[t0] != z_undefinedkey) {
	    buf[1] = t0 & 0x7f;
	    addhnode(ztrdup(buf), makefunckey(emacsbind[t0]), em_xbindtab, 0);
	    ky->prefixct++;
	}
    stackhist = stackcs = -1;
}

char *getkeystring(s, len, fromwhere, misc)	/**/
char *s;
int *len;
int fromwhere;
int *misc;
{
    char *buf = ((fromwhere == 2)
		 ? zalloc(strlen(s) + 1) : alloc(strlen(s) + 1));
    char *t = buf, *u = NULL;
    char svchar = '\0';
    int meta = 0, control = 0;

    for (; *s; s++) {
	if (*s == '\\' && s[1])
	    switch (*++s) {
	    case 'a':
#ifdef __STDC__
		*t++ = '\a';
#else
		*t++ = '\07';
#endif
		break;
	    case 'n':
		*t++ = '\n';
		break;
	    case 'b':
		*t++ = '\010';
		break;
	    case 't':
		*t++ = '\t';
		break;
	    case 'v':
		*t++ = '\v';
		break;
	    case 'f':
		*t++ = '\f';
		break;
	    case 'r':
		*t++ = '\r';
		break;
	    case 'E':
		if (!fromwhere) {
		    *t++ = '\\', s--;
		    continue;
		}
	    case 'e':
		*t++ = '\033';
		break;
	    case 'M':
		if (fromwhere) {
		    if (s[1] == '-')
			s++;
		    meta = 1 + control;	/* preserve the order of ^ and meta */
		} else
		    *t++ = '\\', s--;
		continue;
	    case 'C':
		if (fromwhere) {
		    if (s[1] == '-')
			s++;
		    control = 1;
		} else
		    *t++ = '\\', s--;
		continue;
	    case 'c':
		if (fromwhere < 2) {
		    *misc = 1;
		    break;
		}
	    default:
		if ((idigit(*s) && *s < '8') || *s == 'x') {
		    if (!fromwhere)
			if (*s == '0')
			    s++;
			else if (*s != 'x') {
			    *t++ = '\\', s--;
			    continue;
			}
		    if (s[1] && s[2] && s[3]) {
			svchar = s[3];
			s[3] = '\0';
			u = s;
		    }
		    *t++ = zstrtol(s + (*s == 'x'), &s,
				   (*s == 'x') ? 16 : 8);
		    if (svchar) {
			u[3] = svchar;
			svchar = '\0';
		    }
		    s--;
		} else {
		    if (!fromwhere && *s != '\\')
			*t++ = '\\';
		    *t++ = *s;
		}
		break;
	} else if (*s == '^' && fromwhere == 2) {
	    control = 1;
	    continue;
	} else
	    *t++ = *s;
	if (meta == 2) {
	    t[-1] |= 0x80;
	    meta = 0;
	}
	if (control) {
	    if (t[-1] == '?')
		t[-1] = 0x7f;
	    else
		t[-1] &= 0x9f;
	    control = 0;
	}
	if (meta) {
	    t[-1] |= 0x80;
	    meta = 0;
	}
    }
    *t = '\0';
    *len = t - buf;
    return buf;
}

void printbind(s, len)		/**/
char *s;
int len;
{
    int ch;

    while (len--) {
	ch = (unsigned char)*s++;
	if (ch & 0x80) {
	    printf("\\M-");
	    ch &= 0x7f;
	}
	if (icntrl(ch))
	    switch (ch) {
	    case 0x7f:
		printf("^?");
		break;
	    default:
		printf("^%c", (ch | 0x40));
		break;
	} else
	    putchar(ch);
    }
}

void printbinding(str, k)	/**/
char *str;
Key k;
{
    int len;

    if (k->func == z_undefinedkey)
	return;
    putchar('\"');
    printbind(str, (len = strlen(str)) ? len : 1);
    printf("\"\t");
    if (k->func == z_sendstring) {
	putchar('\"');
	printbind(k->str, k->len);
	printf("\"\n");
    } else
	printf("%s\n", zlecmds[k->func].name);
}

int bin_bindkey(name, argv, ops, junc)	/**/
char *name;
char **argv;
char *ops;
int junc;
{
    int i, *tab;

    if (ops['v'] && ops['e']) {
	zerrnam(name, "incompatible options", NULL, 0);
	return 1;
    }
    if (ops['v'] || ops['e'] || ops['d'] || ops['m']) {
	if (*argv) {
	    zerrnam(name, "too many arguments", NULL, 0);
	    return 1;
	}
	if (ops['d']) {
	    freehtab(em_xbindtab, freekey);
	    freehtab(vi_xbindtab, freekey);
	    initxbindtab();
	}
	if (ops['e']) {
	    mainbindtab = emacs_cur_bindtab;
	    xbindtab = em_xbindtab;
	} else if (ops['v']) {
	    mainbindtab = viins_cur_bindtab;
	    xbindtab = vi_xbindtab;
	}
	if (ops['m'])
	    for (i = 128; i != 256; i++)
		if (mainbindtab[i] == z_selfinsert)
		    mainbindtab[i] = emacsbind[i];
	return 0;
    }
    tab = (ops['a']) ? altbindtab : mainbindtab;
    if (!*argv) {
	char buf[2];

	buf[1] = '\0';
	for (i = 0; i != 256; i++) {
	    buf[0] = i;
	    putchar('\"');
	    printbind(buf, 1);
	    if (i < 254 && tab[i] == tab[i + 1] && tab[i] == tab[i + 2]) {
		printf("\" to \"");
		while (tab[i] == tab[i + 1])
		    i++;
		buf[0] = i;
		printbind(buf, 1);
	    }
	    printf("\"\t%s\n", zlecmds[tab[i]].name);
	}
	listhtable(xbindtab, (HFunc) printbinding);
	return 0;
    }
    while (*argv) {
	Key ky = NULL, cur = NULL;
	char *s;
	int func, len, firstzero = 0;

	s = getkeystring(*argv++, &len, 2, NULL);
	if (len > 1) {
	    if (s[0])
		firstzero = 0;
	    else
		firstzero = 1;
	    for (i = 0; i < len; i++)
		if (!s[i])
		    s[i] = (char)0x80;
	}
	if (!*argv || ops['r']) {
	    if (len == 1)
		func = tab[(unsigned char)*s];
	    else
		func = (ky = (Key) gethnode(s, xbindtab)) ? ky->func
		    : z_undefinedkey;
	    if (func == z_undefinedkey) {
		zerrnam(name, "in-string is not bound", NULL, 0);
		zfree(s, len);
		return 1;
	    }
	    if (ops['r']) {
		if (len == 1 && func != z_sequenceleadin) {
		    tab[(unsigned char)*s] = z_undefinedkey;
		    if (func == z_sendstring)
			free(remhnode(s, xbindtab));
		} else {
		    if (ky->prefixct) {
			if (ky->func == z_sendstring)
			    zfree(ky->str, ky->len);
			ky->func = z_undefinedkey;
		    } else
			free(remhnode(s, xbindtab));
		    if (len > 1) {
			s[--len] = '\0';
			while (len > 1) {
			    (ky = (Key) gethnode(s, xbindtab))->prefixct--;
			    if (!ky->prefixct && ky->func == z_undefinedkey)
				free(remhnode(s, xbindtab));
			    s[--len] = '\0';
			}
			(ky = (Key) gethnode(s, xbindtab))->prefixct--;
			if (!ky->prefixct) {
			    tab[(unsigned char)*s] = ky->func;
			    if (ky->func != z_sendstring)
				free(remhnode(s, xbindtab));
			}
		    }
		}
		zfree(s, len);
		continue;
	    }
	    if (func == z_sendstring) {
		if (len == 1)
		    ky = (Key) gethnode(s, xbindtab);
		printbind(ky->str, ky->len);
		putchar('\n');
	    } else
		printf("%s\n", zlecmds[func].name);
	    zfree(s, len);
	    return 0;
	}
	if (!ops['s']) {
	    for (i = 0; i != ZLECMDCOUNT; i++)
		if (!strcmp(*argv, zlecmds[i].name))
		    break;
	    if (i == ZLECMDCOUNT) {
		zerr("undefined function: %s", *argv, 0);
		zfree(s, len);
		return 1;
	    }
	    func = i;
	} else
	    func = z_sendstring;

	if (len == 1 && tab[(unsigned char)*s] != z_sequenceleadin) {
	    if (ops['s']) {
		addhnode(ztrdup(s), cur = makefunckey(z_sendstring),
			 xbindtab, freekey);
	    } else if (tab[(unsigned char)*s] == z_sendstring)
		free(remhnode(s, xbindtab));
	    tab[(unsigned char)*s] = func;
	} else {
	    if (!(cur = (Key) gethnode(s, xbindtab))
		|| (cur->func == z_undefinedkey))
		for (i = len - 1; i > 0; i--) {
		    char sav;

		    sav = s[i];
		    s[i] = '\0';
		    if (i == 1 && firstzero)
			*s = '\0';
		    if (!(ky = (Key) gethnode(s, xbindtab)))
			addhnode(ztrdup(s), ky = makefunckey(z_undefinedkey),
				 xbindtab, freekey);
		    ky->prefixct++;
		    s[i] = sav;
		    if (i == 1 && firstzero)
			*s = (char)0x80;
		}
	    if (cur) {
		cur->func = func;
		zfree(cur->str, cur->len);
	    } else
		addhnode(ztrdup(s), cur = makefunckey(func), xbindtab, freekey);
	    if (firstzero)
		*s = 0;
	    if (tab[(unsigned char)*s] != z_sequenceleadin) {
		cur->func = tab[(unsigned char)*s];
		tab[(unsigned char)*s] = z_sequenceleadin;
	    }
	}
	if (ops['s']) {
	    cur->str = getkeystring(*argv, &cur->len, 2, NULL);
	    cur->str = (char *)realloc(cur->str, cur->len);
	}
	argv++;
	zfree(s, len);
    }
    return 0;
}

void freekey(x)			/**/
vptr x;
{
    Key k = (Key) x;

    if (k->str)
	zsfree(k->str);
    zfree(k, sizeof(struct key));
}

extern int clearflag;

void trashzle()
{				/**/
    if (zleactive) {
	refresh();
	moveto(nlnct, 0);
	if (clearflag && tccan(TCCLEAREOD)) {
	    tcout(TCCLEAREOD);
	    clearflag = 0;
	}
	printf("%s", postedit);
	fflush(stdout);
	resetneeded = 1;
	settyinfo(&shttyinfo);
    }
    if (errflag)
	kungetct = 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 *
 * zle_misc.c - miscellaneous editor routines
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define ZLE
#include "zsh.h"

void selfinsert()
{				/**/
    int ncs = cs + mult;

    if (complexpect && isset(AUTOPARAMKEYS)) {
	if (complexpect == 2 && c == '}') {
	    spaceinline(1);
	    line[cs - 1] = c;
	    line[cs++] = ' ';
	    return;
	} else if (complexpect == 1 &&
		   (c == '[' || c == ':' || c == '#' || c == '%' ||
		    c == '-' || c == '?' || c == '+')) {
	    line[cs - 1] = c;
	    return;
	}
    }
    if (mult < 0) {
	mult = -mult;
	ncs = cs;
    }
    if (insmode || ll == cs)
	spaceinline(mult);
    else if (mult + cs > ll)
	spaceinline(ll - (mult + cs));
    while (mult--)
	line[cs++] = c;
    cs = ncs;
}

void selfinsertunmeta()
{				/**/
    c &= 0x7f;
    if (c == '\r')
	c = '\n';
    selfinsert();
}

void deletechar()
{				/**/
    if (mult < 0) {
	mult = -mult;
	backwarddeletechar();
	return;
    }
    if (!(cs + mult > ll || line[cs] == '\n')) {
	cs += mult;
	backdel(mult);
    } else
	feep();
}

void backwarddeletechar()
{				/**/
    if (mult < 0) {
	mult = -mult;
	deletechar();
	return;
    }
    if (mult > cs)
	mult = cs;
    backdel(mult);
}

void vibackwarddeletechar()
{				/**/
    if (mult < 0) {
	mult = -mult;
	videletechar();
	return;
    }
    if (mult > cs)
	mult = cs;
    if (cs - mult < viinsbegin) {
	feep();
	return;
    }
    backkill(mult, 1);
}

void vikillline()
{				/**/
    if (viinsbegin > cs) {
	feep();
	return;
    }
    backdel(cs - viinsbegin);
}

void killwholeline()
{				/**/
    int i, fg;

    if (mult < 0)
	return;
    while (mult--) {
	if ((fg = (cs && cs == ll)))
	    cs--;
	while (cs && line[cs - 1] != '\n')
	    cs--;
	for (i = cs; i != ll && line[i] != '\n'; i++);
	forekill(i - cs + (i != ll), fg);
    }
}

void killbuffer()
{				/**/
    cs = 0;
    forekill(ll, 0);
}

void backwardkillline()
{				/**/
    int i = 0;

    if (mult < 0) {
	mult = -mult;
	killline();
	return;
    }
    while (mult--) {
	if (cs && line[cs - 1] == '\n')
	    cs--, i++;
	else
	    while (cs && line[cs - 1] != '\n')
		cs--, i++;
    }
    forekill(i, 1);
}

void gosmacstransposechars()
{				/**/
    int cc;

    if (cs < 2 || line[cs - 1] == '\n' || line[cs - 2] == '\n') {
	if (line[cs] == '\n' || line[cs + 1] == '\n') {
	    feep();
	    return;
	}
	cs += (cs == 0 || line[cs - 1] == '\n') ? 2 : 1;
    }
    cc = line[cs - 2];
    line[cs - 2] = line[cs - 1];
    line[cs - 1] = cc;
}

void transposechars()
{				/**/
    int cc, ct;
    int neg = mult < 0;

    if (neg)
	mult = -mult;
    while (mult--) {
	if (!(ct = cs) || line[cs - 1] == '\n') {
	    if (ll == cs || line[cs] == '\n') {
		feep();
		return;
	    }
	    if (!neg)
		cs++;
	    ct++;
	}
	if (neg) {
	    if (cs && line[cs - 1] != '\n') {
		cs--;
		if (ct > 1 && line[ct - 2] != '\n')
		    ct--;
	    }
	} else {
	    if (cs != ll && line[cs] != '\n')
		cs++;
	}
	if (ct == ll || line[ct] == '\n')
	    ct--;
	if (ct < 1 || line[ct - 1] == '\n') {
	    feep();
	    return;
	}
	cc = line[ct - 1];
	line[ct - 1] = line[ct];
	line[ct] = cc;
    }
}

void poundinsert()
{				/**/
    if (*line != '#') {
	cs = 0;
	spaceinline(1);
	*line = '#';
    } else {
	cs = 0;
	foredel(1);
    }
    done = 1;
}

void acceptline()
{				/**/
    done = 1;
}

void acceptandhold()
{				/**/
    pushnode(bufstack, ztrdup((char *)line));
    stackcs = cs;
    done = 1;
}

void killline()
{				/**/
    int i = 0;

    if (mult < 0) {
	mult = -mult;
	backwardkillline();
	return;
    }
    while (mult--) {
	if (line[cs] == '\n')
	    cs++, i++;
	else
	    while (cs != ll && line[cs] != '\n')
		cs++, i++;
    }
    backkill(i, 0);
}

void killregion()
{				/**/
    if (mark > ll)
	mark = ll;
    if (mark > cs)
	forekill(mark - cs, 0);
    else
	backkill(cs - mark, 1);
}

void copyregionaskill()
{				/**/
    if (mark > ll)
	mark = ll;
    if (mark > cs)
	cut(cs, mark - cs, 0);
    else
	cut(mark, cs - mark, 1);
}

static int kct, yankb, yanke;

void yank()
{				/**/
    int cc;
    char *buf = cutbuf;

    if (!cutbuf) {
	feep();
	return;
    }
    if (mult < 0)
	return;
    if (vibufspec) {
	if (!(buf = vibuf[vibufspec])) {
	    feep();
	    vibufspec = 0;
	    return;
	}
	vibufspec = 0;
    }
    yankb = cs;
    while (mult--) {
	kct = kringnum;
	cc = strlen(buf);
	spaceinline(cc);
	strncpy((char *)line + cs, buf, cc);
	cs += cc;
	yanke = cs;
    }
}

void viputafter()
{				/**/
    int cc;
    char *buf = cutbuf;

    if (!cutbuf) {
	feep();
	return;
    }
    if (mult < 0)
	return;
    if (vibufspec) {
	if (!(buf = vibuf[vibufspec])) {
	    feep();
	    vibufspec = 0;
	    return;
	}
	vibufspec = 0;
    }
    if (strchr(buf, '\n')) {
	cs = findeol();
	if (cs == ll) {
	    spaceinline(1);
	    line[cs] = '\n';
	}
    }
    if (cs != ll)
	cs++;
    yankb = cs;
    while (mult--) {
	kct = kringnum;
	cc = strlen(buf);
	spaceinline(cc);
	strncpy((char *)line + cs, buf, cc);
	cs += cc;
	yanke = cs;
    }
    cs = yankb;
}

void yankpop()
{				/**/
    int cc;

    if (!(lastcmd & ZLE_YANK) || !kring[kct]) {
	feep();
	return;
    }
    cs = yankb;
    foredel(yanke - yankb);
    cc = strlen(kring[kct]);
    spaceinline(cc);
    strncpy((char *)line + cs, kring[kct], cc);
    cs += cc;
    yanke = cs;
    kct = (kct - 1) & (KRINGCT - 1);
}

void overwritemode()
{				/**/
    insmode ^= 1;
}

void undefinedkey()
{				/**/
    feep();
}

void quotedinsert()
{				/**/
#ifndef HAS_TIO
    struct sgttyb sob;

    sob = shttyinfo.sgttyb;
    sob.sg_flags = (sob.sg_flags | RAW) & ~ECHO;
    ioctl(SHTTY, TIOCSETN, &sob);
#endif
    c = getkey(0);
#ifndef HAS_TIO
    setterm();
#endif
    if (c > 0)
	selfinsert();
    else
	feep();
}

void digitargument()
{				/**/
    int sign = (mult < 0 || (lastcmd & ZLE_NEGARG)) ? -1 : 1;

    if ((lastcmd & (ZLE_ARG | ZLE_NEGARG)) != ZLE_ARG)
	mult = 0;
    mult = mult * 10 + sign * (c & 0xf);
}

void negargument()
{				/**/
    if (lastcmd & ZLE_ARG)
	feep();
    mult = -1;
}

void universalargument()
{				/**/
    if (!(lastcmd & ZLE_ARG))
	mult = 4;
    else
	mult *= 4;
}

void copyprevword()
{				/**/
    int len, t0;

    for (t0 = cs - 1; t0 >= 0; t0--)
	if (iword(line[t0]))
	    break;
    for (; t0 >= 0; t0--)
	if (!iword(line[t0]))
	    break;
    if (t0)
	t0++;
    len = cs - t0;
    spaceinline(len);
    strncpy((char *)line + cs, (char *)line + t0, len);
    cs += len;
}

void sendbreak()
{				/**/
    errflag = 1;
}

void undo()
{				/**/
    char *s;
    struct undoent *ue;

    ue = undos + undoct;
    if (!ue->change) {
	feep();
	return;
    }
    line[ll] = '\0';
    s = ztrdup((char *)line + ll - ue->suff);
    sizeline((ll = ue->pref + ue->suff + ue->len) + 1);
    strncpy((char *)line + ue->pref, ue->change, ue->len);
    strcpy((char *)line + ue->pref + ue->len, s);
    zsfree(s);
    ue->change = NULL;
    undoct = (undoct - 1) & (UNDOCT - 1);
    cs = ue->cs;
}

void quoteregion()
{				/**/
    char *s, *t;
    int x, y;

    if (mark > ll)
	mark = ll;
    if (mark < cs) {
	x = mark;
	mark = cs;
	cs = x;
    }
    s = (char *)hcalloc((y = mark - cs) + 1);
    strncpy(s, (char *)line + cs, y);
    s[y] = '\0';
    foredel(mark - cs);
    t = makequote(s);
    spaceinline(x = strlen(t));
    strncpy((char *)line + cs, t, x);
    mark = cs;
    cs += x;
}

void quoteline()
{				/**/
    char *s;

    line[ll] = '\0';
    s = makequote((char *)line);
    setline(s);
}

char *makequote(s)		/**/
char *s;
{
    int qtct = 0;
    char *l, *ol;

    for (l = s; *l; l++)
	if (*l == '\'')
	    qtct++;
    l = ol = (char *)halloc((qtct * 3) + 3 + strlen(s));
    *l++ = '\'';
    for (; *s; s++)
	if (*s == '\'') {
	    *l++ = '\'';
	    *l++ = '\\';
	    *l++ = '\'';
	    *l++ = '\'';
	} else
	    *l++ = *s;
    *l++ = '\'';
    *l = '\0';
    return ol;
}

#define NAMLEN 70

int executenamedcommand()
{				/**/
    char buf[NAMLEN], *ptr;
    int len, cmd, t0;

    strcpy(buf, "execute: ");
    ptr = buf + 9;
    len = 0;
    statusline = buf;
    refresh();
    for (;; refresh()) {
	if ((cmd = getkeycmd()) < 0 || cmd == z_sendbreak) {
	    statusline = NULL;
	    return z_undefinedkey;
	}
	switch (cmd) {
	case z_backwarddeletechar:
	case z_vibackwarddeletechar:
	    if (len) {
		len--;
		*--ptr = '\0';
	    }
	    break;
	case z_killregion:
	case z_backwardkillword:
	case z_vibackwardkillword:
	    while (len && (len--, *--ptr != '-'))
		*ptr = '\0';
	    break;
	case z_killwholeline:
	case z_vikillline:
	case z_backwardkillline:
	    len = 0;
	    ptr = buf + 9;
	    *ptr = '\0';
	    break;
	case z_acceptline:
	    for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
		if (!strcmp(buf + 9, zlecmds[t0].name))
		    break;
	    if (t0 != ZLECMDCOUNT) {
		lastnamed = t0;
		statusline = NULL;
		return t0;
	    } else {
		feep();
		break;
	    }
	default:
	    if (cmd == z_listchoices || cmd == z_deletecharorlist ||
		c == ' ' || c == '\t') {
		Lklist cmdll;
		int ambig = 100;

		heapalloc();
		cmdll = newlist();
		for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
		    if (strpfx(buf + 9, zlecmds[t0].name)) {
			int xx;

			addnode(cmdll, zlecmds[t0].name);
			xx = pfxlen(peekfirst(cmdll), zlecmds[t0].name);
			if (xx < ambig)
			    ambig = xx;
		    }
		permalloc();
		if (empty(cmdll))
		    feep();
		else if (cmd == z_listchoices ||
			 cmd == z_deletecharorlist)
		    listlist(cmdll);
		else if (!nextnode(firstnode(cmdll))) {
		    strcpy(buf + 9, peekfirst(cmdll));
		    ptr = buf + (len = strlen(buf));
		} else {
		    strcpy(buf + 9, peekfirst(cmdll));
		    len = ambig;
		    ptr = buf + 9 + len;
		    *ptr = '\0';
		    feep();
		    if (isset(AUTOLIST))
			listlist(cmdll);
		}
	    } else {
		if (len == NAMLEN - 10 || icntrl(c))
		    feep();
		else
		    *ptr++ = c, *ptr = '\0', len++;
	    }
	}
    }
}

void vijoin()
{				/**/
    int x;

    if ((x = findeol()) == ll) {
	feep();
	return;
    }
    cs = x + 1;
    for (x = 1; cs != ll && iblank(line[cs]); cs++, x++);
    backdel(x);
    spaceinline(1);
    line[cs] = ' ';
}

void viswapcase()
{				/**/
    if (cs < ll) {
	int ch = line[cs];

	if (islower(ch))
	    ch = tuupper(ch);
	else if (isupper(ch))
	    ch = tulower(ch);
	line[cs] = ch;
	if (cs != ll - 1)
	    cs++;
    }
}

void vicapslockpanic()
{				/**/
    char ch;

    statusline = "press a lowercase key to continue";
    refresh();
    do
	ch = getkey(0);
    while (!islower(ch));
}

int owrite;

void visetbuffer()
{				/**/
    int ch;

    ch = getkey(0);
    if (!isalnum(ch)) {
	feep();
	return;
    }
    if (ch >= 'A' && ch <= 'Z')	/* needed in cut() */
	owrite = 0;
    else
	owrite = 1;
    vibufspec = tolower(ch) + (idigit(ch)) ? -'1' + 26 : -'a';
}

static char *bp;
static int lensb, countp;

void stradd(d)			/**/
char *d;
{
    while ((*bp++ = *d++));
    bp--;
}

int putstr(d)			/**/
int d;
{
    *bp++ = d;
    if (countp)
	lensb++;
    return 0;
}

void tstradd(X)			/**/
char *X;
{
    int t0;

    if (termok && unset(SINGLELINEZLE)) {
#ifdef _IBMR2
    /* AIX tgetstr() ignores second argument */
	char *tbuf;

	if (tbuf = tgetstr(X, &tbuf))
#else
	char tbuf[2048], *tptr = tbuf;

	if (tgetstr(X, &tptr))
#endif
	    tputs(tbuf, 1, putstr);
	if (*X == 's' && (X[1] == 'o' || X[1] == 'e') &&
	    (t0 = tgetnum("sg")) > -1)
	    lensb -= t0;
    }
}

/* get a prompt string */

static char *buf, *bl0, *fm;
static int bracepos;

char *putprompt(fmin, lenp, isspell)	/**/
char *fmin;
int *lenp;
int isspell;
{
    static char buf0[256], buf1[256], buf2[256];

    bracepos = 0;
    lensb = 0;
    countp = 1;
    fm = fmin;
    if (!fm) {
	*lenp = 0;
	return "";
    }
/* KLUDGE ALERT!  What we have here are three buffers:
	 *  buf1 and buf2 alternate between PS1 and PS2, though which is
	 *   which is indeterminate depending on spellchecking, "select",
	 *   etc. -- those operations also share these two buffers.
	 *  buf0 is used for any prompting that manages to happen while
	 *   zleread() is in progress (signal traps, etc.), because
	 *   zleread() re-uses the pointers returned to buf1 and buf2
	 *   and will be confused if either of those is overwritten.
	 */
    buf = zleactive ? buf0 : ((buf == buf1) ? buf2 : buf1);
    bp = bl0 = buf;
    if (!columns)
	columns = 80;
    clearerr(stdin);

    putpromptchar(isspell == -1 ? 0 : isspell, 1, '\0');

    if (isspell != -1) {
	*lenp = (bp - bl0) - lensb;
	*lenp %= columns;
	if (*lenp == columns - 1) {
	    *lenp = 0;
	    *bp++ = ' ';
	}
    } else
	*lenp = (bp - bl0);
    *bp = '\0';

    *bp = '\0';
    return buf;
}

int putpromptchar(isspell, doprint, endchar)	/**/
int isspell;
int doprint;
int endchar;
{
    char buf3[MAXPATHLEN], *ss;
    int t0, arg, test, sep;
    struct tm *tm;
    time_t timet;

    if (isset(PROMPTSUBST)) {
	char *sss;

	fm = dupstring(fm);
	for (ss = fm; *ss; ss++)
	    if (*ss == '$' && ss[1] && (ss == fm || ss[-1] != '%')) {
		*ss = String;
		if (ss[1] == '[') {
		    ss[1] = Inbrack;
		    for (t0 = 0, sss = ss + 2; *sss && (t0 || *sss != ']'); sss++) {
			if (*sss == '[')
			    t0++;
			if (*sss == ']')
			    t0--;
			if (*sss == '\\' && sss[1])
			    sss++;
		    }
		    if (*sss == ']')
			*sss = Outbrack, ss = sss;
		} else if (ss[1] == '(') {
		    ss[1] = Inpar;
		    for (t0 = 0, sss = ss + 2; *sss && (t0 || *sss != ')'); sss++) {
			if (*sss == '(')
			    t0++;
			if (*sss == ')')
			    t0--;
			if (*sss == '\\' && sss[1])
			    sss++;
		    }
		    if (*sss == ')')
			*sss = Outpar, ss = sss;
		}
	    }
	lexsave();
	singsub(&fm);
	lexrestore();
    }
    for (; *fm && *fm != endchar; fm++) {
	if (bp - buf >= 220)
	    break;
	arg = 0;
	if (*fm == '%') {
	    if (idigit(*++fm)) {
		arg = zstrtol(fm, &fm, 10);
	    }
	    if (*fm == '(') {
		int tc;

		if (idigit(*++fm)) {
		    arg = zstrtol(fm, &fm, 10);
		}
		test = 0;
		ss = pwd;
		switch (tc = *fm) {
		case 'c':
		case '.':
		case '~':
		    t0 = finddir(ss);
		    if (t0 != -1) {
			arg--;
			ss += namdirs[t0].len;
		    }
		case '/':
		case 'C':
		    for (; *ss; ss++)
			if (*ss == '/')
			    arg--;
		    if (arg <= 0)
			test = 1;
		    break;
		case 't':
		case 'T':
		case 'd':
		case 'D':
		case 'w':
		    timet = time(NULL);
		    tm = localtime(&timet);
		    switch (tc) {
		    case 't':
			test = (arg == tm->tm_min);
			break;
		    case 'T':
			test = (arg == tm->tm_hour);
			break;
		    case 'd':
			test = (arg == tm->tm_mday);
			break;
		    case 'D':
			test = (arg == tm->tm_mon);
			break;
		    case 'w':
			test = (arg == tm->tm_wday);
			break;
		    }
		    break;
		case '?':
		    if (lastval == arg)
			test = 1;
		    break;
		case '#':
		    if (geteuid() == arg)
			test = 1;
		    break;
		case 'g':
		    if (getegid() == arg)
			test = 1;
		    break;
		case 'L':
		    if (shlvl >= arg)
			test = 1;
		    break;
		case 'S':
		    if (time(NULL) - shtimer.tv_sec >= arg)
			test = 1;
		    break;
		case 'v':
		    if (arrlen(psvar) >= arg)
			test = 1;
		    break;
		case '_':
		    test = (cmdsp >= arg);
		    break;
		default:
		    test = -1;
		    break;
		}
		if (!*fm || !(sep = *++fm))
		    return 0;
		fm++;
		if (!putpromptchar(isspell, test == 1 && doprint, sep) || !*++fm ||
		    !putpromptchar(isspell, test == 0 && doprint, ')')) {
		    return 0;
		}
		continue;
	    }
	    if (!doprint)
		continue;
	    switch (*fm) {
	    case '~':
		t0 = finddir(pwd);
		if (t0 != -1) {
		    *bp++ = '~';
		    stradd(namdirs[t0].name);
		    stradd(pwd + namdirs[t0].len);
		    break;
		}
	    case 'd':
	    case '/':
		stradd(pwd);
		break;
	    case 'c':
	    case '.':
		t0 = finddir(pwd);
		if (t0 != -1) {
		    sprintf(buf3, "~%s%s", namdirs[t0].name,
			    pwd + namdirs[t0].len);
		} else {
		    strcpy(buf3, pwd);
		}
		if (!arg)
		    arg++;
		for (ss = buf3 + strlen(buf3); ss > buf3; ss--)
		    if (*ss == '/' && !--arg) {
			ss++;
			break;
		    }
		if (*ss == '/' && ss[1] && (ss != buf3))
		    ss++;
		stradd(ss);
		break;
	    case 'C':
		strcpy(buf3, pwd);
		if (!arg)
		    arg++;
		for (ss = buf3 + strlen(buf3); ss > buf3; ss--)
		    if (*ss == '/' && !--arg) {
			ss++;
			break;
		    }
		if (*ss == '/' && ss[1] && (ss != buf3))
		    ss++;
		stradd(ss);
		break;
	    case 'h':
	    case '!':
		sprintf(bp, "%d", curhist);
		bp += strlen(bp);
		break;
	    case 'M':
		stradd(hostnam);
		break;
	    case 'm':
		if (!arg)
		    arg++;
		for (ss = hostnam; *ss; ss++)
		    if (*ss == '.' && !--arg)
			break;
		t0 = *ss;
		*ss = '\0';
		stradd(hostnam);
		*ss = t0;
		break;
	    case 'S':
		tstradd("so");
		break;
	    case 's':
		tstradd("se");
		break;
	    case 'B':
		tstradd("md");
		break;
	    case 'b':
		tstradd("me");
		break;
	    case 'U':
		tstradd("us");
		break;
	    case 'u':
		tstradd("ue");
		break;
	    case '{':
		bracepos = bp - buf;
		countp = 0;
		break;
	    case '}':
		lensb += (bp - buf) - bracepos;
		countp = 1;
		break;
	    case 't':
	    case '@':
	    case 'T':
	    case '*':
	    case 'w':
	    case 'W':
	    case 'D':
		{
		    char *tmfmt, *dd;

		    switch (*fm) {
		    case 'T':
			tmfmt = "%k:%M";
			break;
		    case '*':
			tmfmt = "%k:%M:%S";
			break;
		    case 'w':
			tmfmt = "%a %e";
			break;
		    case 'W':
			tmfmt = "%m/%d/%y";
			break;
		    case 'D':
			tmfmt = "%y-%m-%d";
			if (fm[1] == '{') {
			    for (ss = fm + 2, dd = buf3; *ss && *ss != '}'; ++ss, ++dd)
				*dd = *((*ss == '\\' && ss[1]) ? ++ss : ss);
			    if (*ss == '}') {
				*dd = '\0';
				fm = ss;
				tmfmt = buf3;
			    }
			}
			break;
		    default:
			tmfmt = "%l:%M%p";
			break;
		    }
		    timet = time(NULL);
		    tm = localtime(&timet);
		    ztrftime(bp, buf + 220 - bp, tmfmt, tm);
		    if (*bp == ' ')
			chuck(bp);
		    bp += strlen(bp);
		    break;
		}
	    case 'n':
		stradd(username);
		break;
	    case 'l':
		if (*ttystrname)
		    stradd((strncmp(ttystrname, "/dev/tty", 8) ?
			    ttystrname + 5 : ttystrname + 8));
		else
		    stradd("()");
		break;
	    case '?':
		sprintf(bp, "%ld", (long)lastval);
		bp += strlen(bp);
		break;
	    case '%':
		*bp++ = '%';
		break;
	    case '#':
		*bp++ = (geteuid())? '%' : '#';
		break;
	    case 'v':
		if (!arg)
		    arg++;
	    /* The number 35 here comes from 256-220-1, where 256 is
	       sizeof(buf), 220 is from the overflow test made at the
	       top of the loop, and 1 is for the \0 byte at the end. */

		if (arrlen(psvar) >= arg && (int)strlen(psvar[arg - 1]) < 35)
		    stradd(psvar[arg - 1]);
		else
		    stradd("");
		break;
	    case 'E':
		tstradd("ce");
		break;
	    case '_':
		if (cmdsp) {
		    if (arg <= 0)
			arg = 1;
		    if (arg > cmdsp)
			arg = cmdsp;
		    for (t0 = cmdsp - arg; arg--; t0++) {
			stradd(cmdnames[cmdstack[t0]]);
			if (arg)
			    stradd(" ");
		    }
		}
		break;
	    case 'r':
		if (isspell) {
		    stradd(rstring);
		    break;
		}
	    case 'R':
		if (isspell) {
		    stradd(Rstring);
		    break;
		}
	    default:
		*bp++ = '%';
		*bp++ = *fm;
		break;
	    }
	} else if (*fm == '!' && doprint) {
	    sprintf(bp, "%d", curhist);
	    bp += strlen(bp);
	} else {
	    if (fm[0] == '\\' && fm[1])
		fm++;
	    if (doprint && (*bp++ = *fm) == '\n')
		bl0 = bp, lensb = 0;
	}
    }

    return *fm;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#/*
 *
 * zle_move.c - editor movement
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define ZLE
#include "zsh.h"

static vimarkcs[27], vimarkline[27];

void beginningofline()
{				/**/
    if (mult < 0) {
	mult = -mult;
	endofline();
	return;
    }
    while (mult--) {
	if (cs == 0)
	    return;
	if (line[cs - 1] == '\n')
	    if (!--cs)
		return;
	while (cs && line[cs - 1] != '\n')
	    cs--;
    }
}

void endofline()
{				/**/
    if (mult < 0) {
	mult = -mult;
	beginningofline();
	return;
    }
    while (mult--) {
	if (cs >= ll) {
	    cs = ll;
	    return;
	}
	if (line[cs] == '\n')
	    if (++cs == ll)
		return;
	while (cs != ll && line[cs] != '\n')
	    cs++;
    }
}

void beginningoflinehist()
{				/**/
    if (mult < 0) {
	mult = -mult;
	endoflinehist();
	return;
    }
    while (mult) {
	if (cs == 0)
	    break;
	if (line[cs - 1] == '\n')
	    if (!--cs)
		break;
	while (cs && line[cs - 1] != '\n')
	    cs--;
	mult--;
    }
    if (mult) {
	uphistory();
	cs = 0;
    }
}

void endoflinehist()
{				/**/
    if (mult < 0) {
	mult = -mult;
	beginningoflinehist();
	return;
    }
    while (mult) {
	if (cs >= ll) {
	    cs = ll;
	    break;
	}
	if (line[cs] == '\n')
	    if (++cs == ll)
		break;
	while (cs != ll && line[cs] != '\n')
	    cs++;
	mult--;
    }
    if (mult)
	downhistory();
}

void forwardchar()
{				/**/
    cs += mult;
    if (cs > ll)
	cs = ll;
    if (cs < 0)
	cs = 0;
}

void backwardchar()
{				/**/
    cs -= mult;
    if (cs > ll)
	cs = ll;
    if (cs < 0)
	cs = 0;
}

void setmarkcommand()
{				/**/
    mark = cs;
}

void exchangepointandmark()
{				/**/
    int x;

    x = mark;
    mark = cs;
    cs = x;
    if (cs > ll)
	cs = ll;
}

void vigotocolumn()
{				/**/
    int x, y, ocs = cs;

    if (mult > 0)
	mult--;
    findline(&x, &y);
    if (mult >= 0)
	cs = x + mult;
    else
	cs = y + mult;
    if (cs < x || cs > y) {
	feep();
	cs = ocs;
    }
}

void vimatchbracket()
{				/**/
    int ocs = cs, dir, ct;
    unsigned char oth, me;

  otog:
    if (cs == ll) {
	feep();
	cs = ocs;
	return;
    }
    switch (me = line[cs]) {
    case '{':
	dir = 1;
	oth = '}';
	break;
    case '}':
	dir = -1;
	oth = '{';
	break;
    case '(':
	dir = 1;
	oth = ')';
	break;
    case ')':
	dir = -1;
	oth = '(';
	break;
    case '[':
	dir = 1;
	oth = ']';
	break;
    case ']':
	dir = -1;
	oth = '[';
	break;
    default:
	cs++;
	goto otog;
    }
    ct = 1;
    while (cs >= 0 && cs < ll && ct) {
	cs += dir;
	if (line[cs] == oth)
	    ct--;
	else if (line[cs] == me)
	    ct++;
    }
    if (cs < 0 || cs >= ll) {
	feep();
	cs = ocs;
    }
}

void viforwardchar()
{				/**/
    if (mult < 0) {
	mult = -mult;
	vibackwardchar();
	return;
    }
    while (mult--) {
	cs++;
	if (cs >= ll || line[cs] == '\n') {
	    cs--;
	    break;
	}
    }
}

void vibackwardchar()
{				/**/
    if (mult < 0) {
	mult = -mult;
	viforwardchar();
	return;
    }
    while (mult--) {
	cs--;
	if (cs < 0 || line[cs] == '\n') {
	    cs++;
	    break;
	}
    }
}

void viendofline()
{				/**/
    cs = findeol();
    if (!virangeflag && cs != 0 && line[cs - 1] != '\n')
	cs--;
}

void vibeginningofline()
{				/**/
    cs = findbol();
}

static int vfindchar, vfinddir, tailadd;

void vifindnextchar()
{				/**/
    if ((vfindchar = vigetkey())) {
	vfinddir = 1;
	tailadd = 0;
	virepeatfind();
    }
}

void vifindprevchar()
{				/**/
    if ((vfindchar = vigetkey())) {
	vfinddir = -1;
	tailadd = 0;
	virepeatfind();
    }
}

void vifindnextcharskip()
{				/**/
    if ((vfindchar = vigetkey())) {
	vfinddir = 1;
	tailadd = -1;
	virepeatfind();
    }
}

void vifindprevcharskip()
{				/**/
    if ((vfindchar = vigetkey())) {
	vfinddir = -1;
	tailadd = 1;
	virepeatfind();
    }
}

void virepeatfind()
{				/**/
    int ocs = cs;

    if (!vfinddir) {
	feep();
	return;
    }
    if (mult < 0) {
	mult = -mult;
	virevrepeatfind();
	return;
    }
    while (mult--) {
	do
	    cs += vfinddir;
	while (cs >= 0 && cs < ll && line[cs] != vfindchar && line[cs] != '\n');
	if (cs < 0 || cs >= ll || line[cs] == '\n') {
	    feep();
	    cs = ocs;
	    return;
	}
    }
    cs += tailadd;
    if (vfinddir == 1 && virangeflag)
	cs++;
}

void virevrepeatfind()
{				/**/
    if (mult < 0) {
	mult = -mult;
	virepeatfind();
	return;
    }
    vfinddir = -vfinddir;
    virepeatfind();
    vfinddir = -vfinddir;
}

void vifirstnonblank()
{				/**/
    cs = findbol();
    while (cs != ll && iblank(line[cs]))
	cs++;
}

void visetmark()
{				/**/
    int ch;

    ch = getkey(0);
    if (ch < 'a' || ch > 'z') {
	feep();
	return;
    }
    ch -= 'a';
    vimarkcs[ch] = cs;
    vimarkline[ch] = histline;
}

void vigotomark()
{				/**/
    int ch;

    ch = getkey(0);
    if (ch == c)
	ch = 26;
    else {
	if (ch < 'a' || ch > 'z') {
	    feep();
	    return;
	}
	ch -= 'a';
    }
    if (!vimarkline[ch]) {
	feep();
	return;
    }
    if (curhist != vimarkline[ch]) {
	mult = vimarkline[ch];
	lastcmd |= ZLE_ARG;
	vifetchhistory();
	if (histline != vimarkline[ch])
	    return;
    }
    cs = vimarkcs[ch];
}

void vigotomarkline()
{				/**/
    vigotomark();
    cs = findbol();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      = *nbuf, refreshop = *obuf; *vp; t0++, vp++) {
	if (*vp != *refreshop && !(*vp == ' ' && !*refreshop)) {
	    singmoveto(t0);
	    putchar(*vp);
	    vcs++;
	}
	if (*refreshop)
	    refreshop++;
    }
    if (*refreshop) {
	singmoveto(t0);
	for (; *refreshop; refreshop++) {
	    putchar(' ');
	    vcs++;
	}
    }
    singmoveto(nvcs);
    qbuf = nbuf;
    nbuf = obuf;
    obuf = qbuf;
    fflush(stdout);
}

void singmoveto(pos)		/**/
int pos;
{
    while (pos < vcs) {
	vcs--;
	putchar('\b');
    }
    while (pos > vcs) {
	putchar(nbuf[0][vcs]);
	vcs++;
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /*
 *
 * zle_refresh.c - screen update
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define ZLE
#include "zsh.h"

char **obuf = NULL, **nbuf = NULL;
static int olnct, vcs, vln, vmaxln, winw, winh, winpos, ovln;

void resetvideo()
{				/**/
    int ln;
    static int lwinw = -1, lwinh = -1;

    winw = columns;
    if (isset(SINGLELINEZLE) || !termok)
	winh = 1;
    else
	winh = (lines < 2) ? 24 : lines;
    winpos = vln = vmaxln = 0;
    if (lwinw != winw || lwinh != winh) {
	if (nbuf) {
	    for (ln = 0; ln != lwinh; ln++) {
		zfree(nbuf[ln], winw + 1);
		zfree(obuf[ln], winw + 1);
	    }
	    free(nbuf);
	    free(obuf);
	}
	nbuf = (char **)zcalloc((winh + 1) * sizeof(char *));
	obuf = (char **)zcalloc((winh + 1) * sizeof(char *));

	nbuf[0] = (char *)zalloc(winw + 1);
	obuf[0] = (char *)zalloc(winw + 1);

	lwinw = winw;
	lwinh = winh;
    }
    for (ln = 0; ln != winh + 1; ln++) {
	if (nbuf[ln])
	    *nbuf[ln] = '\0';
	if (obuf[ln])
	    *obuf[ln] = '\0';
    }

    if (pptlen) {
	for (ln = 0; ln != pptlen; ln++)
	    nbuf[0][ln] = obuf[0][ln] = ' ';
	nbuf[0][pptlen] = obuf[0][pptlen] = '\0';
    }
    vcs = pptlen;
    olnct = nlnct = 1;
}

int scrollwindow()
{				/**/
    int t0, hwinh = winh / 2;

    for (t0 = 0; t0 != winh - hwinh; t0++) {
	char *s;

	s = nbuf[t0];
	nbuf[t0] = nbuf[t0 + hwinh];
	nbuf[t0 + hwinh] = s;
    }
    for (t0 = 0; t0 < pptlen - 1; t0++)
	nbuf[0][t0] = ' ';
    strcpy(nbuf[0] + t0, "> ...");
    return winh - hwinh;
}

/* this is the messy part. */
/* this define belongs where it's used!!! */

#define nextline { *s = (unsigned char)'\0'; \
	if (winh == ln+1) if (nvln != -1) break; else ln = scrollwindow()-1; \
	if (!nbuf[++ln]) nbuf[ln] = (char *)zalloc(winw + 1); \
	s = (unsigned char *)nbuf[ln]; sen = s+winw; \
	}

#ifdef TIOCGWINSZ
int winchanged;

#endif

int hasam;
static oput_rprompt;
extern int clearflag;

void refresh()
{				/**/
    unsigned char *s, *t, *sen, *scs = line + cs;
    char **qbuf;
    int ln = 0, nvcs = 0, nvln = -1, t0 = -1, put_rprompt, res = 0;

#ifdef HAS_SELECT
    cost = 0;
#endif
    if (resetneeded) {
	setterm();
#ifdef TIOCGWINSZ
	if (winchanged) {
	    moveto(0, 0);
	    t0 = olnct;		/* this is to clear extra lines even when */
	    winchanged = 0;	/* the terminal cannot TCCLEAREOD */
	}
#endif
	resetvideo();
	resetneeded = 0;
	oput_rprompt = 0;
	if (!clearflag)
	    if (tccan(TCCLEAREOD))
		tcout(TCCLEAREOD);
	    else
		res = 1;
	if (t0 > -1)
	    olnct = t0;
	if (isset(SINGLELINEZLE) || !termok)
	    vcs = 0;
	else if (pmpt && !clearflag)
	    fputs(pmpt, stdout), fflush(stdout);
	if (clearflag)
	    putchar('\r'), vcs = 0, moveto(0, pptlen);
    }
    if (isset(SINGLELINEZLE) || !termok) {
	singlerefresh();
	return;
    }
/* first, we generate the video line buffers so we know what to
	put on the screen.

	s = ptr into the video buffer.
	t = ptr into the real buffer.
	sen = end of the video buffer (eol)
*/

    s = (unsigned char *)(nbuf[ln = 0] + pptlen);
    t = line;
    sen = (unsigned char *)(*nbuf + winw);
    for (; *t; t++) {
	if (icntrl(*t))
	    if (*t == '\n') {
		if (t == scs) {
		    if ((nvcs = (char *)s - nbuf[nvln = ln]) == columns)
			nvcs = 0, nvln++;
		    scs = NULL;
		}
		if (s == sen)
		    nextline;
		nextline;
	    } else if ((char)*t == '\t') {
		t0 = (char *)s - nbuf[ln];
		if (t == scs) {
		    nvln = ln;
		    scs = NULL;
		    if ((nvcs = t0) == columns)
			nvcs = 0, nvln++;
		}
		if ((t0 | 7) + 1 >= winw) {
		    nextline;
		    if (t0 == columns)
			for (t0 = 8; t0; t0--)
			    *s++ = ' ';	/* make tab in first column visible */
		} else {
		    if (t0 == winw) {
			t0 = 0;
			nextline;
		    }
		    do
			*s++ = ' ';
		    while ((++t0) & 7);
		}
	    } else {
		if (s == sen)
		    nextline;
		*s++ = '^';
		if (t == scs)
		    nvcs = s - (unsigned char *)(nbuf[nvln = ln]) - 1,
			scs = NULL;
		if (s == sen)
		    nextline;
		*s++ = (*t == 127) ? '?' : (*t | '@');
	} else {
	    if (s == sen)
		nextline;
	    *s++ = *t;
	}
    /* if the cursor is here, remember it */

	if (t == scs)
	    nvcs = s - (unsigned char *)(nbuf[nvln = ln]) - 1;
    }
    if (scs == t && (nvcs = s - (unsigned char *)(nbuf[nvln = ln])) == columns)
	nvcs = 0, nvln++;
    *s = '\0';
    nlnct = ln + 1;

    if (statusline) {
	if (!nbuf[(nlnct == winh) ? winh - 1 : nlnct++])
	    nbuf[nlnct - 1] = (char *)zalloc(winw + 1);
	s = (unsigned char *)nbuf[nlnct - 1];
	t = (unsigned char *)statusline;
	sen = (unsigned char *)(*nbuf + winw);
	for (; *t; t++) {
	    if (icntrl(*t)) {	/* simplified processing in the status line */
		if (s == sen)
		    nextline;
		*s++ = '^';
		if (s == sen)
		    nextline;
		*s++ = (*t == 127) ? '?' : (*t | '@');
	    } else {
		if (s == sen)
		    nextline;
		*s++ = *t;
	    }
	}
	*s = '\0';
    }
    for (ln = nlnct; ln < winh; ln++)
	zfree(nbuf[ln], winw + 1), nbuf[ln] = NULL;

/* do RPROMPT */

    put_rprompt = pmpt2 && (int)strlen(nbuf[0]) + ppt2len < winw - 1;
    if (put_rprompt) {
	for (t0 = strlen(nbuf[0]); t0 != winw - 1 - ppt2len; t0++)
	    nbuf[0][t0] = ' ';
	nbuf[0][t0] = '\0';
    }
    for (ln = 0; ln < nlnct; ln++) {

    /* if old line and new line are different,
       see if we can insert/delete a line */

	if (ln < olnct - 1 && !(hasam && vcs == columns) &&
	    nbuf[ln] && obuf[ln] &&
	    strncmp(nbuf[ln], obuf[ln], 16)) {
	    if (tccan(TCDELLINE) && obuf[ln + 1] && obuf[ln + 1][0] &&
		nbuf[ln] && !strncmp(nbuf[ln], obuf[ln + 1], 16)) {
		moveto(ln, 0);
		tcout(TCDELLINE);
		zfree(obuf[ln], winw + 1);
		for (t0 = ln; t0 != olnct; t0++)
		    obuf[t0] = obuf[t0 + 1];
		obuf[--olnct] = NULL;
	    }
	/* don't try to insert a line if olnct = vmaxln (vmaxln is the number
	   of lines that have been displayed by this routine) so that we don't
	   go off the end of the screen. */

	    else if (tccan(TCINSLINE) && olnct < vmaxln && nbuf[ln + 1] &&
		     obuf[ln] && !strncmp(nbuf[ln + 1], obuf[ln], 16)) {
		moveto(ln, 0);
		tcout(TCINSLINE);
		for (t0 = olnct; t0 != ln; t0--)
		    obuf[t0] = obuf[t0 - 1];
		obuf[ln] = NULL;
		olnct++;
	    }
	}
	if (res && tccan(TCCLEAREOL)) {
	    moveto(ln, 0);
	    tcout(TCCLEAREOL);
	    refreshline(ln, put_rprompt, 0);
	} else
	    refreshline(ln, put_rprompt, res);
	if (!ln && put_rprompt && !oput_rprompt) {
	    moveto(0, winw - 1 - ppt2len);
	    fputs(pmpt2, stdout);
	    vcs = winw - 1;
	}
    }

/* if old buffer had extra lines, do a clear-end-of-display if we can,
   otherwise, just fill new buffer with blank lines and refresh them */

    if (olnct > nlnct)
	if (tccan(TCCLEAREOD)) {
	    moveto(nlnct, 0);
	    tcout(TCCLEAREOD);
	} else
	    for (ln = nlnct; ln < olnct; ln++)
		if (res && tccan(TCCLEAREOL)) {
		    moveto(ln, 0);
		    tcout(TCCLEAREOL);
		    refreshline(ln, put_rprompt, 0);
		} else
		    refreshline(ln, put_rprompt, res);

/* move to the new cursor position */

    moveto(nvln, nvcs);

    if (isset(ALWAYSLASTPROMPT) &&
	(!nvcs || (nvln == ovln + 1)) &&
	cs == ll &&
	tccan(TCCLEAREOL))
	tcout(TCCLEAREOL);

    ovln = nvln;
    qbuf = nbuf;
    nbuf = obuf;
    obuf = qbuf;
    olnct = nlnct;
    oput_rprompt = put_rprompt;
    if (nlnct > vmaxln)
	vmaxln = nlnct;
    fflush(stdout);
}

#define tcinscost(X) (tccan(TCMULTINS) ? tclen[TCMULTINS] : (X)*tclen[TCINS])
#define tcdelcost(X) (tccan(TCMULTDEL) ? tclen[TCMULTDEL] : (X)*tclen[TCDEL])
#define tc_delchars(X) tcmultout(TCDEL,TCMULTDEL,(X))
#define tc_inschars(X) tcmultout(TCINS,TCMULTINS,(X))
#define tc_upcurs(X) tcmultout(TCUP,TCMULTUP,(X))
#define tc_leftcurs(X) tcmultout(TCLEFT,TCMULTLEFT,(X))

void refreshline(ln, put_rprompt, res)	/**/
int ln;
int put_rprompt;
int res;
{
/* the test in nl below is to prevent a segv if the terminal cannot clear
   either to end of line or display, and nlnct < olnct :-( */

    char *nl = nbuf[ln] ? nbuf[ln] : obuf[0], *ol = obuf[ln] ? obuf[ln] : "", *p1;
    int ccs = 0;

    if (res) {
	char *p = hcalloc(winw + 1);

	memset(p, ' ', winw);
	strcpy(p, nl);
	p[strlen(p)] = ' ';
	nl = p;
    }
    if (hasam && vcs == columns) {	/* must always write another char */
	if (*nl) {		/* after writing in last column */
	    putchar(*nl);
	    nl++, vcs = ccs = 1;
	    if (*ol)
		ol++;
	} else
	    putchar('\r'), putchar('\n'), vcs = 0;
	vln++;
    }
    for (;;) {
	while (*nl && *nl == *ol) {
	    nl++, ol++, ccs++;
	}
	if (!*nl && !*ol)
	    if (!ln && !put_rprompt && oput_rprompt)
		if (tccan(TCCLEAREOL)) {
		    if (ccs < columns) {
			moveto(0, ccs);
			tcout(TCCLEAREOL);
		    }
		    return;
		} else {
		    int x = winw - 1 - ccs;

		    p1 = nl;
		    while (x--)
			*p1++ = ' ';
		    *p1 = '\0';
	    } else {
		if (hasam && ccs == columns && ln < nlnct - 1 &&
		    ln < olnct - 1 && *nbuf[ln + 1] &&
		    !*obuf[ln + 1]) {	/* force join of lines */
		    moveto(ln, ccs - 1);
		    putchar(nl[-1]);
#ifdef HAS_SELECT
		    cost++;
#endif
		    vcs++;
		}
		return;
	    }
    /* if this is the end of the new buffer but the old buffer has stuff
       here, clear to end of line if we can, otherwise fill the new buffer
       with blanks and continue. */

	if (!*nl) {
	    int x = strlen(ol);

	    if (tccan(TCCLEAREOL) &&
		(x > tclen[TCCLEAREOL] || (hasam && ccs + x == columns))) {
		moveto(ln, ccs);
		tcout(TCCLEAREOL);
		*ol = '\0';
		return;
	    } else {
		p1 = nl;
		while (x--)
		    *p1++ = ' ';
		*p1 = '\0';
		continue;
	    }
	}
    /* if this is the end of the old buffer, just dump the rest of the
       new buffer. */

	if (!*ol) {
	    while (!res && *nl == ' ')
		nl++, ccs++;
	    if (*nl) {
		moveto(ln, ccs);
		fwrite(nl, strlen(nl), 1, stdout);
#ifdef HAS_SELECT
		cost += strlen(nl);
#endif
		vcs += strlen(nl);

		if (oput_rprompt && !put_rprompt) {
		    ccs += strlen(nl);
		    *nl = '\0';
		    continue;
		}
	    } else if (hasam && ccs == columns) {	/* must always write */
		moveto(ln, ccs - 1);	/* last column */
		putchar(' '), vcs++;
#ifdef HAS_SELECT
		cost++;
#endif
	    }
	    return;
	}
    /* try to insert/delete characters unless there is an rprompt and the old
       line also had it; in this case the length is not changed so that we
       don't have to redraw the rprompt */

	moveto(ln, ccs);
	if (!ln && put_rprompt && oput_rprompt)
	    goto jump;

	if (ol[1] != nl[1] && tccan(TCDEL)) {
	    int ct = 0;

	    for (p1 = ol; *p1; p1++, ct++)
		if (tcdelcost(ct) < pfxlen(p1, nl)) {
		    tc_delchars(ct);
		    ol = p1;
		    break;
		}
	    if (*p1)
		continue;
	}
	if (ol[1] != nl[1] && tccan(TCINS)) {
	    int ct = 0;

	    for (p1 = nl; *p1; p1++, ct++)
		if (tcinscost(ct) < pfxlen(p1, ol) + ct) {
		/* make sure we aren't inserting characters off the end of the
		   screen */
#if 0
		/* if we are, jump to the end and truncate the line, if we can
		   do it quickly (gee, clever idea, Paul!) */
		    if (ct + ccs + strlen(ol) >= winw - 1) {
			if (!tccan(TCMULTRIGHT) || ccs > winw - tclen[TCMULTRIGHT])
			    continue;
			moveto(ln, winw - 1 - ct);
			if (!tccan(TCCLEAREOL) || ct < tclen[TCCLEAREOL]) {
			    int x = ct;

			    while (vcs++, x--)
				putchar(' ');
			} else
			    tcout(TCCLEAREOL);
			moveto(ln, ccs);
		    }
#endif
		    if (ct + ccs + (int)strlen(ol) < winw - 1) {
			tc_inschars(ct = p1 - nl);
			ccs = (vcs += ct);
#ifdef HAS_SELECT
			cost += ct;
#endif
			fwrite(nl, ct, 1, stdout);
			nl += ct;
			break;
		    }
		}
	    if (*p1)
		continue;
	}
    /* if we can't do anything fancy, just write the new character and
       keep going. */

      jump:
	putchar(*nl);
#ifdef HAS_SELECT
	cost++;
#endif
	nl++, ol++, ccs = ++vcs;
    }
}

void moveto(ln, cl)		/**/
int ln;
int cl;
{
    if (ln == vln && cl == vcs)
	return;

    if (hasam && vcs == columns && vln != lines - 1) {
	putchar(' '), tcout(TCLEFT);
	vln++, vcs = 0;
#ifdef HAS_SELECT
	cost++;
#endif
    }
/* move up */

    if (ln < vln) {
	tc_upcurs(vln - ln);
	vln = ln;
    }
/* move down; if we might go off the end of the screen, use newlines
	instead of TCDOWN */

    while (ln > vln) {
	if (vln < vmaxln - 1)
	    if (ln > vmaxln - 1) {
		if (tc_downcurs(vmaxln - 1 - vln))
		    vcs = 0;
		vln = vmaxln - 1;
	    } else {
		if (tc_downcurs(ln - vln))
		    vcs = 0;
		vln = ln;
		continue;
	    }
	putchar('\r'), vcs = 0;	/* safety precaution */
#ifdef HAS_SELECT
	cost++;
#endif
	while (ln > vln) {
	    putchar('\n');
#ifdef HAS_SELECT
	    cost++;
#endif
	    vln++;
	}
    }
    if (cl < vcs / 2) {
	putchar('\r');
#ifdef HAS_SELECT
	cost++;
#endif
	vcs = 0;
    }
    if (vcs < cl)
	tc_rightcurs(cl);
    else if (vcs > cl)
	tc_leftcurs(vcs - cl);
    vcs = cl;
}

void tcmultout(cap, multcap, ct)/**/
int cap;
int multcap;
int ct;
{
    if (tccan(multcap) && (!tccan(cap) || tclen[multcap] < tclen[cap] * ct))
	tcoutarg(multcap, ct);
    else
	while (ct--)
	    tcout(cap);
}

void tc_rightcurs(cl)		/**/
int cl;
{
    int ct = cl - vcs;

/* do a multright if it's cheaper or if we're walking over the prompt.  */

    if (tccan(TCMULTRIGHT) &&
	(ct > tclen[TCMULTRIGHT] || (vln == 0 && vcs < pptlen))) {
	tcoutarg(TCMULTRIGHT, ct);
	return;
    }
/* try to go with tabs if a multright is not feasible/convenient;
   tabs are assumed to be 8 spaces */

    if (tccan(TCNEXTTAB)) {
	if ((vcs | 7) + 1 <= cl) {
	    tcout(TCNEXTTAB);
	    vcs = (vcs | 7) + 1;
	}
	for (; vcs + 8 <= cl; vcs += 8)
	    tcout(TCNEXTTAB);
	if (vcs == cl)
	    return;
    }
/* if we're walking over the prompt and we can do a bunch of cursor rights,
   do them, even though they're more expensive.  (We can't redraw the
   prompt very easily in general.)  */

    if (vln == 0 && tccan(TCRIGHT))
	for (; vcs < pptlen; vcs++)
	    tcout(TCRIGHT);

/* otherwise write the contents of the video buffer. */

    if ((ct = cl - vcs)) {
	fwrite(nbuf[vln] + vcs, ct, 1, stdout);
#ifdef HAS_SELECT
	cost += ct;
#endif
    }
}

int tc_downcurs(ct)		/**/
int ct;
{
    int ret = 0;

    if (ct) {
	if (tccan(TCMULTDOWN) &&
	    (!tccan(TCDOWN) || tclen[TCMULTDOWN] < tclen[TCDOWN] * ct))
	    tcoutarg(TCMULTDOWN, ct);
	else if (tccan(TCDOWN)) {
	    while (ct--)
		tcout(TCDOWN);
	} else {
	    while (ct--)
		putchar('\n');
	    putchar('\r'), ret = -1;
	}
    }
    return ret;
}

/* I'm NOT going to worry about padding unless anyone complains. */

void tcout(cap)			/**/
int cap;
{
    tputs(tcstr[cap], 1, putraw);
}

void tcoutarg(cap, arg)		/**/
int cap;
int arg;
{
    tputs(tgoto(tcstr[cap], arg, arg), 1, putraw);
}

void clearscreen()
{				/**/
    tcout(TCCLEARSCREEN);
    resetneeded = 1;
    clearflag = 0;
}

void redisplay()
{				/**/
    moveto(0, pptlen);
    if (tccan(TCCLEAREOD))
	tcout(TCCLEAREOD);
    resetneeded = clearflag = 1;
}

void singlerefresh()
{				/**/
    char *vbuf, *vp, **qbuf, *refreshop;
    int t0, vsiz, nvcs = 0;

    for (vsiz = 1 + pptlen, t0 = 0; t0 != ll; t0++, vsiz++)
	if (line[t0] == '\t')
	    vsiz += 7;
	else if (icntrl(line[t0]))
	    vsiz++;
    vbuf = (char *)zalloc(vsiz);
    strcpy(vbuf, pmpt);
    vp = vbuf + pptlen;
    for (t0 = 0; t0 != ll; t0++) {
	if (line[t0] == '\t')
	    do
		*vp++ = ' ';
	    while ((vp - vbuf) & 7);
	else if (line[t0] == '\n') {
	    *vp++ = '\\';
	    *vp++ = 'n';
	} else if (line[t0] == 0x7f) {
	    *vp++ = '^';
	    *vp++ = '?';
	} else if (icntrl(line[t0])) {
	    *vp++ = '^';
	    *vp++ = line[t0] | '@';
	} else
	    *vp++ = line[t0];
	if (t0 == cs)
	    nvcs = vp - vbuf - 1;
    }
    if (t0 == cs)
	nvcs = vp - vbuf;
    *vp = '\0';
    if ((winpos && nvcs < winpos + 1) || (nvcs > winpos + winw - 1)) {
	if ((winpos = nvcs - (winw / 2)) < 0)
	    winpos = 0;
    }
    if (winpos)
	vbuf[winpos] = '<';
    if ((int)strlen(vbuf + winpos) > winw) {
	vbuf[winpos + winw - 1] = '>';
	vbuf[winpos + winw] = '\0';
    }
    strcpy(nbuf[0], vbuf + winpos);
    zfree(vbuf, vsiz);
    nvcs -= winpos;
    for (t0 = 0, vp /*
 *
 * zle_tricky.c - expansion and completion
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define ZLE
#include "zsh.h"
#include	<pwd.h>

#ifdef HAS_NIS
#include	<rpc/types.h>
#include	<rpc/rpc.h>
#include	<rpcsvc/ypclnt.h>
#include	<rpcsvc/yp_prot.h>

#define PASSWD_FILE	"/etc/passwd"
#define PASSWD_MAP	"passwd.byname"

typedef struct {
    int len;
    char *s;
}
dopestring;

#endif

#define inststr(X) inststrlen((X),1,-1)

extern char *glob_pre, *glob_suf;

/*
 * We store the following prefizes/suffizes:
 * lpre/lsuf -- what's on the line
 * rpre/rsuf -- same as lpre/lsuf, but expanded
 *   ... and if we are completing files, too:
 * ppre/psuf -- the path prefix/suffix
 * fpre/fsuf -- prefix/suffix of the pathname component the cursor is in
 * prpre     -- ppre in expanded form usable for opendir
 */

static int we, wb, usemenu, useglob;

static char **menuarr, **menucur;
static int menupos, menulen, menuend, menuwe;
static Lklist matches;
static char **amatches;
static int nmatches;
static int ispattern;
static Comp patcomp, filecomp;
static char *lpre, *lsuf;
static char *rpre, *rsuf;
static char *ppre, *psuf, *prpre;
static char *fpre, *fsuf;
static char *mpre, *msuf;
static char ic;
static int lpl, lsl, rpl, rsl, fpl, fsl, noreal;
static int ab, ae;
static int addwhat;
static char *firstm, *shortest, *qword;
static int shortl, amenu;

int usetab()
{				/**/
    unsigned char *s = line + cs - 1;

    for (; s >= line && *s != '\n'; s--)
	if (*s != '\t' && *s != ' ')
	    return 0;
    return 1;
}

#define COMP_COMPLETE 0
#define COMP_LIST_COMPLETE 1
#define COMP_SPELL 2
#define COMP_EXPAND 3
#define COMP_EXPAND_COMPLETE 4
#define COMP_LIST_EXPAND 5
#define COMP_ISEXPAND(X) ((X) >= COMP_EXPAND)

void completeword()
{				/**/
    usemenu = isset(MENUCOMPLETE);
    useglob = isset(GLOBCOMPLETE);
    if (c == '\t' && usetab())
	selfinsert();
    else
	docomplete(COMP_COMPLETE);
}

void menucompleteword()
{				/**/
    usemenu = 1;
    useglob = isset(GLOBCOMPLETE);
    if (c == '\t' && usetab())
	selfinsert();
    else
	docomplete(COMP_COMPLETE);
}

void listchoices()
{				/**/
    usemenu = isset(MENUCOMPLETE);
    useglob = isset(GLOBCOMPLETE);
    docomplete(COMP_LIST_COMPLETE);
}

void spellword()
{				/**/
    usemenu = useglob = 0;
    docomplete(COMP_SPELL);
}

void deletecharorlist()
{				/**/
    char **mc = menucur;

    usemenu = isset(MENUCOMPLETE);
    useglob = isset(GLOBCOMPLETE);
    if (cs != ll)
	deletechar();
    else
	docomplete(COMP_LIST_COMPLETE);

    menucur = mc;
}

void expandword()
{				/**/
    usemenu = useglob = 0;
    if (c == '\t' && usetab())
	selfinsert();
    else
	docomplete(COMP_EXPAND);
}

void expandorcomplete()
{				/**/
    usemenu = isset(MENUCOMPLETE);
    useglob = isset(GLOBCOMPLETE);
    if (c == '\t' && usetab())
	selfinsert();
    else
	docomplete(COMP_EXPAND_COMPLETE);
}

void menuexpandorcomplete()
{				/**/
    usemenu = 1;
    useglob = isset(GLOBCOMPLETE);
    if (c == '\t' && usetab())
	selfinsert();
    else
	docomplete(COMP_EXPAND_COMPLETE);
}

void listexpand()
{				/**/
    usemenu = isset(MENUCOMPLETE);
    useglob = isset(GLOBCOMPLETE);
    docomplete(COMP_LIST_EXPAND);
}

void reversemenucomplete()
{				/**/
    if (!menucmp) {
	menucompleteword();	/* better than just feep'ing, pem */
	return;
    }
    if (menucur == menuarr)
	menucur = menuarr + arrlen(menuarr) - 1;
    else
	menucur--;
    do_single(*menucur);
}

/*
 * Accepts the current completion and starts a new arg,
 * with the next completions. This gives you a way to accept
 * several selections from the list of matches.
 */
void acceptandmenucomplete()
{				/**/
    if (!menucmp) {
	feep();
	return;
    }
    cs = menuend;
    inststrlen(" ", 1, 1);
    if (mpre)
	inststrlen(mpre, 1, -1);
    if (msuf)
	inststrlen(msuf, 0, -1);
    menupos = cs;
    menuend = cs + (msuf ? strlen(msuf) : 0);
    menulen = 0;
    menuwe = 1;
    menucompleteword();
}

static int lincmd, linredir, lastambig, inwhat, haswhat;
static char *cmdstr;

#define IN_NOTHING 0
#define IN_CMD     1
#define IN_MATH    2
#define IN_COND    3
#define IN_ENV     4

#define HAS_SUFFIX  1
#define HAS_FILES   2
#define HAS_MISC    4
#define HAS_PATHPAT 8

int checkparams(p)		/**/
char *p;
{
    int t0, n, l = strlen(p), e = 0;
    struct hashnode *hn;

    for (t0 = paramtab->hsize - 1, n = 0; n < 2 && t0 >= 0; t0--)
	for (hn = paramtab->nodes[t0]; n < 2 && hn; hn = hn->next)
	    if (pfxlen(p, hn->nam) == l) {
		n++;
		if (strlen(hn->nam) == l)
		    e = 1;
	    }
    return (n == 1) ? (getsparam(p) != NULL) :
	(!menucmp && e && isset(RECEXACT));
}

int cmphaswilds(str)		/**/
char *str;
{
    if ((*str == Inbrack || *str == Outbrack) && !str[1])
	return 0;
    if (str[0] == '%')
	return 0;
    for (; *str;) {
	if (*str == String || *str == Qstring) {
	    if (*++str == Inbrace) {
		for (str++; *str; str++)
		    if (*str == Outbrace)
			break;
	    } else
		for (; *str; str++)
		    if (*str != '^' && *str != Hat &&
			*str != '=' && *str != Equals &&
			*str != '#' && *str != Pound &&
			*str != '~' && *str != Tilde &&
			*str != '+')
			break;
	}
	if (*str == Pound || *str == Hat || *str == Star ||
	    *str == Bar || *str == Inbrack || *str == Inang ||
	    *str == Quest || (*str == Inpar && str[1] == ':'))
	    return 1;
	if (*str)
	    str++;
    }
    return 0;
}

void docomplete(lst)		/**/
int lst;
{
    char *s, *ol;
    int olst = lst, dh, chl = 0;

    if (menucmp) {
	do_menucmp(lst);
	return;
    } else if ((amenu = (isset(AUTOMENU) &&
			 (lastcmd & ZLE_MENUCMP) &&
			 lastambig)))
	usemenu = 1;

    dh = doexpandhist();
    if (dh == 0 || dh == 1)
	return;

    if (!isfirstln && chline != NULL) {
	char *p;

	ol = dupstring((char *) line);
	*hptr = '\0';
	chl = strlen(chline);
	sizeline(ll + chl + 1);
	strcpy((char *) line, chline);
	strcat((char *) line, ol);
	for (p = (char *) line; *p; p++)
	    if (*p == '\n')
		*p = ' ';
	cs += chl;
	ll = strlen((char *) line);
    }
    else
	ol = NULL;
    inwhat = IN_NOTHING;
    qword = NULL;
    s = get_comp_string();
    lexrestore();
    if (ol) {
	strcpy((char *) line, ol);
	ll = strlen((char *) line);
	cs -= chl;
	wb -= chl;
	we -= chl;
	if (wb < 0 || we < 0)
	    return;
    }
    freeheap();
    lexsave();
    if (inwhat == IN_ENV)
	lincmd = 0;
    if (s) {
	if (lst == COMP_EXPAND_COMPLETE) {
	    char *q = s;

	    if (*q == Equals) {
		q = s + 1;
		if (gethnode(q, cmdnamtab) || hashcmd(q, pathchecked))
		    if (isset(RECEXACT))
			lst = COMP_EXPAND;
		    else {
			int t0, n = 0;
			char *fc;
			struct hashnode *hn;

			for (t0 = cmdnamtab->hsize - 1; t0 >= 0; t0--)
			    for (hn = cmdnamtab->nodes[t0]; hn; hn = hn->next) {
				if (strpfx(q, hn->nam) &&
				    ISEXCMD(((Cmdnam) hn)->flags) &&
				    (fc = findcmd(hn->nam))) {
				    zsfree(fc);
				    n++;
				}
				if (n == 2)
				    break;
			    }

			if (n == 1)
			    lst = COMP_EXPAND;
		    }
	    } else if (*q != Tilde) {
		for (; *q && *q != String; q++);
		if (*q == String && q[1] != Inpar && q[1] != Inbrack) {
		    if (*++q == Inbrace) {
			for (++q; *q && *q != Outbrace; q++);
			if (*q && q - s + 1 == cs - wb)
			    lst = COMP_EXPAND;
		    } else {
			char *t, sav;

			for (; *q; q++)
			    if (*q != '^' && *q != Hat &&
				*q != '=' && *q != Equals &&
				*q != '#' && *q != Pound &&
				*q != '~' && *q != Tilde &&
				*q != '+')
				break;
			for (t = q; *q && (ialnum(*q) || *q == '_'); q++);
			sav = *q;
			*q = '\0';
			if (cs - wb == q - s && checkparams(t))
			    lst = COMP_EXPAND;
			*q = sav;
		    }
		    if (lst != COMP_EXPAND)
			lst = COMP_COMPLETE;
		}
		q = s;
	    }
	    if (lst == COMP_EXPAND_COMPLETE) {
		for (q = s; *q; q++)
		    if (*q == Tick || *q == Qtick ||
			*q == String || *q == Qstring)
			break;
		lst = *q ? COMP_EXPAND : COMP_COMPLETE;
	    }
	    if (unset(GLOBCOMPLETE) && cmphaswilds(s))
		lst = COMP_EXPAND;
	}
	if (lincmd && (inwhat == IN_NOTHING))
	    inwhat = IN_CMD;

	if (lst == COMP_SPELL) {
	    char **x = &s;
	    char *q = s;

	    for (; *q; q++)
		if (INULL(*q))
		    *q = Nularg;
	    untokenize(s);
	    cs = wb;
	    foredel(we - wb);
	/* call the real spell checker, ash@aaii.oz.zu */
	    spckword(x, NULL, NULL, !lincmd, 0);
	    inststr(*x);
	} else if (COMP_ISEXPAND(lst)) {
	    char *ol = (olst == COMP_EXPAND_COMPLETE) ?
	    dupstring((char *)line) : (char *)line;
	    int ocs = cs, ne = noerrs;

	    noerrs = 1;

	    doexpansion(s, lst, lincmd);
	    lastambig = 0;

	    noerrs = ne;

	    if (olst == COMP_EXPAND_COMPLETE &&
		!strcmp(ol, (char *)line)) {

		cs = ocs;
		errflag = 0;

		untokenize(s);
		docompletion(s, lst, lincmd);
	    }
	} else
	    docompletion(s, lst, lincmd);
	zsfree(s);
    }
    lexrestore();
    popheap();
    zsfree(qword);
}

void do_menucmp(lst)		/**/
int lst;
{
    if (lst == COMP_LIST_COMPLETE) {
	amatches = menuarr;
	listmatches();
	return;
    }
    if (!*++menucur)
	menucur = menuarr;
    do_single(*menucur);
}

int addedx;			/* 1 if x added to complete in a blank between words */
int instring;			/* 1 if we are completing in a string */

void addx(ptmp)			/**/
char **ptmp;
{
    if (!line[cs] || inblank(line[cs]) || line[cs] == ')') {
	*ptmp = (char *)line;
	line = (unsigned char *)ncalloc(strlen((char *)line) + 3);
	memcpy(line, *ptmp, cs);
	line[cs] = 'x';
	strcpy((char *)line + cs + 1, (*ptmp) + cs);
	addedx = 1;
    } else {
	addedx = 0;
	*ptmp = NULL;
    }
}

char *get_comp_string()
{				/**/
    int t0, tt0, i, j, k, l, cp, rd, inc = 0, opb = -1, sl, im = 0, ocs;
    char *s = NULL, *linptr, *tmp, *p, *tt = NULL, *q = NULL;

    noaliases = isset(COMPLETEALIASES);

    instring = 0;
    for (i = j = k = l = 0, q = p = (char *)line; p < (char *)line + cs; p++)
	if (*p == '`' && !(k & 1))
	    i++, q = p;
	else if (*p == '\"' && !(k & 1))
	    j++;
	else if (*p == '\'' && !(j & 1))
	    k++;
	else if (*p == '(' && p[1] == '(')
	    l++, p++;
	else if (*p == ')' && p[1] == ')')
	    l--, p++;
	else if (*p == '\\' && p[1] && !((k & 1) && p[1] == '\''))
	    p++;
    if ((i & 1) || (j & 1) || (k & 1) || l) {
	instring = (j & 1) ? 2 : (k & 1);
	if (l)
	    im = 2;
	addx(&tmp);
	if (!addedx) {
	    tmp = (char *)line;
	    if (i & 1) {
		line = (unsigned char *)dupstring((char *)line);
		strcpy((char *)line, (char *)tmp);
	    } else
		line = (unsigned char *)dupstring((char *)line);
	}
	for (p = (char *)line; *p; p++)
	    if (*p == '"' || *p == '\'')
		*p = ' ';
	    else if ((*p == '(' && p[1] == '(') || (*p == ')' && p[1] == ')'))
		*p = p[1] = ' ', p++;
    } else
	addx(&tmp);
    if (i & 1) {
	sizeline(ll + 1);
	if (tmp)
	    q = (char *)line + (q - tmp);
	for (p = q + strlen(q); p > q; p--)
	    p[1] = *p;
	*q++ = '$';
	*q = '(';
	ll++;
	cs++;
	inc = 1;
    }
    linptr = (char *)line;
    q = NULL;
  start:
    lincmd = incmdpos;
    linredir = inredir;
    cmdstr = NULL;
    zleparse = 1;
    clwpos = -1;
    lexsave();
    hungets(" ");		/* KLUDGE! */
    hungets(UTOSCP(linptr));
    strinbeg();
    pushheap();
    heapalloc();
    i = tt0 = cp = rd = 0;

    do {
	lincmd = incmdpos;
	linredir = inredir;
	ctxtlex();
	if (tok == DINBRACK)
	    im |= 1;
	else if (tok == DOUTBRACK)
	    im &= ~1;
	else if (tok == DINPAR)
	    im |= 2;
	else if (tok == DOUTPAR)
	    im &= ~2;

	if (tok == ENDINPUT)
	    break;
	if (tok == BAR || tok == AMPER || tok == BARAMP ||
	    tok == DBAR || tok == DAMPER)
	    if (tt)
		break;
	    else
		i = tt0 = cp = rd = 0;
	if (lincmd && tok == STRING)
	    cmdstr = dupstring(tokstr), i = 0;
	if (!zleparse && !tt0) {
	    tt = tokstr ? dupstring(tokstr) : NULL;
	    if (addedx && tt)
		chuck(tt + cs - wb - 1);
	    tt0 = tok;
	    clwpos = i;
	    cp = lincmd;
	    rd = linredir;
	}
	if (!tokstr)
	    continue;
	if (i + 1 == clwsize) {
	    clwords = (char **)realloc(clwords, (clwsize *= 2) * sizeof(char *));
	    memset((vptr) (clwords + i), 0, (clwsize / 2) * sizeof(char *));
	}
	zsfree(clwords[i]);
	clwords[i] = ztrdup(tokstr);
	sl = strlen(tokstr);
	while (sl && clwords[i][sl - 1] == ' ')
	    clwords[i][--sl] = '\0';
	if (clwpos == i++ && addedx)
	    chuck(&clwords[i - 1][((cs - wb - 1) >= sl) ? (sl - 1) : (cs - wb - 1)]);
    }
    while (tok != LEXERR && tok != ENDINPUT &&
	   (tok != SEPER || (zleparse && !tt0)));
    clwnum = (tt || !i) ? i : i - 1;
    zsfree(clwords[clwnum]);
    clwords[clwnum] = NULL;
    t0 = tt0;
    lincmd = cp;
    linredir = rd;

    if (!t0 || t0 == ENDINPUT) {
	s = ztrdup("");
	we = wb = cs;
	clwpos = clwnum;
	t0 = STRING;
    } else if (t0 == STRING) {
	s = ztrdup(clwords[clwpos]);
    } else if (t0 == ENVSTRING) {
	for (s = tt; *s && *s != '='; s++, wb++);
	if (*s) {
	    s++;
	    wb++;
	    t0 = STRING;
	    s = ztrdup(s);
	    inwhat = IN_ENV;
	}
	lincmd = 1;
    }
    hflush();
    strinend();
    errflag = zleparse = 0;
    if (addedx)
	wb++;
    if (we > ll)
	we = ll;
    if (im & 2) {
	if (tokstr) {
	    *tokstr = ' ';
	    if (addedx)
		tokstr[cs - wb + 1] = '\0';
	    s = ztrdup(tokstr);
	}
	if (tmp)
	    line = (unsigned char *)tmp;
	goto check;
    }
    if (t0 == LEXERR && parbegin != -1) {
	if (opb == parbegin) {
	    if (inc)
		cs--, ll--, inc = 0;
	    if (tmp)
		line = (unsigned char *)tmp;
	    feep();
	    noaliases = 0;
	    permalloc();
	    return NULL;
	}
	opb = parbegin;
	linptr += ll + 1 - parbegin;
	popheap();
	permalloc();
	lexrestore();
	if (inc)
	    cs--, ll--, inc = 0;
	goto start;
    }
    if (inc)
	cs--, ll--, inc = 0;
    tt = (char *)line;
    if (tmp)
	line = (unsigned char *)tmp;
    if (t0 != STRING) {
	if (tmp) {
	    tmp = NULL;
	    linptr = (char *)line;
	    popheap();
	    permalloc();
	    lexrestore();
	    goto start;
	}
	feep();
	noaliases = 0;
	permalloc();
	return NULL;
    } else if (clwords[clwpos] && clwords[clwpos][0]) {
	for (p = clwords[clwpos]; *p; p++)
	    if ((*p == String || *p == Equals || *p == Inang || *p == Outang) &&
		p[1] == Inpar)
		break;
	if (*p && cs > p - clwords[clwpos]) {
	    for (q = clwords[clwpos] + we - wb; q > p; q--)
		if (*q == Outpar)
		    break;
	    if (q > p && cs - wb <= q - clwords[clwpos]) {
		if (!tmp) {
		    tmp = (char *)line;
		    tt = dupstring((char *)line);
		}
		line = (unsigned char *)tt;
		line[wb + q - clwords[clwpos] + addedx] = '\0';
		linptr = (char *)line;
		ll = strlen((char *)line) - 1;
		popheap();
		permalloc();
		lexrestore();
		q = NULL;
		goto start;
	    }
	    q = NULL;
	}
    }
  check:

    if (q)
	wb--, we--;

    noaliases = 0;

    inwhat = (im & 1) ? IN_COND : (inwhat == IN_ENV ? IN_ENV : IN_NOTHING);
    im &= ~1;

 /* check if we are in a mathematical expression */

    if (!im) {
	for (tt = s + cs - wb; tt > s && *tt != Inbrack; tt--);
	if (*tt == Inbrack) {
	    if (tt[-1] == String)
		im = 1;
	    else {
		for (p = tt - 1; p > s && (ialnum(*p) || *p == '_'); p--);
		if (*p == String || (*p == Inbrace && p > s && p[-1] == String))
		    im = 1;
		else if (*p == Outpar) {
		    for (i = 1, p--; p >= s && i; p--)
			if (*p == Outpar)
			    i++;
			else if (*p == Inpar)
			    i--;
		    if (!i && ((p >= s && *p == String) ||
			       (p > s && *p == Inbrack && p[-1] == String)))
			im = 1;
		}
	    }
	    if (im) {
		for (i = 1, p = tt + 1; *p && i; p++)
		    if (*p == Inbrack)
			i++;
		    else if (*p == Outbrack)
			i--;
		if (cs - wb >= p - s)
		    im = 0;
	    }
	}
    }
    if (im) {
	inwhat = IN_MATH;
	for (p = s + cs - wb - 1; p >= s && (ialnum(*p) || *p == '_'); p--);
	if (++p > s) {
	    strcpy(s, p);
	    wb += p - s - ((im & 2) ? 1 : 0);
	}
	for (p = s; *p && (ialnum(*p) || *p == '_'); p++);
	*p = '\0';
	we = wb + p - s;
    }
    qword = ztrdup(s);
    for (p = s, tt = qword, i = wb; *p; p++, tt++, i++)
	if (INULL(*p)) {
	    if (p[1] || *p != Bnull) {
		if (*p == Bnull)
		    *tt = '\\';
		else {
		    ocs = cs;
		    cs = i;
		    foredel(1);
		    chuck(tt--);
		    if ((cs = ocs) >= i--)
			cs--;
		    we--;
		}
	    } else {
		ocs = cs;
		*tt = '\0';
		cs = we;
		backdel(1);
		if (ocs == we)
		    cs = we - 1;
		else
		    cs = ocs;
		we--;
	    }
	    chuck(p--);
	}
    if (unset(NOBANGHIST)) {
	q = tt = ncalloc(2 * strlen(qword) + 1);
	for (p = qword; *p; p++) {
	    if (*p == (char)bangchar)
		*q++ = '\\';	/*, wb--, cs--;*/
	    *q++ = *p;
	}
	*q = '\0';
	zsfree(qword);
	qword = ztrdup(tt);
    }
    ll = strlen((char *)line);
    permalloc();

    return (char *)s;
}

void doexpansion(s, lst, explincmd)	/**/
char *s;
int lst;
int explincmd;
{
    Lklist vl = newlist();
    char *ss;
    int ng = opts[NULLGLOB];

    opts[NULLGLOB] = OPT_SET;
    lexsave();
    s = dupstring(s);
    pushheap();
    addnode(vl, s);
    prefork(vl, 0);
    if (errflag)
	goto end;
    postfork(vl, (lst == COMP_LIST_EXPAND) || (lst == COMP_EXPAND));
    if (errflag)
	goto end;
    if (empty(vl) || !*(char *)peekfirst(vl)) {
	if (!noerrs)
	    feep();
	goto end;
    }
    if (lst == COMP_LIST_EXPAND) {
	listlist(vl);
	goto end;
    } else if (peekfirst(vl) == (vptr) s ||
	       (!nextnode(firstnode(vl)) && *s == Tilde &&
		(ss = dupstring(s), filesubstr(&ss, 0)) &&
		!strcmp(ss, (char *)peekfirst(vl)))) {
	if (lst == COMP_EXPAND_COMPLETE)
	    docompletion(s, COMP_COMPLETE, explincmd);
	else
	    feep();
	goto end;
    }
    cs = wb;
    foredel(we - wb);
    while ((ss = (char *)ugetnode(vl))) {
	untokenize(ss);
	ss = quotename(ss, NULL, NULL, NULL);
	inststr(ss);
#if 0
	if (full(vl)) {
	    spaceinline(1);
	    line[cs++] = ' ';
	}
#endif
	spaceinline(1);
	line[cs++] = ' ';
    }
  end:
    opts[NULLGLOB] = ng;
    popheap();
    lexrestore();
}

void gotword(s)			/**/
char *s;
{
    we = ll + 1 - inbufct;
    if (cs <= we) {
	wb = ll - wordbeg;
	zleparse = 0;
    /* major hack ahead */
	if (wb > 0 && line[wb] == '!' && line[wb - 1] == '\\')
	    wb--;
    }
}

void inststrlen(str, move, len)	/**/
char *str;
int move;
int len;
{
    if (!len)
	return;
    if (len == -1)
	len = strlen(str);
    spaceinline(len);
    strncpy((char *)(line + cs), str, len);
    if (move)
	cs += len;
}

char *quotename(s, e, te, pl)	/**/
char *s;
char **e;
char **te;
int *pl;
{
    char *tt, *v, *u, buf[MAXPATHLEN * 2];
    int sf = 0;

    tt = v = buf;
    u = s;
    for (; *u; u++) {
	if (e && *e == u)
	    *e = v, sf |= 1;
	if (te && *te == u)
	    *pl = v - tt, sf |= 2;
	if (ispecial(*u) &&
	    (!instring || (!isset(NOBANGHIST) &&
			   *u == (char)bangchar) ||
	     (instring == 2 &&
	      (*u == '$' || *u == '`' || *u == '\"')) ||
	     (instring == 1 && *u == '\'')))
	    if (*u == '\n' || (instring == 1 && *u == '\'')) {
		*v++ = '\'';
		if (*u == '\'')
		    *v++ = '\\';
		*v++ = *u;
		*v++ = '\'';
		continue;
	    } else
		*v++ = '\\';
	*v++ = *u;
    }
    *v = '\0';
    if (strcmp(buf, s))
	tt = dupstring(buf);
    else
	tt = s;
    v += tt - buf;
    if (e && (sf & 1))
	*e += tt - buf;
    if (te && (sf & 2))
	*te += tt - buf;

    if (e && *e == u)
	*e = v;
    if (te && *te == u)
	*pl = v - tt;

    return tt;
}

void addmatch(s, t)		/**/
char *s;
char *t;
{
    int test = 0, sl = strlen(s), pl = rpl, cc = 0;
    char sav = 0, *e = NULL, *tt, *te, *fc;
    Comp cp = patcomp;
    Param pm;

    if (!addwhat)
	test = 1;
    else if (addwhat == -1 || addwhat == -5 || addwhat == -6 ||
	     addwhat == CC_FILES || addwhat == -7 || addwhat == -8) {
	if (sl < fpl + fsl)
	    return;

	if ((addwhat == CC_FILES ||
	     addwhat == -5) && !*psuf && !*fsuf) {
	    char **pt = fignore;
	    int filell;

	    for (test = 1; test && *pt; pt++)
		if ((filell = strlen(*pt)) < sl
		    && !strcmp(*pt, s + sl - filell))
		    test = 0;

	    if (!test)
		return;
	}
	pl = fpl;
	if (addwhat == -5 || addwhat == -8) {
	    test = 1;
	    cp = filecomp;
	    cc = cp || ispattern;
	    e = s + sl - fsl;
	} else {
	    if ((cp = filecomp)) {
		if ((test = domatch(s, filecomp, 0)))
		    cc = 1;
	    } else {
		e = s + sl - fsl;
		if ((test = !strncmp(s, fpre, fpl)))
		    test = !strcmp(e, fsuf);
		if (ispattern)
		    cc = 1;
	    }
	}
	if (test) {
	    fc = NULL;
	    if (addwhat == -7 && ISEXCMD(((Cmdnam) t)->flags) &&
		!(fc = findcmd(s)))
		return;
	    if (fc)
		zsfree(fc);
	    haswhat |= HAS_FILES;

	    if (addwhat == CC_FILES || addwhat == -6 ||
		addwhat == -5 || addwhat == -8) {
		te = s + pl;
		s = quotename(s, &e, &te, &pl);
		sl = strlen(s);
	    } else if (!cc) {
		s = dupstring(t = s);
		e += s - t;
	    }
	    if (cc) {
		tt = (char *)halloc(strlen(ppre) + strlen(psuf) + sl + 1);
		strcpy(tt, ppre);
		strcat(tt, s);
		strcat(tt, psuf);
		untokenize(s = tt);
	    }
	}
    } else if (addwhat == -2 ||
	       (addwhat == -3 && !(((Cmdnam) t)->flags & DISABLED)) ||
	       (addwhat == -4 && (pm = (Param) t) && (pmtype(pm) == PMFLAG_s) &&
		(tt = pm->gets.cfn(pm)) && *tt == '/') ||
	       (addwhat > 0 &&
		(((addwhat & CC_ARRAYS) && (((Param) t)->flags & PMFLAG_A)) ||
		 ((addwhat & CC_INTVARS) && (((Param) t)->flags & PMFLAG_i)) ||
		 ((addwhat & CC_ENVVARS) && (((Param) t)->flags & PMFLAG_x)) ||
		 ((addwhat & CC_SCALARS) &&
		  !(((Param) t)->flags & (PMFLAG_A | PMFLAG_i))) ||
		 ((addwhat & CC_READONLYS) && (((Param) t)->flags & PMFLAG_r)) ||
		 ((addwhat & CC_SPECIALS) && (((Param) t)->flags & PMFLAG_SPECIAL)) ||
		 ((addwhat & CC_PARAMS) && !(((Param) t)->flags & PMFLAG_x)) ||
		 ((addwhat & CC_FUNCS) && (((Cmdnam) t)->flags & SHFUNC)) ||
		 ((addwhat & CC_BUILTINS) && (((Cmdnam) t)->flags & BUILTIN) &&
		  !(((Cmdnam) t)->flags & EXCMD)) ||
		 ((addwhat & CC_DISCMDS) && (((Cmdnam) t)->flags & DISABLED)) ||
		 ((addwhat & CC_EXCMDS) && (((Cmdnam) t)->flags & EXCMD)) ||
		 ((addwhat & CC_ALREG) && (((Alias) t)->cmd) == 1) ||
		 ((addwhat & CC_ALGLOB) && !(((Alias) t)->cmd))))) {
	if (sl >= rpl + rsl) {
	    if (cp)
		test = domatch(s, patcomp, 0);
	    else {
		e = s + sl - rsl;
		if ((test = !strncmp(s, rpre, rpl)))
		    test = !strcmp(e, rsuf);
	    }
	}
	if (!test && sl < lpl + lsl)
	    return;
	if (!test && !noreal && sl >= lpl + lsl) {
	    e = s + sl - lsl;
	    if ((test = !strncmp(s, lpre, lpl)))
		test = !strcmp(e, lsuf);
	    pl = lpl;
	}
	if (test)
	    haswhat |= HAS_MISC;
    }
    if (!test)
	return;

    t = s += (ispattern ? 0 : pl);
    e += t - s;
    s = t;

    if (ispattern)
	e = NULL, sav = '\0';
    else {
	if ((sav = *e)) {
	    *e = '\0';
	    t = dupstring(t);
	}
    }

    if (!ispattern && firstm) {
	if ((test = pfxlen(firstm, s)) < ab)
	    ab = test;
	if ((test = sfxlen(firstm, s)) < ae)
	    ae = test;
    }
 /* If we are doing a glob completion we store the whole string in
     * the list. Otherwise only the part that fits between the prefix
     * and the suffix is stored. */

    addnode(matches, t);
    if (!firstm)
	firstm = t, ab = ae = shortl = 100000;
    if (!ispattern && (sl = strlen(t)) < shortl)
	shortl = sl, shortest = t;
    if (sav)
	*e = sav;
}

#ifdef HAS_NIS
static int match_username(status, key, keylen, val, vallen, data)
int status;
char *key, *val;
int keylen, vallen;
dopestring *data;
{
    if (errflag || status != YP_TRUE)
	return 1;

    if (vallen > keylen && val[keylen] == ':') {
	val[keylen] = '\0';
	addmatch(dupstring(val), NULL);
    }
    return 0;
}

#endif

void maketildelist()
{				/**/
    int i;

#ifdef HAS_NIS
    char domain[YPMAXDOMAIN];
    struct ypall_callback cb;
    dopestring data;
    FILE *pwf;
    char buf[BUFSIZ], *p;
    int skipping;

    data.s = fpre;
    data.len = fpl;
 /* Get potential matches from NIS and cull those without local accounts */
    if (getdomainname(domain, YPMAXDOMAIN) == 0) {
	cb.foreach = (int ((*)()))match_username;
	cb.data = (char *)&data;
	yp_all(domain, PASSWD_MAP, &cb);
/*	for (n = firstnode(matches); n; incnode(n))
	    if (getpwnam(getdata(n)) == NULL)
		uremnode(matches, n);*/
    }
 /* Don't forget the non-NIS matches from the flat passwd file */
    if ((pwf = fopen(PASSWD_FILE, "r")) != NULL) {
	skipping = 0;
	while (fgets(buf, BUFSIZ, pwf) != NULL) {
	    if (strchr(buf, '\n') != NULL) {
		if (!skipping) {
		    if ((p = strchr(buf, ':')) != NULL) {
			*p = '\0';
			addmatch(dupstring(buf), NULL);
		    }
		} else
		    skipping = 0;
	    } else
		skipping = 1;
	}
	fclose(pwf);
    }
#else
    struct passwd *tmppwd;

#ifdef CACHE_USERNAMES
    static int usernamescached = 0;

    if (!usernamescached) {
	setpwent();
	while ((tmppwd = getpwent()) != NULL && !errflag)
	    adduserdir(dupstring(tmppwd->pw_name), tmppwd->pw_dir, 1, 1);
	endpwent();
	usernamescached = 1;
    }
#else
    setpwent();
    while ((tmppwd = getpwent()) != NULL && !errflag)
	addmatch(dupstring(tmppwd->pw_name), NULL);
    endpwent();

    if (addwhat != -1)
	return;
#endif
#endif

    for (i = 0; i < userdirct; i++)
	if (addwhat == -1 || namdirs[i].homedir)
	    addmatch(namdirs[i].name, NULL);
}

char *rembslash(s)		/**/
char *s;
{
    char *t = s = dupstring(s);

    while (*s)
	if (*s == '\\') {
	    chuck(s);
	    if (*s)
		s++;
	} else
	    s++;

    return t;
}

int getcpat(str, cpatindex, cpat, class)	/**/
char *str;
int cpatindex;
char *cpat;
int class;
{
    char *s, *t, *p;
    int d = 0;

    if (!str || !*str)
	return -1;

    cpat = rembslash(cpat);

    str = ztrdup(str);
    untokenize(str);
    if (!cpatindex)
	cpatindex++, d = 0;
    else if ((d = (cpatindex < 0)))
	cpatindex = -cpatindex;

    for (s = d ? str + strlen(str) - 1 : str;
	 d ? (s >= str) : *s;
	 d ? s-- : s++) {
	for (t = s, p = cpat; *t && *p; p++) {
	    if (class) {
		if (*p == *s && !--cpatindex) {
		    zsfree(str);
		    return (int)(s - str + 1);
		}
	    } else if (*t++ != *p)
		break;
	}
	if (!class && !*p && !--cpatindex) {
	    zsfree(str);
	    return (int)(t - str);
	}
    }
    zsfree(str);
    return -1;
}

Compctl ccmain;

Compctl get_ccompctl(occ, compadd, incmd)	/**/
Compctl occ;
int *compadd;
int incmd;
{
    Compctl compc, ret;
    Compctlp ccp;
    int t, i, a, b, tt, ra = 0, rb = 0, j;
    Compcond or, cc;
    char *s, *ss, *sc = NULL;
    Comp comp;

    *compadd = 0;

    if (!(ret = compc = occ)) {
	if (inwhat == IN_ENV)
	    ret = &cc_default;
	else if (inwhat == IN_MATH) {
	    cc_dummy.mask = CC_PARAMS;
	    ret = &cc_dummy;
	    cc_dummy.refc = 10000;
	} else if (inwhat == IN_COND) {
	    s = clwpos ? clwords[clwpos - 1] : "";
	    cc_dummy.mask = !strcmp("-o", s) ? CC_OPTIONS :
		((*s == '-' && s[1] && !s[2]) ||
		 !strcmp("-nt", s) ||
		 !strcmp("-ot", s) ||
		 !strcmp("-ef", s)) ? CC_FILES :
		(CC_FILES | CC_PARAMS);
	    ret = &cc_dummy;
	    cc_dummy.refc = 10000;
	} else if (incmd)
	    ret = &cc_compos;
	else if (linredir ||
		 !(cmdstr &&
		   (((ccp = (Compctlp) gethnode(cmdstr, compctltab)) &&
		     (compc = ret = ccp->cc)) ||
		    ((s = dupstring(cmdstr)) && remlpaths(&s) &&
		     (ccp = (Compctlp) gethnode(s, compctltab)) &&
		     (compc = ret = ccp->cc)))))
	    ret = &cc_default;

	ccmain = compc = ret;
	ccmain->refc++;
    }
    if (compc && compc->ext) {
	compc = compc->ext;
	for (t = 0; compc && !t; compc = compc->next) {
	    for (cc = compc->cond; cc && !t; cc = or) {
		or = cc->or;
		for (t = 1; cc && t; cc = cc->and) {
		    for (t = i = 0; i < cc->n && !t; i++) {
			s = NULL;
			ra = 0;
			rb = clwnum - 1;
			switch (cc->type) {
			case CCT_POS:
			    tt = clwpos;
			    goto cct_num;
			case CCT_NUMWORDS:
			    tt = clwnum;
			  cct_num:
			    if ((a = cc->u.r.a[i]) < 0)
				a += clwnum;
			    if ((b = cc->u.r.b[i]) < 0)
				b += clwnum;
			    if (cc->type == CCT_POS)
				ra = a, rb = b;
			    t = (tt >= a && tt <= b);
			    break;
			case CCT_CURSUF:
			case CCT_CURPRE:
			    s = ztrdup(clwpos < clwnum ? clwords[clwpos] : "");
			    untokenize(s);
			    sc = rembslash(cc->u.s.s[i]);
			    a = strlen(sc);
			    if (!strncmp(s, sc, a)) {
				*compadd = (cc->type == CCT_CURSUF ? a : 0);
				t = 1;
			    }
			    break;
			case CCT_CURSUB:
			case CCT_CURSUBC:
			    if (clwpos < 0 || clwpos > clwnum)
				t = 0;
			    else {
				if ((a = getcpat(clwords[clwpos],
						 cc->u.s.p[i],
						 cc->u.s.s[i],
						 cc->type == CCT_CURSUBC)) != -1)
				    *compadd = a, t = 1;
			    }
			    break;

			case CCT_CURPAT:
			case CCT_CURSTR:
			    tt = clwpos;
			    goto cct_str;
			case CCT_WORDPAT:
			case CCT_WORDSTR:
			    tt = 0;
			  cct_str:
			    if ((a = tt + cc->u.s.p[i]) < 0)
				a += clwnum;
			    s = ztrdup((a < 0 || a >= clwnum) ? "" : clwords[a]);
			    untokenize(s);

			    if (cc->type == CCT_CURPAT || cc->type == CCT_WORDPAT) {
				tokenize(ss = dupstring(cc->u.s.s[i]));
				t = ((comp = parsereg(ss)) && domatch(s, comp, 0));
			    } else
				t = (!strcmp(s, rembslash(cc->u.s.s[i])));
			    break;
			case CCT_RANGESTR:
			case CCT_RANGEPAT:
			    if (cc->type == CCT_RANGEPAT)
				tokenize(sc = dupstring(cc->u.l.a[i]));
			    for (j = clwpos; j; j--) {
				untokenize(s = ztrdup(clwords[j]));
				if (cc->type == CCT_RANGESTR)
				    sc = rembslash(cc->u.l.a[i]);
				if (cc->type == CCT_RANGESTR ?
				    !strncmp(s, sc, strlen(sc)) :
				    ((comp = parsereg(sc)) &&
				     domatch(s, comp, 0))) {
				    zsfree(s);
				    ra = j + 1;
				    t = 1;
				    break;
				}
				zsfree(s);
			    }
			    if (t) {
				if (cc->type == CCT_RANGEPAT)
				    tokenize(sc = dupstring(cc->u.l.b[i]));
				for (j++; j < clwnum; j++) {
				    untokenize(s = ztrdup(clwords[j]));
				    if (cc->type == CCT_RANGESTR)
					sc = rembslash(cc->u.l.b[i]);
				    if (cc->type == CCT_RANGESTR ?
					!strncmp(s, sc, strlen(sc)) :
					((comp = parsereg(sc)) &&
					 domatch(s, comp, 0))) {
					zsfree(s);
					rb = j - 1;
					t = clwpos <= rb;
					break;
				    }
				    zsfree(s);
				}
			    }
			    s = NULL;
			}
			zsfree(s);
		    }
		}
	    }
	    if (t)
		break;
	}
	if (compc)
	    ret = compc;
    }
    if (ret->subcmd) {
	char **ow = clwords, *os = cmdstr, *ops = NULL;
	int oldn = clwnum, oldp = clwpos;

	if (ra < 1)
	    ra = 1;
	if (ra >= clwnum)
	    ra = clwnum - 1;
	if (rb < 1)
	    rb = 1;
	if (rb >= clwnum)
	    rb = clwnum - 1;

	clwnum = rb - ra + 1;
	clwpos = clwpos - ra;
	if (ret->subcmd[0]) {
	    clwnum++;
	    clwpos++;
	    incmd = 0;
	    ops = clwords[ra - 1];
	    clwords[ra - 1] = cmdstr = ret->subcmd;
	    clwords += ra - 1;
	} else {
	    cmdstr = clwords[ra];
	    incmd = !clwpos;
	    clwords += ra;
	}
	*compadd = 0;
	if (ccmain != &cc_dummy)
	    freecompctl(ccmain);
	ret = get_ccompctl(NULL, compadd, incmd);
	clwords = ow;
	cmdstr = os;
	clwnum = oldn;
	clwpos = oldp;
	if (ops)
	    clwords[ra - 1] = ops;
    }
    return ret;
}

void dumphtable(ht, what)	/**/
Hashtab ht;
int what;
{
    int t0;
    struct hashnode *hn;

    addwhat = what;

    for (t0 = ht->hsize - 1; t0 >= 0; t0--)
	for (hn = ht->nodes[t0]; hn; hn = hn->next)
	    addmatch(hn->nam, (char *)hn);

}

char *getreal(str)		/**/
char *str;
{
    Lklist l = newlist();
    int ne = noerrs;

    noerrs = 1;
    addnode(l, dupstring(str));
    prefork(l, 0);
    if (!errflag) {
	postfork(l, 0);
	if (!errflag && full(l)) {
	    noerrs = ne;
	    return ztrdup(peekfirst(l));
	}
    }
    errflag = 0;
    noerrs = ne;

    return ztrdup(str);
}

void gen_matches_files(dirs, execs, all)	/**/
int dirs;
int execs;
int all;
{
    DIR *d;
    struct dirent *de;
    struct stat buf;
    char *n, p[MAXPATHLEN], *q = NULL, *e;
    Lklist l = NULL;
    int ns = 0, ng = opts[NULLGLOB], test, aw = addwhat;

    addwhat = execs ? -8 : -5;
    opts[NULLGLOB] = OPT_SET;

    if (*psuf) {
	q = psuf + strlen(psuf) - 1;
	ns = !(*q == Star || *q == Outpar);
	l = newlist();
	dirs = 1;
	all = execs = 0;
    }
    if ((d = opendir((prpre && *prpre) ? prpre : "."))) {
	if (!all && prpre) {
	    strcpy(p, prpre);
	    q = p + strlen(prpre);
	}
	while ((de = readdir(d)) && !errflag) {
	    n = de->d_name;
	    if (n[0] == '.' && (n[1] == '\0' || (n[1] == '.' && n[2] == '\0')))
		continue;
	    if (*n != '.' || *fpre == '.' || isset(GLOBDOTS)) {
		if (filecomp)
		    test = domatch(n, filecomp, 0);
		else {
		    e = n + strlen(n) - fsl;
		    if ((test = !strncmp(n, fpre, fpl)))
			test = !strcmp(e, fsuf);
		}
		if (!test)
		    continue;
		if (!all) {
		    strcpy(q, n);
		    if (stat(p, &buf) < 0)
			continue;
		}
		if (all ||
		    (dirs && (buf.st_mode & S_IFMT) == S_IFDIR) ||
		    (execs &&
		     ((buf.st_mode & (S_IFMT | S_IEXEC))
		      == (S_IFREG | S_IEXEC)))) {
		    if (*psuf) {
			int o = strlen(p), tt;

			strcpy(p + o, psuf);

			if (ispattern || (ns && isset(GLOBCOMPLETE))) {
			    if (ns) {
				int tl = strlen(p);

				p[tl] = Star;
				p[tl + 1] = '\0';
			    }
			    addnode(l, p);
			    postfork(l, 1);
			    tt = full(l);
			    while (ugetnode(l));
			} else
			    tt = !access(p, F_OK);

			p[o] = '\0';
			if (tt)
			    addmatch(dupstring(n), NULL);
		    } else
			addmatch(dupstring(n), NULL);
		}
	    }
	}
	closedir(d);
    }
    opts[NULLGLOB] = ng;
    addwhat = aw;
}

char *expl, *ccsuffix;
int remsuffix;

void quotepresuf(ps)		/**/
char **ps;
{
    if (*ps) {
	char *p = quotename(*ps, NULL, NULL, NULL);

	if (p != *ps) {
	    zsfree(*ps);
	    *ps = ztrdup(p);
	}
    }
}

int clearflag;

void docompletion(s, lst, incmd)/**/
char *s;
int lst;
int incmd;
{
    Compctl cc = NULL;
    int offs, t, sf1, sf2, compadd, isp = 0, ooffs;
    char *p, *sd = NULL, sav, *tt, *s1, *s2, *os = NULL;
    int owe = we, owb = wb, ocs = cs, delit;
    unsigned char *ol = NULL;

  xorrec:

    if (unset(COMPLETEINWORD) && cs != we)
	cs = we;
    if ((offs = cs - wb) > (t = strlen(s)))
	offs = t;

    ispattern = haswhat = lastambig = 0;
    patcomp = filecomp = NULL;
    menucur = NULL;
    shortest = NULL;

    zsfree(rpre);
    zsfree(rsuf);
    zsfree(lpre);
    zsfree(lsuf);
    zsfree(ppre);
    zsfree(psuf);
    zsfree(prpre);
    zsfree(fpre);
    zsfree(fsuf);
    zsfree(mpre);
    zsfree(msuf);

    rpre = rsuf = lpre = lsuf = ppre = psuf = prpre =
	fpre = fsuf = mpre = msuf = firstm = NULL;

    if (!cc) {
	heapalloc();
	pushheap();
	os = dupstring(s);
	ol = (unsigned char *)dupstring((char *)line);
    }
    matches = newlist();

    if (!cc || cc->ext)
	cc = get_ccompctl(cc, &compadd, incmd);

    wb += compadd;
    s += compadd;
    if ((offs -= compadd) < 0) {
	feep();
	goto compend;
    }
 /* insert prefix, if any */

    if (cc->prefix) {
	int pl = 0, sl = strlen(cc->prefix);

	if (*s) {
	    sd = dupstring(s);
	    untokenize(sd);
	    pl = pfxlen(cc->prefix, sd);
	    s += pl;
	}
	if (pl < sl) {
	    int savecs = cs;

	    cs = wb + pl;
	    inststrlen(cc->prefix + pl, 0, sl - pl);
	    cs = savecs + sl - pl;
	}
	wb += sl;
	we += sl - pl;
    }
    if ((ccsuffix = cc->suffix) && *ccsuffix) {
	char *sdup = dupstring(ccsuffix);
	int sl = strlen(sdup), suffixll;

	for (p = sdup + sl - 1; p >= sdup && *p == ' '; p--, sl--);
	p[1] = '\0';

	if (!sd) {
	    sd = dupstring(s);
	    untokenize(sd);
	}
	if (*sd && (suffixll = strlen(sd)) >= sl &&
	    !strcmp(sdup, sd + suffixll - sl))
	    ccsuffix = NULL, haswhat |= HAS_SUFFIX, s[suffixll - sl] = '\0';
    }
    if ((ic = *s) != Tilde && ic != Equals)
	ic = '\0';
    offs = cs - wb;
    if ((offs = cs - wb) > (t = strlen(s)))
	offs = t;

 /* Check if we have to complete a parameter name... */

    for (p = s + offs; p > s && *p != String; p--);
    if (*p == String && p[1] != Inpar && p[1] != Inbrack) {
	char *b = p + 1, *e = b;
	int n, br = 1;

	if (*b == Inbrace)
	    b++, br++;

	for (t = 0; *b && !t; b++)
	    if (*b == Inpar) {
		for (n = 1, b++; *b && b < s + offs && n; b++)
		    if (*b == Inpar)
			n++;
		    else if (*b == Outpar)
			n--;
		b--;
	    } else
		t = ialnum(*b) || *b == '_' || *b == Star || *b == Quest ||
		    *b == Inbrack || *b == Outbrace || *b == '/';

	for (e = b; *e && t; e++)
	    if (!(ialnum(*e) || *e == '_' || *e == Star || *e == Quest))
		break;

	if (offs <= e - s) {
	    if (b > s && b[-1] != String)
		b--;
	    if (cs == we)
		complexpect = br;
	    wb += b - s;
	    offs -= b - s;
	    we = wb + e - b;
	    *e = '\0';
	    s = b;
	    isp = 1;
	    cc = ccmain = &cc_dummy;
	    cc_dummy.refc = 10000;
	    cc_dummy.mask = CC_PARAMS | CC_ENVVARS;
	} else
	    complexpect = 0;
    }
    ooffs = offs;
    if (cc->mask & CC_DELETE) {
	delit = 1;
	*s = '\0';
	offs = 0;
    } else
	delit = 0;

 /* compute line prefix/suffix */

    sav = s[offs];
    s[offs] = '\0';
    p = quotename(s, NULL, NULL, NULL);
    if (strcmp(p, s) && !strpfx(p, qword)) {
	int l1, l2;

	backdel(l1 = cs - wb);
	untokenize(p);
	inststrlen(p, 1, l2 = strlen(p));
	we += l2 - 1l;
    }
    lpre = ztrdup(s);
    s[offs] = sav;
    if (s[offs] &&
	(p = quotename(s + offs, NULL, NULL, NULL)) &&
	(strcmp(p, s + offs) && !strsfx(p, qword))) {
	int l1, l2;

	foredel(l1 = strlen(s + offs));
	untokenize(p);
	inststrlen(p, 0, l2 = strlen(p));
	we += l2 - l1;
    }
    lsuf = ztrdup(s + offs);

 /* first check for ~... and =... */

    if (ic) {
	for (p = lpre + strlen(lpre); p > lpre; p--)
	    if (*p == '/')
		break;

	if (*p == '/')
	    ic = 0;
    }
 /* compute real prefix/suffix */

    noreal = !delit;
    for (p = lpre; *p && *p != String && *p != Tick; p++);
    tt = ic ? lpre + 1 : lpre;
    rpre = (*p || *lpre == Tilde || *lpre == Equals) ?
	(noreal = 0, getreal(tt)) :
	ztrdup(tt);

    for (p = lsuf; *p && *p != String && *p != Tick; p++);
    rsuf = *p ? (noreal = 0, getreal(lsuf)) : ztrdup(lsuf);

 /* check if word is a pattern */

    for (s1 = NULL, sf1 = 0, p = rpre + (rpl = strlen(rpre)) - 1;
	 p >= rpre && (ispattern != 3 || !sf1);
	 p--)
	if (itok(*p) && (p > rpre || (*p != Equals && *p != Tilde)))
	    ispattern |= sf1 ? 1 : 2;
	else if (*p == '/') {
	    sf1++;
	    if (!s1)
		s1 = p;
	}
    for (s2 = NULL, sf2 = t = 0, p = rsuf; *p && (!t || !sf2); p++)
	if (itok(*p))
	    t |= sf2 ? 4 : 2;
	else if (*p == '/') {
	    sf2++;
	    if (!s2)
		s2 = p;
	}
    ispattern = ispattern | t;

    if (!useglob)
	ispattern = 0;

    if (ispattern) {
	p = (char *)ncalloc(rpl + rsl + 2);
	strcpy(p, rpre);
	if (rpl && p[rpl - 1] != Star) {
	    p[rpl] = Star;
	    strcpy(p + rpl + 1, rsuf);
	} else
	    strcpy(p + rpl, rsuf);
	patcomp = parsereg(p);
    }
    if (!patcomp) {
	untokenize(rpre);
	untokenize(rsuf);

	rpl = strlen(rpre);
	rsl = strlen(rsuf);
    }
    untokenize(lpre);
    untokenize(lsuf);

    lpl = strlen(lpre);
    lsl = strlen(lsuf);

 /* handle completion of files specially */

    if ((cc->mask & (CC_FILES | CC_COMMPATH)) || cc->glob) {
	if (!s1)
	    s1 = rpre;
	if (!s2)
	    s2 = rsuf + rsl;

	if (*s1 != '/')
	    ppre = ztrdup("");
	else {
	    if ((sav = *s1 ? s1[1] : '\0'))
		s1[1] = '\0';
	    ppre = ztrdup(rpre);
	    if (sav)
		s1[1] = sav;
	}
	psuf = ztrdup(s2);

	fpre = ztrdup(((s1 == s || s1 == rpre || ic) &&
		       (*s != '/' || cs == wb)) ? s1 : s1 + 1);
	sav = *s2;
	*s2 = '\0';
	fsuf = ztrdup(rsuf);
	*s2 = sav;

	if (useglob && (ispattern & 2)) {
	    int t2;

	    p = (char *)ncalloc((t2 = strlen(fpre)) + strlen(fsuf) + 2);
	    strcpy(p, fpre);
	    if ((!t2 || p[t2 - 1] != Star) && *fsuf != Star)
		p[t2++] = Star;
	    strcpy(p + t2, fsuf);
	    filecomp = parsereg(p);
	}
	if (!filecomp) {
	    untokenize(fpre);
	    untokenize(fsuf);

	    fpl = strlen(fpre);
	    fsl = strlen(fsuf);
	}
	addwhat = -1;

	if (ic == Tilde)
	    maketildelist();
	else if (ic == Equals) {
	    if (isset(HASHLISTALL))
		fullhash();
	    dumphtable(cmdnamtab, -7);
	} else {
	    if (ispattern & 1) {
		Lklist l = newlist();
		Lknode n;
		int ng = opts[NULLGLOB];

		opts[NULLGLOB] = OPT_SET;

		addwhat = 0;
		p = (char *)ncalloc(lpl + lsl + 3);
		strcpy(p, lpre);
		if (*lsuf != '*' && *lpre && lpre[lpl - 1] != '*')
		    strcat(p, "*");
		strcat(p, lsuf);
		if (*lsuf && lsuf[lsl - 1] != '*' && lsuf[lsl - 1] != ')')
		    strcat(p, "*");

		tokenize(p);
		addnode(l, p);
		postfork(l, 1);

		if (full(l)) {
		    haswhat |= HAS_PATHPAT;
		    for (n = firstnode(l); n; incnode(n))
			addmatch(getdata(n), NULL);
		}
		opts[NULLGLOB] = ng;
	    } else {
		addwhat = CC_FILES;
		prpre = ztrdup(ppre);

		if (sf2)
		    gen_matches_files(1, 0, 0);
		else {
		    if (cc->mask & CC_FILES)
			gen_matches_files(0, 0, 1);
		    else if (cc->mask & CC_COMMPATH) {
			if (sf1)
			    gen_matches_files(1, 1, 0);
			else {
			    char **pc = path, *pp = prpre;

			    for (; *pc; pc++)
				if (pc[0][0] == '.' && !pc[0][1])
				    break;
			    if (*pc) {
				prpre = "./";
				gen_matches_files(1, 1, 0);
				prpre = pp;
			    }
			}
		    }
		    if (cc->glob) {
			int ns, pl = strlen(prpre), o;
			char *g = dupstring(cc->glob), pa[MAXPATHLEN];
			char *p2, *p3;
			int ne = noerrs, md = opts[MARKDIRS];

			glob_pre = fpre;
			glob_suf = fsuf;

			noerrs = 1;
			addwhat = -6;
			strcpy(pa, prpre);
			o = strlen(pa);
			opts[MARKDIRS] = OPT_UNSET;

			while (*g) {
			    Lklist l = newlist();

			    while (*g && inblank(*g))
				g++;
			    if (!*g)
				break;
			    for (p = g + 1; *p && !inblank(*p); p++)
				if (*p == '\\' && p[1])
				    p++;
			    sav = *p;
			    *p = '\0';
			    tokenize(g = dupstring(g));
			    if (*g == Equals || *g == Tilde) {
				filesub(&g, 0);
				addnode(l, dupstring(g));
			    } else if (*g == '/')
				addnode(l, dupstring(g));
			    else {
				strcpy(pa + o, g);
				addnode(l, dupstring(pa));
			    }
			    postfork(l, 1);
			    if (full(l) && peekfirst(l)) {
				for (p2 = (char *)peekfirst(l); *p2; p2++)
				    if (itok(*p2))
					break;
				if (!*p2) {
				    if (*g == Equals || *g == Tilde || *g == '/') {
					while ((p2 = (char *)ugetnode(l)))
					    if (strpfx(prpre, p2))
						addmatch(p2 + pl, NULL);
				    } else {
					while ((p2 = p3 = (char *)ugetnode(l))) {
					    for (ns = sf1; *p3 && ns; p3++)
						if (*p3 == '/')
						    ns--;

					    addmatch(p3, NULL);
					}
				    }
				}
			    }
			    pa[o] = '\0';
			    *p = sav;
			    g = p;
			}
			glob_pre = glob_suf = NULL;
			noerrs = ne;
			opts[MARKDIRS] = md;
		    }
		}
	    }
	}
    }
 /* Use tricat() instead of dyncat() to get zalloc()'d memory */
    if (ic == Tilde || ic == Equals) {
	char *orpre = rpre;

	rpre = tricat("", (ic == Tilde) ? "~" : "=", rpre);
	rpl++;
	zsfree(orpre);
    }
    if (!ic && (cc->mask & CC_COMMPATH) && !*ppre && !*psuf) {
	dumphtable(aliastab, -2);
	if (isset(HASHLISTALL))
	    fullhash();
	dumphtable(cmdnamtab, -3);
	if (isset(AUTOCD) && isset(CDABLEVARS))
	    dumphtable(paramtab, -4);
    }
    addwhat = -2;

    if (cc->mask & CC_NAMED) {
	int t0;

	for (t0 = 0; t0 < userdirct; t0++)
	    addmatch(namdirs[t0].name, NULL);
    }
    if (cc->mask & CC_OPTIONS) {
	struct option *o;

	for (o = optns; o->name; o++)
	    addmatch(dupstring(o->name), NULL);
    }
    if (cc->mask & CC_VARS)
	dumphtable(paramtab, -2);
    if (cc->mask & CC_BINDINGS) {
	int t0;

	for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
	    if (*zlecmds[t0].name)
		addmatch(dupstring(zlecmds[t0].name), NULL);
    }
    if (cc->keyvar) {
	char **usr = get_user_var(cc->keyvar);

	if (usr)
	    while (*usr)
		addmatch(*usr++, NULL);
    }
    if (cc->mask & CC_USERS)
	maketildelist();
    if (cc->func) {
	List list;
	char **r;
	int lv = lastval;

	if ((list = getshfunc(cc->func))) {
	    Lklist args = newlist();

	    addnode(args, cc->func);

	    if (delit) {
		sav = os[ooffs];
		os[ooffs] = '\0';
		p = dupstring(os);
		untokenize(p);
		addnode(args, p);
		os[ooffs] = sav;
		p = dupstring(os + ooffs);
		untokenize(p);
		addnode(args, p);
	    } else {
		addnode(args, lpre);
		addnode(args, lsuf);
	    }

	    inzlefunc = 1;
	    doshfuncnoval(list, args, 0);
	    inzlefunc = 0;
	    if ((r = get_user_var("reply")))
		while (*r)
		    addmatch(*r++, NULL);
	}
	lastval = lv;
    }
    if (cc->mask & (CC_JOBS | CC_RUNNING | CC_STOPPED)) {
	int i;
	char *j, *jj;

	for (i = 0; i < MAXJOB; i++)
	    if (jobtab[i].stat & STAT_INUSE) {
		int stopped = jobtab[i].stat & STAT_STOPPED;

		j = jj = dupstring(jobtab[i].procs->text);
		for (; *jj; jj++)
		    if (*jj == ' ') {
			*jj = '\0';
			break;
		    }
		if ((cc->mask & CC_JOBS) || (stopped && (cc->mask & CC_STOPPED))
		    || (!stopped && (cc->mask & CC_RUNNING)))
		    addmatch(j, NULL);
	    }
    }
    if (cc->str) {
	Lklist foo = newlist();
	Lknode n;
	int first = 1, ng = opts[NULLGLOB], oowe = we, oowb = wb;

	opts[NULLGLOB] = OPT_SET;

	zleparse = 1;
	lexsave();
	hungets(cc->str);
	hungets("foo ");	/* KLUDGE! */
	strinbeg();
	noaliases = 1;
	do {
	    ctxtlex();
	    if (tok == ENDINPUT)
		break;
	    if (!first && tokstr && *tokstr)
		addnode(foo, ztrdup(tokstr));
	    first = 0;
	}
	while (tok != ENDINPUT && zleparse);
	noaliases = 0;
	hflush();
	strinend();
	errflag = zleparse = 0;
	lexrestore();
	prefork(foo, 0);
	if (!errflag) {
	    postfork(foo, 1);
	    if (!errflag)
		for (n = firstnode(foo); n; incnode(n))
		    addmatch((char *)n->dat, NULL);
	}
	opts[NULLGLOB] = ng;
	we = oowe;
	wb = oowb;
    }
    if (cc->hpat) {
	Comp compc = NULL;
	char *e, *h, hpatsav;
	int i = curhist - 1, n = cc->hnum, l = lithist;

	if (*(cc->hpat)) {
	    char *thpat = dupstring(cc->hpat);

	    tokenize(thpat);
	    compc = parsereg(thpat);
	}
	if (!n)
	    n = -1;
	lithist = 0;

	while (n-- && (h = qgetevent(i--))) {
	    while (*h) {
		for (e = h; *e && *e != HISTSPACE; e++);
		hpatsav = *e;
		*e = '\0';
		if (*h != '\'' && *h != '"' && *h != '`' && *h != '$' &&
		    (!compc || domatch(h, compc, 0)))
		    addmatch(dupstring(h), NULL);
		if (hpatsav) {
		    *e = hpatsav;
		    h = e + 1;
		} else
		    h = e;
	    }
	}
	lithist = l;
    }
    if ((t = cc->mask & (CC_ARRAYS | CC_INTVARS | CC_ENVVARS | CC_SCALARS |
			 CC_READONLYS | CC_SPECIALS | CC_PARAMS)))
	dumphtable(paramtab, t);
    if ((t = cc->mask & (CC_FUNCS | CC_BUILTINS | CC_DISCMDS | CC_EXCMDS)))
	dumphtable(cmdnamtab, t);
    if ((t = cc->mask & (CC_ALREG | CC_ALGLOB)))
	dumphtable(aliastab, t);

    expl = cc->explain;

    remsuffix = (cc->mask & CC_REMOVE);
    ccsuffix = cc->suffix;

    mpre = ztrdup(lpre);
    msuf = ztrdup(lsuf);
    quotepresuf(&lpre);
    quotepresuf(&lsuf);
    quotepresuf(&fpre);
    quotepresuf(&fsuf);
    quotepresuf(&ppre);
    quotepresuf(&psuf);

    if (empty(matches) || errflag) {
	if (cc->xor && !isp) {
	    errflag = 0;
	    cc = cc->xor;
	    wb = owb;
	    we = owe;
	    cs = ocs;
	    s = dupstring(os);
	    strcpy((char *)line, (char *)ol);
	    goto xorrec;
	}
	strcpy((char *)line, (char *)ol);
	feep();
    } else if (lst == COMP_LIST_COMPLETE)
	listtlist(matches);
    else {
	if (delit) {
	    wb -= compadd;
	    strcpy((char *)line + wb, (char *)line + we);
	    we = cs = wb;
	}
	if (nextnode(firstnode(matches)))
	    do_ambiguous();
	else
	    do_single((char *)peekfirst(matches));
    }

    if (expl && (empty(matches) || nextnode(firstnode(matches)))) {
	int up;

	trashzle();

	clearflag = (isset(USEZLE) && termok &&
		     (isset(ALWAYSLASTPROMPT) && mult == 1)) ||
	    (unset(ALWAYSLASTPROMPT) && mult != 1);

	up = printfmt(expl, countnodes(matches), 1);

	if (clearflag)
	    tcmultout(TCUP, TCMULTUP, up + nlnct);
	fflush(stdout);
    }
    ll = strlen((char *)line);
    if (cs > ll)
	cs = ll;
  compend:
    if (ccmain != &cc_dummy)
	freecompctl(ccmain);
    popheap();
    permalloc();
}

char **get_user_var(nam)	/**/
char *nam;
{
    if (!nam)
	return NULL;
    else if (*nam == '(') {
	char *ptr, *s, **uarr, **aptr;
	int count = 0, nonempty = 0, brk = 0;
	Lklist arrlist = newlist();

	ptr = dupstring(nam);
	s = ptr + 1;
	while (*++ptr) {
	    if (*ptr == '\\' && ptr[1])
		chuck(ptr), nonempty++;
	    else if (*ptr == ',' || inblank(*ptr) || *ptr == ')') {
		if (*ptr == ')')
		    brk++;
		if (nonempty) {
		    *ptr = '\0';
		    count++;
		    if (*s == '\n')
			s++;
		    addnode(arrlist, s);
		}
		s = ptr + 1;
		nonempty = 0;
	    } else
		nonempty++;
	    if (brk)
		break;
	}
	if (!brk || !count)
	    return NULL;
	*ptr = '\0';
	aptr = uarr = (char **)ncalloc(sizeof(char *) * (count + 1));

	while ((*aptr++ = (char *)ugetnode(arrlist)));
	uarr[count] = NULL;
	return uarr;
    } else
	return getaparam(nam);
}

int strbpcmp(a, b)		/**/
const void *a;
const void *b;
{
    char *aa = *((char **)a), *bb = *((char **)b);

    while (*aa && *bb) {
	if (*aa == '\\')
	    aa++;
	if (*bb == '\\')
	    bb++;
	if (*aa != *bb)
	    return (int)(*aa - *bb);
	if (*aa)
	    aa++;
	if (*bb)
	    bb++;
    }
    return 0;
}

void do_ambiguous()
{				/**/
    char **ap, **bp, **cp;
    int p, atend = (cs == we);
    Lknode nod;

    lastambig = 1;

    if (menuarr) {
	freearray(menuarr);
	menuarr = NULL;
	menucmp = 0;
    }
    ap = amatches = (char **)ncalloc(((nmatches = countnodes(matches)) + 1) *
				     sizeof(char *));

    for (nod = firstnode(matches); nod; incnode(nod))
	*ap++ = (char *)getdata(nod);
    *ap = NULL;

    qsort((vptr) amatches, nmatches, sizeof(char *),
	       (int (*)DCLPROTO((const void *, const void *)))strbpcmp);

    for (ap = cp = amatches; *ap; ap++) {
	*cp++ = *ap;
	for (bp = ap; bp[1] && !strcmp(*ap, bp[1]); bp++);
	ap = bp;
    }
    *cp = NULL;

    if ((nmatches = arrlen(amatches)) == 1) {
	lastambig = 0;
	do_single(amatches[0]);
	return;
    }
    complexpect = 0;

    if ((p = (usemenu || ispattern)) || isset(AUTOMENU)) {
	permalloc();
	menuarr = arrdup(amatches);
	heapalloc();
    }
    if (shortest && shortl == 0 && isset(RECEXACT) &&
	(usemenu == 0 || unset(AUTOMENU))) {
	do_single(shortest);
    } else {
	if (p)
	    do_ambig_menu();
	else {
	    if (ab)
		inststrlen(firstm, 1, ab);
	    if (ae && !atend)
		inststrlen(firstm + strlen(firstm) - ae, 0, ae);
	    if (isset(LISTAMBIGUOUS) && (ab || (ae && !atend))) {
		lastambig = 0;
		return;
	    }
	}
	if (unset(NOLISTBEEP))
	    feep();
	if (isset(AUTOLIST) && !amenu)
	    listmatches();
    }
}

int ztat(nam, buf, ls)		/**/
char *nam;
struct stat *buf;
int ls;
{
    char b[MAXPATHLEN], *p;

    for (p = b; *nam; nam++)
	if (*nam == '\\' && nam[1])
	    *p++ = *++nam;
	else
	    *p++ = *nam;
    *p = '\0';

    return ls ? lstat(b, buf) : stat(b, buf);
}

void do_single(str)		/**/
char *str;
{
    int ccs, l, insc = 0, inscs = 0;
    char singlec = ' ';

    addedsuffix = 0;

    if (!menucur) {
	if (ispattern) {
	    cs = we;
	    menupos = wb;
	} else
	    menupos = cs;
	menuwe = (cs == we);
	if (ccsuffix && !(haswhat & HAS_SUFFIX)) {
	    if (*ccsuffix) {
		ccs = cs;
		cs = we;
		inststrlen(ccsuffix, menuwe, -1);
		menuend = cs;
		cs = ccs;
		if (remsuffix)
		    addedsuffix = strlen(ccsuffix);
	    } else
		menuend = we;

	    haswhat |= HAS_SUFFIX;
	} else
	    menuend = we;
    }
    ccs = cs;
    cs = menupos;
    if (menucur)
	l = menulen;
    else if (ispattern)
	l = we - wb;
    else
	l = 0;

    if (l) {
	foredel(l);
	if (menuwe)
	    ccs -= l;
	menuend -= l;
    }
    inststrlen(str, 1, menulen = strlen(str));

    if (menuwe)
	cs = ccs + menulen;
    menuend += menulen;

    if (!(haswhat & HAS_SUFFIX)) {
	if (!(haswhat & HAS_MISC)) {
	    char p[MAXPATHLEN], *ss;
	    struct stat buf;

	    if (ispattern || ic) {
		int ne = noerrs;

		noerrs = 1;

		if (ic) {
		    *p = ic;
		    sprintf(p + 1, "%s%s%s%s", fpre, str, fsuf, psuf);
		} else
		    strcpy(p, str);
		ss = dupstring(p);
		singsub(&ss);
		strcpy(p, ss);

		noerrs = ne;
	    } else
		sprintf(p, "%s%s%s%s%s",
			(prpre && *prpre) ? prpre : "./", fpre, str,
			fsuf, psuf);
	    if (!ztat(p, &buf, 0) && (buf.st_mode & S_IFMT) == S_IFDIR) {
		singlec = '/';
		if (menuwe)
		    addedsuffix = isset(AUTOREMOVESLASH) ? 1 : 0;
	    }
	}
	if (menuend > ll)
	    menuend = ll;
	if (menuend && ((char)line[menuend - 1]) != singlec)
	    if (!menucur || !line[menuend]) {
		ccs = cs;
		cs = menuend;
		inststrlen((char *)&singlec, 1, 1);
		insc = 1;
		inscs = cs;
		if (!menuwe)
		    cs = ccs;
	    } else
		line[menuend] = (unsigned char)singlec;
    }
    if (isset(ALWAYSTOEND) || menuwe)
	cs = menuend + !(haswhat & HAS_SUFFIX);
    if (menucmp && singlec == ' ' && !(haswhat & HAS_SUFFIX)) {
	if (insc) {
	    ccs = cs;
	    cs = inscs;
	    backdel(1);
	    if (ccs != inscs)
	      cs = ccs;
	}
	else
	    cs--;
    }
}

void do_ambig_menu()
{				/**/
    menucmp = 1;
    menucur = NULL;
    do_single(*menuarr);
    menucur = menuarr;
}

int strpfx(s, t)		/**/
char *s;
char *t;
{
    while (*s && *s == *t)
	s++, t++;
    return !*s;
}

int strsfx(s, t)		/**/
char *s;
char *t;
{
    int ls = strlen(s), lt = strlen(t);

    if (ls <= lt)
	return !strcmp(t + lt - ls, s);
    return 0;
}

int pfxlen(s, t)		/**/
char *s;
char *t;
{
    int i = 0;

    while (*s && *s == *t)
	s++, t++, i++;
    return i;
}

int sfxlen(s, t)		/**/
char *s;
char *t;
{
    if (*s && *t) {
	int i = 0;
	char *s2 = s + strlen(s) - 1, *t2 = t + strlen(t) - 1;

	while (s2 >= s && t2 >= t && *s2 == *t2)
	    s2--, t2--, i++;

	return i;
    } else
	return 0;
}

int printfmt(fmt, n, dopr)	/**/
char *fmt;
int n;
int dopr;
{
    char *p = fmt, nc[14];
    int l = 1, cc = 0;

    for (; *p; p++) {
	if (*p == '%')
	    if (*++p)
		switch (*p) {
		case '%':
		    if (dopr)
			putchar('%');
		    cc++;
		    break;
		case 'n':
		    sprintf(nc, "%d", n);
		    if (dopr)
			printf(nc);
		    cc += strlen(nc);
	    } else
		break;
	else {
	    cc++;
	    if (*p == '\n') {
		l += 1 + (cc / columns);
		cc = 0;
	    }
	    if (dopr)
		putchar(*p);
	}
    }
    if (dopr)
	putchar('\n');

    return l + (cc / columns);
}

void listmatches()
{				/**/
    int longest = 1, fct, fw = 0, colsz, t0, t1, ct, up, cl;
    int off, boff;
    int of = (isset(LISTTYPES) && !(haswhat & HAS_MISC));
    char **arr, **ap, sav;

    off = ispattern && ppre && *ppre &&
	!(haswhat & (HAS_MISC | HAS_PATHPAT)) ? strlen(ppre) : 0;
    boff = ispattern && psuf && *psuf &&
	!(haswhat & (HAS_MISC | HAS_PATHPAT)) ? strlen(psuf) : 0;

    trashzle();
    ct = nmatches;

    clearflag = (isset(USEZLE) && termok &&
		 (isset(ALWAYSLASTPROMPT) && mult == 1)) ||
	(unset(ALWAYSLASTPROMPT) && mult != 1);

    arr = amatches;

    for (ap = arr; *ap; ap++)
	if ((cl = strlen(*ap + off) - boff +
	     (ispattern ? 0 :
	      (!(haswhat & HAS_MISC) ? fpl + fsl : lpl + lsl))) > longest)
	    longest = cl;
    if (of)
	longest++;

    fct = (columns - 1) / (longest + 2);
    if (fct == 0)
	fct = 1;
    else
	fw = (columns - 1) / fct;
    colsz = (ct + fct - 1) / fct;

    up = colsz + nlnct - clearflag;

    if (expl)
	up += printfmt(expl, ct, 0);

    if ((listmax && ct > listmax) || (!listmax && up >= lines)) {
	fprintf(stdout, "zsh: do you wish to see all %d possibilities? ", ct);
	fflush(stdout);
	if (getquery() != 'y') {
	    if (clearflag) {
		tcmultout(TCUP, TCMULTUP, 1);
		if (tccan(TCCLEAREOD))
		    tcout(TCCLEAREOD);
		tcmultout(TCUP, TCMULTUP, nlnct);
	    }
	    return;
	}
	if (clearflag) {
	    tcout(TCUP);
	    if (tccan(TCCLEAREOD))
		tcout(TCCLEAREOD);
	}
    }
    if (expl)
	printfmt(expl, ct, 1);

    for (t1 = 0; t1 != colsz; t1++) {
	ap = arr + t1;
	if (of) {
	    while (*ap) {
		int t2 = ispattern ? strlen(*ap) :
		strlen(*ap + off) - boff + 1 + fpl + fsl;
		char pbuf[MAXPATHLEN], *pb;
		struct stat buf;

		if (ispattern) {
		    sav = ap[0][t2 - boff];
		    ap[0][t2 - boff] = '\0';
		    printf("%s", *ap + off);
		    ap[0][t2 - boff] = sav;
		    pb = *ap;
		    t2 -= off + boff - 1;
		} else {
		    printf("%s%s%s", fpre, *ap, fsuf);
		    sprintf(pb = pbuf, "%s%s%s%s",
			    (prpre && *prpre) ? prpre : "./", fpre, *ap, fsuf);
		}
		if (ztat(pb, &buf, 1))
		    putchar(' ');
		else
		    putchar(file_type(buf.st_mode));
		for (t0 = colsz; t0 && *ap; t0--, ap++);
		if (*ap)
		    for (; t2 < fw; t2++)
			putchar(' ');
	    }
	} else
	    while (*ap) {
		int t2 = ispattern ? strlen(*ap) :
		strlen(*ap + off) - boff;

		if (ispattern) {
		    sav = ap[0][t2 - boff];
		    ap[0][t2 - boff] = '\0';
		    printf("%s", *ap + off);
		    ap[0][t2 - boff] = sav;
		    t2 -= off + boff;
		} else if (!(haswhat & HAS_MISC)) {
		    printf("%s%s%s", fpre, *ap, fsuf);
		    t2 += fpl + fsl;
		} else {
		    printf("%s%s%s", lpre, *ap, lsuf);
		    t2 += lpl + lsl;
		}
		for (t0 = colsz; t0 && *ap; t0--, ap++);
		if (*ap)
		    for (; t2 < fw; t2++)
			putchar(' ');
	    }
	if (t1 != colsz - 1 || !clearflag)
	    putchar('\n');
    }
    if (clearflag)
	if (up < lines)
	    tcmultout(TCUP, TCMULTUP, up);
	else
	    clearflag = 0, putchar('\n');

    expl = NULL;

    fflush(stdout);
}

void listtlist(l)		/**/
Lklist l;
{
    int n = countnodes(l), nm = nmatches;
    char **am = amatches, **ap, **bp, **cp;
    Lknode nod;

    nmatches = n;

    amatches = ap = (char **)ncalloc((n + 1) * sizeof(char *));

    for (nod = firstnode(l); nod; incnode(nod))
	*ap++ = (char *)getdata(nod);
    *ap = NULL;

    qsort((vptr) amatches, nmatches, sizeof(char *),
	       (int (*)DCLPROTO((const void *, const void *)))strpcmp);

    for (ap = cp = amatches; *ap; ap++) {
	*cp++ = *ap;
	for (bp = ap; bp[1] && !strcmp(*ap, bp[1]); bp++);
	ap = bp;
    }
    *cp = NULL;

    listmatches();

    amatches = am;
    nmatches = nm;
}

void listlist(l)		/**/
Lklist l;
{
    int hw = haswhat, ip = ispattern;
    char *lp = lpre, *ls = lsuf;

    haswhat = HAS_MISC;
    ispattern = 0;
    lpre = lsuf = "";

    listtlist(l);

    lpre = lp;
    lsuf = ls;
    ispattern = ip;
    haswhat = hw;
}

void selectlist(l)		/**/
Lklist l;
{
    int longest = 1, fct, fw = 0, colsz, t0, t1, ct;
    Lknode n;
    char **arr, **ap;

    trashzle();
    ct = countnodes(l);
    ap = arr = (char **)alloc((countnodes(l) + 1) * sizeof(char **));

    for (n = (Lknode) firstnode(l); n; incnode(n))
	*ap++ = (char *)getdata(n);
    *ap = NULL;
    for (ap = arr; *ap; ap++)
	if (strlen(*ap) > longest)
	    longest = strlen(*ap);
    t0 = ct;
    longest++;
    while (t0)
	t0 /= 10, longest++;
    fct = (columns - 1) / (longest + 3);	/* to compensate for added ')' */
    if (fct == 0)
	fct = 1;
    else
	fw = (columns - 1) / fct;
    colsz = (ct + fct - 1) / fct;
    for (t1 = 0; t1 != colsz; t1++) {
	ap = arr + t1;
	do {
	    int t2 = strlen(*ap) + 2, t3;

	    fprintf(stderr, "%d) %s", t3 = ap - arr + 1, *ap);
	    while (t3)
		t2++, t3 /= 10;
	    for (; t2 < fw; t2++)
		fputc(' ', stderr);
	    for (t0 = colsz; t0 && *ap; t0--, ap++);
	}
	while (*ap);
	fputc('\n', stderr);
    }

 /* Below is a simple attempt at doing it the Korn Way..
       ap = arr;
       t0 = 0;
       do
       {
       t0++;
       fprintf(stderr,"%d) %s\n",t0,*ap);
       ap++;
       }
       while (*ap);*/
    fflush(stderr);
}

int doexpandhist()
{				/**/
    unsigned char *cc, *ce, oc = ' ', ooc = ' ';
    int t0, oldcs, oldll;

    for (cc = line, ce = line + ll; cc < ce; ooc = oc, oc = *cc++)
	if (*cc == '\\' && cc[1])
	    cc++;
	else if ((*cc == bangchar && oc != '>' && (oc != '&' || ooc != '>')) ||
		 (*cc == hatchar && *line == hatchar && cc != line))
	    break;
    if (*cc == bangchar && cc[1] == '"')
	return 3;
    if (cc == ce)
	return 2;
    oldcs = cs;
    oldll = ll;
    zleparse = 1;
    lexsave();
    hungets(UTOSCP(line));
    strinbeg();
    pushheap();
    ll = cs = 0;
    for (;;) {
	t0 = hgetc();
	if (lexstop)
	    break;
	spaceinline(1);
	line[cs++] = t0;
    }
    hflush();
    popheap();
    strinend();
    errflag = zleparse = 0;
    t0 = histdone;
    lexrestore();
    line[ll = cs] = '\0';
    if (ll == oldll)
	cs = oldcs;
    return t0;
}

void magicspace()
{				/**/
    c = ' ';
    selfinsert();
    doexpandhist();
}

void expandhistory()
{				/**/
    if (!doexpandhist())
	feep();
}

static int cmdwb, cmdwe;

char *getcurcmd()
{				/**/
    int curlincmd;
    char *s = NULL;

    zleparse = 1;
    lexsave();
    hungets(" ");		/* KLUDGE! */
    hungets(UTOSCP(line));
    strinbeg();
    pushheap();
    do {
	curlincmd = incmdpos;
	ctxtlex();
	if (tok == ENDINPUT)
	    break;
	if (tok == STRING && curlincmd) {
	    zsfree(s);
	    s = ztrdup(tokstr);
	    cmdwb = ll - wordbeg;
	    cmdwe = ll + 1 - inbufct;
	}
    }
    while (tok != ENDINPUT && zleparse);
    hflush();
    popheap();
    strinend();
    errflag = zleparse = 0;
    lexrestore();
    return s;
}

void processcmd()
{				/**/
    char *s, *t;

    s = getcurcmd();
    if (!s) {
	feep();
	return;
    }
    t = zlecmds[bindk].name;
    mult = 1;
    permalloc();
    pushline();
    lastalloc();
    sizeline(strlen(s) + strlen(t) + 1);
    strcpy((char *)line, t);
    strcat((char *)line, " ");
    cs = ll = strlen((char *)line);
    inststr(s);
    zsfree(s);
    done = 1;
}

void expandcmdpath()
{				/**/
    int oldcs = cs, na = noaliases;
    char *s, *str;

    noaliases = 1;
    s = getcurcmd();
    noaliases = na;
    if (!s || cmdwb < 0 || cmdwe < cmdwb) {
	feep();
	return;
    }
    str = findcmd(s);
    zsfree(s);
    if (!str) {
	feep();
	return;
    }
    cs = cmdwb;
    foredel(cmdwe - cmdwb);
    spaceinline(strlen(str));
    strncpy((char *)line + cs, str, strlen(str));
    cs = oldcs;
    if (cs >= cmdwe - 1)
	cs += cmdwe - cmdwb + strlen(str);
    if (cs > ll)
	cs = ll;
    zsfree(str);
}

/* Extra function added by AR Iano-Fletcher. */
/* This is a expand/complete in the vein of wash. */

void expandorcompleteprefix()
{				/**/
 /* global c is the current character typed. */
    int csafe = c;

 /* insert a space and backspace. */
    c = ' ';
    selfinsert();		/* insert the extra character */
    forwardchar();		/* move towards beginning */

 /* do the expansion/completion. */
    c = csafe;
    expandorcomplete();		/* complete. */

 /* remove the inserted space. */
    backwardchar();		/* move towards ends */
    deletechar();		/* delete the added space. */
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /*
 *
 * ztype.h - character classification macros
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define IDIGIT  1
#define IALNUM  2
#define IBLANK  4
#define INBLANK 8
#define ITOK    16
#define ISEP    32
#define IALPHA  64
#define IIDENT  128
#define IUSER   256
#define ICNTRL  512
#define IWORD	 1024
#define ISPECIAL 2048
#define _icom(X,Y) (typtab[(int) (unsigned char) (X)] & Y)
#define idigit(X) _icom(X,IDIGIT)
#define ialnum(X) _icom(X,IALNUM)
#define iblank(X) _icom(X,IBLANK)	/* blank, not including \n */
#define inblank(X) _icom(X,INBLANK)	/* blank or \n */
#define itok(X) _icom(X,ITOK)
#define isep(X) _icom(X,ISEP)
#define ialpha(X) _icom(X,IALPHA)
#define iident(X) _icom(X,IIDENT)
#define iuser(X) _icom(X,IUSER)	/* username char */
#define icntrl(X) _icom(X,ICNTRL)
#define iword(X) _icom(X,IWORD)
#define ispecial(X) _icom(X,ISPECIAL)

EXTERN short int typtab[256];
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
/*
 *
 * zle_utils.c - miscellaneous line editor utilities
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define ZLE
#include "zsh.h"

/* make sure that the line buffer has at least sz chars */

void sizeline(sz)		/**/
int sz;
{
    while (sz > linesz)
	line = (unsigned char *)realloc(line, (linesz *= 4) + 1);
}

/* insert space for ct chars at cursor position */

void spaceinline(ct)		/**/
int ct;
{
    int i;

    while (ct + ll > linesz)
	line = (unsigned char *)realloc(line, (linesz *= 4) + 1);
    for (i = ll; i >= cs; i--)
	line[i + ct] = line[i];
    ll += ct;
    line[ll] = '\0';
}

void backkill(ct, dir)		/**/
int ct;
int dir;
{
    int i = (cs -= ct);

    cut(i, ct, dir);
    while ((line[i] = line[i + ct]))
	i++;
    ll -= ct;
}

void forekill(ct, dir)		/**/
int ct;
int dir;
{
    int i = cs;

    cut(i, ct, dir);
    while ((line[i] = line[i + ct]))
	i++;
    ll -= ct;
}

extern owrite;

void cut(i, ct, dir)		/**/
int i;
int ct;
int dir;
{
    if (vibufspec) {
	if (owrite || !vibuf[vibufspec]) {
	    if (vibuf[vibufspec])
		free(vibuf[vibufspec]);
	    vibuf[vibufspec] = (char *)zalloc(ct + 1);
	    ztrncpy(vibuf[vibufspec], UTOSCP(line + i), ct);
	} else {
	    int len = strlen(vibuf[vibufspec]);

	    vibuf[vibufspec] = realloc(vibuf[vibufspec], ct + len);
	    ztrncpy(vibuf[vibufspec] + len, UTOSCP(line + i), ct);
	}
	vibufspec = 0;
	return;
    }
    if (!cutbuf)
	cutbuf = ztrdup("");
    else if (!(lastcmd & ZLE_KILL)) {
	kringnum = (kringnum + 1) & (KRINGCT - 1);
	if (kring[kringnum])
	    free(kring[kringnum]);
	kring[kringnum] = cutbuf;
	cutbuf = ztrdup("");
    }
    if (dir) {
	char *s = (char *)zalloc(strlen(cutbuf) + ct + 1);

	strncpy(s, (char *)line + i, ct);
	strcpy(s + ct, cutbuf);
	free(cutbuf);
	cutbuf = s;
    } else {
	int x;

	cutbuf = realloc(cutbuf, (x = strlen(cutbuf)) + ct + 1);
	ztrncpy(cutbuf + x, UTOSCP(line + i), ct);
    }
}

void backdel(ct)		/**/
int ct;
{
    int i = (cs -= ct);

    while ((line[i] = line[i + ct]))
	i++;
    ll -= ct;
}

void foredel(ct)		/**/
int ct;
{
    int i = cs;

    while ((line[i] = line[i + ct]))
	i++;
    ll -= ct;
}

void setline(s)			/**/
char *s;
{
    sizeline(strlen(s));
    strcpy((char *)line, s);
    cs = ll = strlen(s);
    if (cs && bindtab == altbindtab)
	cs--;
}

void sethistline(s)		/**/
unsigned char *s;
{
    setline(UTOSCP(s));
    for (s = line; *s; s++)
	if (*s == STOUC(HISTSPACE))
	    *s = ' ';
}

int findbol()
{				/**/
    int x = cs;

    while (x > 0 && line[x - 1] != '\n')
	x--;
    return x;
}

int findeol()
{				/**/
    int x = cs;

    while (x != ll && line[x] != '\n')
	x++;
    return x;
}

void findline(a, b)		/**/
int *a;
int *b;
{
    *a = findbol();
    *b = findeol();
}

static int lastlinelen;

void initundo()
{				/**/
    int t0;

    for (t0 = 0; t0 != UNDOCT; t0++)
	undos[t0].change = NULL;
    undoct = 0;
    lastline = (unsigned char *)zalloc(lastlinelen = (ll + 1 < 32) ? 32 : ll + 1);
    strcpy((char *)lastline, (char *)line);
    lastcs = cs;
}

void addundo()
{				/**/
    int pf, sf;
    unsigned char *s, *s2, *t, *t2;
    struct undoent *ue;

    for (s = line, t = lastline; *s && *s == *t; s++, t++);
    if (!*s && !*t)
	return;
    pf = s - line;
    for (s2 = (unsigned char *)line + strlen((char *)line),
	 t2 = lastline + strlen((char *)lastline);
	 s2 > s && t > t2 && s2[-1] == t2[-1]; s2--, t2--);
    sf = strlen((char *)s2);
    ue = undos + (undoct = (UNDOCT - 1) & (undoct + 1));
    ue->pref = pf;
    ue->suff = sf;
    ue->len = t2 - t;
    ue->cs = lastcs;
    strncpy(ue->change = (char *)halloc(ue->len), (char *)t, ue->len);
    while (ll + 1 > lastlinelen) {
	free(lastline);
	lastline = (unsigned char *)zalloc(lastlinelen *= 2);
    }
    strcpy((char *)lastline, (char *)line);
    lastcs = cs;
}

int hstrncmp(s, t, len)		/**/
char *s;
char *t;
int len;
{
    while (len && *s && (*s == *t || (*s == ' ' && *t == HISTSPACE) ||
			 (*s == HISTSPACE && *t == ' ')))
	s++, t++, len--;
    return len;
}

int hstrcmp(s, t)		/**/
char *s;
char *t;
{
    while (*s && (*s == *t || (*s == ' ' && *t == HISTSPACE) ||
		  (*s == HISTSPACE && *t == ' ')))
	s++, t++;
    return !(*s == '\0' && *t == '\0');
}

char *hstrnstr(s, t, len)	/**/
char *s;
char *t;
int len;
{
    for (; *s; s++)
	if (!hstrncmp(t, s, len))
	    return s;
    return NULL;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#
/*
 *
 * zle_vi.c - vi-specific functions
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define ZLE
#include "zsh.h"

SPROTO(void startvichange, (int im));

static void startvichange(im)
int im;
{
    insmode = im;
    if (vichgbuf)
	free(vichgbuf);
    vichgbuf = (char *)zalloc(vichgbufsz = 16);
    vichgbuf[0] = c;
    vichgbufptr = 1;
    vichgflag = 1;
    viinsbegin = cs;
}

SPROTO(void startvitext, (int im));

static void startvitext(im)
int im;
{
    startvichange(im);
    bindtab = mainbindtab;
    undoing = 0;
}

int vigetkey()
{				/**/
    int cmd;

    if ((cmd = getkeycmd()) < 0 || cmd == z_sendbreak) {
	feep();
	return 0;
    }
    if (cmd == z_quotedinsert) {
	if ((c = getkey(0)) == EOF)
	    return 0;
	return c;
    } else if (cmd == z_vicmdmode)
	return 0;
    return c;
}

int getvirange(wf)		/**/
int wf;
{
    int k2, t0, startline, endline;

    startline = findbol();
    endline = findeol();
    for (;;) {

	if ((k2 = getkeycmd()) < 0 || k2 == z_sendbreak) {
	    feep();
	    return -1;
	}
	if (zlecmds[k2].flags & ZLE_ARG)
	    (*zlecmds[k2].func) ();
	else
	    break;
    }
    if (k2 == bindk) {
	findline(&cs, &t0);
	return (t0 == ll) ? t0 : t0 + 1;
    }
    if (!(zlecmds[k2].flags & ZLE_MOVEMENT)) {
	feep();
	return -1;
    }
    t0 = cs;

    virangeflag = 1;
    wordflag = wf;
    (*zlecmds[k2].func) ();
    wordflag = virangeflag = 0;
    if (cs == t0) {
	feep();
	return -1;
    }
    if (startline != findbol()) {
	if (zlecmds[k2].flags & ZLE_LINEMOVE) {
	    if (cs < t0) {
		cs = startline;
		t0 = findeol() + 1;
	    } else {
		t0 = startline;
		cs = findeol() + 1;
	    }
	} else {
	    if (cs < startline)
		cs = startline;
	    else if (cs >= endline)
		cs = endline - 1;
	}
    }
    if (cs > t0) {
	k2 = cs;
	cs = t0;
	t0 = k2;
    }
    return t0;
}

void viaddnext()
{				/**/
    if (cs != ll)
	cs++;
    startvitext(1);
}

void viaddeol()
{				/**/
    cs = findeol();
    startvitext(1);
}

void viinsert()
{				/**/
    startvitext(1);
}

void viinsertbol()
{				/**/
    cs = findbol();
    startvitext(1);
}

void videlete()
{				/**/
    int c2;

    startvichange(1);
    if ((c2 = getvirange(0)) == -1) {
	vichgflag = 0;
	return;
    }
    forekill(c2 - cs, 0);
    vichgflag = 0;
}

void videletechar()
{				/**/
    if (mult < 0) {
	mult = -mult;
	vibackwarddeletechar();
	return;
    }
    if (!(cs + mult > ll || line[cs] == '\n')) {
	if (vichgbuf == NULL)
	    vichgbuf = (char *)zalloc(vichgbufsz = 16);
	vichgbufptr = 1;
	vichgbuf[0] = c;
	cs += mult;
	backkill(mult, 0);
	if (cs && (cs == ll || line[cs] == '\n'))
	    cs--;
    } else
	feep();
}

void vichange()
{				/**/
    int c2;

    startvichange(1);
    if ((c2 = getvirange(1)) == -1) {
	vichgflag = 0;
	return;
    }
    forekill(c2 - cs, 0);
    bindtab = mainbindtab;
    undoing = 0;
}

void visubstitute()
{				/**/
    if (mult < 0)
	return;
    if (findeol() - cs < mult)
	mult = findeol() - cs;
    if (mult) {
	foredel(mult);
	startvitext(1);
    }
}

void vichangeeol()
{				/**/
    killline();
    startvitext(1);
}

void vichangewholeline()
{				/**/
    int cq;

    findline(&cs, &cq);
    foredel(cq - cs);
    startvitext(1);
}

void viyank()
{				/**/
    int c2;

    if ((c2 = getvirange(0)) == -1)
	return;
    cut(cs, c2 - cs, 0);
}

void viyankeol()
{				/**/
    int x = findeol();

    if (x == cs)
	feep();
    else
	cut(cs, x - cs, 0);
}

void vireplace()
{				/**/
    startvitext(0);
}

void vireplacechars()
{				/**/
    int ch;

    if (mult < 0)
	return;
    if (mult + cs > ll) {
	feep();
	return;
    }
    startvichange(1);
    if ((ch = vigetkey()))
	while (mult--)
	    line[cs++] = ch;
    vichgflag = 0;
    cs--;
}

void vicmdmode()
{				/**/
    if (bindtab == altbindtab)
	feep();
    else {
	bindtab = altbindtab;
	if (cs)
	    cs--;
	undoing = 1;
	if (vichgflag)
	    vichgflag = 0;
    }
}

void viopenlinebelow()
{				/**/
    cs = findeol();
    spaceinline(1);
    line[cs++] = '\n';
    startvitext(1);
}

void viopenlineabove()
{				/**/
    cs = findbol();
    spaceinline(1);
    line[cs] = '\n';
    startvitext(1);
}

void vioperswapcase()
{				/**/
    int c2;

    if ((c2 = getvirange(0)) == -1)
	return;
    while (cs < c2) {
	int ch = line[cs];

	if (islower(ch))
	    ch = tuupper(ch);
	else if (isupper(ch))
	    ch = tulower(ch);
	line[cs++] = ch;
    }
}

void virepeatchange()
{				/**/
    if (!vichgbuf || bindtab == mainbindtab || vichgflag)
	feep();
    else
	ungetkeys(vichgbuf, vichgbufptr);
}

void viindent()
{				/**/
    int c2, endcs, t0, rmult;

    if (mult < 0) {
	mult = -mult;
	viunindent();
	return;
    }
    rmult = mult;
    if ((c2 = getvirange(0)) == -1)
	return;
    if (cs != findbol()) {
	feep();
	return;
    }
    endcs = cs + rmult;
    while (cs < c2) {
	spaceinline(rmult);
	for (t0 = 0; t0 != rmult; t0++)
	    line[cs++] = '\t';
	cs = findeol() + 1;
    }
    cs = endcs;
}

void viunindent()
{				/**/
    int c2, endcs, t0, rmult;

    rmult = mult;
    if (mult < 0) {
	mult = -mult;
	viindent();
	return;
    }
    if ((c2 = getvirange(0)) == -1)
	return;
    if (cs != findbol()) {
	feep();
	return;
    }
    endcs = cs;
    while (cs < c2) {
	for (t0 = 0; t0 != rmult && line[cs] == '\t'; t0++)
	    foredel(1);
	cs = findeol() + 1;
    }
    cs = endcs;
}
                                                                                                                                                                                                                                                             œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#
/*
 *
 * zle_word.c - word-related editor functions
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#define ZLE
#include "zsh.h"

void forwardword()
{				/**/
    if (mult < 0) {
	mult = -mult;
	backwardword();
	return;
    }
    while (mult--) {
	while (cs != ll && iword(line[cs]))
	    cs++;
	if (wordflag && !mult)
	    return;
	while (cs != ll && !iword(line[cs]))
	    cs++;
    }
}

void viforwardword()
{				/**/
    if (mult < 0) {
	mult = -mult;
	backwardword();
	return;
    }
    while (mult--) {
	if (iident(line[cs]))
	    while (cs != ll && iident(line[cs]))
		cs++;
	else
	    while (cs != ll && !iident(line[cs]) && !iblank(line[cs]))
		cs++;
	if (wordflag && !mult)
	    return;
	while (cs != ll && iblank(line[cs]))
	    cs++;
    }
}

void viforwardblankword()
{				/**/
    if (mult < 0) {
	mult = -mult;
	vibackwardblankword();
	return;
    }
    while (mult--) {
	while (cs != ll && !iblank(line[cs]))
	    cs++;
	if (wordflag && !mult)
	    return;
	while (cs != ll && iblank(line[cs]))
	    cs++;
    }
}

void emacsforwardword()
{				/**/
    if (mult < 0) {
	mult = -mult;
	emacsbackwardword();
	return;
    }
    while (mult--) {
	while (cs != ll && !iword(line[cs]))
	    cs++;
	if (wordflag && !mult)
	    return;
	while (cs != ll && iword(line[cs]))
	    cs++;
    }
}

void viforwardblankwordend()
{				/**/
    if (mult < 0)
	return;
    while (mult--) {
	while (cs != ll && iblank(line[cs + 1]))
	    cs++;
	while (cs != ll && !iblank(line[cs + 1]))
	    cs++;
    }
    if (cs != ll && virangeflag)
	cs++;
}

void viforwardwordend()
{				/**/
    if (mult < 0) {
	mult = -mult;
	backwardword();
	return;
    }
    while (mult--) {
	if (iblank(line[cs + 1]))
	    while (cs != ll && iblank(line[cs + 1]))
		cs++;
	if (iident(line[cs + 1]))
	    while (cs != ll && iident(line[cs + 1]))
		cs++;
	else
	    while (cs != ll && !iident(line[cs + 1]) && !iblank(line[cs + 1]))
		cs++;
    }
    if (cs != ll && virangeflag)
	cs++;
}

void backwardword()
{				/**/
    if (mult < 0) {
	mult = -mult;
	forwardword();
	return;
    }
    while (mult--) {
	while (cs && !iword(line[cs - 1]))
	    cs--;
	while (cs && iword(line[cs - 1]))
	    cs--;
    }
}

void vibackwardword()
{				/**/
    if (mult < 0) {
	mult = -mult;
	backwardword();
	return;
    }
    while (mult--) {
	while (cs && iblank(line[cs - 1]))
	    cs--;
	if (iident(line[cs - 1]))
	    while (cs && iident(line[cs - 1]))
		cs--;
	else
	    while (cs && !iident(line[cs - 1]) && !iblank(line[cs - 1]))
		cs--;
    }
}

void vibackwardblankword()
{				/**/
    if (mult < 0) {
	mult = -mult;
	viforwardblankword();
	return;
    }
    while (mult--) {
	while (cs && iblank(line[cs - 1]))
	    cs--;
	while (cs && !iblank(line[cs - 1]))
	    cs--;
    }
}

void emacsbackwardword()
{				/**/
    if (mult < 0) {
	mult = -mult;
	emacsforwardword();
	return;
    }
    while (mult--) {
	while (cs && !iword(line[cs - 1]))
	    cs--;
	while (cs && iword(line[cs - 1]))
	    cs--;
    }
}

void backwarddeleteword()
{				/**/
    int x = cs;

    if (mult < 0) {
	mult = -mult;
	deleteword();
	return;
    }
    while (mult--) {
	while (x && !iword(line[x - 1]))
	    x--;
	while (x && iword(line[x - 1]))
	    x--;
    }
    backdel(cs - x);
}

void vibackwardkillword()
{				/**/
    int x = cs;

    if (mult < 0) {
	feep();
	return;
    }
/* this taken from "vibackwardword" */
    while (mult--) {
	while ((x > viinsbegin) && iblank(line[x - 1]))
	    x--;
	if (iident(line[x - 1]))
	    while ((x > viinsbegin) && iident(line[x - 1]))
		x--;
	else
	    while ((x > viinsbegin) && !iident(line[x - 1]) && !iblank(line[x - 1]))
		x--;
    }
/*
        while (mult--) {
                while ( (x > viinsbegin) && (iwordsep(line[x-1]))) x--;
                while ( (x > viinsbegin) && (!iwordsep(line[x-1]))) x--;
        }
        */
    backkill(cs - x, 1);
}

void backwardkillword()
{				/**/
    int x = cs;

    if (mult < 0) {
	mult = -mult;
	killword();
	return;
    }
    while (mult--) {
	while (x && !iword(line[x - 1]))
	    x--;
	while (x && iword(line[x - 1]))
	    x--;
    }
    backkill(cs - x, 1);
}

void upcaseword()
{				/**/
    int neg = mult < 0, ocs = cs;

    if (neg)
	mult = -mult;
    while (mult--) {
	while (cs != ll && !iword(line[cs]))
	    cs++;
	while (cs != ll && iword(line[cs])) {
	    line[cs] = tuupper(line[cs]);
	    cs++;
	}
    }
    if (neg)
	cs = ocs;
}

void downcaseword()
{				/**/
    int neg = mult < 0, ocs = cs;

    if (neg)
	mult = -mult;
    while (mult--) {
	while (cs != ll && !iword(line[cs]))
	    cs++;
	while (cs != ll && iword(line[cs])) {
	    line[cs] = tulower(line[cs]);
	    cs++;
	}
    }
    if (neg)
	cs = ocs;
}

void capitalizeword()
{				/**/
    int first;
    int neg = mult < 0, ocs = cs;

    if (neg)
	mult = -mult;
    while (mult--) {
	first = 1;
	while (cs != ll && !iword(line[cs]))
	    cs++;
	while (cs != ll && iword(line[cs])) {
	    line[cs] = (first) ? tuupper(line[cs]) : tulower(line[cs]);
	    first = 0;
	    cs++;
	}
    }
    if (neg)
	cs = ocs;
}

void deleteword()
{				/**/
    int x = cs;

    if (mult < 0) {
	mult = -mult;
	backwarddeleteword();
	return;
    }
    while (mult--) {
	while (x != ll && !iword(line[x]))
	    x++;
	while (x != ll && iword(line[x]))
	    x++;
    }
    foredel(x - cs);
}

void killword()
{				/**/
    int x = cs;

    if (mult < 0) {
	mult = -mult;
	backwardkillword();
	return;
    }
    while (mult--) {
	while (x != ll && !iword(line[x]))
	    x++;
	while (x != ll && iword(line[x]))
	    x++;
    }
    forekill(x - cs, 0);
}

void transposewords()
{				/**/
    int p1, p2, p3, p4, x = cs;
    char *temp, *pp;
    int neg = mult < 0, ocs = cs;

    if (neg)
	mult = -mult;
    while (mult--) {
	while (x != ll && line[x] != '\n' && !iword(line[x]))
	    x++;
	if (x == ll || line[x] == '\n') {
	    x = cs;
	    while (x && line[x - 1] != '\n' && !iword(line[x]))
		x--;
	    if (!x || line[x - 1] == '\n') {
		feep();
		return;
	    }
	}
	for (p4 = x; p4 != ll && iword(line[p4]); p4++);
	for (p3 = p4; p3 && iword(line[p3 - 1]); p3--);
	if (!p3) {
	    feep();
	    return;
	}
	for (p2 = p3; p2 && !iword(line[p2 - 1]); p2--);
	if (!p2) {
	    feep();
	    return;
	}
	for (p1 = p2; p1 && iword(line[p1 - 1]); p1--);
	pp = temp = (char *)halloc(p4 - p1 + 1);
	struncpy(&pp, UTOSCP(line + p3), p4 - p3);
	struncpy(&pp, UTOSCP(line + p2), p3 - p2);
	struncpy(&pp, UTOSCP(line + p1), p2 - p1);
	strncpy((char *)line + p1, temp, p4 - p1);
	cs = p4;
    }
    if (neg)
	cs = ocs;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*
 *
 * zsh.h - standard header file
 *
 * This file is part of zsh, the Z shell.
 *
 * This software is Copyright 1992 by Paul Falstad
 *
 * Permission is hereby granted to copy, reproduce, redistribute or otherwise
 * use this software as long as: there is no monetary profit gained
 * specifically from the use or reproduction of this software, it is not
 * sold, rented, traded or otherwise marketed, and this copyright notice is
 * included prominently in any copy made.
 *
 * The author make no claims as to the fitness or correctness of this software
 * for any use whatsoever, and it is provided as is. Any use of this software
 * is at the user's own risk.
 *
 */

#include "config.h"

#ifdef HAS_UNISTD
#include <unistd.h>
#endif
#ifdef _POSIX_VERSION
#define POSIX 1
#endif

#ifdef __NeXT__
#include <bsd/libc.h>
#endif

#include <stdio.h>
#include <ctype.h>

#ifdef HAS_STRING
#include <string.h>
#else
#include <strings.h>
#endif

#ifdef HAS_MEMORY
#include <memory.h>
#endif

#ifdef HAS_LOCALE
#include <locale.h>
#endif

#ifdef HAS_STDLIB
#include <stdlib.h>
#endif

#ifdef SYSV

#ifndef SYSVR4
#if defined(SCO) || defined(_SEQUENT_)
#include <limits.h>
#include <sys/types.h>
#include <sys/stat.h>
#ifdef SCO
#define MAXPATHLEN 255
#endif
#else
#include <sys/bsdtypes.h>
#include <sys/limits.h>
#include <sys/sioctl.h>
#define MAXPATHLEN PATH_MAX
#define lstat stat
#endif
#endif

#if defined(IRIX5) || defined(SCO)
#include <sys/signal.h>
#endif

int gethostname();

#else				/* not SYSV */

#include <sys/types.h>		/* this is the key to the whole thing */

#endif				/* not SYSV */

#ifdef _IBMR2
#undef _BSD			/* union wait SUCKS! */
#include <sys/wait.h>
#define _BSD
#else
#ifdef HAS_WAIT
#include <wait.h>
#else
#include <sys/wait.h>
#endif
#endif

#if defined(IRIX5) && defined(_POSIX_SOURCE)
/* this stuff is in <sys/wait.h> but with _POSIX_SOURCE
 * it will not be seen -- this is correct but not nice
 * considering using "union wait" */
typedef union wait {
    int w_status;		/* used in syscall */
    struct {
#ifdef _MIPSEL
	unsigned int w_Termsig:7,	/* termination signal */
	    w_Coredump:1,	/* core dump indicator */
	    w_Retcode:8,	/* exit code if w_termsig==0 */
	    w_Filler:16;	/* upper bits filler */
#endif
#ifdef _MIPSEB
	unsigned int w_Filler:16,	/* upper bits filler */
	    w_Retcode:8,	/* exit code if w_termsig==0 */
	    w_Coredump:1,	/* core dump indicator */
	    w_Termsig:7;	/* termination signal */
#endif
    }
    w_T;
 /*
	 * Stopped process status.  Returned
	 * only for traced children unless requested
	 * with the WUNTRACED option bit.
	 */
    struct {
#ifdef _MIPSEL
	unsigned int w_Stopval:8,	/* == W_STOPPED if stopped */
	    w_Stopsig:8,	/* signal that stopped us */
	    w_Filler:16;	/* upper bits filler */
#endif
#ifdef _MIPSEB
	unsigned int w_Filler:16,	/* upper bits filler */
	    w_Stopsig:8,	/* signal that stopped us */
	    w_Stopval:8;	/* == W_STOPPED if stopped */
#endif
    }
    w_S;
}
wait_t;

#endif

#ifdef _CRAY
#define MAXPATHLEN PATH_MAX
#include <sys/machd.h>		/* HZ definition here */
#endif

#if defined(HAS_TIME) || defined(_CRAY) || defined(IRIX5) || defined(_SEQUENT_)
#include <time.h>
/* Sequent DYNIX/ptx gettimeofday() is in the X11 library.  Define timezone
   here so we don't have to load all of X11/Xos.h.
   billb@progress.com 4-Jan-93 */
#ifdef _SEQUENT_
struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

#endif
#if (defined(_CRAY) && defined(__STDC__)) || defined(IRIX5)
#include <sys/time.h>
#endif
#else
#include <sys/time.h>
#endif

#if defined(IRIX5) || defined(SCO)
#include <sys/select.h>		/* needs timeval */
#endif

#ifdef SYSV
#include <fcntl.h>
#else
#include <sys/file.h>
#endif

#if !defined(SYSV) || defined(SYSVR4)
#include <sys/resource.h>
#endif

#if defined(RLIMIT_OFILE) && defined(RLIMIT_NOFILE)
#undef RLIMIT_NOFILE
#endif

#include <signal.h>
#ifdef USE_SIGSET
#undef signal
#define signal sigset
#endif

#if defined(SCO)
#include <sys/stream.h>
#include <sys/ptem.h>
#endif

#ifdef HAS_TERMIO
#define VDISABLEVAL -1
#define HAS_TIO 1
#include <sys/termio.h>
#else
#ifdef HAS_TERMIOS
#define VDISABLEVAL 0
#define HAS_TIO 1
#include <termios.h>
#ifdef __sgi
#ifndef VSWTCH
#define VSWTCH 7		/* VSWTCH not defined if _POSIX_SOURCE */
#endif
#ifndef CSWTCH
#ifndef CTRL
#define	CTRL(c)	((c)&037)
#endif
#define CSWTCH CTRL('z')	/* CSWTCH not defined if _POSIX_SOURCE */
#endif
#ifndef XTABS
#define XTABS 0014000		/* XTABS not defined if _POSIX_SOURCE */
#endif
#ifndef ONLCR
#define	ONLCR 0000004		/* ONLCR not defined if _POSIX_SOURCE */
#endif
#endif				/* __sgi */
#else
#include <sgtty.h>
#endif
#endif

#if defined(SYSV) && !defined(SYSVR4)
#define readlink(s,t,z)	(-1)
#undef TIOCGWINSZ
#endif

#include <sys/param.h>
#if defined(_CRAY) && defined(__STDC__)
#define OPEN_MAX 64
#define NOFILE OPEN_MAX
#endif

#if defined(SCO)
#define NOFILE _POSIX_OPEN_MAX
#endif

#if defined(SCO)
#include <utime.h>
#endif
#include <sys/times.h>

#ifdef HAS_DIRENT
#if defined(ardent)		/* ardent = Titan */
#include <sys/dirent.h>
#endif
#include <dirent.h>
#else
#include <sys/dir.h>
#if defined(sony) || defined(MACH)
#define dirent direct
#endif
#endif
#if defined(__NeXT__)
#define dirent direct		/* if you have absolutely no struct dirent */
#endif				/* anywhere in system headers, add your */
 /* system here and pray */

#ifdef __hp9000s800
#include <sys/bsdtty.h>
#endif

#if !defined(sun) && (!defined(SYSVR4) || defined(DGUX))
#if defined(_IBMR2) && defined(NOFLSH)
#undef NOFLSH
#endif
#ifndef ardent
#include <sys/ioctl.h>
#endif
#else
#include <sys/filio.h>		/* for FIONREAD */
#endif

#ifdef __STDC__
#define DCLPROTO(X) X
/* prototype template for static functions */
/* Note that the argument list "a" must have its own ()s around it */
#define SPROTO(f,a) static f a
#include <fcntl.h>
#include <sys/stat.h>
#ifndef NULL
#define NULL ((void *)0)
#endif
#else				/* K&R C */
#define DCLPROTO(X) ()
#define SPROTO(f,a) static f()
/* SGI cc digs "const" even when K&R */
#if !(defined(__sgi) && defined(__mips))
#define const
#endif
#include <sys/stat.h>
#ifndef NULL
#define NULL 0
#endif
#endif

#ifdef HAS_UTMPX
#include <utmpx.h>
#define utmp utmpx
#define ut_time ut_xtime
#undef UTMP_FILE
#define UTMP_FILE UTMPX_FILE
#undef WTMP_FILE
#define WTMP_FILE WTMPX_FILE
#else
#include <utmp.h>
#endif

#if !defined(UTMP_FILE) && defined(_PATH_UTMP)
#define UTMP_FILE _PATH_UTMP
#endif
#if !defined(WTMP_FILE) && defined(_PATH_WTMP)
#define WTMP_FILE _PATH_WTMP
#endif

#define DEFWORDCHARS "*?_-.[]~=/&;!#$%^(){}<>"
#define DEFTIMEFMT "%E real  %U user  %S system  %P %J"
#ifdef UTMP_HOST
#define DEFWATCHFMT "%n has %a %l from %m."
#else
#define DEFWATCHFMT "%n has %a %l."
#endif

#ifdef GLOBALS
#define EXTERN
#else
#define EXTERN extern
#endif

#ifdef HAS_STRING
#define killpg(pgrp,sig) kill(-(pgrp),sig)
#endif

/* SYSV or POSIX compatible BSD */
/* ARGH, this is currently broken as the 'BSD' test had to be taken stripped
 * of an additional test BSD >= 199301 as Solaris cpp is broken ++jhi; */
#if (defined(SYSV) || defined(_POSIX_SOURCE) || defined(BSD) || defined(__convex__) || defined(_CRAY) || defined(__osf__) || defined(__linux__)) && !defined(NeXT)
#if !defined(__sgi) || !defined(_BSD_COMPAT)	/* IRIX */
#ifdef __hpux
#define GETPGRP()  getpgrp2(0)
#else
#define GETPGRP()  getpgrp()
#endif
#else
#define GETPGRP()  getpgrp(0)
#endif
#else
#define GETPGRP()  getpgrp(0)
#endif

#if defined(__sgi) && defined(__STDC__) && (defined(_BSD_COMPAT) || defined(_BSD_SIGNALS))
#ifdef _POSIX_SOURCE
#ifdef IRIX5
#define gettimeofday(tp, tzp) BSDgettimeofday(tp, tzp)
#else
#undef signal
#define signal(s, h) BSDsignal(s, (HANDTYPE (*)()) h)
#endif
#endif
#endif

#ifndef F_OK
#define F_OK 00
#define R_OK 04
#define W_OK 02
#define X_OK 01
#endif

/* sigvec sv_handler needs special casting */
#if defined(__convexc__)
#define SIGVEC_HANDTYPE _SigFunc_Ptr_t
#else
#if defined(IRIX5)
#define SIGVEC_HANDTYPE __sigret_t (*)()
#else
#if defined(ultrix)
/* Ultrix has void here but HANDTYPE is int? */
#define SIGVEC_HANDTYPE void (*)()
#else
#define SIGVEC_HANDTYPE HANDTYPE (*)()
#endif
#endif
#endif

#if 0
/* The quad_t should be used for BSD 4.4.  There was an ifdef BSD4_4
   here, but it broke FreeBSD compilation.  */
#define RLIM_TYPE quad_t
#else
#define RLIM_TYPE long
#endif

/* math.c */
typedef int LV;

#include "zle.h"

/* size of job list */

#define MAXJOB 80

/* memory allocation routines - changed with permalloc()/heapalloc() */

/* real things in mem.c */
extern vptr(*alloc) DCLPROTO((int));
extern vptr(*ncalloc) DCLPROTO((int));

/* character tokens */

#define ALPOP			((char) 0x81)
#define HISTSPACE		((char) 0x83)
#define Pound			((char) 0x84)
#define String			((char) 0x85)
#define Hat			((char) 0x86)
#define Star			((char) 0x87)
#define Inpar			((char) 0x88)
#define Outpar			((char) 0x89)
#define Qstring		        ((char) 0x8a)
#define Equals			((char) 0x8b)
#define Bar		      	((char) 0x8c)
#define Inbrace		        ((char) 0x8d)
#define Outbrace		((char) 0x8e)
#define Inbrack		        ((char) 0x8f)
#define Outbrack		((char) 0x90)
#define Tick			((char) 0x91)
#define Inang			((char) 0x92)
#define Outang			((char) 0x93)
#define Quest			((char) 0x94)
#define Tilde			((char) 0x95)
#define Qtick			((char) 0x96)
#define Comma			((char) 0x97)
#define Snull			((char) 0x98)
#define Dnull			((char) 0x99)
#define Bnull			((char) 0x9a)
#define Nularg			((char) 0x9b)

#define INULL(x)		(((x) & 0xf8) == 0x98)

/* Character tokens are sometimes casted to (unsigned char)'s. Unfortunately,
   SVR4's deceiving compiler botches non-terminal, same size, signed to
   unsigned promotions; i.e. (int) (unsigned char) ((char) -1) evaluates to
   -1, 	not 255 as it should!
   We circumvent the troubles of such shameful delinquency by casting to a
   larger unsigned type then back down to unsigned char.  		--
   Marc Boucher <marc@cam.org>
   Dec Alpha OSF compilers have the same property
   <daniel@ug.eds.com> 25-Jan-1993 */

#if (defined(SYSVR4) || defined (__osf__)) && !defined(__GNUC__)
#define STOUC(X)	((unsigned char)(unsigned short)(X))
#else
#define STOUC(X)	((unsigned char)(X))
#endif

/*
 * The source was full of implicit casts between signed and unsigned
 * character pointers.  To get a clean compile, I've made these casts
 * explicit, but the potential for error is still there.  If your machine
 * needs special treatment, just define your own macros here.
 * 	--jim <jmattson@ucsd.edu>
 */

#define STOUCP(X)	((unsigned char *)(X))
#define UTOSCP(X)	((char *)(X))

/* chars that need to be quoted if meant literally */

#define SPECCHARS "#$^*()$=|{}[]`<>?~;&!\n\t \\\'\""

/* ALPOP in the form of a string */

#define ALPOPS " \201"
#define HISTMARK "\201"

#define SEPER 1
#define NEWLIN 2
#define LEXERR 3
#define SEMI 4
#define DSEMI 5
#define AMPER 6
#define INPAR 7
#define INBRACE 8
#define OUTPAR 9
#define DBAR 10
#define DAMPER 11
#define BANG 12
#define OUTBRACE 13
#define OUTANG 14
#define OUTANGBANG 15
#define DOUTANG 16
#define DOUTANGBANG 17
#define INANG 18
#define DINANG 19
#define DINANGDASH 20
#define INANGAMP 21
#define OUTANGAMP 22
#define OUTANGAMPBANG 23
#define DOUTANGAMP 24
#define DOUTANGAMPBANG 25
#define TRINANG 26
#define BAR 27
#define BARAMP 28
#define DINBRACK 29
#define DOUTBRACK 30
#define STRING 31
#define ENVSTRING 32
#define ENVARRAY 33
#define ENDINPUT 34
#define INOUTPAR 35
#define DO 36
#define DONE 37
#define ESAC 38
#define THEN 39
#define ELIF 40
#define ELSE 41
#define FI 42
#define FOR 43
#define CASE 44
#define IF 45
#define WHILE 46
#define FUNC 47
#define REPEAT 48
#define TIME 49
#define UNTIL 50
#define EXEC 51
#define COMMAND 52
#define SELECT 53
#define COPROC 54
#define NOGLOB 55
#define DASH 56
#define NOCORRECT 57
#define FOREACH 58
#define ZEND 59
#define DINPAR 60
#define DOUTPAR 61

#define WRITE 0
#define WRITENOW 1
#define APP 2
#define APPNOW 3
#define MERGEOUT 4
#define MERGEOUTNOW 5
#define ERRAPP 6
#define ERRAPPNOW 7
#define READ 8
#define HEREDOC 9
#define HEREDOCDASH 10
#define HERESTR 11
#define MERGE 12
#define CLOSE 13
#define INPIPE 14
#define OUTPIPE 15
#define NONE 16

#ifdef GLOBALS
int redirtab[TRINANG - OUTANG + 1] =
{
    WRITE,
    WRITENOW,
    APP,
    APPNOW,
    READ,
    HEREDOC,
    HEREDOCDASH,
    MERGE,
    MERGEOUT,
    MERGEOUTNOW,
    ERRAPP,
    ERRAPPNOW,
    HERESTR,
};

#else
extern int redirtab[TRINANG - OUTANG + 1];

#endif

#ifdef GLOBALS
char nulstring[] =
{Nularg, '\0'};
int nulstrlen = sizeof(nulstring) - 1;

#else
extern char nulstring[];
extern int nulstrlen;

#endif

#define IS_READFD(X) ((X)>=READ && (X)<=MERGE)
#define IS_REDIROP(X) ((X)>=OUTANG && (X)<=TRINANG)
#define IS_ERROR_REDIR(X) ((X)>=MERGEOUT && (X)<=ERRAPPNOW)
#define UN_ERROR_REDIR(X) ((X)-MERGEOUT+WRITE)

#define FD_WORD   -1
#define FD_COPROC -2
#define FD_CLOSE  -3

extern char **environ;

/* linked list abstract data type */

struct lknode {
    struct lknode *next, *last;
    vptr dat;
};
struct lklist {
    struct lknode *first, *last;
};

typedef struct hashtab *Hashtab;
typedef struct hashnode *Hashnode;
typedef struct schedcmd *Schedcmd;
typedef struct alias *Alias;
typedef struct process *Process;
typedef struct job *Job;
typedef struct value *Value;
typedef struct arrind *Arrind;
typedef struct varasg *Varasg;
typedef struct param *Param;
typedef struct cmdnam *Cmdnam;
typedef struct cond *Cond;
typedef struct cmd *Cmd;
typedef struct pline *Pline;
typedef struct sublist *Sublist;
typedef struct list *List;
typedef struct lklist *Lklist;
typedef struct lknode *Lknode;
typedef struct comp *Comp;
typedef struct redir *Redir;
typedef struct complist *Complist;
typedef struct heap *Heap;
typedef struct heappos *Heappos;
typedef struct histent *Histent;
typedef struct compctlp *Compctlp;
typedef struct compctl *Compctl;
typedef struct compcond *Compcond;
typedef void (*FFunc) DCLPROTO((vptr));
typedef vptr(*VFunc) DCLPROTO((vptr));
typedef void (*HFunc) DCLPROTO((char *, char *));

#define addnode(X,Y) insnode(X,(X)->last,Y)
#define full(X) ((X)->first != NULL)
#define empty(X) ((X)->first == NULL)
#define firstnode(X) ((X)->first)
#define getaddrdata(X) (&((X)->dat))
#define getdata(X) ((X)->dat)
#define setdata(X,Y) ((X)->dat = (Y))
#define lastnode(X) ((X)->last)
#define nextnode(X) ((X)->next)
#define prevnode(X) ((X)->last)
#define peekfirst(X) ((X)->first->dat)
#define pushnode(X,Y) insnode(X,(Lknode) X,Y)
#define incnode(X) (X = nextnode(X))
#define gethistent(X) (histentarr+((X)%histentct))

/* node structure for syntax trees */

/* struct list, struct sublist, struct pline, etc.  all fit the form
	of this structure and are used interchangably.
	The ptrs may hold integers or pointers, depending on the type of
	the node.
*/

struct node {
    int type;			/* node type */
};

#define N_LIST 0
#define N_SUBLIST 1
#define N_PLINE 2
#define N_CMD 3
#define N_REDIR 4
#define N_COND 5
#define N_FOR 6
#define N_CASE 7
#define N_IF 8
#define N_WHILE 9
#define N_VARASG 10
#define N_COUNT 11

/* values for types[4] */

#define NT_EMPTY 0
#define NT_NODE  1
#define NT_STR   2
#define NT_LIST  4
#define NT_ARR   8

#define NT_TYPE(T) ((T) & 0xff)
#define NT_N(T, N) (((T) >> (8 + (N) * 4)) & 0xf)
#define NT_SET(T0, N, T1, T2, T3, T4) \
    ((T0) | ((N) << 24) | \
     ((T1) << 8) | ((T2) << 12) | ((T3) << 16) | ((T4) << 20))
#define NT_NUM(T) (((T) >> 24) & 7)
#define NT_HEAP   (1 << 30)

/* tree element for lists */

struct list {
    int ntype;
    int type;
    Sublist left;
    List right;
};

#define SYNC 0			/* ; */
#define ASYNC 1			/* & */
#define TIMED 2

/* tree element for sublists */

struct sublist {
    int ntype;
    int type;
    int flags;			/* see PFLAGs below */
    Pline left;
    Sublist right;
};

#define ORNEXT 10		/* || */
#define ANDNEXT 11		/* && */

#define PFLAG_NOT 1		/* ! ... */
#define PFLAG_COPROC 32		/* coproc ... */

/* tree element for pipes */

struct pline {
    int ntype;
    int type;
    Cmd left;
    Pline right;
};

#define END	0		/* pnode *right is null */
#define PIPE	1		/* pnode *right is the rest of the pipeline */

/* tree element for commands */

struct cmd {
    int ntype;
    int type;
    int flags;			/* see CFLAGs below */
    int lineno;			/* lineno of script for command */
    Lklist args;		/* command & argmument List (char *'s) */
    union {
	List list;		/* for SUBSH/CURSH/SHFUNC */
	struct forcmd *forcmd;
	struct casecmd *casecmd;
	struct ifcmd *ifcmd;
	struct whilecmd *whilecmd;
	Sublist pline;
	Cond cond;
	vptr generic;
    } u;
    Lklist redir;		/* i/o redirections (struct redir *'s) */
    Lklist vars;		/* param assignments (struct varasg *'s) */
};

#define SIMPLE 0
#define SUBSH 1
#define CURSH 2
#define ZCTIME 3
#define FUNCDEF 4
#define CFOR 5
#define CWHILE 6
#define CREPEAT 7
#define CIF 8
#define CCASE 9
#define CSELECT 10
#define COND 11

#define CFLAG_EXEC 1		/* exec ... */
#define CFLAG_COMMAND 2		/* command ... */
#define CFLAG_NOGLOB 4		/* noglob ... */
#define CFLAG_DASH 8		/* - ... */

/* tree element for redirection lists */

struct redir {
    int ntype;
    int type, fd1, fd2;
    char *name;
};

/* tree element for conditionals */

struct cond {
    int ntype;
    int type;			/* can be cond_type, or a single letter (-a, -b, ...) */
    vptr left, right;
};

#define COND_NOT 0
#define COND_AND 1
#define COND_OR 2
#define COND_STREQ 3
#define COND_STRNEQ 4
#define COND_STRLT 5
#define COND_STRGTR 6
#define COND_NT 7
#define COND_OT 8
#define COND_EF 9
#define COND_EQ 10
#define COND_NE 11
#define COND_LT 12
#define COND_GT 13
#define COND_LE 14
#define COND_GE 15

struct forcmd {			/* for/select */
/* Cmd->args contains list of words to loop thru */
    int ntype;
    int inflag;			/* if there is an in ... clause */
    char *name;			/* parameter to assign values to */
    List list;			/* list to look through for each name */
};
struct casecmd {
/* Cmd->args contains word to test */
    int ntype;
    char **pats;
    List *lists;		/* list to execute */
};

/*

	a command like "if foo then bar elif baz then fubar else fooble"
	generates a tree like:

	struct ifcmd a = { next =  &b,  ifl = "foo", thenl = "bar" }
	struct ifcmd b = { next =  &c,  ifl = "baz", thenl = "fubar" }
	struct ifcmd c = { next = NULL, ifl = NULL, thenl = "fooble" }

*/

struct ifcmd {
    int ntype;
    List *ifls;
    List *thenls;
};

struct whilecmd {
    int ntype;
    int cond;			/* 0 for while, 1 for until */
    List cont;			/* condition */
    List loop;			/* list to execute until condition met */
};

/* structure used for multiple i/o redirection */
/* one for each fd open */

struct multio {
    int ct;			/* # of redirections on this fd */
    int rflag;			/* 0 if open for reading, 1 if open for writing */
    int pipe;			/* fd of pipe if ct > 1 */
    int fds[NOFILE];		/* list of src/dests redirected to/from this fd */
};

/* node used in command path hash table (cmdnamtab) */

struct cmdnam {
    struct hashnode *next;
    char *nam;			/* hash data */
    int flags;
    union {
	char **name;		/* full pathname if !(flags & BUILTIN) */
	char *cmd;		/* file name for hashed commands */
	int binnum;		/* func to exec if type & BUILTIN */
	List list;		/* list to exec if type & SHFUNC */
    }
    u;
};

#define EXCMD        0x10000
#define BUILTIN      0x20000
#define SHFUNC       0x40000
#define DISABLED     0x80000
#define HASHCMD      (EXCMD | BUILTIN)

#define ISEXCMD(X) ((X) & EXCMD)

/* node used in parameter hash table (paramtab) */

struct param {
    struct hashnode *next;
    char *nam;			/* hash data */
    union {
	char **arr;		/* value if declared array */
	char *str;		/* value if declared string (scalar) */
	long val;		/* value if declared integer */
    }
    u;
    union {			/* functions to call to set value */
	void (*cfn) DCLPROTO((Param, char *));
	void (*ifn) DCLPROTO((Param, long));
	void (*afn) DCLPROTO((Param, char **));
    }
    sets;
    union {			/* functions to call to get value */
	char *(*cfn) DCLPROTO((Param));
	long (*ifn) DCLPROTO((Param));
	char **(*afn) DCLPROTO((Param));
    }
    gets;
    int ct;			/* output base or field width */
    int flags;
    vptr data;			/* used by getfns */
    char *env;			/* location in environment, if exported */
    char *ename;		/* name of corresponding environment var */
    Param old;			/* old struct for use with local */
    int level;			/* if (old != NULL), level of localness */
};

#define PMFLAG_s 0		/* scalar */
#define PMFLAG_L 1		/* left justify and remove leading blanks */
#define PMFLAG_R 2		/* right justify and fill with leading blanks */
#define PMFLAG_Z 4		/* right justify and fill with leading zeros */
#define PMFLAG_i 8		/* integer */
#define PMFLAG_l 16		/* all lower case */
#define PMFLAG_u 32		/* all upper case */
#define PMFLAG_r 64		/* readonly */
#define PMFLAG_t 128		/* tagged */
#define PMFLAG_x 256		/* exported */
#define PMFLAG_A 512		/* array */
#define PMFLAG_SPECIAL	1024
#define PMFLAG_UNSET	2048
#define PMTYPE (PMFLAG_i|PMFLAG_A)
#define pmtype(X) ((X)->flags & PMTYPE)

/* variable assignment tree element */

struct varasg {
    int ntype;
    int type;			/* nonzero means array */
    char *name;
    char *str;			/* should've been a union here.  oh well */
    Lklist arr;
};

/* lvalue for variable assignment/expansion */

struct value {
    int isarr;
    struct param *pm;		/* parameter node */
    int inv;			/* should we return the index ? */
    int a;			/* first element of array slice, or -1 */
    int b;			/* last element of array slice, or -1 */
};

struct fdpair {
    int fd1, fd2;
};

/* tty state structure */

struct ttyinfo {
#ifdef HAS_TERMIOS
    struct termios tio;
#else
#ifdef HAS_TERMIO
    struct termio tio;
#else
    struct sgttyb sgttyb;
    int lmodes;
    struct tchars tchars;
    struct ltchars ltchars;
#endif
#endif
#ifdef TIOCGWINSZ
    struct winsize winsize;
#endif
};

/* entry in job table */

struct job {
    long gleader;		/* process group leader of this job */
    int stat;
    char *pwd;			/* current working dir of shell when
				   this job was spawned */
    struct process *procs;	/* list of processes */
    Lklist filelist;		/* list of files to delete when done */
    int stty_in_env;		/* if STTY=... is present */
    struct ttyinfo *ty;		/* the modes specified by STTY */
};

#define STAT_CHANGED 1		/* status changed and not reported */
#define STAT_STOPPED 2		/* all procs stopped or exited */
#define STAT_TIMED 4		/* job is being timed */
#define STAT_DONE 8
#define STAT_LOCKED 16		/* shell is finished creating this job,	may be
				   deleted from job table */
#define STAT_INUSE 64		/* this job entry is in use */

#define SP_RUNNING -1		/* fake statusp for running jobs */

#ifndef RUSAGE_CHILDREN
#undef HAS_RUSAGE
#endif

struct timeinfo {
#ifdef HAS_RUSAGE
    struct rusage ru;
#else
    long ut, st;
#endif
};

/* node in job process lists */

#define JOBTEXTSIZE 80

struct process {
    struct process *next;
    long pid;
    char text[JOBTEXTSIZE];	/* text to print when 'jobs' is run */
    int statusp;		/* return code from wait3() */
    struct timeinfo ti;
    struct timeval bgtime;	/* time job was spawned */
    struct timeval endtime;	/* time job exited */
};

/* node in alias hash table */

struct alias {
    struct hashnode *next;
    char *nam;			/* hash data */
    char *text;			/* expansion of alias */
    int cmd;			/* one for regular aliases, zero for global
				   aliases, negative for reserved words */
    int inuse;			/* alias is being expanded */
};

/* node in sched list */

struct schedcmd {
    struct schedcmd *next;
    char *cmd;			/* command to run */
    time_t time;		/* when to run it */
};

#define MAXAL 20		/* maximum number of aliases expanded at once */

/* hash table node */

struct hashnode {
    struct hashnode *next;
    char *nam;
};

/* hash table */

struct hashtab {
    int hsize;			/* size of nodes[] */
    int ct;			/* # of elements */
    struct hashnode **nodes;	/* array of size hsize */
};

/* history entry */

struct histent {
    char *lex;			/* lexical history line */
    char *lit;			/* literal history line */
    time_t stim;		/* command started time (datestamp) */
    time_t ftim;		/* command finished time */
    int flags;			/* Misc flags */
};

#define HIST_OLD	0x00000001	/* Command is already written to disk*/

/* completion control */

struct compcond {
    struct compcond *and, *or;	/* the next or'ed/and'ed conditions */
    int type, n;		/* the type (CCT_*) and the array length */
    union {			/* these structs hold the data used to */
	struct {		/* test this condition */
	    int *a, *b;		/* CCT_POS, CCT_NUMWORDS */
	}
	r;
	struct {		/* CCT_CURSTR, CCT_CURPAT,... */
	    int *p;
	    char **s;
	}
	s;
	struct {		/* CCT_RANGESTR,... */
	    char **a, **b;
	}
	l;
    }
    u;
};

#define CCT_UNUSED     0
#define CCT_POS        1
#define CCT_CURSTR     2
#define CCT_CURPAT     3
#define CCT_WORDSTR    4
#define CCT_WORDPAT    5
#define CCT_CURSUF     6
#define CCT_CURPRE     7
#define CCT_CURSUB     8
#define CCT_CURSUBC    9
#define CCT_NUMWORDS  10
#define CCT_RANGESTR  11
#define CCT_RANGEPAT  12

struct compctlp {		/* the hash table node for compctls */
    struct hashnode *next;
    char *nam;			/* command name */
    Compctl cc;			/* pointer to the compctl desc. */
};

struct compctl {		/* the real desc. for compctls */
    int refc;			/* reference count */
    struct compctl *next;	/* next compctl for -x */
    unsigned long mask;		/* mask of things to complete (CC_*) */
    char *keyvar;		/* for -k (variable) */
    char *glob;			/* for -g (globbing) */
    char *str;			/* for -s (expansion) */
    char *func;			/* for -f (function) */
    char *explain;		/* for -X (explanation) */
    char *prefix, *suffix;	/* for -P and -S (prefix, suffix) */
    char *subcmd;		/* for -l (command name to use) */
    char *hpat;			/* for -H (history pattern) */
    int hnum;			/* for -H (number of events to search) */
    struct compctl *ext;	/* for -x (first of the compctls after -x) */
    struct compcond *cond;	/* for -x (condition for this compctl) */
    struct compctl *xor;	/* for + (next of the xor'ed compctls) */
};

#define CC_FILES	(1<<0)
#define CC_COMMPATH	(1<<1)
#define CC_REMOVE       (1<<2)
#define CC_OPTIONS	(1<<3)
#define CC_VARS		(1<<4)
#define CC_BINDINGS	(1<<5)
#define CC_ARRAYS	(1<<6)
#define CC_INTVARS	(1<<7)
#define CC_FUNCS	(1<<8)
#define CC_PARAMS	(1<<9)
#define CC_ENVVARS	(1<<10)
#define CC_JOBS		(1<<11)
#define CC_RUNNING	(1<<12)
#define CC_STOPPED	(1<<13)
#define CC_BUILTINS	(1<<14)
#define CC_ALREG	(1<<15)
#define CC_ALGLOB	(1<<16)
#define CC_USERS	(1<<17)
#define CC_DISCMDS	(1<<18)
#define CC_EXCMDS	(1<<19)
#define CC_SCALARS	(1<<20)
#define CC_READONLYS    (1<<21)
#define CC_SPECIALS	(1<<22)
#define CC_DELETE       (1<<23)
#define CC_NAMED        (1<<24)

#define CC_RESERVED     (1<<31)

#include <errno.h>
#ifdef __NetBSD__
extern const char *const sys_errlist[];

#else
extern char *sys_errlist[];

#endif
extern int sys_nerr;
extern int errno;

/* values in opts[] array */

#define OPT_INVALID 1		/* opt is invalid, like -$ */
#define OPT_UNSET 0
#define OPT_SET 2

/* the options */

struct option {
    char *name;
    char id;			/* corresponding letter */
};

#define CORRECT '0'
#define NOCLOBBER '1'
#define NOBADPATTERN '2'
#define NONOMATCH '3'
#define GLOBDOTS '4'
#define NOTIFY '5'
#define BGNICE '6'
#define IGNOREEOF '7'
#define MARKDIRS '8'
#define AUTOLIST '9'
#define NOBEEP 'B'
#define PRINTEXITVALUE 'C'
#define PUSHDTOHOME 'D'
#define PUSHDSILENT 'E'
#define NOGLOBOPT 'F'
#define NULLGLOB 'G'
#define RMSTARSILENT 'H'
#define IGNOREBRACES 'I'
#define AUTOCD 'J'
#define NOBANGHIST 'K'
#define SUNKEYBOARDHACK 'L'
#define SINGLELINEZLE 'M'
#define AUTOPUSHD 'N'
#define CORRECTALL 'O'
#define RCEXPANDPARAM 'P'
#define PATHDIRS 'Q'
#define LONGLISTJOBS 'R'
#define RECEXACT 'S'
#define CDABLEVARS 'T'
#define MAILWARNING 'U'
#define NOPROMPTCR 'V'
#define AUTORESUME 'W'
#define LISTTYPES 'X'
#define MENUCOMPLETE 'Y'
#define USEZLE 'Z'
#define ALLEXPORT 'a'
#define ERREXIT 'e'
#define NORCS 'f'
#define HISTIGNORESPACE 'g'
#define HISTIGNOREDUPS 'h'
#define INTERACTIVE 'i'
#define HISTLIT 'j'
#define INTERACTIVECOMMENTS 'k'
#define LOGINSHELL 'l'
#define MONITOR 'm'
#define NOEXEC 'n'
#define KSHPRIV 'p'
#define SHINSTDIN 's'
#define NOUNSET 'u'
#define VERBOSE 'v'
#define CHASELINKS 'w'
#define XTRACE 'x'
#define SHWORDSPLIT 'y'
#define HISTNOSTORE '\3'
#define EXTENDEDGLOB '\5'
#define GLOBCOMPLETE '\6'
#define CSHJUNKIEQUOTES '\7'
#define PUSHDMINUS '\10'
#define CSHJUNKIELOOPS '\11'
#define RCQUOTES '\12'
#define KSHOPTIONPRINT '\13'
#define NOSHORTLOOPS '\14'
#define COMPLETEINWORD '\15'
#define AUTOMENU '\16'
#define HISTVERIFY '\17'
#define NOLISTBEEP '\20'
#define NOHUP '\21'
#define NOEQUALS '\22'
#define CSHNULLGLOB '\23'
#define HASHCMDS '\24'
#define HASHDIRS '\25'
#define NUMERICGLOBSORT '\26'
#define BRACECCL '\27'
#define HASHLISTALL '\30'
#define OVERSTRIKE '\31'
#define NOHISTBEEP '\32'
#define PUSHDIGNOREDUPS '\33'
#define AUTOREMOVESLASH '\34'
#define EXTENDEDHISTORY '\35'
#define APPENDHISTORY '\36'
#define CSHJUNKIEHISTORY '\037'
#define MAGICEQUALSUBST '\040'
#define GLOBSUBST '\041'
#define PROMPTSUBST '\043'
#define ALWAYSLASTPROMPT '\044'
#define COMPLETEALIASES '\045'
#define AUTOPARAMKEYS '\046'
#define ALWAYSTOEND '\047'
#define NOFLOWCONTROL '\050'
#define LISTAMBIGUOUS '\051'
#define AUTONAMEDIRS '\052'
#define CSHJUNKIEPAREN '\053'

#ifndef GLOBALS
extern struct option optns[];

#else
struct option optns[] =
{
    {"correct", CORRECT},
    {"noclobber", NOCLOBBER},
    {"nobadpattern", NOBADPATTERN},
    {"nonomatch", NONOMATCH},
    {"globdots", GLOBDOTS},
    {"notify", NOTIFY},
    {"bgnice", BGNICE},
    {"ignoreeof", IGNOREEOF},
    {"markdirs", MARKDIRS},
    {"autolist", AUTOLIST},
    {"nobeep", NOBEEP},
    {"printexitvalue", PRINTEXITVALUE},
    {"pushdtohome", PUSHDTOHOME},
    {"pushdsilent", PUSHDSILENT},
    {"noglob", NOGLOBOPT},
    {"nullglob", NULLGLOB},
    {"rmstarsilent", RMSTARSILENT},
    {"ignorebraces", IGNOREBRACES},
    {"braceccl", BRACECCL},
    {"autocd", AUTOCD},
    {"nobanghist", NOBANGHIST},
    {"sunkeyboardhack", SUNKEYBOARDHACK},
    {"singlelinezle", SINGLELINEZLE},
    {"autopushd", AUTOPUSHD},
    {"correctall", CORRECTALL},
    {"rcexpandparam", RCEXPANDPARAM},
    {"pathdirs", PATHDIRS},
    {"longlistjobs", LONGLISTJOBS},
    {"recexact", RECEXACT},
    {"cdablevars", CDABLEVARS},
    {"mailwarning", MAILWARNING},
    {"nopromptcr", NOPROMPTCR},
    {"autoresume", AUTORESUME},
    {"listtypes", LISTTYPES},
    {"menucomplete", MENUCOMPLETE},
    {"zle", USEZLE},
    {"allexport", ALLEXPORT},
    {"errexit", ERREXIT},
    {"norcs", NORCS},
    {"histignorespace", HISTIGNORESPACE},
    {"histignoredups", HISTIGNOREDUPS},
    {"interactive", INTERACTIVE},
    {"histlit", HISTLIT},
    {"interactivecomments", INTERACTIVECOMMENTS},
    {"login", LOGINSHELL},
    {"monitor", MONITOR},
    {"noexec", NOEXEC},
    {"shinstdin", SHINSTDIN},
    {"nounset", NOUNSET},
    {"verbose", VERBOSE},
    {"chaselinks", CHASELINKS},
    {"xtrace", XTRACE},
    {"shwordsplit", SHWORDSPLIT},
    {"histnostore", HISTNOSTORE},
    {"extendedglob", EXTENDEDGLOB},
    {"globcomplete", GLOBCOMPLETE},
    {"cshjunkiequotes", CSHJUNKIEQUOTES},
    {"pushdminus", PUSHDMINUS},
    {"cshjunkieloops", CSHJUNKIELOOPS},
    {"rcquotes", RCQUOTES},
    {"noshortloops", NOSHORTLOOPS},
    {"completeinword", COMPLETEINWORD},
    {"automenu", AUTOMENU},
    {"histverify", HISTVERIFY},
    {"nolistbeep", NOLISTBEEP},
    {"nohup", NOHUP},
    {"noequals", NOEQUALS},
    {"kshoptionprint", KSHOPTIONPRINT},
    {"cshnullglob", CSHNULLGLOB},
    {"hashcmds", HASHCMDS},
    {"hashdirs", HASHDIRS},
    {"numericglobsort", NUMERICGLOBSORT},
    {"hashlistall", HASHLISTALL},
    {"overstrike", OVERSTRIKE},
    {"nohistbeep", NOHISTBEEP},
    {"pushdignoredups", PUSHDIGNOREDUPS},
    {"autoremoveslash", AUTOREMOVESLASH},
    {"extendedhistory", EXTENDEDHISTORY},
    {"appendhistory", APPENDHISTORY},
    {"cshjunkiehistory", CSHJUNKIEHISTORY},
    {"magicequalsubst", MAGICEQUALSUBST},
    {"globsubst", GLOBSUBST},
    {"promptsubst", PROMPTSUBST},
    {"alwayslastprompt", ALWAYSLASTPROMPT},
    {"completealiases", COMPLETEALIASES},
    {"autoparamkeys", AUTOPARAMKEYS},
    {"alwaystoend", ALWAYSTOEND},
    {"noflowcontrol", NOFLOWCONTROL},
    {"listambiguous", LISTAMBIGUOUS},
    {"autonamedirs", AUTONAMEDIRS},
    {"cshjunkieparen", CSHJUNKIEPAREN},
    {NULL, 0}
};

#endif

#define ALSTAT_MORE 1		/* last alias ended with ' ' */
#define ALSTAT_JUNK 2		/* don't put word in history List */

#undef isset
#define isset(X) (opts[(int)X] == OPT_SET)
#define unset(X) (opts[(int)X] == OPT_UNSET)
#define interact (isset(INTERACTIVE))
#define jobbing (isset(MONITOR))
#define jobbingv opts[MONITOR]
#define islogin (isset(LOGINSHELL))

#ifndef SYSVR4
#ifndef _IBMR2
#undef WIFSTOPPED
#undef WIFSIGNALED
#undef WIFEXITED
#undef WEXITSTATUS
#undef WTERMSIG
#undef WSTOPSIG
#undef WCOREDUMP

#define WIFSTOPPED(X) (((X)&0377)==0177)
#define WIFSIGNALED(X) (((X)&0377)!=0&&((X)&0377)!=0177)
#define WIFEXITED(X) (((X)&0377)==0)
#define WEXITSTATUS(X) (((X)>>8)&0377)
#define WTERMSIG(X) ((X)&0177)
#define WSTOPSIG(X) (((X)>>8)&0377)
#endif
#if !defined(IRIX5) || !defined(_POSIX_SOURCE)
#define WCOREDUMP(X) ((X)&0200)
#endif
#endif

#if defined(IRIX5) && defined(_POSIX_SOURCE)
#define WCOREDUMP(X) ((*(int *)&(X)) & 0200)
#endif

#ifndef S_ISBLK
#define	_IFMT		0170000
#define	_IFDIR	0040000
#define	_IFCHR	0020000
#define	_IFBLK	0060000
#define	_IFREG	0100000
#define	_IFIFO	0010000
#define	S_ISBLK(m)	(((m)&_IFMT) == _IFBLK)
#define	S_ISCHR(m)	(((m)&_IFMT) == _IFCHR)
#define	S_ISDIR(m)	(((m)&_IFMT) == _IFDIR)
#define	S_ISFIFO(m)	(((m)&_IFMT) == _IFIFO)
#define	S_ISREG(m)	(((m)&_IFMT) == _IFREG)
#endif

#ifndef _IFMT
#define _IFMT 0170000
#endif

#ifndef S_ISSOCK
#define	_IFSOCK	0140000
#define	S_ISSOCK(m)	(((m)&_IFMT) == _IFSOCK)
#endif

#ifndef S_ISLNK
#define	_IFLNK	0120000
#define	S_ISLNK(m)	(((m)&_IFMT) == _IFLNK)
#endif

#if S_IFIFO == S_IFSOCK
#undef S_IFIFO
#endif

#ifndef S_IFIFO
#undef HAS_FIFOS
#endif

#if !defined(S_ISFIFO) && !defined(HAS_FIFOS)
#define S_ISFIFO(m) 0
#endif

/* buffered shell input for non-interactive shells */

EXTERN FILE *bshin;

/* NULL-terminated arrays containing path, cdpath, etc. */

EXTERN char **path, **cdpath, **fpath, **watch, **mailpath;
EXTERN char **manpath, **tildedirs, **fignore;
EXTERN char **psvar;

/* named directories */

typedef struct nameddirs *Nameddirs;

struct nameddirs {
    int len;			/* length of path namdirs[t0].dir */
    int namelen;		/* length of name */
    char *name;
    char *dir;
    int homedir;		/* is this name a home directory? */
};

EXTERN struct nameddirs *namdirs;

/* size of userdirs[], # of userdirs */

EXTERN int userdirsz, userdirct;

EXTERN char *mailfile;

EXTERN char *yytext;

/* error/break flag */

EXTERN int errflag;

/* Status of return from a trap */

EXTERN int trapreturn;

EXTERN char *tokstr;
EXTERN int tok, tokfd;

/* lexical analyzer error flag */

EXTERN int lexstop;

/* suppress error messages */

EXTERN int noerrs;

/* nonzero means we are not evaluating, just parsing (in math.c) */

EXTERN int noeval;

/* current history event number */

EXTERN int curhist;

/* if != 0, this is the first line of the command */

EXTERN int isfirstln;

/* if != 0, this is the first char of the command (not including
	white space) */

EXTERN int isfirstch;

/* number of history entries */

EXTERN int histentct;

/* array of history entries */

EXTERN Histent histentarr;

/* capacity of history lists */

EXTERN int histsiz, lithistsiz;

/* if = 1, we have performed history substitution on the current line
 	if = 2, we have used the 'p' modifier */

EXTERN int histdone;

/* default event (usually curhist-1, that is, "!!") */

EXTERN int defev;

/* != 0 if we are about to read a command word */

EXTERN int incmdpos;

/* != 0 if we are in the middle of a [[ ... ]] */

EXTERN int incond;

/* != 0 if we are after a redirection (for ctxtlex only) */

EXTERN int inredir;

/* != 0 if we are about to read a case pattern */

EXTERN int incasepat;

/* != 0 if we just read FUNCTION */

EXTERN int infunc;

/* != 0 if we just read a newline */

EXTERN int isnewlin;

/* the lists of history events */

EXTERN Lklist histlist, lithistlist;

/* the directory stack */

EXTERN Lklist dirstack;

/* the zle buffer stack */

EXTERN Lklist bufstack;

/* the input queue (stack?)

	inbuf    = start of buffer
	inbufptr = location in buffer	(= inbuf for a FULL buffer)
					(= inbuf+inbufsz for an EMPTY buffer)
	inbufct  = # of chars in buffer (inbufptr+inbufct == inbuf+inbufsz)
	inbufsz  = max size of buffer
*/

EXTERN char *inbuf, *inbufptr;
EXTERN int inbufct, inbufsz;

EXTERN char *ifs;		/* $IFS */

EXTERN char *oldpwd;		/* $OLDPWD */

EXTERN char *underscore;	/* $_ */

/* != 0 if this is a subshell */

EXTERN int subsh;

/* # of break levels */

EXTERN int breaks;

/* != 0 if we have a return pending */

EXTERN int retflag;

/* how far we've hashed the PATH so far */

EXTERN char **pathchecked;

/* # of nested loops we are in */

EXTERN int loops;

/* # of continue levels */

EXTERN int contflag;

/* the job we are working on */

EXTERN int thisjob;

/* the current job (+) */

EXTERN int curjob;

/* the previous job (-) */

EXTERN int prevjob;

/* hash table containing the aliases and reserved words */

EXTERN Hashtab aliastab;

/* hash table containing the parameters */

EXTERN Hashtab paramtab;

/* hash table containing the builtins/shfuncs/hashed commands */

EXTERN Hashtab cmdnamtab;

/* hash table for completion info for commands */

EXTERN Hashtab compctltab;

/* default completion infos */

EXTERN struct compctl cc_compos, cc_default, cc_dummy;

/* the job table */

EXTERN struct job jobtab[MAXJOB];

/* shell timings */

#ifndef HAS_RUSAGE
EXTERN struct tms shtms;

#endif

/* the list of sched jobs pending */

EXTERN struct schedcmd *schedcmds;

/* the last l for s/l/r/ history substitution */

EXTERN char *hsubl;

/* the last r for s/l/r/ history substitution */

EXTERN char *hsubr;

EXTERN char *username;		/* $USERNAME */
EXTERN char *zlogname;		/* $LOGNAME */
EXTERN long lastval;		/* $? */
EXTERN long baud;		/* $BAUD */
EXTERN long columns;		/* $COLUMNS */
EXTERN long lines;		/* $LINES */
EXTERN long reporttime;		/* $REPORTTIME */
EXTERN long lastval2;

/* input fd from the coprocess */

EXTERN int coprocin;

/* output fd from the coprocess */

EXTERN int coprocout;

EXTERN long mailcheck;		/* $MAILCHECK */
EXTERN long logcheck;		/* $LOGCHECK */

/* the last time we checked mail */

EXTERN time_t lastmailcheck;

/* the last time we checked the people in the WATCH variable */

EXTERN time_t lastwatch;

/* the last time we did the periodic() shell function */

EXTERN time_t lastperiod;

/* $SECONDS = time(NULL) - shtimer.tv_sec */

EXTERN struct timeval shtimer;

EXTERN long mypid;		/* $$ */
EXTERN long lastpid;		/* $! */
EXTERN long ppid;		/* $PPID */

/* the process group of the shell */

EXTERN long mypgrp;

EXTERN char *pwd;		/* $PWD */
EXTERN char *zoptarg;		/* $OPTARG */
EXTERN long zoptind;		/* $OPTIND */
EXTERN char *prompt;		/* $PROMPT */
EXTERN char *rprompt;		/* $RPROMPT */
EXTERN char *prompt2;		/* etc. */
EXTERN char *prompt3;
EXTERN char *prompt4;
EXTERN char *sprompt;
EXTERN char *timefmt;
EXTERN char *watchfmt;
EXTERN char *wordchars;
EXTERN char *fceditparam;
EXTERN char *tmpprefix;
EXTERN char *rstring, *Rstring;
EXTERN char *postedit;

EXTERN char *argzero;		/* $0 */

EXTERN char *hackzero;

/* the hostname */

EXTERN char *hostnam;

EXTERN char *home;		/* $HOME */
EXTERN char **pparams;		/* $argv */

/* the default command for null commands */

EXTERN char *nullcmd;
EXTERN char *readnullcmd;

/* the List of local variables we have to destroy */

EXTERN Lklist locallist;

/* what level of localness we are at */

EXTERN int locallevel;

/* what level of sourcing we are at */

EXTERN int sourcelevel;

/* the shell input fd */

EXTERN int SHIN;

/* the shell tty fd */

EXTERN int SHTTY;

/* the stack of aliases we are expanding */

EXTERN struct alias *alstack[MAXAL];

/* the alias stack pointer; also, the number of aliases currently
 	being expanded */

EXTERN int alstackind;

/* != 0 means we are reading input from a string */

EXTERN int strin;

/* period between periodic() commands, in seconds */

EXTERN long period;

/* != 0 means history substitution is turned off */

EXTERN int stophist;

EXTERN int lithist;

/* this line began with a space, so junk it if HISTIGNORESPACE is on */

EXTERN int spaceflag;

/* don't do spelling correction */

EXTERN int nocorrect;

/* != 0 means we have removed the current event from the history List */

EXTERN int histremmed;

/* the options; e.g. if opts['a'] == OPT_SET, -a is turned on */

EXTERN int opts[128];

EXTERN long keytimeout;		/* KEYTIMEOUT */
EXTERN long lineno;		/* LINENO */
EXTERN long listmax;		/* LISTMAX */
EXTERN long savehist;		/* SAVEHIST */
EXTERN long shlvl;		/* SHLVL */
EXTERN long tmout;		/* TMOUT */
EXTERN long dirstacksize;	/* DIRSTACKSIZE */

/* != 0 means we have called execlist() and then intend to exit(),
 	so don't fork if not necessary */

EXTERN int exiting;

EXTERN int lastbase;		/* last input base we used */

/* the limits for child processes */

#ifdef RLIM_INFINITY
EXTERN struct rlimit limits[RLIM_NLIMITS];

#endif

/* the current word in the history List */

EXTERN char *hlastw;

/* pointer into the history line */

EXTERN char *hptr;

/* the current history line */

EXTERN char *chline;

/* the termcap buffer */

EXTERN char termbuf[1024];

/* $TERM */

EXTERN char *term;

/* != 0 if this $TERM setup is usable */

EXTERN int termok;

/* flag for CSHNULLGLOB */

EXTERN int badcshglob;

/* max size of histline */

EXTERN int hlinesz;

/* the alias expansion status - if == ALSTAT_MORE, we just finished
	expanding an alias ending with a space */

EXTERN int alstat;

/* we have printed a 'you have stopped (running) jobs.' message */

EXTERN int stopmsg;

/* the default tty state */

EXTERN struct ttyinfo shttyinfo;

/* $TTY */

EXTERN char *ttystrname;

/* 1 if ttyctl -f has been executed */

EXTERN int ttyfrozen;

/* != 0 if we are allocating in the heaplist */

EXTERN int useheap;

/* Words on the command line, for use in completion */

EXTERN int clwsize, clwnum, clwpos;
EXTERN char **clwords;

/* pid of process undergoing 'process substitution' */

EXTERN int cmdoutpid;

/* exit status of process undergoing 'process substitution' */

EXTERN int cmdoutval;

/* 1 if aliases should not be expanded */

EXTERN int noaliases;

#include "signals.h"

#ifdef GLOBALS

/* signal names */
char **sigptr = sigs;

/* tokens */
char *ztokens = "#$^*()$=|{}[]`<>?~`,'\"\\";

#else
extern char *ztokens, **sigptr;

#endif

#define SIGZERR (SIGCOUNT+1)
#define SIGDEBUG (SIGCOUNT+2)
#define VSIGCOUNT (SIGCOUNT+3)
#define SIGEXIT 0

/* signals that are trapped = 1, signals ignored =2 */

EXTERN int sigtrapped[VSIGCOUNT];

/* trap functions for each signal */

EXTERN List sigfuncs[VSIGCOUNT];

/* $HISTCHARS */

EXTERN unsigned char bangchar, hatchar, hashchar;

EXTERN int eofseen;

/* we are parsing a line sent to use by the editor */

EXTERN int zleparse;

EXTERN int wordbeg;

EXTERN int parbegin;

/* used in arrays of lists instead of NULL pointers */

EXTERN struct list dummy_list;

/* interesting termcap strings */

#define TCCLEARSCREEN 0
#define TCLEFT 1
#define TCMULTLEFT 2
#define TCRIGHT 3
#define TCMULTRIGHT 4
#define TCUP 5
#define TCMULTUP 6
#define TCDOWN 7
#define TCMULTDOWN 8
#define TCDEL 9
#define TCMULTDEL 10
#define TCINS 11
#define TCMULTINS 12
#define TCCLEAREOD 13
#define TCCLEAREOL 14
#define TCINSLINE 15
#define TCDELLINE 16
#define TCNEXTTAB 17
#define TC_COUNT 18

/* lengths of each string */

EXTERN int tclen[TC_COUNT];

EXTERN char *tcstr[TC_COUNT];

#ifdef GLOBALS

/* names of the strings we want */

char *tccapnams[TC_COUNT] =
{
    "cl", "le", "LE", "nd", "RI", "up", "UP", "do",
    "DO", "dc", "DC", "ic", "IC", "cd", "ce", "al", "dl", "ta"
};

#else
extern char *tccapnams[TC_COUNT];

#endif

#define tccan(X) (tclen[X])

#define HISTFLAG_DONE   1
#define HISTFLAG_NOEXEC 2
#define HISTFLAG_RECALL 4

#ifdef HAS_SETPGID
#define setpgrp setpgid
#endif

#define _INCLUDE_POSIX_SOURCE
#define _INCLUDE_XOPEN_SOURCE
#define _INCLUDE_HPUX_SOURCE

#ifdef SV_BSDSIG
#define SV_INTERRUPT SV_BSDSIG
#endif

#if defined(POSIX) || !defined(SYSV)
#define SIGNAL_MASKS
#endif

#ifndef POSIX
typedef unsigned int sigset_t;
typedef unsigned int mode_t;

#define sigemptyset(s)    (*(s) = 0)
#if NSIG == 32
#define sigfillset(s)     ((*(s) = 0xffffffff), 0)
#else
#define sigfillset(s)     ((*(s) = (1 << NSIG) - 1), 0)
#endif
#define z_sigmask(n)      (1 << ((n) - 1))
#define sigaddset(s,n)    ((*(s) |= z_sigmask(n)), 0)
#define sigdelset(s,n)    ((*(s) &= ~z_sigmask(n)), 0)
#define sigismember(s,n)  ((*(s) & z_sigmask(n)) ? 1 : 0)
#endif

#define blockchld()        sig_block(sig_mask(SIGCHLD))
#define unblockchld()      sig_unblock(sig_mask(SIGCHLD))
#define chldpause(S)       sig_suspend(SIGCHLD, (S))

#ifdef SIGNAL_MASKS
#define fast_block(s)      (void)(*(s) = sig_block(sig_notmask(0)))
#define fast_unblock(s)    (void)sig_setmask(*(s))
#else
#define fast_block(s)      (void)sigemptyset(s)
#define fast_unblock(s)    (void)(s)
#endif

EXTERN int zigsig, zigblock;
EXTERN sigset_t zigmask;

#define zigunsafe()	(zigblock++ ? 0 : (zigsig = 0))
#define zighold(z,m)	(zigsig ? 0 : (zigsig = (z), zigmask = (m), 0))
#define zigheld		(zigblock > 0)
#define zigsafe()	if (zigheld && zigsig) { \
			    if (zigblock > 0) \
				zigblock--; \
			    if (zigblock == 0) { \
				int zs = zigsig; \
				zigsig = 0; \
				fast_unblock(&zigmask); \
				handler(zs); \
			    } \
			} else { \
			    if (zigblock > 0) \
				zigblock--; \
			}

#include "ztype.h"
#include "funcs.h"

/* the command stack for use with %_ in prompts */

EXTERN unsigned char *cmdstack;
EXTERN int cmdsp;

#define cmdpush(X) if (!(cmdsp >= 0 && cmdsp < 256)) {;} else cmdstack[cmdsp++]=(X)
#define cmdpop() if (cmdsp <= 0) {;} else cmdsp--

#define CS_FOR          0
#define CS_WHILE        1
#define CS_REPEAT       2
#define CS_SELECT       3
#define CS_UNTIL        4
#define CS_IF           5
#define CS_IFTHEN       6
#define CS_ELSE         7
#define CS_ELIF         8
#define CS_MATH         9
#define CS_COND        10
#define CS_CMDOR       11
#define CS_CMDAND      12
#define CS_PIPE        13
#define CS_ERRPIPE     14
#define CS_FOREACH     15
#define CS_CASE        16
#define CS_FUNCDEF     17
#define CS_SUBSH       18
#define CS_CURSH       19
#define CS_ARRAY       20
#define CS_QUOTE       21
#define CS_DQUOTE      22
#define CS_BQUOTE      23
#define CS_CMDSUBST    24
#define CS_MATHSUBST   25
#define CS_ELIFTHEN    26
#define CS_HEREDOC     27
#define CS_HEREDOCD    28

#ifndef GLOBALS
extern char *cmdnames[];

#else
char *cmdnames[] =
{
    "for",
    "while",
    "repeat",
    "select",
    "until",
    "if",
    "then",
    "else",
    "elif",
    "math",
    "cond",
    "cmdor",
    "cmdand",
    "pipe",
    "errpipe",
    "foreach",
    "case",
    "function",
    "subsh",
    "cursh",
    "array",
    "quote",
    "dquote",
    "bquote",
    "cmdsubst",
    "mathsubst",
    "elif-then",
    "heredoc",
    "heredocd",
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#œ#                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           <                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   